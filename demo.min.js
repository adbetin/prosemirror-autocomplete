/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/orderedmap/index.es.js":
/*!*********************************************!*\
  !*** ./node_modules/orderedmap/index.es.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// ::- Persistent data structure representing an ordered mapping from
// strings to values, with some convenient update methods.
function OrderedMap(content) {
  this.content = content;
}

OrderedMap.prototype = {
  constructor: OrderedMap,

  find: function(key) {
    for (var i = 0; i < this.content.length; i += 2)
      if (this.content[i] === key) return i
    return -1
  },

  // :: (string) → ?any
  // Retrieve the value stored under `key`, or return undefined when
  // no such key exists.
  get: function(key) {
    var found = this.find(key);
    return found == -1 ? undefined : this.content[found + 1]
  },

  // :: (string, any, ?string) → OrderedMap
  // Create a new map by replacing the value of `key` with a new
  // value, or adding a binding to the end of the map. If `newKey` is
  // given, the key of the binding will be replaced with that key.
  update: function(key, value, newKey) {
    var self = newKey && newKey != key ? this.remove(newKey) : this;
    var found = self.find(key), content = self.content.slice();
    if (found == -1) {
      content.push(newKey || key, value);
    } else {
      content[found + 1] = value;
      if (newKey) content[found] = newKey;
    }
    return new OrderedMap(content)
  },

  // :: (string) → OrderedMap
  // Return a map with the given key removed, if it existed.
  remove: function(key) {
    var found = this.find(key);
    if (found == -1) return this
    var content = this.content.slice();
    content.splice(found, 2);
    return new OrderedMap(content)
  },

  // :: (string, any) → OrderedMap
  // Add a new key to the start of the map.
  addToStart: function(key, value) {
    return new OrderedMap([key, value].concat(this.remove(key).content))
  },

  // :: (string, any) → OrderedMap
  // Add a new key to the end of the map.
  addToEnd: function(key, value) {
    var content = this.remove(key).content.slice();
    content.push(key, value);
    return new OrderedMap(content)
  },

  // :: (string, string, any) → OrderedMap
  // Add a key after the given key. If `place` is not found, the new
  // key is added to the end.
  addBefore: function(place, key, value) {
    var without = this.remove(key), content = without.content.slice();
    var found = without.find(place);
    content.splice(found == -1 ? content.length : found, 0, key, value);
    return new OrderedMap(content)
  },

  // :: ((key: string, value: any))
  // Call the given function for each key/value pair in the map, in
  // order.
  forEach: function(f) {
    for (var i = 0; i < this.content.length; i += 2)
      f(this.content[i], this.content[i + 1]);
  },

  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by prepending the keys in this map that don't
  // appear in `map` before the keys in `map`.
  prepend: function(map) {
    map = OrderedMap.from(map);
    if (!map.size) return this
    return new OrderedMap(map.content.concat(this.subtract(map).content))
  },

  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by appending the keys in this map that don't
  // appear in `map` after the keys in `map`.
  append: function(map) {
    map = OrderedMap.from(map);
    if (!map.size) return this
    return new OrderedMap(this.subtract(map).content.concat(map.content))
  },

  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a map containing all the keys in this map that don't
  // appear in `map`.
  subtract: function(map) {
    var result = this;
    map = OrderedMap.from(map);
    for (var i = 0; i < map.content.length; i += 2)
      result = result.remove(map.content[i]);
    return result
  },

  // :: number
  // The amount of keys in this map.
  get size() {
    return this.content.length >> 1
  }
};

// :: (?union<Object, OrderedMap>) → OrderedMap
// Return a map with the given content. If null, create an empty
// map. If given an ordered map, return that map itself. If given an
// object, create a map from the object's properties.
OrderedMap.from = function(value) {
  if (value instanceof OrderedMap) return value
  var content = [];
  if (value) for (var prop in value) content.push(prop, value[prop]);
  return new OrderedMap(content)
};

var orderedmap = OrderedMap;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (orderedmap);


/***/ }),

/***/ "./node_modules/prosemirror-commands/dist/index.es.js":
/*!************************************************************!*\
  !*** ./node_modules/prosemirror-commands/dist/index.es.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "baseKeymap": () => (/* binding */ baseKeymap),
/* harmony export */   "chainCommands": () => (/* binding */ chainCommands),
/* harmony export */   "exitCode": () => (/* binding */ exitCode),
/* harmony export */   "joinDown": () => (/* binding */ joinDown),
/* harmony export */   "joinUp": () => (/* binding */ joinUp),
/* harmony export */   "lift": () => (/* binding */ lift),
/* harmony export */   "selectParentNode": () => (/* binding */ selectParentNode),
/* harmony export */   "setBlockType": () => (/* binding */ setBlockType),
/* harmony export */   "toggleMark": () => (/* binding */ toggleMark),
/* harmony export */   "wrapIn": () => (/* binding */ wrapIn)
/* harmony export */ });
/* unused harmony exports autoJoin, createParagraphNear, deleteSelection, joinBackward, joinForward, liftEmptyBlock, macBaseKeymap, newlineInCode, pcBaseKeymap, selectAll, selectNodeBackward, selectNodeForward, splitBlock, splitBlockKeepMarks */
/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-transform */ "./node_modules/prosemirror-transform/dist/index.es.js");
/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-model */ "./node_modules/prosemirror-model/dist/index.es.js");
/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.es.js");




// :: (EditorState, ?(tr: Transaction)) → bool
// Delete the selection, if there is one.
function deleteSelection(state, dispatch) {
  if (state.selection.empty) { return false }
  if (dispatch) { dispatch(state.tr.deleteSelection().scrollIntoView()); }
  return true
}

// :: (EditorState, ?(tr: Transaction), ?EditorView) → bool
// If the selection is empty and at the start of a textblock, try to
// reduce the distance between that block and the one before it—if
// there's a block directly before it that can be joined, join them.
// If not, try to move the selected block closer to the next one in
// the document structure by lifting it out of its parent or moving it
// into a parent of the previous block. Will use the view for accurate
// (bidi-aware) start-of-textblock detection if given.
function joinBackward(state, dispatch, view) {
  var ref = state.selection;
  var $cursor = ref.$cursor;
  if (!$cursor || (view ? !view.endOfTextblock("backward", state)
                        : $cursor.parentOffset > 0))
    { return false }

  var $cut = findCutBefore($cursor);

  // If there is no node before this, try to lift
  if (!$cut) {
    var range = $cursor.blockRange(), target = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget)(range);
    if (target == null) { return false }
    if (dispatch) { dispatch(state.tr.lift(range, target).scrollIntoView()); }
    return true
  }

  var before = $cut.nodeBefore;
  // Apply the joining algorithm
  if (!before.type.spec.isolating && deleteBarrier(state, $cut, dispatch))
    { return true }

  // If the node below has no content and the node above is
  // selectable, delete the node below and select the one above.
  if ($cursor.parent.content.size == 0 &&
      (textblockAt(before, "end") || prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.NodeSelection.isSelectable(before))) {
    if (dispatch) {
      var tr = state.tr.deleteRange($cursor.before(), $cursor.after());
      tr.setSelection(textblockAt(before, "end") ? prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1)
                      : prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.NodeSelection.create(tr.doc, $cut.pos - before.nodeSize));
      dispatch(tr.scrollIntoView());
    }
    return true
  }

  // If the node before is an atom, delete it
  if (before.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch) { dispatch(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView()); }
    return true
  }

  return false
}

function textblockAt(node, side, only) {
  for (; node; node = (side == "start" ? node.firstChild : node.lastChild)) {
    if (node.isTextblock) { return true }
    if (only && node.childCount != 1) { return false }
  }
  return false
}

// :: (EditorState, ?(tr: Transaction), ?EditorView) → bool
// When the selection is empty and at the start of a textblock, select
// the node before that textblock, if possible. This is intended to be
// bound to keys like backspace, after
// [`joinBackward`](#commands.joinBackward) or other deleting
// commands, as a fall-back behavior when the schema doesn't allow
// deletion at the selected point.
function selectNodeBackward(state, dispatch, view) {
  var ref = state.selection;
  var $head = ref.$head;
  var empty = ref.empty;
  var $cut = $head;
  if (!empty) { return false }

  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("backward", state) : $head.parentOffset > 0) { return false }
    $cut = findCutBefore($head);
  }
  var node = $cut && $cut.nodeBefore;
  if (!node || !prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.NodeSelection.isSelectable(node)) { return false }
  if (dispatch)
    { dispatch(state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView()); }
  return true
}

function findCutBefore($pos) {
  if (!$pos.parent.type.spec.isolating) { for (var i = $pos.depth - 1; i >= 0; i--) {
    if ($pos.index(i) > 0) { return $pos.doc.resolve($pos.before(i + 1)) }
    if ($pos.node(i).type.spec.isolating) { break }
  } }
  return null
}

// :: (EditorState, ?(tr: Transaction), ?EditorView) → bool
// If the selection is empty and the cursor is at the end of a
// textblock, try to reduce or remove the boundary between that block
// and the one after it, either by joining them or by moving the other
// block closer to this one in the tree structure. Will use the view
// for accurate start-of-textblock detection if given.
function joinForward(state, dispatch, view) {
  var ref = state.selection;
  var $cursor = ref.$cursor;
  if (!$cursor || (view ? !view.endOfTextblock("forward", state)
                        : $cursor.parentOffset < $cursor.parent.content.size))
    { return false }

  var $cut = findCutAfter($cursor);

  // If there is no node after this, there's nothing to do
  if (!$cut) { return false }

  var after = $cut.nodeAfter;
  // Try the joining algorithm
  if (deleteBarrier(state, $cut, dispatch)) { return true }

  // If the node above has no content and the node below is
  // selectable, delete the node above and select the one below.
  if ($cursor.parent.content.size == 0 &&
      (textblockAt(after, "start") || prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.NodeSelection.isSelectable(after))) {
    if (dispatch) {
      var tr = state.tr.deleteRange($cursor.before(), $cursor.after());
      tr.setSelection(textblockAt(after, "start") ? prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1)
                      : prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)));
      dispatch(tr.scrollIntoView());
    }
    return true
  }

  // If the next node is an atom, delete it
  if (after.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch) { dispatch(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView()); }
    return true
  }

  return false
}

// :: (EditorState, ?(tr: Transaction), ?EditorView) → bool
// When the selection is empty and at the end of a textblock, select
// the node coming after that textblock, if possible. This is intended
// to be bound to keys like delete, after
// [`joinForward`](#commands.joinForward) and similar deleting
// commands, to provide a fall-back behavior when the schema doesn't
// allow deletion at the selected point.
function selectNodeForward(state, dispatch, view) {
  var ref = state.selection;
  var $head = ref.$head;
  var empty = ref.empty;
  var $cut = $head;
  if (!empty) { return false }
  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("forward", state) : $head.parentOffset < $head.parent.content.size)
      { return false }
    $cut = findCutAfter($head);
  }
  var node = $cut && $cut.nodeAfter;
  if (!node || !prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.NodeSelection.isSelectable(node)) { return false }
  if (dispatch)
    { dispatch(state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.NodeSelection.create(state.doc, $cut.pos)).scrollIntoView()); }
  return true
}

function findCutAfter($pos) {
  if (!$pos.parent.type.spec.isolating) { for (var i = $pos.depth - 1; i >= 0; i--) {
    var parent = $pos.node(i);
    if ($pos.index(i) + 1 < parent.childCount) { return $pos.doc.resolve($pos.after(i + 1)) }
    if (parent.type.spec.isolating) { break }
  } }
  return null
}

// :: (EditorState, ?(tr: Transaction)) → bool
// Join the selected block or, if there is a text selection, the
// closest ancestor block of the selection that can be joined, with
// the sibling above it.
function joinUp(state, dispatch) {
  var sel = state.selection, nodeSel = sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.NodeSelection, point;
  if (nodeSel) {
    if (sel.node.isTextblock || !(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(state.doc, sel.from)) { return false }
    point = sel.from;
  } else {
    point = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.joinPoint)(state.doc, sel.from, -1);
    if (point == null) { return false }
  }
  if (dispatch) {
    var tr = state.tr.join(point);
    if (nodeSel) { tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.NodeSelection.create(tr.doc, point - state.doc.resolve(point).nodeBefore.nodeSize)); }
    dispatch(tr.scrollIntoView());
  }
  return true
}

// :: (EditorState, ?(tr: Transaction)) → bool
// Join the selected block, or the closest ancestor of the selection
// that can be joined, with the sibling after it.
function joinDown(state, dispatch) {
  var sel = state.selection, point;
  if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.NodeSelection) {
    if (sel.node.isTextblock || !(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(state.doc, sel.to)) { return false }
    point = sel.to;
  } else {
    point = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.joinPoint)(state.doc, sel.to, 1);
    if (point == null) { return false }
  }
  if (dispatch)
    { dispatch(state.tr.join(point).scrollIntoView()); }
  return true
}

// :: (EditorState, ?(tr: Transaction)) → bool
// Lift the selected block, or the closest ancestor block of the
// selection that can be lifted, out of its parent node.
function lift(state, dispatch) {
  var ref = state.selection;
  var $from = ref.$from;
  var $to = ref.$to;
  var range = $from.blockRange($to), target = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget)(range);
  if (target == null) { return false }
  if (dispatch) { dispatch(state.tr.lift(range, target).scrollIntoView()); }
  return true
}

// :: (EditorState, ?(tr: Transaction)) → bool
// If the selection is in a node whose type has a truthy
// [`code`](#model.NodeSpec.code) property in its spec, replace the
// selection with a newline character.
function newlineInCode(state, dispatch) {
  var ref = state.selection;
  var $head = ref.$head;
  var $anchor = ref.$anchor;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) { return false }
  if (dispatch) { dispatch(state.tr.insertText("\n").scrollIntoView()); }
  return true
}

function defaultBlockAt(match) {
  for (var i = 0; i < match.edgeCount; i++) {
    var ref = match.edge(i);
    var type = ref.type;
    if (type.isTextblock && !type.hasRequiredAttrs()) { return type }
  }
  return null
}

// :: (EditorState, ?(tr: Transaction)) → bool
// When the selection is in a node with a truthy
// [`code`](#model.NodeSpec.code) property in its spec, create a
// default block after the code block, and move the cursor there.
function exitCode(state, dispatch) {
  var ref = state.selection;
  var $head = ref.$head;
  var $anchor = ref.$anchor;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) { return false }
  var above = $head.node(-1), after = $head.indexAfter(-1), type = defaultBlockAt(above.contentMatchAt(after));
  if (!above.canReplaceWith(after, after, type)) { return false }
  if (dispatch) {
    var pos = $head.after(), tr = state.tr.replaceWith(pos, pos, type.createAndFill());
    tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.Selection.near(tr.doc.resolve(pos), 1));
    dispatch(tr.scrollIntoView());
  }
  return true
}

// :: (EditorState, ?(tr: Transaction)) → bool
// If a block node is selected, create an empty paragraph before (if
// it is its parent's first child) or after it.
function createParagraphNear(state, dispatch) {
  var sel = state.selection;
  var $from = sel.$from;
  var $to = sel.$to;
  if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.AllSelection || $from.parent.inlineContent || $to.parent.inlineContent) { return false }
  var type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()));
  if (!type || !type.isTextblock) { return false }
  if (dispatch) {
    var side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;
    var tr = state.tr.insert(side, type.createAndFill());
    tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.TextSelection.create(tr.doc, side + 1));
    dispatch(tr.scrollIntoView());
  }
  return true
}

// :: (EditorState, ?(tr: Transaction)) → bool
// If the cursor is in an empty textblock that can be lifted, lift the
// block.
function liftEmptyBlock(state, dispatch) {
  var ref = state.selection;
  var $cursor = ref.$cursor;
  if (!$cursor || $cursor.parent.content.size) { return false }
  if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {
    var before = $cursor.before();
    if ((0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(state.doc, before)) {
      if (dispatch) { dispatch(state.tr.split(before).scrollIntoView()); }
      return true
    }
  }
  var range = $cursor.blockRange(), target = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget)(range);
  if (target == null) { return false }
  if (dispatch) { dispatch(state.tr.lift(range, target).scrollIntoView()); }
  return true
}

// :: (EditorState, ?(tr: Transaction)) → bool
// Split the parent block of the selection. If the selection is a text
// selection, also delete its content.
function splitBlock(state, dispatch) {
  var ref = state.selection;
  var $from = ref.$from;
  var $to = ref.$to;
  if (state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.NodeSelection && state.selection.node.isBlock) {
    if (!$from.parentOffset || !(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(state.doc, $from.pos)) { return false }
    if (dispatch) { dispatch(state.tr.split($from.pos).scrollIntoView()); }
    return true
  }

  if (!$from.parent.isBlock) { return false }

  if (dispatch) {
    var atEnd = $to.parentOffset == $to.parent.content.size;
    var tr = state.tr;
    if (state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.TextSelection || state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.AllSelection) { tr.deleteSelection(); }
    var deflt = $from.depth == 0 ? null : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));
    var types = atEnd && deflt ? [{type: deflt}] : null;
    var can = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(tr.doc, tr.mapping.map($from.pos), 1, types);
    if (!types && !can && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(tr.doc, tr.mapping.map($from.pos), 1, deflt && [{type: deflt}])) {
      types = [{type: deflt}];
      can = true;
    }
    if (can) {
      tr.split(tr.mapping.map($from.pos), 1, types);
      if (!atEnd && !$from.parentOffset && $from.parent.type != deflt) {
        var first = tr.mapping.map($from.before()), $first = tr.doc.resolve(first);
        if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt))
          { tr.setNodeMarkup(tr.mapping.map($from.before()), deflt); }
      }
    }
    dispatch(tr.scrollIntoView());
  }
  return true
}

// :: (EditorState, ?(tr: Transaction)) → bool
// Acts like [`splitBlock`](#commands.splitBlock), but without
// resetting the set of active marks at the cursor.
function splitBlockKeepMarks(state, dispatch) {
  return splitBlock(state, dispatch && (function (tr) {
    var marks = state.storedMarks || (state.selection.$to.parentOffset && state.selection.$from.marks());
    if (marks) { tr.ensureMarks(marks); }
    dispatch(tr);
  }))
}

// :: (EditorState, ?(tr: Transaction)) → bool
// Move the selection to the node wrapping the current selection, if
// any. (Will not select the document node.)
function selectParentNode(state, dispatch) {
  var ref = state.selection;
  var $from = ref.$from;
  var to = ref.to;
  var pos;
  var same = $from.sharedDepth(to);
  if (same == 0) { return false }
  pos = $from.before(same);
  if (dispatch) { dispatch(state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.NodeSelection.create(state.doc, pos))); }
  return true
}

// :: (EditorState, ?(tr: Transaction)) → bool
// Select the whole document.
function selectAll(state, dispatch) {
  if (dispatch) { dispatch(state.tr.setSelection(new prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.AllSelection(state.doc))); }
  return true
}

function joinMaybeClear(state, $pos, dispatch) {
  var before = $pos.nodeBefore, after = $pos.nodeAfter, index = $pos.index();
  if (!before || !after || !before.type.compatibleContent(after.type)) { return false }
  if (!before.content.size && $pos.parent.canReplace(index - 1, index)) {
    if (dispatch) { dispatch(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView()); }
    return true
  }
  if (!$pos.parent.canReplace(index, index + 1) || !(after.isTextblock || (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(state.doc, $pos.pos)))
    { return false }
  if (dispatch)
    { dispatch(state.tr
             .clearIncompatible($pos.pos, before.type, before.contentMatchAt(before.childCount))
             .join($pos.pos)
             .scrollIntoView()); }
  return true
}

function deleteBarrier(state, $cut, dispatch) {
  var before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match;
  if (before.type.spec.isolating || after.type.spec.isolating) { return false }
  if (joinMaybeClear(state, $cut, dispatch)) { return true }

  var canDelAfter = $cut.parent.canReplace($cut.index(), $cut.index() + 1);
  if (canDelAfter &&
      (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) &&
      match.matchType(conn[0] || after.type).validEnd) {
    if (dispatch) {
      var end = $cut.pos + after.nodeSize, wrap = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty;
      for (var i = conn.length - 1; i >= 0; i--)
        { wrap = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(conn[i].create(null, wrap)); }
      wrap = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(before.copy(wrap));
      var tr = state.tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceAroundStep($cut.pos - 1, end, $cut.pos, end, new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(wrap, 1, 0), conn.length, true));
      var joinAt = end + 2 * conn.length;
      if ((0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(tr.doc, joinAt)) { tr.join(joinAt); }
      dispatch(tr.scrollIntoView());
    }
    return true
  }

  var selAfter = prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.Selection.findFrom($cut, 1);
  var range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget)(range);
  if (target != null && target >= $cut.depth) {
    if (dispatch) { dispatch(state.tr.lift(range, target).scrollIntoView()); }
    return true
  }

  if (canDelAfter && textblockAt(after, "start", true) && textblockAt(before, "end")) {
    var at = before, wrap$1 = [];
    for (;;) {
      wrap$1.push(at);
      if (at.isTextblock) { break }
      at = at.lastChild;
    }
    var afterText = after, afterDepth = 1;
    for (; !afterText.isTextblock; afterText = afterText.firstChild) { afterDepth++; }
    if (at.canReplace(at.childCount, at.childCount, afterText.content)) {
      if (dispatch) {
        var end$1 = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty;
        for (var i$1 = wrap$1.length - 1; i$1 >= 0; i$1--) { end$1 = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(wrap$1[i$1].copy(end$1)); }
        var tr$1 = state.tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceAroundStep($cut.pos - wrap$1.length, $cut.pos + after.nodeSize,
                                                     $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth,
                                                     new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(end$1, wrap$1.length, 0), 0, true));
        dispatch(tr$1.scrollIntoView());
      }
      return true
    }
  }

  return false
}

// Parameterized commands

// :: (NodeType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool
// Wrap the selection in a node of the given type with the given
// attributes.
function wrapIn(nodeType, attrs) {
  return function(state, dispatch) {
    var ref = state.selection;
    var $from = ref.$from;
    var $to = ref.$to;
    var range = $from.blockRange($to), wrapping = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.findWrapping)(range, nodeType, attrs);
    if (!wrapping) { return false }
    if (dispatch) { dispatch(state.tr.wrap(range, wrapping).scrollIntoView()); }
    return true
  }
}

// :: (NodeType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool
// Returns a command that tries to set the selected textblocks to the
// given node type with the given attributes.
function setBlockType(nodeType, attrs) {
  return function(state, dispatch) {
    var ref = state.selection;
    var from = ref.from;
    var to = ref.to;
    var applicable = false;
    state.doc.nodesBetween(from, to, function (node, pos) {
      if (applicable) { return false }
      if (!node.isTextblock || node.hasMarkup(nodeType, attrs)) { return }
      if (node.type == nodeType) {
        applicable = true;
      } else {
        var $pos = state.doc.resolve(pos), index = $pos.index();
        applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType);
      }
    });
    if (!applicable) { return false }
    if (dispatch) { dispatch(state.tr.setBlockType(from, to, nodeType, attrs).scrollIntoView()); }
    return true
  }
}

function markApplies(doc, ranges, type) {
  var loop = function ( i ) {
    var ref = ranges[i];
    var $from = ref.$from;
    var $to = ref.$to;
    var can = $from.depth == 0 ? doc.type.allowsMarkType(type) : false;
    doc.nodesBetween($from.pos, $to.pos, function (node) {
      if (can) { return false }
      can = node.inlineContent && node.type.allowsMarkType(type);
    });
    if (can) { return { v: true } }
  };

  for (var i = 0; i < ranges.length; i++) {
    var returned = loop( i );

    if ( returned ) return returned.v;
  }
  return false
}

// :: (MarkType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool
// Create a command function that toggles the given mark with the
// given attributes. Will return `false` when the current selection
// doesn't support that mark. This will remove the mark if any marks
// of that type exist in the selection, or add it otherwise. If the
// selection is empty, this applies to the [stored
// marks](#state.EditorState.storedMarks) instead of a range of the
// document.
function toggleMark(markType, attrs) {
  return function(state, dispatch) {
    var ref = state.selection;
    var empty = ref.empty;
    var $cursor = ref.$cursor;
    var ranges = ref.ranges;
    if ((empty && !$cursor) || !markApplies(state.doc, ranges, markType)) { return false }
    if (dispatch) {
      if ($cursor) {
        if (markType.isInSet(state.storedMarks || $cursor.marks()))
          { dispatch(state.tr.removeStoredMark(markType)); }
        else
          { dispatch(state.tr.addStoredMark(markType.create(attrs))); }
      } else {
        var has = false, tr = state.tr;
        for (var i = 0; !has && i < ranges.length; i++) {
          var ref$1 = ranges[i];
          var $from = ref$1.$from;
          var $to = ref$1.$to;
          has = state.doc.rangeHasMark($from.pos, $to.pos, markType);
        }
        for (var i$1 = 0; i$1 < ranges.length; i$1++) {
          var ref$2 = ranges[i$1];
          var $from$1 = ref$2.$from;
          var $to$1 = ref$2.$to;
          if (has) {
            tr.removeMark($from$1.pos, $to$1.pos, markType);
          } else {
            var from = $from$1.pos, to = $to$1.pos, start = $from$1.nodeAfter, end = $to$1.nodeBefore;
            var spaceStart = start && start.isText ? /^\s*/.exec(start.text)[0].length : 0;
            var spaceEnd = end && end.isText ? /\s*$/.exec(end.text)[0].length : 0;
            if (from + spaceStart < to) { from += spaceStart; to -= spaceEnd; }
            tr.addMark(from, to, markType.create(attrs));
          }
        }
        dispatch(tr.scrollIntoView());
      }
    }
    return true
  }
}

function wrapDispatchForJoin(dispatch, isJoinable) {
  return function (tr) {
    if (!tr.isGeneric) { return dispatch(tr) }

    var ranges = [];
    for (var i = 0; i < tr.mapping.maps.length; i++) {
      var map = tr.mapping.maps[i];
      for (var j = 0; j < ranges.length; j++)
        { ranges[j] = map.map(ranges[j]); }
      map.forEach(function (_s, _e, from, to) { return ranges.push(from, to); });
    }

    // Figure out which joinable points exist inside those ranges,
    // by checking all node boundaries in their parent nodes.
    var joinable = [];
    for (var i$1 = 0; i$1 < ranges.length; i$1 += 2) {
      var from = ranges[i$1], to = ranges[i$1 + 1];
      var $from = tr.doc.resolve(from), depth = $from.sharedDepth(to), parent = $from.node(depth);
      for (var index = $from.indexAfter(depth), pos = $from.after(depth + 1); pos <= to; ++index) {
        var after = parent.maybeChild(index);
        if (!after) { break }
        if (index && joinable.indexOf(pos) == -1) {
          var before = parent.child(index - 1);
          if (before.type == after.type && isJoinable(before, after))
            { joinable.push(pos); }
        }
        pos += after.nodeSize;
      }
    }
    // Join the joinable points
    joinable.sort(function (a, b) { return a - b; });
    for (var i$2 = joinable.length - 1; i$2 >= 0; i$2--) {
      if ((0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(tr.doc, joinable[i$2])) { tr.join(joinable[i$2]); }
    }
    dispatch(tr);
  }
}

// :: ((state: EditorState, ?(tr: Transaction)) → bool, union<(before: Node, after: Node) → bool, [string]>) → (state: EditorState, ?(tr: Transaction)) → bool
// Wrap a command so that, when it produces a transform that causes
// two joinable nodes to end up next to each other, those are joined.
// Nodes are considered joinable when they are of the same type and
// when the `isJoinable` predicate returns true for them or, if an
// array of strings was passed, if their node type name is in that
// array.
function autoJoin(command, isJoinable) {
  if (Array.isArray(isJoinable)) {
    var types = isJoinable;
    isJoinable = function (node) { return types.indexOf(node.type.name) > -1; };
  }
  return function (state, dispatch, view) { return command(state, dispatch && wrapDispatchForJoin(dispatch, isJoinable), view); }
}

// :: (...[(EditorState, ?(tr: Transaction), ?EditorView) → bool]) → (EditorState, ?(tr: Transaction), ?EditorView) → bool
// Combine a number of command functions into a single function (which
// calls them one by one until one returns true).
function chainCommands() {
  var commands = [], len = arguments.length;
  while ( len-- ) commands[ len ] = arguments[ len ];

  return function(state, dispatch, view) {
    for (var i = 0; i < commands.length; i++)
      { if (commands[i](state, dispatch, view)) { return true } }
    return false
  }
}

var backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward);
var del = chainCommands(deleteSelection, joinForward, selectNodeForward);

// :: Object
// A basic keymap containing bindings not specific to any schema.
// Binds the following keys (when multiple commands are listed, they
// are chained with [`chainCommands`](#commands.chainCommands)):
//
// * **Enter** to `newlineInCode`, `createParagraphNear`, `liftEmptyBlock`, `splitBlock`
// * **Mod-Enter** to `exitCode`
// * **Backspace** and **Mod-Backspace** to `deleteSelection`, `joinBackward`, `selectNodeBackward`
// * **Delete** and **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`
// * **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`
// * **Mod-a** to `selectAll`
var pcBaseKeymap = {
  "Enter": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),
  "Mod-Enter": exitCode,
  "Backspace": backspace,
  "Mod-Backspace": backspace,
  "Shift-Backspace": backspace,
  "Delete": del,
  "Mod-Delete": del,
  "Mod-a": selectAll
};

// :: Object
// A copy of `pcBaseKeymap` that also binds **Ctrl-h** like Backspace,
// **Ctrl-d** like Delete, **Alt-Backspace** like Ctrl-Backspace, and
// **Ctrl-Alt-Backspace**, **Alt-Delete**, and **Alt-d** like
// Ctrl-Delete.
var macBaseKeymap = {
  "Ctrl-h": pcBaseKeymap["Backspace"],
  "Alt-Backspace": pcBaseKeymap["Mod-Backspace"],
  "Ctrl-d": pcBaseKeymap["Delete"],
  "Ctrl-Alt-Backspace": pcBaseKeymap["Mod-Delete"],
  "Alt-Delete": pcBaseKeymap["Mod-Delete"],
  "Alt-d": pcBaseKeymap["Mod-Delete"]
};
for (var key in pcBaseKeymap) { macBaseKeymap[key] = pcBaseKeymap[key]; }

// declare global: os, navigator
var mac = typeof navigator != "undefined" ? /Mac/.test(navigator.platform)
          : typeof os != "undefined" ? os.platform() == "darwin" : false;

// :: Object
// Depending on the detected platform, this will hold
// [`pcBasekeymap`](#commands.pcBaseKeymap) or
// [`macBaseKeymap`](#commands.macBaseKeymap).
var baseKeymap = mac ? macBaseKeymap : pcBaseKeymap;


//# sourceMappingURL=index.es.js.map


/***/ }),

/***/ "./node_modules/prosemirror-dropcursor/dist/index.es.js":
/*!**************************************************************!*\
  !*** ./node_modules/prosemirror-dropcursor/dist/index.es.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "dropCursor": () => (/* binding */ dropCursor)
/* harmony export */ });
/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.es.js");
/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-transform */ "./node_modules/prosemirror-transform/dist/index.es.js");



// :: (options: ?Object) → Plugin
// Create a plugin that, when added to a ProseMirror instance,
// causes a decoration to show up at the drop position when something
// is dragged over the editor.
//
//   options::- These options are supported:
//
//     color:: ?string
//     The color of the cursor. Defaults to `black`.
//
//     width:: ?number
//     The precise width of the cursor in pixels. Defaults to 1.
//
//     class:: ?string
//     A CSS class name to add to the cursor element.
function dropCursor(options) {
  if ( options === void 0 ) options = {};

  return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({
    view: function view(editorView) { return new DropCursorView(editorView, options) }
  })
}

var DropCursorView = function DropCursorView(editorView, options) {
  var this$1 = this;

  this.editorView = editorView;
  this.width = options.width || 1;
  this.color = options.color || "black";
  this.class = options.class;
  this.cursorPos = null;
  this.element = null;
  this.timeout = null;

  this.handlers = ["dragover", "dragend", "drop", "dragleave"].map(function (name) {
    var handler = function (e) { return this$1[name](e); };
    editorView.dom.addEventListener(name, handler);
    return {name: name, handler: handler}
  });
};

DropCursorView.prototype.destroy = function destroy () {
    var this$1 = this;

  this.handlers.forEach(function (ref) {
      var name = ref.name;
      var handler = ref.handler;

      return this$1.editorView.dom.removeEventListener(name, handler);
    });
};

DropCursorView.prototype.update = function update (editorView, prevState) {
  if (this.cursorPos != null && prevState.doc != editorView.state.doc) {
    if (this.cursorPos > editorView.state.doc.content.size) { this.setCursor(null); }
    else { this.updateOverlay(); }
  }
};

DropCursorView.prototype.setCursor = function setCursor (pos) {
  if (pos == this.cursorPos) { return }
  this.cursorPos = pos;
  if (pos == null) {
    this.element.parentNode.removeChild(this.element);
    this.element = null;
  } else {
    this.updateOverlay();
  }
};

DropCursorView.prototype.updateOverlay = function updateOverlay () {
  var $pos = this.editorView.state.doc.resolve(this.cursorPos), rect;
  if (!$pos.parent.inlineContent) {
    var before = $pos.nodeBefore, after = $pos.nodeAfter;
    if (before || after) {
      var nodeRect = this.editorView.nodeDOM(this.cursorPos - (before ?before.nodeSize : 0)).getBoundingClientRect();
      var top = before ? nodeRect.bottom : nodeRect.top;
      if (before && after)
        { top = (top + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2; }
      rect = {left: nodeRect.left, right: nodeRect.right, top: top - this.width / 2, bottom: top + this.width / 2};
    }
  }
  if (!rect) {
    var coords = this.editorView.coordsAtPos(this.cursorPos);
    rect = {left: coords.left - this.width / 2, right: coords.left + this.width / 2, top: coords.top, bottom: coords.bottom};
  }

  var parent = this.editorView.dom.offsetParent;
  if (!this.element) {
    this.element = parent.appendChild(document.createElement("div"));
    if (this.class) { this.element.className = this.class; }
    this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none; background-color: " + this.color;
  }
  var parentLeft, parentTop;
  if (!parent || parent == document.body && getComputedStyle(parent).position == "static") {
    parentLeft = -pageXOffset;
    parentTop = -pageYOffset;
  } else {
    var rect$1 = parent.getBoundingClientRect();
    parentLeft = rect$1.left - parent.scrollLeft;
    parentTop = rect$1.top - parent.scrollTop;
  }
  this.element.style.left = (rect.left - parentLeft) + "px";
  this.element.style.top = (rect.top - parentTop) + "px";
  this.element.style.width = (rect.right - rect.left) + "px";
  this.element.style.height = (rect.bottom - rect.top) + "px";
};

DropCursorView.prototype.scheduleRemoval = function scheduleRemoval (timeout) {
    var this$1 = this;

  clearTimeout(this.timeout);
  this.timeout = setTimeout(function () { return this$1.setCursor(null); }, timeout);
};

DropCursorView.prototype.dragover = function dragover (event) {
  if (!this.editorView.editable) { return }
  var pos = this.editorView.posAtCoords({left: event.clientX, top: event.clientY});
  if (pos) {
    var target = pos.pos;
    if (this.editorView.dragging && this.editorView.dragging.slice) {
      target = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.dropPoint)(this.editorView.state.doc, target, this.editorView.dragging.slice);
      if (target == null) { return this.setCursor(null) }
    }
    this.setCursor(target);
    this.scheduleRemoval(5000);
  }
};

DropCursorView.prototype.dragend = function dragend () {
  this.scheduleRemoval(20);
};

DropCursorView.prototype.drop = function drop () {
  this.scheduleRemoval(20);
};

DropCursorView.prototype.dragleave = function dragleave (event) {
  if (event.target == this.editorView.dom || !this.editorView.dom.contains(event.relatedTarget))
    { this.setCursor(null); }
};


//# sourceMappingURL=index.es.js.map


/***/ }),

/***/ "./node_modules/prosemirror-example-setup/dist/index.es.js":
/*!*****************************************************************!*\
  !*** ./node_modules/prosemirror-example-setup/dist/index.es.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "buildInputRules": () => (/* binding */ buildInputRules),
/* harmony export */   "buildKeymap": () => (/* binding */ buildKeymap),
/* harmony export */   "buildMenuItems": () => (/* binding */ buildMenuItems),
/* harmony export */   "exampleSetup": () => (/* binding */ exampleSetup)
/* harmony export */ });
/* harmony import */ var prosemirror_keymap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-keymap */ "./node_modules/prosemirror-keymap/dist/index.es.js");
/* harmony import */ var prosemirror_history__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-history */ "./node_modules/prosemirror-history/dist/index.es.js");
/* harmony import */ var prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-commands */ "./node_modules/prosemirror-commands/dist/index.es.js");
/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.es.js");
/* harmony import */ var prosemirror_dropcursor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! prosemirror-dropcursor */ "./node_modules/prosemirror-dropcursor/dist/index.es.js");
/* harmony import */ var prosemirror_gapcursor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! prosemirror-gapcursor */ "./node_modules/prosemirror-gapcursor/dist/index.es.js");
/* harmony import */ var prosemirror_menu__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! prosemirror-menu */ "./node_modules/prosemirror-menu/dist/index.es.js");
/* harmony import */ var prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! prosemirror-schema-list */ "./node_modules/prosemirror-schema-list/dist/index.es.js");
/* harmony import */ var prosemirror_inputrules__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! prosemirror-inputrules */ "./node_modules/prosemirror-inputrules/dist/index.es.js");










var prefix = "ProseMirror-prompt";

function openPrompt(options) {
  var wrapper = document.body.appendChild(document.createElement("div"));
  wrapper.className = prefix;

  var mouseOutside = function (e) { if (!wrapper.contains(e.target)) { close(); } };
  setTimeout(function () { return window.addEventListener("mousedown", mouseOutside); }, 50);
  var close = function () {
    window.removeEventListener("mousedown", mouseOutside);
    if (wrapper.parentNode) { wrapper.parentNode.removeChild(wrapper); }
  };

  var domFields = [];
  for (var name in options.fields) { domFields.push(options.fields[name].render()); }

  var submitButton = document.createElement("button");
  submitButton.type = "submit";
  submitButton.className = prefix + "-submit";
  submitButton.textContent = "OK";
  var cancelButton = document.createElement("button");
  cancelButton.type = "button";
  cancelButton.className = prefix + "-cancel";
  cancelButton.textContent = "Cancel";
  cancelButton.addEventListener("click", close);

  var form = wrapper.appendChild(document.createElement("form"));
  if (options.title) { form.appendChild(document.createElement("h5")).textContent = options.title; }
  domFields.forEach(function (field) {
    form.appendChild(document.createElement("div")).appendChild(field);
  });
  var buttons = form.appendChild(document.createElement("div"));
  buttons.className = prefix + "-buttons";
  buttons.appendChild(submitButton);
  buttons.appendChild(document.createTextNode(" "));
  buttons.appendChild(cancelButton);

  var box = wrapper.getBoundingClientRect();
  wrapper.style.top = ((window.innerHeight - box.height) / 2) + "px";
  wrapper.style.left = ((window.innerWidth - box.width) / 2) + "px";

  var submit = function () {
    var params = getValues(options.fields, domFields);
    if (params) {
      close();
      options.callback(params);
    }
  };

  form.addEventListener("submit", function (e) {
    e.preventDefault();
    submit();
  });

  form.addEventListener("keydown", function (e) {
    if (e.keyCode == 27) {
      e.preventDefault();
      close();
    } else if (e.keyCode == 13 && !(e.ctrlKey || e.metaKey || e.shiftKey)) {
      e.preventDefault();
      submit();
    } else if (e.keyCode == 9) {
      window.setTimeout(function () {
        if (!wrapper.contains(document.activeElement)) { close(); }
      }, 500);
    }
  });

  var input = form.elements[0];
  if (input) { input.focus(); }
}

function getValues(fields, domFields) {
  var result = Object.create(null), i = 0;
  for (var name in fields) {
    var field = fields[name], dom = domFields[i++];
    var value = field.read(dom), bad = field.validate(value);
    if (bad) {
      reportInvalid(dom, bad);
      return null
    }
    result[name] = field.clean(value);
  }
  return result
}

function reportInvalid(dom, message) {
  // FIXME this is awful and needs a lot more work
  var parent = dom.parentNode;
  var msg = parent.appendChild(document.createElement("div"));
  msg.style.left = (dom.offsetLeft + dom.offsetWidth + 2) + "px";
  msg.style.top = (dom.offsetTop - 5) + "px";
  msg.className = "ProseMirror-invalid";
  msg.textContent = message;
  setTimeout(function () { return parent.removeChild(msg); }, 1500);
}

// ::- The type of field that `FieldPrompt` expects to be passed to it.
var Field = function Field(options) { this.options = options; };

// render:: (state: EditorState, props: Object) → dom.Node
// Render the field to the DOM. Should be implemented by all subclasses.

// :: (dom.Node) → any
// Read the field's value from its DOM node.
Field.prototype.read = function read (dom) { return dom.value };

// :: (any) → ?string
// A field-type-specific validation function.
Field.prototype.validateType = function validateType (_value) {};

Field.prototype.validate = function validate (value) {
  if (!value && this.options.required)
    { return "Required field" }
  return this.validateType(value) || (this.options.validate && this.options.validate(value))
};

Field.prototype.clean = function clean (value) {
  return this.options.clean ? this.options.clean(value) : value
};

// ::- A field class for single-line text fields.
var TextField = /*@__PURE__*/(function (Field) {
  function TextField () {
    Field.apply(this, arguments);
  }

  if ( Field ) TextField.__proto__ = Field;
  TextField.prototype = Object.create( Field && Field.prototype );
  TextField.prototype.constructor = TextField;

  TextField.prototype.render = function render () {
    var input = document.createElement("input");
    input.type = "text";
    input.placeholder = this.options.label;
    input.value = this.options.value || "";
    input.autocomplete = "off";
    return input
  };

  return TextField;
}(Field));

// Helpers to create specific types of items

function canInsert(state, nodeType) {
  var $from = state.selection.$from;
  for (var d = $from.depth; d >= 0; d--) {
    var index = $from.index(d);
    if ($from.node(d).canReplaceWith(index, index, nodeType)) { return true }
  }
  return false
}

function insertImageItem(nodeType) {
  return new prosemirror_menu__WEBPACK_IMPORTED_MODULE_6__.MenuItem({
    title: "Insert image",
    label: "Image",
    enable: function enable(state) { return canInsert(state, nodeType) },
    run: function run(state, _, view) {
      var ref = state.selection;
      var from = ref.from;
      var to = ref.to;
      var attrs = null;
      if (state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_3__.NodeSelection && state.selection.node.type == nodeType)
        { attrs = state.selection.node.attrs; }
      openPrompt({
        title: "Insert image",
        fields: {
          src: new TextField({label: "Location", required: true, value: attrs && attrs.src}),
          title: new TextField({label: "Title", value: attrs && attrs.title}),
          alt: new TextField({label: "Description",
                              value: attrs ? attrs.alt : state.doc.textBetween(from, to, " ")})
        },
        callback: function callback(attrs) {
          view.dispatch(view.state.tr.replaceSelectionWith(nodeType.createAndFill(attrs)));
          view.focus();
        }
      });
    }
  })
}

function cmdItem(cmd, options) {
  var passedOptions = {
    label: options.title,
    run: cmd
  };
  for (var prop in options) { passedOptions[prop] = options[prop]; }
  if ((!options.enable || options.enable === true) && !options.select)
    { passedOptions[options.enable ? "enable" : "select"] = function (state) { return cmd(state); }; }

  return new prosemirror_menu__WEBPACK_IMPORTED_MODULE_6__.MenuItem(passedOptions)
}

function markActive(state, type) {
  var ref = state.selection;
  var from = ref.from;
  var $from = ref.$from;
  var to = ref.to;
  var empty = ref.empty;
  if (empty) { return type.isInSet(state.storedMarks || $from.marks()) }
  else { return state.doc.rangeHasMark(from, to, type) }
}

function markItem(markType, options) {
  var passedOptions = {
    active: function active(state) { return markActive(state, markType) },
    enable: true
  };
  for (var prop in options) { passedOptions[prop] = options[prop]; }
  return cmdItem((0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.toggleMark)(markType), passedOptions)
}

function linkItem(markType) {
  return new prosemirror_menu__WEBPACK_IMPORTED_MODULE_6__.MenuItem({
    title: "Add or remove link",
    icon: prosemirror_menu__WEBPACK_IMPORTED_MODULE_6__.icons.link,
    active: function active(state) { return markActive(state, markType) },
    enable: function enable(state) { return !state.selection.empty },
    run: function run(state, dispatch, view) {
      if (markActive(state, markType)) {
        (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.toggleMark)(markType)(state, dispatch);
        return true
      }
      openPrompt({
        title: "Create a link",
        fields: {
          href: new TextField({
            label: "Link target",
            required: true
          }),
          title: new TextField({label: "Title"})
        },
        callback: function callback(attrs) {
          (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.toggleMark)(markType, attrs)(view.state, view.dispatch);
          view.focus();
        }
      });
    }
  })
}

function wrapListItem(nodeType, options) {
  return cmdItem((0,prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_7__.wrapInList)(nodeType, options.attrs), options)
}

// :: (Schema) → Object
// Given a schema, look for default mark and node types in it and
// return an object with relevant menu items relating to those marks:
//
// **`toggleStrong`**`: MenuItem`
//   : A menu item to toggle the [strong mark](#schema-basic.StrongMark).
//
// **`toggleEm`**`: MenuItem`
//   : A menu item to toggle the [emphasis mark](#schema-basic.EmMark).
//
// **`toggleCode`**`: MenuItem`
//   : A menu item to toggle the [code font mark](#schema-basic.CodeMark).
//
// **`toggleLink`**`: MenuItem`
//   : A menu item to toggle the [link mark](#schema-basic.LinkMark).
//
// **`insertImage`**`: MenuItem`
//   : A menu item to insert an [image](#schema-basic.Image).
//
// **`wrapBulletList`**`: MenuItem`
//   : A menu item to wrap the selection in a [bullet list](#schema-list.BulletList).
//
// **`wrapOrderedList`**`: MenuItem`
//   : A menu item to wrap the selection in an [ordered list](#schema-list.OrderedList).
//
// **`wrapBlockQuote`**`: MenuItem`
//   : A menu item to wrap the selection in a [block quote](#schema-basic.BlockQuote).
//
// **`makeParagraph`**`: MenuItem`
//   : A menu item to set the current textblock to be a normal
//     [paragraph](#schema-basic.Paragraph).
//
// **`makeCodeBlock`**`: MenuItem`
//   : A menu item to set the current textblock to be a
//     [code block](#schema-basic.CodeBlock).
//
// **`makeHead[N]`**`: MenuItem`
//   : Where _N_ is 1 to 6. Menu items to set the current textblock to
//     be a [heading](#schema-basic.Heading) of level _N_.
//
// **`insertHorizontalRule`**`: MenuItem`
//   : A menu item to insert a horizontal rule.
//
// The return value also contains some prefabricated menu elements and
// menus, that you can use instead of composing your own menu from
// scratch:
//
// **`insertMenu`**`: Dropdown`
//   : A dropdown containing the `insertImage` and
//     `insertHorizontalRule` items.
//
// **`typeMenu`**`: Dropdown`
//   : A dropdown containing the items for making the current
//     textblock a paragraph, code block, or heading.
//
// **`fullMenu`**`: [[MenuElement]]`
//   : An array of arrays of menu elements for use as the full menu
//     for, for example the [menu bar](https://github.com/prosemirror/prosemirror-menu#user-content-menubar).
function buildMenuItems(schema) {
  var r = {}, type;
  if (type = schema.marks.strong)
    { r.toggleStrong = markItem(type, {title: "Toggle strong style", icon: prosemirror_menu__WEBPACK_IMPORTED_MODULE_6__.icons.strong}); }
  if (type = schema.marks.em)
    { r.toggleEm = markItem(type, {title: "Toggle emphasis", icon: prosemirror_menu__WEBPACK_IMPORTED_MODULE_6__.icons.em}); }
  if (type = schema.marks.code)
    { r.toggleCode = markItem(type, {title: "Toggle code font", icon: prosemirror_menu__WEBPACK_IMPORTED_MODULE_6__.icons.code}); }
  if (type = schema.marks.link)
    { r.toggleLink = linkItem(type); }

  if (type = schema.nodes.image)
    { r.insertImage = insertImageItem(type); }
  if (type = schema.nodes.bullet_list)
    { r.wrapBulletList = wrapListItem(type, {
      title: "Wrap in bullet list",
      icon: prosemirror_menu__WEBPACK_IMPORTED_MODULE_6__.icons.bulletList
    }); }
  if (type = schema.nodes.ordered_list)
    { r.wrapOrderedList = wrapListItem(type, {
      title: "Wrap in ordered list",
      icon: prosemirror_menu__WEBPACK_IMPORTED_MODULE_6__.icons.orderedList
    }); }
  if (type = schema.nodes.blockquote)
    { r.wrapBlockQuote = (0,prosemirror_menu__WEBPACK_IMPORTED_MODULE_6__.wrapItem)(type, {
      title: "Wrap in block quote",
      icon: prosemirror_menu__WEBPACK_IMPORTED_MODULE_6__.icons.blockquote
    }); }
  if (type = schema.nodes.paragraph)
    { r.makeParagraph = (0,prosemirror_menu__WEBPACK_IMPORTED_MODULE_6__.blockTypeItem)(type, {
      title: "Change to paragraph",
      label: "Plain"
    }); }
  if (type = schema.nodes.code_block)
    { r.makeCodeBlock = (0,prosemirror_menu__WEBPACK_IMPORTED_MODULE_6__.blockTypeItem)(type, {
      title: "Change to code block",
      label: "Code"
    }); }
  if (type = schema.nodes.heading)
    { for (var i = 1; i <= 10; i++)
      { r["makeHead" + i] = (0,prosemirror_menu__WEBPACK_IMPORTED_MODULE_6__.blockTypeItem)(type, {
        title: "Change to heading " + i,
        label: "Level " + i,
        attrs: {level: i}
      }); } }
  if (type = schema.nodes.horizontal_rule) {
    var hr = type;
    r.insertHorizontalRule = new prosemirror_menu__WEBPACK_IMPORTED_MODULE_6__.MenuItem({
      title: "Insert horizontal rule",
      label: "Horizontal rule",
      enable: function enable(state) { return canInsert(state, hr) },
      run: function run(state, dispatch) { dispatch(state.tr.replaceSelectionWith(hr.create())); }
    });
  }

  var cut = function (arr) { return arr.filter(function (x) { return x; }); };
  r.insertMenu = new prosemirror_menu__WEBPACK_IMPORTED_MODULE_6__.Dropdown(cut([r.insertImage, r.insertHorizontalRule]), {label: "Insert"});
  r.typeMenu = new prosemirror_menu__WEBPACK_IMPORTED_MODULE_6__.Dropdown(cut([r.makeParagraph, r.makeCodeBlock, r.makeHead1 && new prosemirror_menu__WEBPACK_IMPORTED_MODULE_6__.DropdownSubmenu(cut([
    r.makeHead1, r.makeHead2, r.makeHead3, r.makeHead4, r.makeHead5, r.makeHead6
  ]), {label: "Heading"})]), {label: "Type..."});

  r.inlineMenu = [cut([r.toggleStrong, r.toggleEm, r.toggleCode, r.toggleLink])];
  r.blockMenu = [cut([r.wrapBulletList, r.wrapOrderedList, r.wrapBlockQuote, prosemirror_menu__WEBPACK_IMPORTED_MODULE_6__.joinUpItem,
                      prosemirror_menu__WEBPACK_IMPORTED_MODULE_6__.liftItem, prosemirror_menu__WEBPACK_IMPORTED_MODULE_6__.selectParentNodeItem])];
  r.fullMenu = r.inlineMenu.concat([[r.insertMenu, r.typeMenu]], [[prosemirror_menu__WEBPACK_IMPORTED_MODULE_6__.undoItem, prosemirror_menu__WEBPACK_IMPORTED_MODULE_6__.redoItem]], r.blockMenu);

  return r
}

var mac = typeof navigator != "undefined" ? /Mac/.test(navigator.platform) : false;

// :: (Schema, ?Object) → Object
// Inspect the given schema looking for marks and nodes from the
// basic schema, and if found, add key bindings related to them.
// This will add:
//
// * **Mod-b** for toggling [strong](#schema-basic.StrongMark)
// * **Mod-i** for toggling [emphasis](#schema-basic.EmMark)
// * **Mod-`** for toggling [code font](#schema-basic.CodeMark)
// * **Ctrl-Shift-0** for making the current textblock a paragraph
// * **Ctrl-Shift-1** to **Ctrl-Shift-Digit6** for making the current
//   textblock a heading of the corresponding level
// * **Ctrl-Shift-Backslash** to make the current textblock a code block
// * **Ctrl-Shift-8** to wrap the selection in an ordered list
// * **Ctrl-Shift-9** to wrap the selection in a bullet list
// * **Ctrl->** to wrap the selection in a block quote
// * **Enter** to split a non-empty textblock in a list item while at
//   the same time splitting the list item
// * **Mod-Enter** to insert a hard break
// * **Mod-_** to insert a horizontal rule
// * **Backspace** to undo an input rule
// * **Alt-ArrowUp** to `joinUp`
// * **Alt-ArrowDown** to `joinDown`
// * **Mod-BracketLeft** to `lift`
// * **Escape** to `selectParentNode`
//
// You can suppress or map these bindings by passing a `mapKeys`
// argument, which maps key names (say `"Mod-B"` to either `false`, to
// remove the binding, or a new key name string.
function buildKeymap(schema, mapKeys) {
  var keys = {}, type;
  function bind(key, cmd) {
    if (mapKeys) {
      var mapped = mapKeys[key];
      if (mapped === false) { return }
      if (mapped) { key = mapped; }
    }
    keys[key] = cmd;
  }


  bind("Mod-z", prosemirror_history__WEBPACK_IMPORTED_MODULE_1__.undo);
  bind("Shift-Mod-z", prosemirror_history__WEBPACK_IMPORTED_MODULE_1__.redo);
  bind("Backspace", prosemirror_inputrules__WEBPACK_IMPORTED_MODULE_8__.undoInputRule);
  if (!mac) { bind("Mod-y", prosemirror_history__WEBPACK_IMPORTED_MODULE_1__.redo); }

  bind("Alt-ArrowUp", prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.joinUp);
  bind("Alt-ArrowDown", prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.joinDown);
  bind("Mod-BracketLeft", prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.lift);
  bind("Escape", prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.selectParentNode);

  if (type = schema.marks.strong) {
    bind("Mod-b", (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.toggleMark)(type));
    bind("Mod-B", (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.toggleMark)(type));
  }
  if (type = schema.marks.em) {
    bind("Mod-i", (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.toggleMark)(type));
    bind("Mod-I", (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.toggleMark)(type));
  }
  if (type = schema.marks.code)
    { bind("Mod-`", (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.toggleMark)(type)); }

  if (type = schema.nodes.bullet_list)
    { bind("Shift-Ctrl-8", (0,prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_7__.wrapInList)(type)); }
  if (type = schema.nodes.ordered_list)
    { bind("Shift-Ctrl-9", (0,prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_7__.wrapInList)(type)); }
  if (type = schema.nodes.blockquote)
    { bind("Ctrl->", (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.wrapIn)(type)); }
  if (type = schema.nodes.hard_break) {
    var br = type, cmd = (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.chainCommands)(prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.exitCode, function (state, dispatch) {
      dispatch(state.tr.replaceSelectionWith(br.create()).scrollIntoView());
      return true
    });
    bind("Mod-Enter", cmd);
    bind("Shift-Enter", cmd);
    if (mac) { bind("Ctrl-Enter", cmd); }
  }
  if (type = schema.nodes.list_item) {
    bind("Enter", (0,prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_7__.splitListItem)(type));
    bind("Mod-[", (0,prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_7__.liftListItem)(type));
    bind("Mod-]", (0,prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_7__.sinkListItem)(type));
  }
  if (type = schema.nodes.paragraph)
    { bind("Shift-Ctrl-0", (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.setBlockType)(type)); }
  if (type = schema.nodes.code_block)
    { bind("Shift-Ctrl-\\", (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.setBlockType)(type)); }
  if (type = schema.nodes.heading)
    { for (var i = 1; i <= 6; i++) { bind("Shift-Ctrl-" + i, (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.setBlockType)(type, {level: i})); } }
  if (type = schema.nodes.horizontal_rule) {
    var hr = type;
    bind("Mod-_", function (state, dispatch) {
      dispatch(state.tr.replaceSelectionWith(hr.create()).scrollIntoView());
      return true
    });
  }

  return keys
}

// : (NodeType) → InputRule
// Given a blockquote node type, returns an input rule that turns `"> "`
// at the start of a textblock into a blockquote.
function blockQuoteRule(nodeType) {
  return (0,prosemirror_inputrules__WEBPACK_IMPORTED_MODULE_8__.wrappingInputRule)(/^\s*>\s$/, nodeType)
}

// : (NodeType) → InputRule
// Given a list node type, returns an input rule that turns a number
// followed by a dot at the start of a textblock into an ordered list.
function orderedListRule(nodeType) {
  return (0,prosemirror_inputrules__WEBPACK_IMPORTED_MODULE_8__.wrappingInputRule)(/^(\d+)\.\s$/, nodeType, function (match) { return ({order: +match[1]}); },
                           function (match, node) { return node.childCount + node.attrs.order == +match[1]; })
}

// : (NodeType) → InputRule
// Given a list node type, returns an input rule that turns a bullet
// (dash, plush, or asterisk) at the start of a textblock into a
// bullet list.
function bulletListRule(nodeType) {
  return (0,prosemirror_inputrules__WEBPACK_IMPORTED_MODULE_8__.wrappingInputRule)(/^\s*([-+*])\s$/, nodeType)
}

// : (NodeType) → InputRule
// Given a code block node type, returns an input rule that turns a
// textblock starting with three backticks into a code block.
function codeBlockRule(nodeType) {
  return (0,prosemirror_inputrules__WEBPACK_IMPORTED_MODULE_8__.textblockTypeInputRule)(/^```$/, nodeType)
}

// : (NodeType, number) → InputRule
// Given a node type and a maximum level, creates an input rule that
// turns up to that number of `#` characters followed by a space at
// the start of a textblock into a heading whose level corresponds to
// the number of `#` signs.
function headingRule(nodeType, maxLevel) {
  return (0,prosemirror_inputrules__WEBPACK_IMPORTED_MODULE_8__.textblockTypeInputRule)(new RegExp("^(#{1," + maxLevel + "})\\s$"),
                                nodeType, function (match) { return ({level: match[1].length}); })
}

// : (Schema) → Plugin
// A set of input rules for creating the basic block quotes, lists,
// code blocks, and heading.
function buildInputRules(schema) {
  var rules = prosemirror_inputrules__WEBPACK_IMPORTED_MODULE_8__.smartQuotes.concat(prosemirror_inputrules__WEBPACK_IMPORTED_MODULE_8__.ellipsis, prosemirror_inputrules__WEBPACK_IMPORTED_MODULE_8__.emDash), type;
  if (type = schema.nodes.blockquote) { rules.push(blockQuoteRule(type)); }
  if (type = schema.nodes.ordered_list) { rules.push(orderedListRule(type)); }
  if (type = schema.nodes.bullet_list) { rules.push(bulletListRule(type)); }
  if (type = schema.nodes.code_block) { rules.push(codeBlockRule(type)); }
  if (type = schema.nodes.heading) { rules.push(headingRule(type, 6)); }
  return (0,prosemirror_inputrules__WEBPACK_IMPORTED_MODULE_8__.inputRules)({rules: rules})
}

// !! This module exports helper functions for deriving a set of basic
// menu items, input rules, or key bindings from a schema. These
// values need to know about the schema for two reasons—they need
// access to specific instances of node and mark types, and they need
// to know which of the node and mark types that they know about are
// actually present in the schema.
//
// The `exampleSetup` plugin ties these together into a plugin that
// will automatically enable this basic functionality in an editor.

// :: (Object) → [Plugin]
// A convenience plugin that bundles together a simple menu with basic
// key bindings, input rules, and styling for the example schema.
// Probably only useful for quickly setting up a passable
// editor—you'll need more control over your settings in most
// real-world situations.
//
//   options::- The following options are recognized:
//
//     schema:: Schema
//     The schema to generate key bindings and menu items for.
//
//     mapKeys:: ?Object
//     Can be used to [adjust](#example-setup.buildKeymap) the key bindings created.
//
//     menuBar:: ?bool
//     Set to false to disable the menu bar.
//
//     history:: ?bool
//     Set to false to disable the history plugin.
//
//     floatingMenu:: ?bool
//     Set to false to make the menu bar non-floating.
//
//     menuContent:: [[MenuItem]]
//     Can be used to override the menu content.
function exampleSetup(options) {
  var plugins = [
    buildInputRules(options.schema),
    (0,prosemirror_keymap__WEBPACK_IMPORTED_MODULE_0__.keymap)(buildKeymap(options.schema, options.mapKeys)),
    (0,prosemirror_keymap__WEBPACK_IMPORTED_MODULE_0__.keymap)(prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.baseKeymap),
    (0,prosemirror_dropcursor__WEBPACK_IMPORTED_MODULE_4__.dropCursor)(),
    (0,prosemirror_gapcursor__WEBPACK_IMPORTED_MODULE_5__.gapCursor)()
  ];
  if (options.menuBar !== false)
    { plugins.push((0,prosemirror_menu__WEBPACK_IMPORTED_MODULE_6__.menuBar)({floating: options.floatingMenu !== false,
                          content: options.menuContent || buildMenuItems(options.schema).fullMenu})); }
  if (options.history !== false)
    { plugins.push((0,prosemirror_history__WEBPACK_IMPORTED_MODULE_1__.history)()); }

  return plugins.concat(new prosemirror_state__WEBPACK_IMPORTED_MODULE_3__.Plugin({
    props: {
      attributes: {class: "ProseMirror-example-setup-style"}
    }
  }))
}


//# sourceMappingURL=index.es.js.map


/***/ }),

/***/ "./node_modules/prosemirror-gapcursor/dist/index.es.js":
/*!*************************************************************!*\
  !*** ./node_modules/prosemirror-gapcursor/dist/index.es.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "gapCursor": () => (/* binding */ gapCursor)
/* harmony export */ });
/* unused harmony export GapCursor */
/* harmony import */ var prosemirror_keymap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-keymap */ "./node_modules/prosemirror-keymap/dist/index.es.js");
/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.es.js");
/* harmony import */ var prosemirror_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-view */ "./node_modules/prosemirror-view/dist/index.es.js");
/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! prosemirror-model */ "./node_modules/prosemirror-model/dist/index.es.js");





// ::- Gap cursor selections are represented using this class. Its
// `$anchor` and `$head` properties both point at the cursor position.
var GapCursor = /*@__PURE__*/(function (Selection) {
  function GapCursor($pos) {
    Selection.call(this, $pos, $pos);
  }

  if ( Selection ) GapCursor.__proto__ = Selection;
  GapCursor.prototype = Object.create( Selection && Selection.prototype );
  GapCursor.prototype.constructor = GapCursor;

  GapCursor.prototype.map = function map (doc, mapping) {
    var $pos = doc.resolve(mapping.map(this.head));
    return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos)
  };

  GapCursor.prototype.content = function content () { return prosemirror_model__WEBPACK_IMPORTED_MODULE_3__.Slice.empty };

  GapCursor.prototype.eq = function eq (other) {
    return other instanceof GapCursor && other.head == this.head
  };

  GapCursor.prototype.toJSON = function toJSON () {
    return {type: "gapcursor", pos: this.head}
  };

  GapCursor.fromJSON = function fromJSON (doc, json) {
    if (typeof json.pos != "number") { throw new RangeError("Invalid input for GapCursor.fromJSON") }
    return new GapCursor(doc.resolve(json.pos))
  };

  GapCursor.prototype.getBookmark = function getBookmark () { return new GapBookmark(this.anchor) };

  GapCursor.valid = function valid ($pos) {
    var parent = $pos.parent;
    if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos)) { return false }
    var override = parent.type.spec.allowGapCursor;
    if (override != null) { return override }
    var deflt = parent.contentMatchAt($pos.index()).defaultType;
    return deflt && deflt.isTextblock
  };

  GapCursor.findFrom = function findFrom ($pos, dir, mustMove) {
    search: for (;;) {
      if (!mustMove && GapCursor.valid($pos)) { return $pos }
      var pos = $pos.pos, next = null;
      // Scan up from this position
      for (var d = $pos.depth;; d--) {
        var parent = $pos.node(d);
        if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {
          next = parent.child(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1);
          break
        } else if (d == 0) {
          return null
        }
        pos += dir;
        var $cur = $pos.doc.resolve(pos);
        if (GapCursor.valid($cur)) { return $cur }
      }

      // And then down into the next node
      for (;;) {
        var inside = dir > 0 ? next.firstChild : next.lastChild;
        if (!inside) {
          if (next.isAtom && !next.isText && !prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(next)) {
            $pos = $pos.doc.resolve(pos + next.nodeSize * dir);
            mustMove = false;
            continue search
          }
          break
        }
        next = inside;
        pos += dir;
        var $cur$1 = $pos.doc.resolve(pos);
        if (GapCursor.valid($cur$1)) { return $cur$1 }
      }

      return null
    }
  };

  return GapCursor;
}(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection));

GapCursor.prototype.visible = false;

prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.jsonID("gapcursor", GapCursor);

var GapBookmark = function GapBookmark(pos) {
  this.pos = pos;
};
GapBookmark.prototype.map = function map (mapping) {
  return new GapBookmark(mapping.map(this.pos))
};
GapBookmark.prototype.resolve = function resolve (doc) {
  var $pos = doc.resolve(this.pos);
  return GapCursor.valid($pos) ? new GapCursor($pos) : prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.near($pos)
};

function closedBefore($pos) {
  for (var d = $pos.depth; d >= 0; d--) {
    var index = $pos.index(d);
    // At the start of this parent, look at next one
    if (index == 0) { continue }
    // See if the node before (or its first ancestor) is closed
    for (var before = $pos.node(d).child(index - 1);; before = before.lastChild) {
      if ((before.childCount == 0 && !before.inlineContent) || before.isAtom || before.type.spec.isolating) { return true }
      if (before.inlineContent) { return false }
    }
  }
  // Hit start of document
  return true
}

function closedAfter($pos) {
  for (var d = $pos.depth; d >= 0; d--) {
    var index = $pos.indexAfter(d), parent = $pos.node(d);
    if (index == parent.childCount) { continue }
    for (var after = parent.child(index);; after = after.firstChild) {
      if ((after.childCount == 0 && !after.inlineContent) || after.isAtom || after.type.spec.isolating) { return true }
      if (after.inlineContent) { return false }
    }
  }
  return true
}

// :: () → Plugin
// Create a gap cursor plugin. When enabled, this will capture clicks
// near and arrow-key-motion past places that don't have a normally
// selectable position nearby, and create a gap cursor selection for
// them. The cursor is drawn as an element with class
// `ProseMirror-gapcursor`. You can either include
// `style/gapcursor.css` from the package's directory or add your own
// styles to make it visible.
var gapCursor = function() {
  return new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Plugin({
    props: {
      decorations: drawGapCursor,

      createSelectionBetween: function createSelectionBetween(_view, $anchor, $head) {
        if ($anchor.pos == $head.pos && GapCursor.valid($head)) { return new GapCursor($head) }
      },

      handleClick: handleClick,
      handleKeyDown: handleKeyDown
    }
  })
};

var handleKeyDown = (0,prosemirror_keymap__WEBPACK_IMPORTED_MODULE_0__.keydownHandler)({
  "ArrowLeft": arrow("horiz", -1),
  "ArrowRight": arrow("horiz", 1),
  "ArrowUp": arrow("vert", -1),
  "ArrowDown": arrow("vert", 1)
});

function arrow(axis, dir) {
  var dirStr = axis == "vert" ? (dir > 0 ? "down" : "up") : (dir > 0 ? "right" : "left");
  return function(state, dispatch, view) {
    var sel = state.selection;
    var $start = dir > 0 ? sel.$to : sel.$from, mustMove = sel.empty;
    if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection) {
      if (!view.endOfTextblock(dirStr) || $start.depth == 0) { return false }
      mustMove = false;
      $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before());
    }
    var $found = GapCursor.findFrom($start, dir, mustMove);
    if (!$found) { return false }
    if (dispatch) { dispatch(state.tr.setSelection(new GapCursor($found))); }
    return true
  }
}

function handleClick(view, pos, event) {
  if (!view.editable) { return false }
  var $pos = view.state.doc.resolve(pos);
  if (!GapCursor.valid($pos)) { return false }
  var ref = view.posAtCoords({left: event.clientX, top: event.clientY});
  var inside = ref.inside;
  if (inside > -1 && prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(view.state.doc.nodeAt(inside))) { return false }
  view.dispatch(view.state.tr.setSelection(new GapCursor($pos)));
  return true
}

function drawGapCursor(state) {
  if (!(state.selection instanceof GapCursor)) { return null }
  var node = document.createElement("div");
  node.className = "ProseMirror-gapcursor";
  return prosemirror_view__WEBPACK_IMPORTED_MODULE_2__.DecorationSet.create(state.doc, [prosemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.widget(state.selection.head, node, {key: "gapcursor"})])
}


//# sourceMappingURL=index.es.js.map


/***/ }),

/***/ "./node_modules/prosemirror-history/dist/index.es.js":
/*!***********************************************************!*\
  !*** ./node_modules/prosemirror-history/dist/index.es.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "history": () => (/* binding */ history),
/* harmony export */   "redo": () => (/* binding */ redo),
/* harmony export */   "undo": () => (/* binding */ undo)
/* harmony export */ });
/* unused harmony exports HistoryState, closeHistory, redoDepth, undoDepth */
/* harmony import */ var rope_sequence__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rope-sequence */ "./node_modules/rope-sequence/dist/index.es.js");
/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-transform */ "./node_modules/prosemirror-transform/dist/index.es.js");
/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.es.js");




// ProseMirror's history isn't simply a way to roll back to a previous
// state, because ProseMirror supports applying changes without adding
// them to the history (for example during collaboration).
//
// To this end, each 'Branch' (one for the undo history and one for
// the redo history) keeps an array of 'Items', which can optionally
// hold a step (an actual undoable change), and always hold a position
// map (which is needed to move changes below them to apply to the
// current document).
//
// An item that has both a step and a selection bookmark is the start
// of an 'event' — a group of changes that will be undone or redone at
// once. (It stores only the bookmark, since that way we don't have to
// provide a document until the selection is actually applied, which
// is useful when compressing.)

// Used to schedule history compression
var max_empty_items = 500;

var Branch = function Branch(items, eventCount) {
  this.items = items;
  this.eventCount = eventCount;
};

// : (EditorState, bool) → ?{transform: Transform, selection: ?SelectionBookmark, remaining: Branch}
// Pop the latest event off the branch's history and apply it
// to a document transform.
Branch.prototype.popEvent = function popEvent (state, preserveItems) {
    var this$1 = this;

  if (this.eventCount == 0) { return null }

  var end = this.items.length;
  for (;; end--) {
    var next = this.items.get(end - 1);
    if (next.selection) { --end; break }
  }

  var remap, mapFrom;
  if (preserveItems) {
    remap = this.remapping(end, this.items.length);
    mapFrom = remap.maps.length;
  }
  var transform = state.tr;
  var selection, remaining;
  var addAfter = [], addBefore = [];

  this.items.forEach(function (item, i) {
    if (!item.step) {
      if (!remap) {
        remap = this$1.remapping(end, i + 1);
        mapFrom = remap.maps.length;
      }
      mapFrom--;
      addBefore.push(item);
      return
    }

    if (remap) {
      addBefore.push(new Item(item.map));
      var step = item.step.map(remap.slice(mapFrom)), map;

      if (step && transform.maybeStep(step).doc) {
        map = transform.mapping.maps[transform.mapping.maps.length - 1];
        addAfter.push(new Item(map, null, null, addAfter.length + addBefore.length));
      }
      mapFrom--;
      if (map) { remap.appendMap(map, mapFrom); }
    } else {
      transform.maybeStep(item.step);
    }

    if (item.selection) {
      selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;
      remaining = new Branch(this$1.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this$1.eventCount - 1);
      return false
    }
  }, this.items.length, 0);

  return {remaining: remaining, transform: transform, selection: selection}
};

// : (Transform, ?SelectionBookmark, Object) → Branch
// Create a new branch with the given transform added.
Branch.prototype.addTransform = function addTransform (transform, selection, histOptions, preserveItems) {
  var newItems = [], eventCount = this.eventCount;
  var oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;

  for (var i = 0; i < transform.steps.length; i++) {
    var step = transform.steps[i].invert(transform.docs[i]);
    var item = new Item(transform.mapping.maps[i], step, selection), merged = (void 0);
    if (merged = lastItem && lastItem.merge(item)) {
      item = merged;
      if (i) { newItems.pop(); }
      else { oldItems = oldItems.slice(0, oldItems.length - 1); }
    }
    newItems.push(item);
    if (selection) {
      eventCount++;
      selection = null;
    }
    if (!preserveItems) { lastItem = item; }
  }
  var overflow = eventCount - histOptions.depth;
  if (overflow > DEPTH_OVERFLOW) {
    oldItems = cutOffEvents(oldItems, overflow);
    eventCount -= overflow;
  }
  return new Branch(oldItems.append(newItems), eventCount)
};

Branch.prototype.remapping = function remapping (from, to) {
  var maps = new prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.Mapping;
  this.items.forEach(function (item, i) {
    var mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from
        ? maps.maps.length - item.mirrorOffset : null;
    maps.appendMap(item.map, mirrorPos);
  }, from, to);
  return maps
};

Branch.prototype.addMaps = function addMaps (array) {
  if (this.eventCount == 0) { return this }
  return new Branch(this.items.append(array.map(function (map) { return new Item(map); })), this.eventCount)
};

// : (Transform, number)
// When the collab module receives remote changes, the history has
// to know about those, so that it can adjust the steps that were
// rebased on top of the remote changes, and include the position
// maps for the remote changes in its array of items.
Branch.prototype.rebased = function rebased (rebasedTransform, rebasedCount) {
  if (!this.eventCount) { return this }

  var rebasedItems = [], start = Math.max(0, this.items.length - rebasedCount);

  var mapping = rebasedTransform.mapping;
  var newUntil = rebasedTransform.steps.length;
  var eventCount = this.eventCount;
  this.items.forEach(function (item) { if (item.selection) { eventCount--; } }, start);

  var iRebased = rebasedCount;
  this.items.forEach(function (item) {
    var pos = mapping.getMirror(--iRebased);
    if (pos == null) { return }
    newUntil = Math.min(newUntil, pos);
    var map = mapping.maps[pos];
    if (item.step) {
      var step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);
      var selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));
      if (selection) { eventCount++; }
      rebasedItems.push(new Item(map, step, selection));
    } else {
      rebasedItems.push(new Item(map));
    }
  }, start);

  var newMaps = [];
  for (var i = rebasedCount; i < newUntil; i++)
    { newMaps.push(new Item(mapping.maps[i])); }
  var items = this.items.slice(0, start).append(newMaps).append(rebasedItems);
  var branch = new Branch(items, eventCount);

  if (branch.emptyItemCount() > max_empty_items)
    { branch = branch.compress(this.items.length - rebasedItems.length); }
  return branch
};

Branch.prototype.emptyItemCount = function emptyItemCount () {
  var count = 0;
  this.items.forEach(function (item) { if (!item.step) { count++; } });
  return count
};

// Compressing a branch means rewriting it to push the air (map-only
// items) out. During collaboration, these naturally accumulate
// because each remote change adds one. The `upto` argument is used
// to ensure that only the items below a given level are compressed,
// because `rebased` relies on a clean, untouched set of items in
// order to associate old items with rebased steps.
Branch.prototype.compress = function compress (upto) {
    if ( upto === void 0 ) upto = this.items.length;

  var remap = this.remapping(0, upto), mapFrom = remap.maps.length;
  var items = [], events = 0;
  this.items.forEach(function (item, i) {
    if (i >= upto) {
      items.push(item);
      if (item.selection) { events++; }
    } else if (item.step) {
      var step = item.step.map(remap.slice(mapFrom)), map = step && step.getMap();
      mapFrom--;
      if (map) { remap.appendMap(map, mapFrom); }
      if (step) {
        var selection = item.selection && item.selection.map(remap.slice(mapFrom));
        if (selection) { events++; }
        var newItem = new Item(map.invert(), step, selection), merged, last = items.length - 1;
        if (merged = items.length && items[last].merge(newItem))
          { items[last] = merged; }
        else
          { items.push(newItem); }
      }
    } else if (item.map) {
      mapFrom--;
    }
  }, this.items.length, 0);
  return new Branch(rope_sequence__WEBPACK_IMPORTED_MODULE_0__["default"].from(items.reverse()), events)
};

Branch.empty = new Branch(rope_sequence__WEBPACK_IMPORTED_MODULE_0__["default"].empty, 0);

function cutOffEvents(items, n) {
  var cutPoint;
  items.forEach(function (item, i) {
    if (item.selection && (n-- == 0)) {
      cutPoint = i;
      return false
    }
  });
  return items.slice(cutPoint)
}

var Item = function Item(map, step, selection, mirrorOffset) {
  // The (forward) step map for this item.
  this.map = map;
  // The inverted step
  this.step = step;
  // If this is non-null, this item is the start of a group, and
  // this selection is the starting selection for the group (the one
  // that was active before the first step was applied)
  this.selection = selection;
  // If this item is the inverse of a previous mapping on the stack,
  // this points at the inverse's offset
  this.mirrorOffset = mirrorOffset;
};

Item.prototype.merge = function merge (other) {
  if (this.step && other.step && !other.selection) {
    var step = other.step.merge(this.step);
    if (step) { return new Item(step.getMap().invert(), step, this.selection) }
  }
};

// The value of the state field that tracks undo/redo history for that
// state. Will be stored in the plugin state when the history plugin
// is active.
var HistoryState = function HistoryState(done, undone, prevRanges, prevTime) {
  this.done = done;
  this.undone = undone;
  this.prevRanges = prevRanges;
  this.prevTime = prevTime;
};

var DEPTH_OVERFLOW = 20;

// : (HistoryState, EditorState, Transaction, Object)
// Record a transformation in undo history.
function applyTransaction(history, state, tr, options) {
  var historyTr = tr.getMeta(historyKey), rebased;
  if (historyTr) { return historyTr.historyState }

  if (tr.getMeta(closeHistoryKey)) { history = new HistoryState(history.done, history.undone, null, 0); }

  var appended = tr.getMeta("appendedTransaction");

  if (tr.steps.length == 0) {
    return history
  } else if (appended && appended.getMeta(historyKey)) {
    if (appended.getMeta(historyKey).redo)
      { return new HistoryState(history.done.addTransform(tr, null, options, mustPreserveItems(state)),
                              history.undone, rangesFor(tr.mapping.maps[tr.steps.length - 1]), history.prevTime) }
    else
      { return new HistoryState(history.done, history.undone.addTransform(tr, null, options, mustPreserveItems(state)),
                              null, history.prevTime) }
  } else if (tr.getMeta("addToHistory") !== false && !(appended && appended.getMeta("addToHistory") === false)) {
    // Group transforms that occur in quick succession into one event.
    var newGroup = history.prevTime == 0 || !appended && (history.prevTime < (tr.time || 0) - options.newGroupDelay ||
                                                          !isAdjacentTo(tr, history.prevRanges));
    var prevRanges = appended ? mapRanges(history.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps[tr.steps.length - 1]);
    return new HistoryState(history.done.addTransform(tr, newGroup ? state.selection.getBookmark() : null,
                                                      options, mustPreserveItems(state)),
                            Branch.empty, prevRanges, tr.time)
  } else if (rebased = tr.getMeta("rebased")) {
    // Used by the collab module to tell the history that some of its
    // content has been rebased.
    return new HistoryState(history.done.rebased(tr, rebased),
                            history.undone.rebased(tr, rebased),
                            mapRanges(history.prevRanges, tr.mapping), history.prevTime)
  } else {
    return new HistoryState(history.done.addMaps(tr.mapping.maps),
                            history.undone.addMaps(tr.mapping.maps),
                            mapRanges(history.prevRanges, tr.mapping), history.prevTime)
  }
}

function isAdjacentTo(transform, prevRanges) {
  if (!prevRanges) { return false }
  if (!transform.docChanged) { return true }
  var adjacent = false;
  transform.mapping.maps[0].forEach(function (start, end) {
    for (var i = 0; i < prevRanges.length; i += 2)
      { if (start <= prevRanges[i + 1] && end >= prevRanges[i])
        { adjacent = true; } }
  });
  return adjacent
}

function rangesFor(map) {
  var result = [];
  map.forEach(function (_from, _to, from, to) { return result.push(from, to); });
  return result
}

function mapRanges(ranges, mapping) {
  if (!ranges) { return null }
  var result = [];
  for (var i = 0; i < ranges.length; i += 2) {
    var from = mapping.map(ranges[i], 1), to = mapping.map(ranges[i + 1], -1);
    if (from <= to) { result.push(from, to); }
  }
  return result
}

// : (HistoryState, EditorState, (tr: Transaction), bool)
// Apply the latest event from one branch to the document and shift the event
// onto the other branch.
function histTransaction(history, state, dispatch, redo) {
  var preserveItems = mustPreserveItems(state), histOptions = historyKey.get(state).spec.config;
  var pop = (redo ? history.undone : history.done).popEvent(state, preserveItems);
  if (!pop) { return }

  var selection = pop.selection.resolve(pop.transform.doc);
  var added = (redo ? history.done : history.undone).addTransform(pop.transform, state.selection.getBookmark(),
                                                                  histOptions, preserveItems);

  var newHist = new HistoryState(redo ? added : pop.remaining, redo ? pop.remaining : added, null, 0);
  dispatch(pop.transform.setSelection(selection).setMeta(historyKey, {redo: redo, historyState: newHist}).scrollIntoView());
}

var cachedPreserveItems = false, cachedPreserveItemsPlugins = null;
// Check whether any plugin in the given state has a
// `historyPreserveItems` property in its spec, in which case we must
// preserve steps exactly as they came in, so that they can be
// rebased.
function mustPreserveItems(state) {
  var plugins = state.plugins;
  if (cachedPreserveItemsPlugins != plugins) {
    cachedPreserveItems = false;
    cachedPreserveItemsPlugins = plugins;
    for (var i = 0; i < plugins.length; i++) { if (plugins[i].spec.historyPreserveItems) {
      cachedPreserveItems = true;
      break
    } }
  }
  return cachedPreserveItems
}

// :: (Transaction) → Transaction
// Set a flag on the given transaction that will prevent further steps
// from being appended to an existing history event (so that they
// require a separate undo command to undo).
function closeHistory(tr) {
  return tr.setMeta(closeHistoryKey, true)
}

var historyKey = new prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.PluginKey("history");
var closeHistoryKey = new prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.PluginKey("closeHistory");

// :: (?Object) → Plugin
// Returns a plugin that enables the undo history for an editor. The
// plugin will track undo and redo stacks, which can be used with the
// [`undo`](#history.undo) and [`redo`](#history.redo) commands.
//
// You can set an `"addToHistory"` [metadata
// property](#state.Transaction.setMeta) of `false` on a transaction
// to prevent it from being rolled back by undo.
//
//   config::-
//   Supports the following configuration options:
//
//     depth:: ?number
//     The amount of history events that are collected before the
//     oldest events are discarded. Defaults to 100.
//
//     newGroupDelay:: ?number
//     The delay between changes after which a new group should be
//     started. Defaults to 500 (milliseconds). Note that when changes
//     aren't adjacent, a new group is always started.
function history(config) {
  config = {depth: config && config.depth || 100,
            newGroupDelay: config && config.newGroupDelay || 500};
  return new prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.Plugin({
    key: historyKey,

    state: {
      init: function init() {
        return new HistoryState(Branch.empty, Branch.empty, null, 0)
      },
      apply: function apply(tr, hist, state) {
        return applyTransaction(hist, state, tr, config)
      }
    },

    config: config,

    props: {
      handleDOMEvents: {
        beforeinput: function beforeinput(view, e) {
          var handled = e.inputType == "historyUndo" ? undo(view.state, view.dispatch) :
              e.inputType == "historyRedo" ? redo(view.state, view.dispatch) : false;
          if (handled) { e.preventDefault(); }
          return handled
        }
      }
    }
  })
}

// :: (EditorState, ?(tr: Transaction)) → bool
// A command function that undoes the last change, if any.
function undo(state, dispatch) {
  var hist = historyKey.getState(state);
  if (!hist || hist.done.eventCount == 0) { return false }
  if (dispatch) { histTransaction(hist, state, dispatch, false); }
  return true
}

// :: (EditorState, ?(tr: Transaction)) → bool
// A command function that redoes the last undone change, if any.
function redo(state, dispatch) {
  var hist = historyKey.getState(state);
  if (!hist || hist.undone.eventCount == 0) { return false }
  if (dispatch) { histTransaction(hist, state, dispatch, true); }
  return true
}

// :: (EditorState) → number
// The amount of undoable events available in a given state.
function undoDepth(state) {
  var hist = historyKey.getState(state);
  return hist ? hist.done.eventCount : 0
}

// :: (EditorState) → number
// The amount of redoable events available in a given editor state.
function redoDepth(state) {
  var hist = historyKey.getState(state);
  return hist ? hist.undone.eventCount : 0
}


//# sourceMappingURL=index.es.js.map


/***/ }),

/***/ "./node_modules/prosemirror-inputrules/dist/index.es.js":
/*!**************************************************************!*\
  !*** ./node_modules/prosemirror-inputrules/dist/index.es.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "InputRule": () => (/* binding */ InputRule),
/* harmony export */   "closeDoubleQuote": () => (/* binding */ closeDoubleQuote),
/* harmony export */   "closeSingleQuote": () => (/* binding */ closeSingleQuote),
/* harmony export */   "ellipsis": () => (/* binding */ ellipsis),
/* harmony export */   "emDash": () => (/* binding */ emDash),
/* harmony export */   "inputRules": () => (/* binding */ inputRules),
/* harmony export */   "openDoubleQuote": () => (/* binding */ openDoubleQuote),
/* harmony export */   "openSingleQuote": () => (/* binding */ openSingleQuote),
/* harmony export */   "smartQuotes": () => (/* binding */ smartQuotes),
/* harmony export */   "textblockTypeInputRule": () => (/* binding */ textblockTypeInputRule),
/* harmony export */   "undoInputRule": () => (/* binding */ undoInputRule),
/* harmony export */   "wrappingInputRule": () => (/* binding */ wrappingInputRule)
/* harmony export */ });
/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.es.js");
/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-transform */ "./node_modules/prosemirror-transform/dist/index.es.js");



// ::- Input rules are regular expressions describing a piece of text
// that, when typed, causes something to happen. This might be
// changing two dashes into an emdash, wrapping a paragraph starting
// with `"> "` into a blockquote, or something entirely different.
var InputRule = function InputRule(match, handler) {
  this.match = match;
  this.handler = typeof handler == "string" ? stringHandler(handler) : handler;
};

function stringHandler(string) {
  return function(state, match, start, end) {
    var insert = string;
    if (match[1]) {
      var offset = match[0].lastIndexOf(match[1]);
      insert += match[0].slice(offset + match[1].length);
      start += offset;
      var cutOff = start - end;
      if (cutOff > 0) {
        insert = match[0].slice(offset - cutOff, offset) + insert;
        start = end;
      }
    }
    return state.tr.insertText(insert, start, end)
  }
}

var MAX_MATCH = 500;

// :: (config: {rules: [InputRule]}) → Plugin
// Create an input rules plugin. When enabled, it will cause text
// input that matches any of the given rules to trigger the rule's
// action.
function inputRules(ref) {
  var rules = ref.rules;

  var plugin = new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({
    state: {
      init: function init() { return null },
      apply: function apply(tr, prev) {
        var stored = tr.getMeta(this);
        if (stored) { return stored }
        return tr.selectionSet || tr.docChanged ? null : prev
      }
    },

    props: {
      handleTextInput: function handleTextInput(view, from, to, text) {
        return run(view, from, to, text, rules, plugin)
      },
      handleDOMEvents: {
        compositionend: function (view) {
          setTimeout(function () {
            var ref = view.state.selection;
            var $cursor = ref.$cursor;
            if ($cursor) { run(view, $cursor.pos, $cursor.pos, "", rules, plugin); }
          });
        }
      }
    },

    isInputRules: true
  });
  return plugin
}

function run(view, from, to, text, rules, plugin) {
  if (view.composing) { return false }
  var state = view.state, $from = state.doc.resolve(from);
  if ($from.parent.type.spec.code) { return false }
  var textBefore = $from.parent.textBetween(Math.max(0, $from.parentOffset - MAX_MATCH), $from.parentOffset,
                                            null, "\ufffc") + text;
  for (var i = 0; i < rules.length; i++) {
    var match = rules[i].match.exec(textBefore);
    var tr = match && rules[i].handler(state, match, from - (match[0].length - text.length), to);
    if (!tr) { continue }
    view.dispatch(tr.setMeta(plugin, {transform: tr, from: from, to: to, text: text}));
    return true
  }
  return false
}

// :: (EditorState, ?(Transaction)) → bool
// This is a command that will undo an input rule, if applying such a
// rule was the last thing that the user did.
function undoInputRule(state, dispatch) {
  var plugins = state.plugins;
  for (var i = 0; i < plugins.length; i++) {
    var plugin = plugins[i], undoable = (void 0);
    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {
      if (dispatch) {
        var tr = state.tr, toUndo = undoable.transform;
        for (var j = toUndo.steps.length - 1; j >= 0; j--)
          { tr.step(toUndo.steps[j].invert(toUndo.docs[j])); }
        if (undoable.text) {
          var marks = tr.doc.resolve(undoable.from).marks();
          tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));
        } else {
          tr.delete(undoable.from, undoable.to);
        }
        dispatch(tr);
      }
      return true
    }
  }
  return false
}

// :: InputRule Converts double dashes to an emdash.
var emDash = new InputRule(/--$/, "—");
// :: InputRule Converts three dots to an ellipsis character.
var ellipsis = new InputRule(/\.\.\.$/, "…");
// :: InputRule “Smart” opening double quotes.
var openDoubleQuote = new InputRule(/(?:^|[\s\{\[\(\<'"\u2018\u201C])(")$/, "“");
// :: InputRule “Smart” closing double quotes.
var closeDoubleQuote = new InputRule(/"$/, "”");
// :: InputRule “Smart” opening single quotes.
var openSingleQuote = new InputRule(/(?:^|[\s\{\[\(\<'"\u2018\u201C])(')$/, "‘");
// :: InputRule “Smart” closing single quotes.
var closeSingleQuote = new InputRule(/'$/, "’");

// :: [InputRule] Smart-quote related input rules.
var smartQuotes = [openDoubleQuote, closeDoubleQuote, openSingleQuote, closeSingleQuote];

// :: (RegExp, NodeType, ?union<Object, ([string]) → ?Object>, ?([string], Node) → bool) → InputRule
// Build an input rule for automatically wrapping a textblock when a
// given string is typed. The `regexp` argument is
// directly passed through to the `InputRule` constructor. You'll
// probably want the regexp to start with `^`, so that the pattern can
// only occur at the start of a textblock.
//
// `nodeType` is the type of node to wrap in. If it needs attributes,
// you can either pass them directly, or pass a function that will
// compute them from the regular expression match.
//
// By default, if there's a node with the same type above the newly
// wrapped node, the rule will try to [join](#transform.Transform.join) those
// two nodes. You can pass a join predicate, which takes a regular
// expression match and the node before the wrapped node, and can
// return a boolean to indicate whether a join should happen.
function wrappingInputRule(regexp, nodeType, getAttrs, joinPredicate) {
  return new InputRule(regexp, function (state, match, start, end) {
    var attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;
    var tr = state.tr.delete(start, end);
    var $start = tr.doc.resolve(start), range = $start.blockRange(), wrapping = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.findWrapping)(range, nodeType, attrs);
    if (!wrapping) { return null }
    tr.wrap(range, wrapping);
    var before = tr.doc.resolve(start - 1).nodeBefore;
    if (before && before.type == nodeType && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.canJoin)(tr.doc, start - 1) &&
        (!joinPredicate || joinPredicate(match, before)))
      { tr.join(start - 1); }
    return tr
  })
}

// :: (RegExp, NodeType, ?union<Object, ([string]) → ?Object>) → InputRule
// Build an input rule that changes the type of a textblock when the
// matched text is typed into it. You'll usually want to start your
// regexp with `^` to that it is only matched at the start of a
// textblock. The optional `getAttrs` parameter can be used to compute
// the new node's attributes, and works the same as in the
// `wrappingInputRule` function.
function textblockTypeInputRule(regexp, nodeType, getAttrs) {
  return new InputRule(regexp, function (state, match, start, end) {
    var $start = state.doc.resolve(start);
    var attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;
    if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), nodeType)) { return null }
    return state.tr
      .delete(start, end)
      .setBlockType(start, start, nodeType, attrs)
  })
}


//# sourceMappingURL=index.es.js.map


/***/ }),

/***/ "./node_modules/prosemirror-keymap/dist/index.es.js":
/*!**********************************************************!*\
  !*** ./node_modules/prosemirror-keymap/dist/index.es.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "keydownHandler": () => (/* binding */ keydownHandler),
/* harmony export */   "keymap": () => (/* binding */ keymap)
/* harmony export */ });
/* harmony import */ var w3c_keyname__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! w3c-keyname */ "./node_modules/w3c-keyname/index.es.js");
/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.es.js");



// declare global: navigator

var mac = typeof navigator != "undefined" ? /Mac/.test(navigator.platform) : false;

function normalizeKeyName(name) {
  var parts = name.split(/-(?!$)/), result = parts[parts.length - 1];
  if (result == "Space") { result = " "; }
  var alt, ctrl, shift, meta;
  for (var i = 0; i < parts.length - 1; i++) {
    var mod = parts[i];
    if (/^(cmd|meta|m)$/i.test(mod)) { meta = true; }
    else if (/^a(lt)?$/i.test(mod)) { alt = true; }
    else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true; }
    else if (/^s(hift)?$/i.test(mod)) { shift = true; }
    else if (/^mod$/i.test(mod)) { if (mac) { meta = true; } else { ctrl = true; } }
    else { throw new Error("Unrecognized modifier name: " + mod) }
  }
  if (alt) { result = "Alt-" + result; }
  if (ctrl) { result = "Ctrl-" + result; }
  if (meta) { result = "Meta-" + result; }
  if (shift) { result = "Shift-" + result; }
  return result
}

function normalize(map) {
  var copy = Object.create(null);
  for (var prop in map) { copy[normalizeKeyName(prop)] = map[prop]; }
  return copy
}

function modifiers(name, event, shift) {
  if (event.altKey) { name = "Alt-" + name; }
  if (event.ctrlKey) { name = "Ctrl-" + name; }
  if (event.metaKey) { name = "Meta-" + name; }
  if (shift !== false && event.shiftKey) { name = "Shift-" + name; }
  return name
}

// :: (Object) → Plugin
// Create a keymap plugin for the given set of bindings.
//
// Bindings should map key names to [command](#commands)-style
// functions, which will be called with `(EditorState, dispatch,
// EditorView)` arguments, and should return true when they've handled
// the key. Note that the view argument isn't part of the command
// protocol, but can be used as an escape hatch if a binding needs to
// directly interact with the UI.
//
// Key names may be strings like `"Shift-Ctrl-Enter"`—a key
// identifier prefixed with zero or more modifiers. Key identifiers
// are based on the strings that can appear in
// [`KeyEvent.key`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key).
// Use lowercase letters to refer to letter keys (or uppercase letters
// if you want shift to be held). You may use `"Space"` as an alias
// for the `" "` name.
//
// Modifiers can be given in any order. `Shift-` (or `s-`), `Alt-` (or
// `a-`), `Ctrl-` (or `c-` or `Control-`) and `Cmd-` (or `m-` or
// `Meta-`) are recognized. For characters that are created by holding
// shift, the `Shift-` prefix is implied, and should not be added
// explicitly.
//
// You can use `Mod-` as a shorthand for `Cmd-` on Mac and `Ctrl-` on
// other platforms.
//
// You can add multiple keymap plugins to an editor. The order in
// which they appear determines their precedence (the ones early in
// the array get to dispatch first).
function keymap(bindings) {
  return new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Plugin({props: {handleKeyDown: keydownHandler(bindings)}})
}

// :: (Object) → (view: EditorView, event: dom.Event) → bool
// Given a set of bindings (using the same format as
// [`keymap`](#keymap.keymap), return a [keydown
// handler](#view.EditorProps.handleKeyDown) that handles them.
function keydownHandler(bindings) {
  var map = normalize(bindings);
  return function(view, event) {
    var name = (0,w3c_keyname__WEBPACK_IMPORTED_MODULE_0__.keyName)(event), isChar = name.length == 1 && name != " ", baseName;
    var direct = map[modifiers(name, event, !isChar)];
    if (direct && direct(view.state, view.dispatch, view)) { return true }
    if (isChar && (event.shiftKey || event.altKey || event.metaKey || name.charCodeAt(0) > 127) &&
        (baseName = w3c_keyname__WEBPACK_IMPORTED_MODULE_0__.base[event.keyCode]) && baseName != name) {
      // Try falling back to the keyCode when there's a modifier
      // active or the character produced isn't ASCII, and our table
      // produces a different name from the the keyCode. See #668,
      // #1060
      var fromCode = map[modifiers(baseName, event, true)];
      if (fromCode && fromCode(view.state, view.dispatch, view)) { return true }
    } else if (isChar && event.shiftKey) {
      // Otherwise, if shift is active, also try the binding with the
      // Shift- prefix enabled. See #997
      var withShift = map[modifiers(name, event, true)];
      if (withShift && withShift(view.state, view.dispatch, view)) { return true }
    }
    return false
  }
}


//# sourceMappingURL=index.es.js.map


/***/ }),

/***/ "./node_modules/prosemirror-menu/dist/index.es.js":
/*!********************************************************!*\
  !*** ./node_modules/prosemirror-menu/dist/index.es.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Dropdown": () => (/* binding */ Dropdown),
/* harmony export */   "DropdownSubmenu": () => (/* binding */ DropdownSubmenu),
/* harmony export */   "MenuItem": () => (/* binding */ MenuItem),
/* harmony export */   "blockTypeItem": () => (/* binding */ blockTypeItem),
/* harmony export */   "icons": () => (/* binding */ icons),
/* harmony export */   "joinUpItem": () => (/* binding */ joinUpItem),
/* harmony export */   "liftItem": () => (/* binding */ liftItem),
/* harmony export */   "menuBar": () => (/* binding */ menuBar),
/* harmony export */   "redoItem": () => (/* binding */ redoItem),
/* harmony export */   "selectParentNodeItem": () => (/* binding */ selectParentNodeItem),
/* harmony export */   "undoItem": () => (/* binding */ undoItem),
/* harmony export */   "wrapItem": () => (/* binding */ wrapItem)
/* harmony export */ });
/* unused harmony export renderGrouped */
/* harmony import */ var crelt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crelt */ "./node_modules/crelt/index.es.js");
/* harmony import */ var prosemirror_commands__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-commands */ "./node_modules/prosemirror-commands/dist/index.es.js");
/* harmony import */ var prosemirror_history__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-history */ "./node_modules/prosemirror-history/dist/index.es.js");
/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.es.js");





var SVG = "http://www.w3.org/2000/svg";
var XLINK = "http://www.w3.org/1999/xlink";

var prefix = "ProseMirror-icon";

function hashPath(path) {
  var hash = 0;
  for (var i = 0; i < path.length; i++)
    { hash = (((hash << 5) - hash) + path.charCodeAt(i)) | 0; }
  return hash
}

function getIcon(icon) {
  var node = document.createElement("div");
  node.className = prefix;
  if (icon.path) {
    var name = "pm-icon-" + hashPath(icon.path).toString(16);
    if (!document.getElementById(name)) { buildSVG(name, icon); }
    var svg = node.appendChild(document.createElementNS(SVG, "svg"));
    svg.style.width = (icon.width / icon.height) + "em";
    var use = svg.appendChild(document.createElementNS(SVG, "use"));
    use.setAttributeNS(XLINK, "href", /([^#]*)/.exec(document.location)[1] + "#" + name);
  } else if (icon.dom) {
    node.appendChild(icon.dom.cloneNode(true));
  } else {
    node.appendChild(document.createElement("span")).textContent = icon.text || '';
    if (icon.css) { node.firstChild.style.cssText = icon.css; }
  }
  return node
}

function buildSVG(name, data) {
  var collection = document.getElementById(prefix + "-collection");
  if (!collection) {
    collection = document.createElementNS(SVG, "svg");
    collection.id = prefix + "-collection";
    collection.style.display = "none";
    document.body.insertBefore(collection, document.body.firstChild);
  }
  var sym = document.createElementNS(SVG, "symbol");
  sym.id = name;
  sym.setAttribute("viewBox", "0 0 " + data.width + " " + data.height);
  var path = sym.appendChild(document.createElementNS(SVG, "path"));
  path.setAttribute("d", data.path);
  collection.appendChild(sym);
}

var prefix$1 = "ProseMirror-menu";

// ::- An icon or label that, when clicked, executes a command.
var MenuItem = function MenuItem(spec) {
  // :: MenuItemSpec
  // The spec used to create the menu item.
  this.spec = spec;
};

// :: (EditorView) → {dom: dom.Node, update: (EditorState) → bool}
// Renders the icon according to its [display
// spec](#menu.MenuItemSpec.display), and adds an event handler which
// executes the command when the representation is clicked.
MenuItem.prototype.render = function render (view) {
  var spec = this.spec;
  var dom = spec.render ? spec.render(view)
      : spec.icon ? getIcon(spec.icon)
      : spec.label ? (0,crelt__WEBPACK_IMPORTED_MODULE_0__["default"])("div", null, translate(view, spec.label))
      : null;
  if (!dom) { throw new RangeError("MenuItem without icon or label property") }
  if (spec.title) {
    var title = (typeof spec.title === "function" ? spec.title(view.state) : spec.title);
    dom.setAttribute("title", translate(view, title));
  }
  if (spec.class) { dom.classList.add(spec.class); }
  if (spec.css) { dom.style.cssText += spec.css; }

  dom.addEventListener("mousedown", function (e) {
    e.preventDefault();
    if (!dom.classList.contains(prefix$1 + "-disabled"))
      { spec.run(view.state, view.dispatch, view, e); }
  });

  function update(state) {
    if (spec.select) {
      var selected = spec.select(state);
      dom.style.display = selected ? "" : "none";
      if (!selected) { return false }
    }
    var enabled = true;
    if (spec.enable) {
      enabled = spec.enable(state) || false;
      setClass(dom, prefix$1 + "-disabled", !enabled);
    }
    if (spec.active) {
      var active = enabled && spec.active(state) || false;
      setClass(dom, prefix$1 + "-active", active);
    }
    return true
  }

  return {dom: dom, update: update}
};

function translate(view, text) {
  return view._props.translate ? view._props.translate(text) : text
}

// MenuItemSpec:: interface
// The configuration object passed to the `MenuItem` constructor.
//
//   run:: (EditorState, (Transaction), EditorView, dom.Event)
//   The function to execute when the menu item is activated.
//
//   select:: ?(EditorState) → bool
//   Optional function that is used to determine whether the item is
//   appropriate at the moment. Deselected items will be hidden.
//
//   enable:: ?(EditorState) → bool
//   Function that is used to determine if the item is enabled. If
//   given and returning false, the item will be given a disabled
//   styling.
//
//   active:: ?(EditorState) → bool
//   A predicate function to determine whether the item is 'active' (for
//   example, the item for toggling the strong mark might be active then
//   the cursor is in strong text).
//
//   render:: ?(EditorView) → dom.Node
//   A function that renders the item. You must provide either this,
//   [`icon`](#menu.MenuItemSpec.icon), or [`label`](#MenuItemSpec.label).
//
//   icon:: ?Object
//   Describes an icon to show for this item. The object may specify
//   an SVG icon, in which case its `path` property should be an [SVG
//   path
//   spec](https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d),
//   and `width` and `height` should provide the viewbox in which that
//   path exists. Alternatively, it may have a `text` property
//   specifying a string of text that makes up the icon, with an
//   optional `css` property giving additional CSS styling for the
//   text. _Or_ it may contain `dom` property containing a DOM node.
//
//   label:: ?string
//   Makes the item show up as a text label. Mostly useful for items
//   wrapped in a [drop-down](#menu.Dropdown) or similar menu. The object
//   should have a `label` property providing the text to display.
//
//   title:: ?union<string, (EditorState) → string>
//   Defines DOM title (mouseover) text for the item.
//
//   class:: ?string
//   Optionally adds a CSS class to the item's DOM representation.
//
//   css:: ?string
//   Optionally adds a string of inline CSS to the item's DOM
//   representation.

var lastMenuEvent = {time: 0, node: null};
function markMenuEvent(e) {
  lastMenuEvent.time = Date.now();
  lastMenuEvent.node = e.target;
}
function isMenuEvent(wrapper) {
  return Date.now() - 100 < lastMenuEvent.time &&
    lastMenuEvent.node && wrapper.contains(lastMenuEvent.node)
}

// ::- A drop-down menu, displayed as a label with a downwards-pointing
// triangle to the right of it.
var Dropdown = function Dropdown(content, options) {
  this.options = options || {};
  this.content = Array.isArray(content) ? content : [content];
};

// :: (EditorView) → {dom: dom.Node, update: (EditorState)}
// Render the dropdown menu and sub-items.
Dropdown.prototype.render = function render (view) {
    var this$1 = this;

  var content = renderDropdownItems(this.content, view);

  var label = (0,crelt__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {class: prefix$1 + "-dropdown " + (this.options.class || ""),
                           style: this.options.css},
                   translate(view, this.options.label));
  if (this.options.title) { label.setAttribute("title", translate(view, this.options.title)); }
  var wrap = (0,crelt__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {class: prefix$1 + "-dropdown-wrap"}, label);
  var open = null, listeningOnClose = null;
  var close = function () {
    if (open && open.close()) {
      open = null;
      window.removeEventListener("mousedown", listeningOnClose);
    }
  };
  label.addEventListener("mousedown", function (e) {
    e.preventDefault();
    markMenuEvent(e);
    if (open) {
      close();
    } else {
      open = this$1.expand(wrap, content.dom);
      window.addEventListener("mousedown", listeningOnClose = function () {
        if (!isMenuEvent(wrap)) { close(); }
      });
    }
  });

  function update(state) {
    var inner = content.update(state);
    wrap.style.display = inner ? "" : "none";
    return inner
  }

  return {dom: wrap, update: update}
};

Dropdown.prototype.expand = function expand (dom, items) {
  var menuDOM = (0,crelt__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {class: prefix$1 + "-dropdown-menu " + (this.options.class || "")}, items);

  var done = false;
  function close() {
    if (done) { return }
    done = true;
    dom.removeChild(menuDOM);
    return true
  }
  dom.appendChild(menuDOM);
  return {close: close, node: menuDOM}
};

function renderDropdownItems(items, view) {
  var rendered = [], updates = [];
  for (var i = 0; i < items.length; i++) {
    var ref = items[i].render(view);
    var dom = ref.dom;
    var update = ref.update;
    rendered.push((0,crelt__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {class: prefix$1 + "-dropdown-item"}, dom));
    updates.push(update);
  }
  return {dom: rendered, update: combineUpdates(updates, rendered)}
}

function combineUpdates(updates, nodes) {
  return function (state) {
    var something = false;
    for (var i = 0; i < updates.length; i++) {
      var up = updates[i](state);
      nodes[i].style.display = up ? "" : "none";
      if (up) { something = true; }
    }
    return something
  }
}

// ::- Represents a submenu wrapping a group of elements that start
// hidden and expand to the right when hovered over or tapped.
var DropdownSubmenu = function DropdownSubmenu(content, options) {
  this.options = options || {};
  this.content = Array.isArray(content) ? content : [content];
};

// :: (EditorView) → {dom: dom.Node, update: (EditorState) → bool}
// Renders the submenu.
DropdownSubmenu.prototype.render = function render (view) {
  var items = renderDropdownItems(this.content, view);

  var label = (0,crelt__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {class: prefix$1 + "-submenu-label"}, translate(view, this.options.label));
  var wrap = (0,crelt__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {class: prefix$1 + "-submenu-wrap"}, label,
                 (0,crelt__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {class: prefix$1 + "-submenu"}, items.dom));
  var listeningOnClose = null;
  label.addEventListener("mousedown", function (e) {
    e.preventDefault();
    markMenuEvent(e);
    setClass(wrap, prefix$1 + "-submenu-wrap-active");
    if (!listeningOnClose)
      { window.addEventListener("mousedown", listeningOnClose = function () {
        if (!isMenuEvent(wrap)) {
          wrap.classList.remove(prefix$1 + "-submenu-wrap-active");
          window.removeEventListener("mousedown", listeningOnClose);
          listeningOnClose = null;
        }
      }); }
  });

  function update(state) {
    var inner = items.update(state);
    wrap.style.display = inner ? "" : "none";
    return inner
  }
  return {dom: wrap, update: update}
};

// :: (EditorView, [union<MenuElement, [MenuElement]>]) → {dom: ?dom.DocumentFragment, update: (EditorState) → bool}
// Render the given, possibly nested, array of menu elements into a
// document fragment, placing separators between them (and ensuring no
// superfluous separators appear when some of the groups turn out to
// be empty).
function renderGrouped(view, content) {
  var result = document.createDocumentFragment();
  var updates = [], separators = [];
  for (var i = 0; i < content.length; i++) {
    var items = content[i], localUpdates = [], localNodes = [];
    for (var j = 0; j < items.length; j++) {
      var ref = items[j].render(view);
      var dom = ref.dom;
      var update$1 = ref.update;
      var span = (0,crelt__WEBPACK_IMPORTED_MODULE_0__["default"])("span", {class: prefix$1 + "item"}, dom);
      result.appendChild(span);
      localNodes.push(span);
      localUpdates.push(update$1);
    }
    if (localUpdates.length) {
      updates.push(combineUpdates(localUpdates, localNodes));
      if (i < content.length - 1)
        { separators.push(result.appendChild(separator())); }
    }
  }

  function update(state) {
    var something = false, needSep = false;
    for (var i = 0; i < updates.length; i++) {
      var hasContent = updates[i](state);
      if (i) { separators[i - 1].style.display = needSep && hasContent ? "" : "none"; }
      needSep = hasContent;
      if (hasContent) { something = true; }
    }
    return something
  }
  return {dom: result, update: update}
}

function separator() {
  return (0,crelt__WEBPACK_IMPORTED_MODULE_0__["default"])("span", {class: prefix$1 + "separator"})
}

// :: Object
// A set of basic editor-related icons. Contains the properties
// `join`, `lift`, `selectParentNode`, `undo`, `redo`, `strong`, `em`,
// `code`, `link`, `bulletList`, `orderedList`, and `blockquote`, each
// holding an object that can be used as the `icon` option to
// `MenuItem`.
var icons = {
  join: {
    width: 800, height: 900,
    path: "M0 75h800v125h-800z M0 825h800v-125h-800z M250 400h100v-100h100v100h100v100h-100v100h-100v-100h-100z"
  },
  lift: {
    width: 1024, height: 1024,
    path: "M219 310v329q0 7-5 12t-12 5q-8 0-13-5l-164-164q-5-5-5-13t5-13l164-164q5-5 13-5 7 0 12 5t5 12zM1024 749v109q0 7-5 12t-12 5h-987q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h987q7 0 12 5t5 12zM1024 530v109q0 7-5 12t-12 5h-621q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h621q7 0 12 5t5 12zM1024 310v109q0 7-5 12t-12 5h-621q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h621q7 0 12 5t5 12zM1024 91v109q0 7-5 12t-12 5h-987q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h987q7 0 12 5t5 12z"
  },
  selectParentNode: {text: "\u2b1a", css: "font-weight: bold"},
  undo: {
    width: 1024, height: 1024,
    path: "M761 1024c113-206 132-520-313-509v253l-384-384 384-384v248c534-13 594 472 313 775z"
  },
  redo: {
    width: 1024, height: 1024,
    path: "M576 248v-248l384 384-384 384v-253c-446-10-427 303-313 509-280-303-221-789 313-775z"
  },
  strong: {
    width: 805, height: 1024,
    path: "M317 869q42 18 80 18 214 0 214-191 0-65-23-102-15-25-35-42t-38-26-46-14-48-6-54-1q-41 0-57 5 0 30-0 90t-0 90q0 4-0 38t-0 55 2 47 6 38zM309 442q24 4 62 4 46 0 81-7t62-25 42-51 14-81q0-40-16-70t-45-46-61-24-70-8q-28 0-74 7 0 28 2 86t2 86q0 15-0 45t-0 45q0 26 0 39zM0 950l1-53q8-2 48-9t60-15q4-6 7-15t4-19 3-18 1-21 0-19v-37q0-561-12-585-2-4-12-8t-25-6-28-4-27-2-17-1l-2-47q56-1 194-6t213-5q13 0 39 0t38 0q40 0 78 7t73 24 61 40 42 59 16 78q0 29-9 54t-22 41-36 32-41 25-48 22q88 20 146 76t58 141q0 57-20 102t-53 74-78 48-93 27-100 8q-25 0-75-1t-75-1q-60 0-175 6t-132 6z"
  },
  em: {
    width: 585, height: 1024,
    path: "M0 949l9-48q3-1 46-12t63-21q16-20 23-57 0-4 35-165t65-310 29-169v-14q-13-7-31-10t-39-4-33-3l10-58q18 1 68 3t85 4 68 1q27 0 56-1t69-4 56-3q-2 22-10 50-17 5-58 16t-62 19q-4 10-8 24t-5 22-4 26-3 24q-15 84-50 239t-44 203q-1 5-7 33t-11 51-9 47-3 32l0 10q9 2 105 17-1 25-9 56-6 0-18 0t-18 0q-16 0-49-5t-49-5q-78-1-117-1-29 0-81 5t-69 6z"
  },
  code: {
    width: 896, height: 1024,
    path: "M608 192l-96 96 224 224-224 224 96 96 288-320-288-320zM288 192l-288 320 288 320 96-96-224-224 224-224-96-96z"
  },
  link: {
    width: 951, height: 1024,
    path: "M832 694q0-22-16-38l-118-118q-16-16-38-16-24 0-41 18 1 1 10 10t12 12 8 10 7 14 2 15q0 22-16 38t-38 16q-8 0-15-2t-14-7-10-8-12-12-10-10q-18 17-18 41 0 22 16 38l117 118q15 15 38 15 22 0 38-14l84-83q16-16 16-38zM430 292q0-22-16-38l-117-118q-16-16-38-16-22 0-38 15l-84 83q-16 16-16 38 0 22 16 38l118 118q15 15 38 15 24 0 41-17-1-1-10-10t-12-12-8-10-7-14-2-15q0-22 16-38t38-16q8 0 15 2t14 7 10 8 12 12 10 10q18-17 18-41zM941 694q0 68-48 116l-84 83q-47 47-116 47-69 0-116-48l-117-118q-47-47-47-116 0-70 50-119l-50-50q-49 50-118 50-68 0-116-48l-118-118q-48-48-48-116t48-116l84-83q47-47 116-47 69 0 116 48l117 118q47 47 47 116 0 70-50 119l50 50q49-50 118-50 68 0 116 48l118 118q48 48 48 116z"
  },
  bulletList: {
    width: 768, height: 896,
    path: "M0 512h128v-128h-128v128zM0 256h128v-128h-128v128zM0 768h128v-128h-128v128zM256 512h512v-128h-512v128zM256 256h512v-128h-512v128zM256 768h512v-128h-512v128z"
  },
  orderedList: {
    width: 768, height: 896,
    path: "M320 512h448v-128h-448v128zM320 768h448v-128h-448v128zM320 128v128h448v-128h-448zM79 384h78v-256h-36l-85 23v50l43-2v185zM189 590c0-36-12-78-96-78-33 0-64 6-83 16l1 66c21-10 42-15 67-15s32 11 32 28c0 26-30 58-110 112v50h192v-67l-91 2c49-30 87-66 87-113l1-1z"
  },
  blockquote: {
    width: 640, height: 896,
    path: "M0 448v256h256v-256h-128c0 0 0-128 128-128v-128c0 0-256 0-256 256zM640 320v-128c0 0-256 0-256 256v256h256v-256h-128c0 0 0-128 128-128z"
  }
};

// :: MenuItem
// Menu item for the `joinUp` command.
var joinUpItem = new MenuItem({
  title: "Join with above block",
  run: prosemirror_commands__WEBPACK_IMPORTED_MODULE_1__.joinUp,
  select: function (state) { return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_1__.joinUp)(state); },
  icon: icons.join
});

// :: MenuItem
// Menu item for the `lift` command.
var liftItem = new MenuItem({
  title: "Lift out of enclosing block",
  run: prosemirror_commands__WEBPACK_IMPORTED_MODULE_1__.lift,
  select: function (state) { return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_1__.lift)(state); },
  icon: icons.lift
});

// :: MenuItem
// Menu item for the `selectParentNode` command.
var selectParentNodeItem = new MenuItem({
  title: "Select parent node",
  run: prosemirror_commands__WEBPACK_IMPORTED_MODULE_1__.selectParentNode,
  select: function (state) { return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_1__.selectParentNode)(state); },
  icon: icons.selectParentNode
});

// :: MenuItem
// Menu item for the `undo` command.
var undoItem = new MenuItem({
  title: "Undo last change",
  run: prosemirror_history__WEBPACK_IMPORTED_MODULE_2__.undo,
  enable: function (state) { return (0,prosemirror_history__WEBPACK_IMPORTED_MODULE_2__.undo)(state); },
  icon: icons.undo
});

// :: MenuItem
// Menu item for the `redo` command.
var redoItem = new MenuItem({
  title: "Redo last undone change",
  run: prosemirror_history__WEBPACK_IMPORTED_MODULE_2__.redo,
  enable: function (state) { return (0,prosemirror_history__WEBPACK_IMPORTED_MODULE_2__.redo)(state); },
  icon: icons.redo
});

// :: (NodeType, Object) → MenuItem
// Build a menu item for wrapping the selection in a given node type.
// Adds `run` and `select` properties to the ones present in
// `options`. `options.attrs` may be an object or a function.
function wrapItem(nodeType, options) {
  var passedOptions = {
    run: function run(state, dispatch) {
      // FIXME if (options.attrs instanceof Function) options.attrs(state, attrs => wrapIn(nodeType, attrs)(state))
      return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_1__.wrapIn)(nodeType, options.attrs)(state, dispatch)
    },
    select: function select(state) {
      return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_1__.wrapIn)(nodeType, options.attrs instanceof Function ? null : options.attrs)(state)
    }
  };
  for (var prop in options) { passedOptions[prop] = options[prop]; }
  return new MenuItem(passedOptions)
}

// :: (NodeType, Object) → MenuItem
// Build a menu item for changing the type of the textblock around the
// selection to the given type. Provides `run`, `active`, and `select`
// properties. Others must be given in `options`. `options.attrs` may
// be an object to provide the attributes for the textblock node.
function blockTypeItem(nodeType, options) {
  var command = (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_1__.setBlockType)(nodeType, options.attrs);
  var passedOptions = {
    run: command,
    enable: function enable(state) { return command(state) },
    active: function active(state) {
      var ref = state.selection;
      var $from = ref.$from;
      var to = ref.to;
      var node = ref.node;
      if (node) { return node.hasMarkup(nodeType, options.attrs) }
      return to <= $from.end() && $from.parent.hasMarkup(nodeType, options.attrs)
    }
  };
  for (var prop in options) { passedOptions[prop] = options[prop]; }
  return new MenuItem(passedOptions)
}

// Work around classList.toggle being broken in IE11
function setClass(dom, cls, on) {
  if (on) { dom.classList.add(cls); }
  else { dom.classList.remove(cls); }
}

var prefix$2 = "ProseMirror-menubar";

function isIOS() {
  if (typeof navigator == "undefined") { return false }
  var agent = navigator.userAgent;
  return !/Edge\/\d/.test(agent) && /AppleWebKit/.test(agent) && /Mobile\/\w+/.test(agent)
}

// :: (Object) → Plugin
// A plugin that will place a menu bar above the editor. Note that
// this involves wrapping the editor in an additional `<div>`.
//
//   options::-
//   Supports the following options:
//
//     content:: [[MenuElement]]
//     Provides the content of the menu, as a nested array to be
//     passed to `renderGrouped`.
//
//     floating:: ?bool
//     Determines whether the menu floats, i.e. whether it sticks to
//     the top of the viewport when the editor is partially scrolled
//     out of view.
function menuBar(options) {
  return new prosemirror_state__WEBPACK_IMPORTED_MODULE_3__.Plugin({
    view: function view(editorView) { return new MenuBarView(editorView, options) }
  })
}

var MenuBarView = function MenuBarView(editorView, options) {
  var this$1 = this;

  this.editorView = editorView;
  this.options = options;

  this.wrapper = (0,crelt__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {class: prefix$2 + "-wrapper"});
  this.menu = this.wrapper.appendChild((0,crelt__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {class: prefix$2}));
  this.menu.className = prefix$2;
  this.spacer = null;

  editorView.dom.parentNode.replaceChild(this.wrapper, editorView.dom);
  this.wrapper.appendChild(editorView.dom);

  this.maxHeight = 0;
  this.widthForMaxHeight = 0;
  this.floating = false;

  var ref = renderGrouped(this.editorView, this.options.content);
  var dom = ref.dom;
  var update = ref.update;
  this.contentUpdate = update;
  this.menu.appendChild(dom);
  this.update();

  if (options.floating && !isIOS()) {
    this.updateFloat();
    var potentialScrollers = getAllWrapping(this.wrapper);
    this.scrollFunc = function (e) {
      var root = this$1.editorView.root;
      if (!(root.body || root).contains(this$1.wrapper)) {
          potentialScrollers.forEach(function (el) { return el.removeEventListener("scroll", this$1.scrollFunc); });
      } else {
          this$1.updateFloat(e.target.getBoundingClientRect && e.target);
      }
    };
    potentialScrollers.forEach(function (el) { return el.addEventListener('scroll', this$1.scrollFunc); });
  }
};

MenuBarView.prototype.update = function update () {
  this.contentUpdate(this.editorView.state);

  if (this.floating) {
    this.updateScrollCursor();
  } else {
    if (this.menu.offsetWidth != this.widthForMaxHeight) {
      this.widthForMaxHeight = this.menu.offsetWidth;
      this.maxHeight = 0;
    }
    if (this.menu.offsetHeight > this.maxHeight) {
      this.maxHeight = this.menu.offsetHeight;
      this.menu.style.minHeight = this.maxHeight + "px";
    }
  }
};

MenuBarView.prototype.updateScrollCursor = function updateScrollCursor () {
  var selection = this.editorView.root.getSelection();
  if (!selection.focusNode) { return }
  var rects = selection.getRangeAt(0).getClientRects();
  var selRect = rects[selectionIsInverted(selection) ? 0 : rects.length - 1];
  if (!selRect) { return }
  var menuRect = this.menu.getBoundingClientRect();
  if (selRect.top < menuRect.bottom && selRect.bottom > menuRect.top) {
    var scrollable = findWrappingScrollable(this.wrapper);
    if (scrollable) { scrollable.scrollTop -= (menuRect.bottom - selRect.top); }
  }
};

MenuBarView.prototype.updateFloat = function updateFloat (scrollAncestor) {
  var parent = this.wrapper, editorRect = parent.getBoundingClientRect(),
      top = scrollAncestor ? Math.max(0, scrollAncestor.getBoundingClientRect().top) : 0;

  if (this.floating) {
    if (editorRect.top >= top || editorRect.bottom < this.menu.offsetHeight + 10) {
      this.floating = false;
      this.menu.style.position = this.menu.style.left = this.menu.style.top = this.menu.style.width = "";
      this.menu.style.display = "";
      this.spacer.parentNode.removeChild(this.spacer);
      this.spacer = null;
    } else {
      var border = (parent.offsetWidth - parent.clientWidth) / 2;
      this.menu.style.left = (editorRect.left + border) + "px";
      this.menu.style.display = (editorRect.top > window.innerHeight ? "none" : "");
      if (scrollAncestor) { this.menu.style.top = top + "px"; }
    }
  } else {
    if (editorRect.top < top && editorRect.bottom >= this.menu.offsetHeight + 10) {
      this.floating = true;
      var menuRect = this.menu.getBoundingClientRect();
      this.menu.style.left = menuRect.left + "px";
      this.menu.style.width = menuRect.width + "px";
      if (scrollAncestor) { this.menu.style.top = top + "px"; }
      this.menu.style.position = "fixed";
      this.spacer = (0,crelt__WEBPACK_IMPORTED_MODULE_0__["default"])("div", {class: prefix$2 + "-spacer", style: ("height: " + (menuRect.height) + "px")});
      parent.insertBefore(this.spacer, this.menu);
    }
  }
};

MenuBarView.prototype.destroy = function destroy () {
  if (this.wrapper.parentNode)
    { this.wrapper.parentNode.replaceChild(this.editorView.dom, this.wrapper); }
};

// Not precise, but close enough
function selectionIsInverted(selection) {
  if (selection.anchorNode == selection.focusNode) { return selection.anchorOffset > selection.focusOffset }
  return selection.anchorNode.compareDocumentPosition(selection.focusNode) == Node.DOCUMENT_POSITION_FOLLOWING
}

function findWrappingScrollable(node) {
  for (var cur = node.parentNode; cur; cur = cur.parentNode)
    { if (cur.scrollHeight > cur.clientHeight) { return cur } }
}

function getAllWrapping(node) {
    var res = [window];
    for (var cur = node.parentNode; cur; cur = cur.parentNode)
        { res.push(cur); }
    return res
}


//# sourceMappingURL=index.es.js.map


/***/ }),

/***/ "./node_modules/prosemirror-model/dist/index.es.js":
/*!*********************************************************!*\
  !*** ./node_modules/prosemirror-model/dist/index.es.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ContentMatch": () => (/* binding */ ContentMatch),
/* harmony export */   "DOMParser": () => (/* binding */ DOMParser),
/* harmony export */   "DOMSerializer": () => (/* binding */ DOMSerializer),
/* harmony export */   "Fragment": () => (/* binding */ Fragment),
/* harmony export */   "Mark": () => (/* binding */ Mark),
/* harmony export */   "MarkType": () => (/* binding */ MarkType),
/* harmony export */   "Node": () => (/* binding */ Node),
/* harmony export */   "NodeRange": () => (/* binding */ NodeRange),
/* harmony export */   "NodeType": () => (/* binding */ NodeType),
/* harmony export */   "ReplaceError": () => (/* binding */ ReplaceError),
/* harmony export */   "ResolvedPos": () => (/* binding */ ResolvedPos),
/* harmony export */   "Schema": () => (/* binding */ Schema),
/* harmony export */   "Slice": () => (/* binding */ Slice)
/* harmony export */ });
/* harmony import */ var orderedmap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! orderedmap */ "./node_modules/orderedmap/index.es.js");


function findDiffStart(a, b, pos) {
  for (var i = 0;; i++) {
    if (i == a.childCount || i == b.childCount)
      { return a.childCount == b.childCount ? null : pos }

    var childA = a.child(i), childB = b.child(i);
    if (childA == childB) { pos += childA.nodeSize; continue }

    if (!childA.sameMarkup(childB)) { return pos }

    if (childA.isText && childA.text != childB.text) {
      for (var j = 0; childA.text[j] == childB.text[j]; j++)
        { pos++; }
      return pos
    }
    if (childA.content.size || childB.content.size) {
      var inner = findDiffStart(childA.content, childB.content, pos + 1);
      if (inner != null) { return inner }
    }
    pos += childA.nodeSize;
  }
}

function findDiffEnd(a, b, posA, posB) {
  for (var iA = a.childCount, iB = b.childCount;;) {
    if (iA == 0 || iB == 0)
      { return iA == iB ? null : {a: posA, b: posB} }

    var childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize;
    if (childA == childB) {
      posA -= size; posB -= size;
      continue
    }

    if (!childA.sameMarkup(childB)) { return {a: posA, b: posB} }

    if (childA.isText && childA.text != childB.text) {
      var same = 0, minSize = Math.min(childA.text.length, childB.text.length);
      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
        same++; posA--; posB--;
      }
      return {a: posA, b: posB}
    }
    if (childA.content.size || childB.content.size) {
      var inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);
      if (inner) { return inner }
    }
    posA -= size; posB -= size;
  }
}

// ::- A fragment represents a node's collection of child nodes.
//
// Like nodes, fragments are persistent data structures, and you
// should not mutate them or their content. Rather, you create new
// instances whenever needed. The API tries to make this easy.
var Fragment = function Fragment(content, size) {
  this.content = content;
  // :: number
  // The size of the fragment, which is the total of the size of its
  // content nodes.
  this.size = size || 0;
  if (size == null) { for (var i = 0; i < content.length; i++)
    { this.size += content[i].nodeSize; } }
};

var prototypeAccessors = { firstChild: { configurable: true },lastChild: { configurable: true },childCount: { configurable: true } };

// :: (number, number, (node: Node, start: number, parent: Node, index: number) → ?bool, ?number)
// Invoke a callback for all descendant nodes between the given two
// positions (relative to start of this fragment). Doesn't descend
// into a node when the callback returns `false`.
Fragment.prototype.nodesBetween = function nodesBetween (from, to, f, nodeStart, parent) {
    if ( nodeStart === void 0 ) nodeStart = 0;

  for (var i = 0, pos = 0; pos < to; i++) {
    var child = this.content[i], end = pos + child.nodeSize;
    if (end > from && f(child, nodeStart + pos, parent, i) !== false && child.content.size) {
      var start = pos + 1;
      child.nodesBetween(Math.max(0, from - start),
                         Math.min(child.content.size, to - start),
                         f, nodeStart + start);
    }
    pos = end;
  }
};

// :: ((node: Node, pos: number, parent: Node) → ?bool)
// Call the given callback for every descendant node. The callback
// may return `false` to prevent traversal of a given node's children.
Fragment.prototype.descendants = function descendants (f) {
  this.nodesBetween(0, this.size, f);
};

// :: (number, number, ?string, ?string | ?(leafNode: Node) -> string) → string
// Extract the text between `from` and `to`. See the same method on
// [`Node`](#model.Node.textBetween).
Fragment.prototype.textBetween = function textBetween (from, to, blockSeparator, leafText) {
  var text = "", separated = true;
  this.nodesBetween(from, to, function (node, pos) {
    if (node.isText) {
      text += node.text.slice(Math.max(from, pos) - pos, to - pos);
      separated = !blockSeparator;
    } else if (node.isLeaf && leafText) {
      text += typeof leafText === 'function' ? leafText(node): leafText;
      separated = !blockSeparator;
    } else if (!separated && node.isBlock) {
      text += blockSeparator;
      separated = true;
    }
  }, 0);
  return text
};

// :: (Fragment) → Fragment
// Create a new fragment containing the combined content of this
// fragment and the other.
Fragment.prototype.append = function append (other) {
  if (!other.size) { return this }
  if (!this.size) { return other }
  var last = this.lastChild, first = other.firstChild, content = this.content.slice(), i = 0;
  if (last.isText && last.sameMarkup(first)) {
    content[content.length - 1] = last.withText(last.text + first.text);
    i = 1;
  }
  for (; i < other.content.length; i++) { content.push(other.content[i]); }
  return new Fragment(content, this.size + other.size)
};

// :: (number, ?number) → Fragment
// Cut out the sub-fragment between the two given positions.
Fragment.prototype.cut = function cut (from, to) {
  if (to == null) { to = this.size; }
  if (from == 0 && to == this.size) { return this }
  var result = [], size = 0;
  if (to > from) { for (var i = 0, pos = 0; pos < to; i++) {
    var child = this.content[i], end = pos + child.nodeSize;
    if (end > from) {
      if (pos < from || end > to) {
        if (child.isText)
          { child = child.cut(Math.max(0, from - pos), Math.min(child.text.length, to - pos)); }
        else
          { child = child.cut(Math.max(0, from - pos - 1), Math.min(child.content.size, to - pos - 1)); }
      }
      result.push(child);
      size += child.nodeSize;
    }
    pos = end;
  } }
  return new Fragment(result, size)
};

Fragment.prototype.cutByIndex = function cutByIndex (from, to) {
  if (from == to) { return Fragment.empty }
  if (from == 0 && to == this.content.length) { return this }
  return new Fragment(this.content.slice(from, to))
};

// :: (number, Node) → Fragment
// Create a new fragment in which the node at the given index is
// replaced by the given node.
Fragment.prototype.replaceChild = function replaceChild (index, node) {
  var current = this.content[index];
  if (current == node) { return this }
  var copy = this.content.slice();
  var size = this.size + node.nodeSize - current.nodeSize;
  copy[index] = node;
  return new Fragment(copy, size)
};

// : (Node) → Fragment
// Create a new fragment by prepending the given node to this
// fragment.
Fragment.prototype.addToStart = function addToStart (node) {
  return new Fragment([node].concat(this.content), this.size + node.nodeSize)
};

// : (Node) → Fragment
// Create a new fragment by appending the given node to this
// fragment.
Fragment.prototype.addToEnd = function addToEnd (node) {
  return new Fragment(this.content.concat(node), this.size + node.nodeSize)
};

// :: (Fragment) → bool
// Compare this fragment to another one.
Fragment.prototype.eq = function eq (other) {
  if (this.content.length != other.content.length) { return false }
  for (var i = 0; i < this.content.length; i++)
    { if (!this.content[i].eq(other.content[i])) { return false } }
  return true
};

// :: ?Node
// The first child of the fragment, or `null` if it is empty.
prototypeAccessors.firstChild.get = function () { return this.content.length ? this.content[0] : null };

// :: ?Node
// The last child of the fragment, or `null` if it is empty.
prototypeAccessors.lastChild.get = function () { return this.content.length ? this.content[this.content.length - 1] : null };

// :: number
// The number of child nodes in this fragment.
prototypeAccessors.childCount.get = function () { return this.content.length };

// :: (number) → Node
// Get the child node at the given index. Raise an error when the
// index is out of range.
Fragment.prototype.child = function child (index) {
  var found = this.content[index];
  if (!found) { throw new RangeError("Index " + index + " out of range for " + this) }
  return found
};

// :: (number) → ?Node
// Get the child node at the given index, if it exists.
Fragment.prototype.maybeChild = function maybeChild (index) {
  return this.content[index]
};

// :: ((node: Node, offset: number, index: number))
// Call `f` for every child node, passing the node, its offset
// into this parent node, and its index.
Fragment.prototype.forEach = function forEach (f) {
  for (var i = 0, p = 0; i < this.content.length; i++) {
    var child = this.content[i];
    f(child, p, i);
    p += child.nodeSize;
  }
};

// :: (Fragment) → ?number
// Find the first position at which this fragment and another
// fragment differ, or `null` if they are the same.
Fragment.prototype.findDiffStart = function findDiffStart$1 (other, pos) {
    if ( pos === void 0 ) pos = 0;

  return findDiffStart(this, other, pos)
};

// :: (Fragment) → ?{a: number, b: number}
// Find the first position, searching from the end, at which this
// fragment and the given fragment differ, or `null` if they are the
// same. Since this position will not be the same in both nodes, an
// object with two separate positions is returned.
Fragment.prototype.findDiffEnd = function findDiffEnd$1 (other, pos, otherPos) {
    if ( pos === void 0 ) pos = this.size;
    if ( otherPos === void 0 ) otherPos = other.size;

  return findDiffEnd(this, other, pos, otherPos)
};

// : (number, ?number) → {index: number, offset: number}
// Find the index and inner offset corresponding to a given relative
// position in this fragment. The result object will be reused
// (overwritten) the next time the function is called. (Not public.)
Fragment.prototype.findIndex = function findIndex (pos, round) {
    if ( round === void 0 ) round = -1;

  if (pos == 0) { return retIndex(0, pos) }
  if (pos == this.size) { return retIndex(this.content.length, pos) }
  if (pos > this.size || pos < 0) { throw new RangeError(("Position " + pos + " outside of fragment (" + (this) + ")")) }
  for (var i = 0, curPos = 0;; i++) {
    var cur = this.child(i), end = curPos + cur.nodeSize;
    if (end >= pos) {
      if (end == pos || round > 0) { return retIndex(i + 1, end) }
      return retIndex(i, curPos)
    }
    curPos = end;
  }
};

// :: () → string
// Return a debugging string that describes this fragment.
Fragment.prototype.toString = function toString () { return "<" + this.toStringInner() + ">" };

Fragment.prototype.toStringInner = function toStringInner () { return this.content.join(", ") };

// :: () → ?Object
// Create a JSON-serializeable representation of this fragment.
Fragment.prototype.toJSON = function toJSON () {
  return this.content.length ? this.content.map(function (n) { return n.toJSON(); }) : null
};

// :: (Schema, ?Object) → Fragment
// Deserialize a fragment from its JSON representation.
Fragment.fromJSON = function fromJSON (schema, value) {
  if (!value) { return Fragment.empty }
  if (!Array.isArray(value)) { throw new RangeError("Invalid input for Fragment.fromJSON") }
  return new Fragment(value.map(schema.nodeFromJSON))
};

// :: ([Node]) → Fragment
// Build a fragment from an array of nodes. Ensures that adjacent
// text nodes with the same marks are joined together.
Fragment.fromArray = function fromArray (array) {
  if (!array.length) { return Fragment.empty }
  var joined, size = 0;
  for (var i = 0; i < array.length; i++) {
    var node = array[i];
    size += node.nodeSize;
    if (i && node.isText && array[i - 1].sameMarkup(node)) {
      if (!joined) { joined = array.slice(0, i); }
      joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text);
    } else if (joined) {
      joined.push(node);
    }
  }
  return new Fragment(joined || array, size)
};

// :: (?union<Fragment, Node, [Node]>) → Fragment
// Create a fragment from something that can be interpreted as a set
// of nodes. For `null`, it returns the empty fragment. For a
// fragment, the fragment itself. For a node or array of nodes, a
// fragment containing those nodes.
Fragment.from = function from (nodes) {
  if (!nodes) { return Fragment.empty }
  if (nodes instanceof Fragment) { return nodes }
  if (Array.isArray(nodes)) { return this.fromArray(nodes) }
  if (nodes.attrs) { return new Fragment([nodes], nodes.nodeSize) }
  throw new RangeError("Can not convert " + nodes + " to a Fragment" +
                       (nodes.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""))
};

Object.defineProperties( Fragment.prototype, prototypeAccessors );

var found = {index: 0, offset: 0};
function retIndex(index, offset) {
  found.index = index;
  found.offset = offset;
  return found
}

// :: Fragment
// An empty fragment. Intended to be reused whenever a node doesn't
// contain anything (rather than allocating a new empty fragment for
// each leaf node).
Fragment.empty = new Fragment([], 0);

function compareDeep(a, b) {
  if (a === b) { return true }
  if (!(a && typeof a == "object") ||
      !(b && typeof b == "object")) { return false }
  var array = Array.isArray(a);
  if (Array.isArray(b) != array) { return false }
  if (array) {
    if (a.length != b.length) { return false }
    for (var i = 0; i < a.length; i++) { if (!compareDeep(a[i], b[i])) { return false } }
  } else {
    for (var p in a) { if (!(p in b) || !compareDeep(a[p], b[p])) { return false } }
    for (var p$1 in b) { if (!(p$1 in a)) { return false } }
  }
  return true
}

// ::- A mark is a piece of information that can be attached to a node,
// such as it being emphasized, in code font, or a link. It has a type
// and optionally a set of attributes that provide further information
// (such as the target of the link). Marks are created through a
// `Schema`, which controls which types exist and which
// attributes they have.
var Mark = function Mark(type, attrs) {
  // :: MarkType
  // The type of this mark.
  this.type = type;
  // :: Object
  // The attributes associated with this mark.
  this.attrs = attrs;
};

// :: ([Mark]) → [Mark]
// Given a set of marks, create a new set which contains this one as
// well, in the right position. If this mark is already in the set,
// the set itself is returned. If any marks that are set to be
// [exclusive](#model.MarkSpec.excludes) with this mark are present,
// those are replaced by this one.
Mark.prototype.addToSet = function addToSet (set) {
  var copy, placed = false;
  for (var i = 0; i < set.length; i++) {
    var other = set[i];
    if (this.eq(other)) { return set }
    if (this.type.excludes(other.type)) {
      if (!copy) { copy = set.slice(0, i); }
    } else if (other.type.excludes(this.type)) {
      return set
    } else {
      if (!placed && other.type.rank > this.type.rank) {
        if (!copy) { copy = set.slice(0, i); }
        copy.push(this);
        placed = true;
      }
      if (copy) { copy.push(other); }
    }
  }
  if (!copy) { copy = set.slice(); }
  if (!placed) { copy.push(this); }
  return copy
};

// :: ([Mark]) → [Mark]
// Remove this mark from the given set, returning a new set. If this
// mark is not in the set, the set itself is returned.
Mark.prototype.removeFromSet = function removeFromSet (set) {
  for (var i = 0; i < set.length; i++)
    { if (this.eq(set[i]))
      { return set.slice(0, i).concat(set.slice(i + 1)) } }
  return set
};

// :: ([Mark]) → bool
// Test whether this mark is in the given set of marks.
Mark.prototype.isInSet = function isInSet (set) {
  for (var i = 0; i < set.length; i++)
    { if (this.eq(set[i])) { return true } }
  return false
};

// :: (Mark) → bool
// Test whether this mark has the same type and attributes as
// another mark.
Mark.prototype.eq = function eq (other) {
  return this == other ||
    (this.type == other.type && compareDeep(this.attrs, other.attrs))
};

// :: () → Object
// Convert this mark to a JSON-serializeable representation.
Mark.prototype.toJSON = function toJSON () {
  var obj = {type: this.type.name};
  for (var _ in this.attrs) {
    obj.attrs = this.attrs;
    break
  }
  return obj
};

// :: (Schema, Object) → Mark
Mark.fromJSON = function fromJSON (schema, json) {
  if (!json) { throw new RangeError("Invalid input for Mark.fromJSON") }
  var type = schema.marks[json.type];
  if (!type) { throw new RangeError(("There is no mark type " + (json.type) + " in this schema")) }
  return type.create(json.attrs)
};

// :: ([Mark], [Mark]) → bool
// Test whether two sets of marks are identical.
Mark.sameSet = function sameSet (a, b) {
  if (a == b) { return true }
  if (a.length != b.length) { return false }
  for (var i = 0; i < a.length; i++)
    { if (!a[i].eq(b[i])) { return false } }
  return true
};

// :: (?union<Mark, [Mark]>) → [Mark]
// Create a properly sorted mark set from null, a single mark, or an
// unsorted array of marks.
Mark.setFrom = function setFrom (marks) {
  if (!marks || marks.length == 0) { return Mark.none }
  if (marks instanceof Mark) { return [marks] }
  var copy = marks.slice();
  copy.sort(function (a, b) { return a.type.rank - b.type.rank; });
  return copy
};

// :: [Mark] The empty set of marks.
Mark.none = [];

// ReplaceError:: class extends Error
// Error type raised by [`Node.replace`](#model.Node.replace) when
// given an invalid replacement.

function ReplaceError(message) {
  var err = Error.call(this, message);
  err.__proto__ = ReplaceError.prototype;
  return err
}

ReplaceError.prototype = Object.create(Error.prototype);
ReplaceError.prototype.constructor = ReplaceError;
ReplaceError.prototype.name = "ReplaceError";

// ::- A slice represents a piece cut out of a larger document. It
// stores not only a fragment, but also the depth up to which nodes on
// both side are ‘open’ (cut through).
var Slice = function Slice(content, openStart, openEnd) {
  // :: Fragment The slice's content.
  this.content = content;
  // :: number The open depth at the start.
  this.openStart = openStart;
  // :: number The open depth at the end.
  this.openEnd = openEnd;
};

var prototypeAccessors$1 = { size: { configurable: true } };

// :: number
// The size this slice would add when inserted into a document.
prototypeAccessors$1.size.get = function () {
  return this.content.size - this.openStart - this.openEnd
};

Slice.prototype.insertAt = function insertAt (pos, fragment) {
  var content = insertInto(this.content, pos + this.openStart, fragment, null);
  return content && new Slice(content, this.openStart, this.openEnd)
};

Slice.prototype.removeBetween = function removeBetween (from, to) {
  return new Slice(removeRange(this.content, from + this.openStart, to + this.openStart), this.openStart, this.openEnd)
};

// :: (Slice) → bool
// Tests whether this slice is equal to another slice.
Slice.prototype.eq = function eq (other) {
  return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd
};

Slice.prototype.toString = function toString () {
  return this.content + "(" + this.openStart + "," + this.openEnd + ")"
};

// :: () → ?Object
// Convert a slice to a JSON-serializable representation.
Slice.prototype.toJSON = function toJSON () {
  if (!this.content.size) { return null }
  var json = {content: this.content.toJSON()};
  if (this.openStart > 0) { json.openStart = this.openStart; }
  if (this.openEnd > 0) { json.openEnd = this.openEnd; }
  return json
};

// :: (Schema, ?Object) → Slice
// Deserialize a slice from its JSON representation.
Slice.fromJSON = function fromJSON (schema, json) {
  if (!json) { return Slice.empty }
  var openStart = json.openStart || 0, openEnd = json.openEnd || 0;
  if (typeof openStart != "number" || typeof openEnd != "number")
    { throw new RangeError("Invalid input for Slice.fromJSON") }
  return new Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd)
};

// :: (Fragment, ?bool) → Slice
// Create a slice from a fragment by taking the maximum possible
// open value on both side of the fragment.
Slice.maxOpen = function maxOpen (fragment, openIsolating) {
    if ( openIsolating === void 0 ) openIsolating=true;

  var openStart = 0, openEnd = 0;
  for (var n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild) { openStart++; }
  for (var n$1 = fragment.lastChild; n$1 && !n$1.isLeaf && (openIsolating || !n$1.type.spec.isolating); n$1 = n$1.lastChild) { openEnd++; }
  return new Slice(fragment, openStart, openEnd)
};

Object.defineProperties( Slice.prototype, prototypeAccessors$1 );

function removeRange(content, from, to) {
  var ref = content.findIndex(from);
  var index = ref.index;
  var offset = ref.offset;
  var child = content.maybeChild(index);
  var ref$1 = content.findIndex(to);
  var indexTo = ref$1.index;
  var offsetTo = ref$1.offset;
  if (offset == from || child.isText) {
    if (offsetTo != to && !content.child(indexTo).isText) { throw new RangeError("Removing non-flat range") }
    return content.cut(0, from).append(content.cut(to))
  }
  if (index != indexTo) { throw new RangeError("Removing non-flat range") }
  return content.replaceChild(index, child.copy(removeRange(child.content, from - offset - 1, to - offset - 1)))
}

function insertInto(content, dist, insert, parent) {
  var ref = content.findIndex(dist);
  var index = ref.index;
  var offset = ref.offset;
  var child = content.maybeChild(index);
  if (offset == dist || child.isText) {
    if (parent && !parent.canReplace(index, index, insert)) { return null }
    return content.cut(0, dist).append(insert).append(content.cut(dist))
  }
  var inner = insertInto(child.content, dist - offset - 1, insert);
  return inner && content.replaceChild(index, child.copy(inner))
}

// :: Slice
// The empty slice.
Slice.empty = new Slice(Fragment.empty, 0, 0);

function replace($from, $to, slice) {
  if (slice.openStart > $from.depth)
    { throw new ReplaceError("Inserted content deeper than insertion position") }
  if ($from.depth - slice.openStart != $to.depth - slice.openEnd)
    { throw new ReplaceError("Inconsistent open depths") }
  return replaceOuter($from, $to, slice, 0)
}

function replaceOuter($from, $to, slice, depth) {
  var index = $from.index(depth), node = $from.node(depth);
  if (index == $to.index(depth) && depth < $from.depth - slice.openStart) {
    var inner = replaceOuter($from, $to, slice, depth + 1);
    return node.copy(node.content.replaceChild(index, inner))
  } else if (!slice.content.size) {
    return close(node, replaceTwoWay($from, $to, depth))
  } else if (!slice.openStart && !slice.openEnd && $from.depth == depth && $to.depth == depth) { // Simple, flat case
    var parent = $from.parent, content = parent.content;
    return close(parent, content.cut(0, $from.parentOffset).append(slice.content).append(content.cut($to.parentOffset)))
  } else {
    var ref = prepareSliceForReplace(slice, $from);
    var start = ref.start;
    var end = ref.end;
    return close(node, replaceThreeWay($from, start, end, $to, depth))
  }
}

function checkJoin(main, sub) {
  if (!sub.type.compatibleContent(main.type))
    { throw new ReplaceError("Cannot join " + sub.type.name + " onto " + main.type.name) }
}

function joinable($before, $after, depth) {
  var node = $before.node(depth);
  checkJoin(node, $after.node(depth));
  return node
}

function addNode(child, target) {
  var last = target.length - 1;
  if (last >= 0 && child.isText && child.sameMarkup(target[last]))
    { target[last] = child.withText(target[last].text + child.text); }
  else
    { target.push(child); }
}

function addRange($start, $end, depth, target) {
  var node = ($end || $start).node(depth);
  var startIndex = 0, endIndex = $end ? $end.index(depth) : node.childCount;
  if ($start) {
    startIndex = $start.index(depth);
    if ($start.depth > depth) {
      startIndex++;
    } else if ($start.textOffset) {
      addNode($start.nodeAfter, target);
      startIndex++;
    }
  }
  for (var i = startIndex; i < endIndex; i++) { addNode(node.child(i), target); }
  if ($end && $end.depth == depth && $end.textOffset)
    { addNode($end.nodeBefore, target); }
}

function close(node, content) {
  if (!node.type.validContent(content))
    { throw new ReplaceError("Invalid content for node " + node.type.name) }
  return node.copy(content)
}

function replaceThreeWay($from, $start, $end, $to, depth) {
  var openStart = $from.depth > depth && joinable($from, $start, depth + 1);
  var openEnd = $to.depth > depth && joinable($end, $to, depth + 1);

  var content = [];
  addRange(null, $from, depth, content);
  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
    checkJoin(openStart, openEnd);
    addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);
  } else {
    if (openStart)
      { addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content); }
    addRange($start, $end, depth, content);
    if (openEnd)
      { addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content); }
  }
  addRange($to, null, depth, content);
  return new Fragment(content)
}

function replaceTwoWay($from, $to, depth) {
  var content = [];
  addRange(null, $from, depth, content);
  if ($from.depth > depth) {
    var type = joinable($from, $to, depth + 1);
    addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);
  }
  addRange($to, null, depth, content);
  return new Fragment(content)
}

function prepareSliceForReplace(slice, $along) {
  var extra = $along.depth - slice.openStart, parent = $along.node(extra);
  var node = parent.copy(slice.content);
  for (var i = extra - 1; i >= 0; i--)
    { node = $along.node(i).copy(Fragment.from(node)); }
  return {start: node.resolveNoCache(slice.openStart + extra),
          end: node.resolveNoCache(node.content.size - slice.openEnd - extra)}
}

// ::- You can [_resolve_](#model.Node.resolve) a position to get more
// information about it. Objects of this class represent such a
// resolved position, providing various pieces of context information,
// and some helper methods.
//
// Throughout this interface, methods that take an optional `depth`
// parameter will interpret undefined as `this.depth` and negative
// numbers as `this.depth + value`.
var ResolvedPos = function ResolvedPos(pos, path, parentOffset) {
  // :: number The position that was resolved.
  this.pos = pos;
  this.path = path;
  // :: number
  // The number of levels the parent node is from the root. If this
  // position points directly into the root node, it is 0. If it
  // points into a top-level paragraph, 1, and so on.
  this.depth = path.length / 3 - 1;
  // :: number The offset this position has into its parent node.
  this.parentOffset = parentOffset;
};

var prototypeAccessors$2 = { parent: { configurable: true },doc: { configurable: true },textOffset: { configurable: true },nodeAfter: { configurable: true },nodeBefore: { configurable: true } };

ResolvedPos.prototype.resolveDepth = function resolveDepth (val) {
  if (val == null) { return this.depth }
  if (val < 0) { return this.depth + val }
  return val
};

// :: Node
// The parent node that the position points into. Note that even if
// a position points into a text node, that node is not considered
// the parent—text nodes are ‘flat’ in this model, and have no content.
prototypeAccessors$2.parent.get = function () { return this.node(this.depth) };

// :: Node
// The root node in which the position was resolved.
prototypeAccessors$2.doc.get = function () { return this.node(0) };

// :: (?number) → Node
// The ancestor node at the given level. `p.node(p.depth)` is the
// same as `p.parent`.
ResolvedPos.prototype.node = function node (depth) { return this.path[this.resolveDepth(depth) * 3] };

// :: (?number) → number
// The index into the ancestor at the given level. If this points at
// the 3rd node in the 2nd paragraph on the top level, for example,
// `p.index(0)` is 1 and `p.index(1)` is 2.
ResolvedPos.prototype.index = function index (depth) { return this.path[this.resolveDepth(depth) * 3 + 1] };

// :: (?number) → number
// The index pointing after this position into the ancestor at the
// given level.
ResolvedPos.prototype.indexAfter = function indexAfter (depth) {
  depth = this.resolveDepth(depth);
  return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1)
};

// :: (?number) → number
// The (absolute) position at the start of the node at the given
// level.
ResolvedPos.prototype.start = function start (depth) {
  depth = this.resolveDepth(depth);
  return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1
};

// :: (?number) → number
// The (absolute) position at the end of the node at the given
// level.
ResolvedPos.prototype.end = function end (depth) {
  depth = this.resolveDepth(depth);
  return this.start(depth) + this.node(depth).content.size
};

// :: (?number) → number
// The (absolute) position directly before the wrapping node at the
// given level, or, when `depth` is `this.depth + 1`, the original
// position.
ResolvedPos.prototype.before = function before (depth) {
  depth = this.resolveDepth(depth);
  if (!depth) { throw new RangeError("There is no position before the top-level node") }
  return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1]
};

// :: (?number) → number
// The (absolute) position directly after the wrapping node at the
// given level, or the original position when `depth` is `this.depth + 1`.
ResolvedPos.prototype.after = function after (depth) {
  depth = this.resolveDepth(depth);
  if (!depth) { throw new RangeError("There is no position after the top-level node") }
  return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize
};

// :: number
// When this position points into a text node, this returns the
// distance between the position and the start of the text node.
// Will be zero for positions that point between nodes.
prototypeAccessors$2.textOffset.get = function () { return this.pos - this.path[this.path.length - 1] };

// :: ?Node
// Get the node directly after the position, if any. If the position
// points into a text node, only the part of that node after the
// position is returned.
prototypeAccessors$2.nodeAfter.get = function () {
  var parent = this.parent, index = this.index(this.depth);
  if (index == parent.childCount) { return null }
  var dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index);
  return dOff ? parent.child(index).cut(dOff) : child
};

// :: ?Node
// Get the node directly before the position, if any. If the
// position points into a text node, only the part of that node
// before the position is returned.
prototypeAccessors$2.nodeBefore.get = function () {
  var index = this.index(this.depth);
  var dOff = this.pos - this.path[this.path.length - 1];
  if (dOff) { return this.parent.child(index).cut(0, dOff) }
  return index == 0 ? null : this.parent.child(index - 1)
};

// :: (number, ?number) → number
// Get the position at the given index in the parent node at the
// given depth (which defaults to `this.depth`).
ResolvedPos.prototype.posAtIndex = function posAtIndex (index, depth) {
  depth = this.resolveDepth(depth);
  var node = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
  for (var i = 0; i < index; i++) { pos += node.child(i).nodeSize; }
  return pos
};

// :: () → [Mark]
// Get the marks at this position, factoring in the surrounding
// marks' [`inclusive`](#model.MarkSpec.inclusive) property. If the
// position is at the start of a non-empty node, the marks of the
// node after it (if any) are returned.
ResolvedPos.prototype.marks = function marks () {
  var parent = this.parent, index = this.index();

  // In an empty parent, return the empty array
  if (parent.content.size == 0) { return Mark.none }

  // When inside a text node, just return the text node's marks
  if (this.textOffset) { return parent.child(index).marks }

  var main = parent.maybeChild(index - 1), other = parent.maybeChild(index);
  // If the `after` flag is true of there is no node before, make
  // the node after this position the main reference.
  if (!main) { var tmp = main; main = other; other = tmp; }

  // Use all marks in the main node, except those that have
  // `inclusive` set to false and are not present in the other node.
  var marks = main.marks;
  for (var i = 0; i < marks.length; i++)
    { if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks)))
      { marks = marks[i--].removeFromSet(marks); } }

  return marks
};

// :: (ResolvedPos) → ?[Mark]
// Get the marks after the current position, if any, except those
// that are non-inclusive and not present at position `$end`. This
// is mostly useful for getting the set of marks to preserve after a
// deletion. Will return `null` if this position is at the end of
// its parent node or its parent node isn't a textblock (in which
// case no marks should be preserved).
ResolvedPos.prototype.marksAcross = function marksAcross ($end) {
  var after = this.parent.maybeChild(this.index());
  if (!after || !after.isInline) { return null }

  var marks = after.marks, next = $end.parent.maybeChild($end.index());
  for (var i = 0; i < marks.length; i++)
    { if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks)))
      { marks = marks[i--].removeFromSet(marks); } }
  return marks
};

// :: (number) → number
// The depth up to which this position and the given (non-resolved)
// position share the same parent nodes.
ResolvedPos.prototype.sharedDepth = function sharedDepth (pos) {
  for (var depth = this.depth; depth > 0; depth--)
    { if (this.start(depth) <= pos && this.end(depth) >= pos) { return depth } }
  return 0
};

// :: (?ResolvedPos, ?(Node) → bool) → ?NodeRange
// Returns a range based on the place where this position and the
// given position diverge around block content. If both point into
// the same textblock, for example, a range around that textblock
// will be returned. If they point into different blocks, the range
// around those blocks in their shared ancestor is returned. You can
// pass in an optional predicate that will be called with a parent
// node to see if a range into that parent is acceptable.
ResolvedPos.prototype.blockRange = function blockRange (other, pred) {
    if ( other === void 0 ) other = this;

  if (other.pos < this.pos) { return other.blockRange(this) }
  for (var d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--)
    { if (other.pos <= this.end(d) && (!pred || pred(this.node(d))))
      { return new NodeRange(this, other, d) } }
};

// :: (ResolvedPos) → bool
// Query whether the given position shares the same parent node.
ResolvedPos.prototype.sameParent = function sameParent (other) {
  return this.pos - this.parentOffset == other.pos - other.parentOffset
};

// :: (ResolvedPos) → ResolvedPos
// Return the greater of this and the given position.
ResolvedPos.prototype.max = function max (other) {
  return other.pos > this.pos ? other : this
};

// :: (ResolvedPos) → ResolvedPos
// Return the smaller of this and the given position.
ResolvedPos.prototype.min = function min (other) {
  return other.pos < this.pos ? other : this
};

ResolvedPos.prototype.toString = function toString () {
  var str = "";
  for (var i = 1; i <= this.depth; i++)
    { str += (str ? "/" : "") + this.node(i).type.name + "_" + this.index(i - 1); }
  return str + ":" + this.parentOffset
};

ResolvedPos.resolve = function resolve (doc, pos) {
  if (!(pos >= 0 && pos <= doc.content.size)) { throw new RangeError("Position " + pos + " out of range") }
  var path = [];
  var start = 0, parentOffset = pos;
  for (var node = doc;;) {
    var ref = node.content.findIndex(parentOffset);
      var index = ref.index;
      var offset = ref.offset;
    var rem = parentOffset - offset;
    path.push(node, index, start + offset);
    if (!rem) { break }
    node = node.child(index);
    if (node.isText) { break }
    parentOffset = rem - 1;
    start += offset + 1;
  }
  return new ResolvedPos(pos, path, parentOffset)
};

ResolvedPos.resolveCached = function resolveCached (doc, pos) {
  for (var i = 0; i < resolveCache.length; i++) {
    var cached = resolveCache[i];
    if (cached.pos == pos && cached.doc == doc) { return cached }
  }
  var result = resolveCache[resolveCachePos] = ResolvedPos.resolve(doc, pos);
  resolveCachePos = (resolveCachePos + 1) % resolveCacheSize;
  return result
};

Object.defineProperties( ResolvedPos.prototype, prototypeAccessors$2 );

var resolveCache = [], resolveCachePos = 0, resolveCacheSize = 12;

// ::- Represents a flat range of content, i.e. one that starts and
// ends in the same node.
var NodeRange = function NodeRange($from, $to, depth) {
  // :: ResolvedPos A resolved position along the start of the
  // content. May have a `depth` greater than this object's `depth`
  // property, since these are the positions that were used to
  // compute the range, not re-resolved positions directly at its
  // boundaries.
  this.$from = $from;
  // :: ResolvedPos A position along the end of the content. See
  // caveat for [`$from`](#model.NodeRange.$from).
  this.$to = $to;
  // :: number The depth of the node that this range points into.
  this.depth = depth;
};

var prototypeAccessors$1$1 = { start: { configurable: true },end: { configurable: true },parent: { configurable: true },startIndex: { configurable: true },endIndex: { configurable: true } };

// :: number The position at the start of the range.
prototypeAccessors$1$1.start.get = function () { return this.$from.before(this.depth + 1) };
// :: number The position at the end of the range.
prototypeAccessors$1$1.end.get = function () { return this.$to.after(this.depth + 1) };

// :: Node The parent node that the range points into.
prototypeAccessors$1$1.parent.get = function () { return this.$from.node(this.depth) };
// :: number The start index of the range in the parent node.
prototypeAccessors$1$1.startIndex.get = function () { return this.$from.index(this.depth) };
// :: number The end index of the range in the parent node.
prototypeAccessors$1$1.endIndex.get = function () { return this.$to.indexAfter(this.depth) };

Object.defineProperties( NodeRange.prototype, prototypeAccessors$1$1 );

var emptyAttrs = Object.create(null);

// ::- This class represents a node in the tree that makes up a
// ProseMirror document. So a document is an instance of `Node`, with
// children that are also instances of `Node`.
//
// Nodes are persistent data structures. Instead of changing them, you
// create new ones with the content you want. Old ones keep pointing
// at the old document shape. This is made cheaper by sharing
// structure between the old and new data as much as possible, which a
// tree shape like this (without back pointers) makes easy.
//
// **Do not** directly mutate the properties of a `Node` object. See
// [the guide](/docs/guide/#doc) for more information.
var Node = function Node(type, attrs, content, marks) {
  // :: NodeType
  // The type of node that this is.
  this.type = type;

  // :: Object
  // An object mapping attribute names to values. The kind of
  // attributes allowed and required are
  // [determined](#model.NodeSpec.attrs) by the node type.
  this.attrs = attrs;

  // :: Fragment
  // A container holding the node's children.
  this.content = content || Fragment.empty;

  // :: [Mark]
  // The marks (things like whether it is emphasized or part of a
  // link) applied to this node.
  this.marks = marks || Mark.none;
};

var prototypeAccessors$3 = { nodeSize: { configurable: true },childCount: { configurable: true },textContent: { configurable: true },firstChild: { configurable: true },lastChild: { configurable: true },isBlock: { configurable: true },isTextblock: { configurable: true },inlineContent: { configurable: true },isInline: { configurable: true },isText: { configurable: true },isLeaf: { configurable: true },isAtom: { configurable: true } };

// text:: ?string
// For text nodes, this contains the node's text content.

// :: number
// The size of this node, as defined by the integer-based [indexing
// scheme](/docs/guide/#doc.indexing). For text nodes, this is the
// amount of characters. For other leaf nodes, it is one. For
// non-leaf nodes, it is the size of the content plus two (the start
// and end token).
prototypeAccessors$3.nodeSize.get = function () { return this.isLeaf ? 1 : 2 + this.content.size };

// :: number
// The number of children that the node has.
prototypeAccessors$3.childCount.get = function () { return this.content.childCount };

// :: (number) → Node
// Get the child node at the given index. Raises an error when the
// index is out of range.
Node.prototype.child = function child (index) { return this.content.child(index) };

// :: (number) → ?Node
// Get the child node at the given index, if it exists.
Node.prototype.maybeChild = function maybeChild (index) { return this.content.maybeChild(index) };

// :: ((node: Node, offset: number, index: number))
// Call `f` for every child node, passing the node, its offset
// into this parent node, and its index.
Node.prototype.forEach = function forEach (f) { this.content.forEach(f); };

// :: (number, number, (node: Node, pos: number, parent: Node, index: number) → ?bool, ?number)
// Invoke a callback for all descendant nodes recursively between
// the given two positions that are relative to start of this node's
// content. The callback is invoked with the node, its
// parent-relative position, its parent node, and its child index.
// When the callback returns false for a given node, that node's
// children will not be recursed over. The last parameter can be
// used to specify a starting position to count from.
Node.prototype.nodesBetween = function nodesBetween (from, to, f, startPos) {
    if ( startPos === void 0 ) startPos = 0;

  this.content.nodesBetween(from, to, f, startPos, this);
};

// :: ((node: Node, pos: number, parent: Node) → ?bool)
// Call the given callback for every descendant node. Doesn't
// descend into a node when the callback returns `false`.
Node.prototype.descendants = function descendants (f) {
  this.nodesBetween(0, this.content.size, f);
};

// :: string
// Concatenates all the text nodes found in this fragment and its
// children.
prototypeAccessors$3.textContent.get = function () { return this.textBetween(0, this.content.size, "") };

// :: (number, number, ?string, ?string | ?(leafNode: Node) -> string) → string
// Get all text between positions `from` and `to`. When
// `blockSeparator` is given, it will be inserted whenever a new
// block node is started. When `leafText` is given, it'll be
// inserted for every non-text leaf node encountered.
Node.prototype.textBetween = function textBetween (from, to, blockSeparator, leafText) {
  return this.content.textBetween(from, to, blockSeparator, leafText)
};

// :: ?Node
// Returns this node's first child, or `null` if there are no
// children.
prototypeAccessors$3.firstChild.get = function () { return this.content.firstChild };

// :: ?Node
// Returns this node's last child, or `null` if there are no
// children.
prototypeAccessors$3.lastChild.get = function () { return this.content.lastChild };

// :: (Node) → bool
// Test whether two nodes represent the same piece of document.
Node.prototype.eq = function eq (other) {
  return this == other || (this.sameMarkup(other) && this.content.eq(other.content))
};

// :: (Node) → bool
// Compare the markup (type, attributes, and marks) of this node to
// those of another. Returns `true` if both have the same markup.
Node.prototype.sameMarkup = function sameMarkup (other) {
  return this.hasMarkup(other.type, other.attrs, other.marks)
};

// :: (NodeType, ?Object, ?[Mark]) → bool
// Check whether this node's markup correspond to the given type,
// attributes, and marks.
Node.prototype.hasMarkup = function hasMarkup (type, attrs, marks) {
  return this.type == type &&
    compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) &&
    Mark.sameSet(this.marks, marks || Mark.none)
};

// :: (?Fragment) → Node
// Create a new node with the same markup as this node, containing
// the given content (or empty, if no content is given).
Node.prototype.copy = function copy (content) {
    if ( content === void 0 ) content = null;

  if (content == this.content) { return this }
  return new this.constructor(this.type, this.attrs, content, this.marks)
};

// :: ([Mark]) → Node
// Create a copy of this node, with the given set of marks instead
// of the node's own marks.
Node.prototype.mark = function mark (marks) {
  return marks == this.marks ? this : new this.constructor(this.type, this.attrs, this.content, marks)
};

// :: (number, ?number) → Node
// Create a copy of this node with only the content between the
// given positions. If `to` is not given, it defaults to the end of
// the node.
Node.prototype.cut = function cut (from, to) {
  if (from == 0 && to == this.content.size) { return this }
  return this.copy(this.content.cut(from, to))
};

// :: (number, ?number) → Slice
// Cut out the part of the document between the given positions, and
// return it as a `Slice` object.
Node.prototype.slice = function slice (from, to, includeParents) {
    if ( to === void 0 ) to = this.content.size;
    if ( includeParents === void 0 ) includeParents = false;

  if (from == to) { return Slice.empty }

  var $from = this.resolve(from), $to = this.resolve(to);
  var depth = includeParents ? 0 : $from.sharedDepth(to);
  var start = $from.start(depth), node = $from.node(depth);
  var content = node.content.cut($from.pos - start, $to.pos - start);
  return new Slice(content, $from.depth - depth, $to.depth - depth)
};

// :: (number, number, Slice) → Node
// Replace the part of the document between the given positions with
// the given slice. The slice must 'fit', meaning its open sides
// must be able to connect to the surrounding content, and its
// content nodes must be valid children for the node they are placed
// into. If any of this is violated, an error of type
// [`ReplaceError`](#model.ReplaceError) is thrown.
Node.prototype.replace = function replace$1 (from, to, slice) {
  return replace(this.resolve(from), this.resolve(to), slice)
};

// :: (number) → ?Node
// Find the node directly after the given position.
Node.prototype.nodeAt = function nodeAt (pos) {
  for (var node = this;;) {
    var ref = node.content.findIndex(pos);
      var index = ref.index;
      var offset = ref.offset;
    node = node.maybeChild(index);
    if (!node) { return null }
    if (offset == pos || node.isText) { return node }
    pos -= offset + 1;
  }
};

// :: (number) → {node: ?Node, index: number, offset: number}
// Find the (direct) child node after the given offset, if any,
// and return it along with its index and offset relative to this
// node.
Node.prototype.childAfter = function childAfter (pos) {
  var ref = this.content.findIndex(pos);
    var index = ref.index;
    var offset = ref.offset;
  return {node: this.content.maybeChild(index), index: index, offset: offset}
};

// :: (number) → {node: ?Node, index: number, offset: number}
// Find the (direct) child node before the given offset, if any,
// and return it along with its index and offset relative to this
// node.
Node.prototype.childBefore = function childBefore (pos) {
  if (pos == 0) { return {node: null, index: 0, offset: 0} }
  var ref = this.content.findIndex(pos);
    var index = ref.index;
    var offset = ref.offset;
  if (offset < pos) { return {node: this.content.child(index), index: index, offset: offset} }
  var node = this.content.child(index - 1);
  return {node: node, index: index - 1, offset: offset - node.nodeSize}
};

// :: (number) → ResolvedPos
// Resolve the given position in the document, returning an
// [object](#model.ResolvedPos) with information about its context.
Node.prototype.resolve = function resolve (pos) { return ResolvedPos.resolveCached(this, pos) };

Node.prototype.resolveNoCache = function resolveNoCache (pos) { return ResolvedPos.resolve(this, pos) };

// :: (number, number, union<Mark, MarkType>) → bool
// Test whether a given mark or mark type occurs in this document
// between the two given positions.
Node.prototype.rangeHasMark = function rangeHasMark (from, to, type) {
  var found = false;
  if (to > from) { this.nodesBetween(from, to, function (node) {
    if (type.isInSet(node.marks)) { found = true; }
    return !found
  }); }
  return found
};

// :: bool
// True when this is a block (non-inline node)
prototypeAccessors$3.isBlock.get = function () { return this.type.isBlock };

// :: bool
// True when this is a textblock node, a block node with inline
// content.
prototypeAccessors$3.isTextblock.get = function () { return this.type.isTextblock };

// :: bool
// True when this node allows inline content.
prototypeAccessors$3.inlineContent.get = function () { return this.type.inlineContent };

// :: bool
// True when this is an inline node (a text node or a node that can
// appear among text).
prototypeAccessors$3.isInline.get = function () { return this.type.isInline };

// :: bool
// True when this is a text node.
prototypeAccessors$3.isText.get = function () { return this.type.isText };

// :: bool
// True when this is a leaf node.
prototypeAccessors$3.isLeaf.get = function () { return this.type.isLeaf };

// :: bool
// True when this is an atom, i.e. when it does not have directly
// editable content. This is usually the same as `isLeaf`, but can
// be configured with the [`atom` property](#model.NodeSpec.atom) on
// a node's spec (typically used when the node is displayed as an
// uneditable [node view](#view.NodeView)).
prototypeAccessors$3.isAtom.get = function () { return this.type.isAtom };

// :: () → string
// Return a string representation of this node for debugging
// purposes.
Node.prototype.toString = function toString () {
  if (this.type.spec.toDebugString) { return this.type.spec.toDebugString(this) }
  var name = this.type.name;
  if (this.content.size)
    { name += "(" + this.content.toStringInner() + ")"; }
  return wrapMarks(this.marks, name)
};

// :: (number) → ContentMatch
// Get the content match in this node at the given index.
Node.prototype.contentMatchAt = function contentMatchAt (index) {
  var match = this.type.contentMatch.matchFragment(this.content, 0, index);
  if (!match) { throw new Error("Called contentMatchAt on a node with invalid content") }
  return match
};

// :: (number, number, ?Fragment, ?number, ?number) → bool
// Test whether replacing the range between `from` and `to` (by
// child index) with the given replacement fragment (which defaults
// to the empty fragment) would leave the node's content valid. You
// can optionally pass `start` and `end` indices into the
// replacement fragment.
Node.prototype.canReplace = function canReplace (from, to, replacement, start, end) {
    if ( replacement === void 0 ) replacement = Fragment.empty;
    if ( start === void 0 ) start = 0;
    if ( end === void 0 ) end = replacement.childCount;

  var one = this.contentMatchAt(from).matchFragment(replacement, start, end);
  var two = one && one.matchFragment(this.content, to);
  if (!two || !two.validEnd) { return false }
  for (var i = start; i < end; i++) { if (!this.type.allowsMarks(replacement.child(i).marks)) { return false } }
  return true
};

// :: (number, number, NodeType, ?[Mark]) → bool
// Test whether replacing the range `from` to `to` (by index) with a
// node of the given type would leave the node's content valid.
Node.prototype.canReplaceWith = function canReplaceWith (from, to, type, marks) {
  if (marks && !this.type.allowsMarks(marks)) { return false }
  var start = this.contentMatchAt(from).matchType(type);
  var end = start && start.matchFragment(this.content, to);
  return end ? end.validEnd : false
};

// :: (Node) → bool
// Test whether the given node's content could be appended to this
// node. If that node is empty, this will only return true if there
// is at least one node type that can appear in both nodes (to avoid
// merging completely incompatible nodes).
Node.prototype.canAppend = function canAppend (other) {
  if (other.content.size) { return this.canReplace(this.childCount, this.childCount, other.content) }
  else { return this.type.compatibleContent(other.type) }
};

// :: ()
// Check whether this node and its descendants conform to the
// schema, and raise error when they do not.
Node.prototype.check = function check () {
  if (!this.type.validContent(this.content))
    { throw new RangeError(("Invalid content for node " + (this.type.name) + ": " + (this.content.toString().slice(0, 50)))) }
  var copy = Mark.none;
  for (var i = 0; i < this.marks.length; i++) { copy = this.marks[i].addToSet(copy); }
  if (!Mark.sameSet(copy, this.marks))
    { throw new RangeError(("Invalid collection of marks for node " + (this.type.name) + ": " + (this.marks.map(function (m) { return m.type.name; })))) }
  this.content.forEach(function (node) { return node.check(); });
};

// :: () → Object
// Return a JSON-serializeable representation of this node.
Node.prototype.toJSON = function toJSON () {
  var obj = {type: this.type.name};
  for (var _ in this.attrs) {
    obj.attrs = this.attrs;
    break
  }
  if (this.content.size)
    { obj.content = this.content.toJSON(); }
  if (this.marks.length)
    { obj.marks = this.marks.map(function (n) { return n.toJSON(); }); }
  return obj
};

// :: (Schema, Object) → Node
// Deserialize a node from its JSON representation.
Node.fromJSON = function fromJSON (schema, json) {
  if (!json) { throw new RangeError("Invalid input for Node.fromJSON") }
  var marks = null;
  if (json.marks) {
    if (!Array.isArray(json.marks)) { throw new RangeError("Invalid mark data for Node.fromJSON") }
    marks = json.marks.map(schema.markFromJSON);
  }
  if (json.type == "text") {
    if (typeof json.text != "string") { throw new RangeError("Invalid text node in JSON") }
    return schema.text(json.text, marks)
  }
  var content = Fragment.fromJSON(schema, json.content);
  return schema.nodeType(json.type).create(json.attrs, content, marks)
};

Object.defineProperties( Node.prototype, prototypeAccessors$3 );

var TextNode = /*@__PURE__*/(function (Node) {
  function TextNode(type, attrs, content, marks) {
    Node.call(this, type, attrs, null, marks);

    if (!content) { throw new RangeError("Empty text nodes are not allowed") }

    this.text = content;
  }

  if ( Node ) TextNode.__proto__ = Node;
  TextNode.prototype = Object.create( Node && Node.prototype );
  TextNode.prototype.constructor = TextNode;

  var prototypeAccessors$1 = { textContent: { configurable: true },nodeSize: { configurable: true } };

  TextNode.prototype.toString = function toString () {
    if (this.type.spec.toDebugString) { return this.type.spec.toDebugString(this) }
    return wrapMarks(this.marks, JSON.stringify(this.text))
  };

  prototypeAccessors$1.textContent.get = function () { return this.text };

  TextNode.prototype.textBetween = function textBetween (from, to) { return this.text.slice(from, to) };

  prototypeAccessors$1.nodeSize.get = function () { return this.text.length };

  TextNode.prototype.mark = function mark (marks) {
    return marks == this.marks ? this : new TextNode(this.type, this.attrs, this.text, marks)
  };

  TextNode.prototype.withText = function withText (text) {
    if (text == this.text) { return this }
    return new TextNode(this.type, this.attrs, text, this.marks)
  };

  TextNode.prototype.cut = function cut (from, to) {
    if ( from === void 0 ) from = 0;
    if ( to === void 0 ) to = this.text.length;

    if (from == 0 && to == this.text.length) { return this }
    return this.withText(this.text.slice(from, to))
  };

  TextNode.prototype.eq = function eq (other) {
    return this.sameMarkup(other) && this.text == other.text
  };

  TextNode.prototype.toJSON = function toJSON () {
    var base = Node.prototype.toJSON.call(this);
    base.text = this.text;
    return base
  };

  Object.defineProperties( TextNode.prototype, prototypeAccessors$1 );

  return TextNode;
}(Node));

function wrapMarks(marks, str) {
  for (var i = marks.length - 1; i >= 0; i--)
    { str = marks[i].type.name + "(" + str + ")"; }
  return str
}

// ::- Instances of this class represent a match state of a node
// type's [content expression](#model.NodeSpec.content), and can be
// used to find out whether further content matches here, and whether
// a given position is a valid end of the node.
var ContentMatch = function ContentMatch(validEnd) {
  // :: bool
  // True when this match state represents a valid end of the node.
  this.validEnd = validEnd;
  this.next = [];
  this.wrapCache = [];
};

var prototypeAccessors$4 = { inlineContent: { configurable: true },defaultType: { configurable: true },edgeCount: { configurable: true } };

ContentMatch.parse = function parse (string, nodeTypes) {
  var stream = new TokenStream(string, nodeTypes);
  if (stream.next == null) { return ContentMatch.empty }
  var expr = parseExpr(stream);
  if (stream.next) { stream.err("Unexpected trailing text"); }
  var match = dfa(nfa(expr));
  checkForDeadEnds(match, stream);
  return match
};

// :: (NodeType) → ?ContentMatch
// Match a node type, returning a match after that node if
// successful.
ContentMatch.prototype.matchType = function matchType (type) {
  for (var i = 0; i < this.next.length; i += 2)
    { if (this.next[i] == type) { return this.next[i + 1] } }
  return null
};

// :: (Fragment, ?number, ?number) → ?ContentMatch
// Try to match a fragment. Returns the resulting match when
// successful.
ContentMatch.prototype.matchFragment = function matchFragment (frag, start, end) {
    if ( start === void 0 ) start = 0;
    if ( end === void 0 ) end = frag.childCount;

  var cur = this;
  for (var i = start; cur && i < end; i++)
    { cur = cur.matchType(frag.child(i).type); }
  return cur
};

prototypeAccessors$4.inlineContent.get = function () {
  var first = this.next[0];
  return first ? first.isInline : false
};

// :: ?NodeType
// Get the first matching node type at this match position that can
// be generated.
prototypeAccessors$4.defaultType.get = function () {
  for (var i = 0; i < this.next.length; i += 2) {
    var type = this.next[i];
    if (!(type.isText || type.hasRequiredAttrs())) { return type }
  }
};

ContentMatch.prototype.compatible = function compatible (other) {
  for (var i = 0; i < this.next.length; i += 2)
    { for (var j = 0; j < other.next.length; j += 2)
      { if (this.next[i] == other.next[j]) { return true } } }
  return false
};

// :: (Fragment, bool, ?number) → ?Fragment
// Try to match the given fragment, and if that fails, see if it can
// be made to match by inserting nodes in front of it. When
// successful, return a fragment of inserted nodes (which may be
// empty if nothing had to be inserted). When `toEnd` is true, only
// return a fragment if the resulting match goes to the end of the
// content expression.
ContentMatch.prototype.fillBefore = function fillBefore (after, toEnd, startIndex) {
    if ( toEnd === void 0 ) toEnd = false;
    if ( startIndex === void 0 ) startIndex = 0;

  var seen = [this];
  function search(match, types) {
    var finished = match.matchFragment(after, startIndex);
    if (finished && (!toEnd || finished.validEnd))
      { return Fragment.from(types.map(function (tp) { return tp.createAndFill(); })) }

    for (var i = 0; i < match.next.length; i += 2) {
      var type = match.next[i], next = match.next[i + 1];
      if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {
        seen.push(next);
        var found = search(next, types.concat(type));
        if (found) { return found }
      }
    }
  }

  return search(this, [])
};

// :: (NodeType) → ?[NodeType]
// Find a set of wrapping node types that would allow a node of the
// given type to appear at this position. The result may be empty
// (when it fits directly) and will be null when no such wrapping
// exists.
ContentMatch.prototype.findWrapping = function findWrapping (target) {
  for (var i = 0; i < this.wrapCache.length; i += 2)
    { if (this.wrapCache[i] == target) { return this.wrapCache[i + 1] } }
  var computed = this.computeWrapping(target);
  this.wrapCache.push(target, computed);
  return computed
};

ContentMatch.prototype.computeWrapping = function computeWrapping (target) {
  var seen = Object.create(null), active = [{match: this, type: null, via: null}];
  while (active.length) {
    var current = active.shift(), match = current.match;
    if (match.matchType(target)) {
      var result = [];
      for (var obj = current; obj.type; obj = obj.via)
        { result.push(obj.type); }
      return result.reverse()
    }
    for (var i = 0; i < match.next.length; i += 2) {
      var type = match.next[i];
      if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || match.next[i + 1].validEnd)) {
        active.push({match: type.contentMatch, type: type, via: current});
        seen[type.name] = true;
      }
    }
  }
};

// :: number
// The number of outgoing edges this node has in the finite
// automaton that describes the content expression.
prototypeAccessors$4.edgeCount.get = function () {
  return this.next.length >> 1
};

// :: (number) → {type: NodeType, next: ContentMatch}
// Get the _n_​th outgoing edge from this node in the finite
// automaton that describes the content expression.
ContentMatch.prototype.edge = function edge (n) {
  var i = n << 1;
  if (i >= this.next.length) { throw new RangeError(("There's no " + n + "th edge in this content match")) }
  return {type: this.next[i], next: this.next[i + 1]}
};

ContentMatch.prototype.toString = function toString () {
  var seen = [];
  function scan(m) {
    seen.push(m);
    for (var i = 1; i < m.next.length; i += 2)
      { if (seen.indexOf(m.next[i]) == -1) { scan(m.next[i]); } }
  }
  scan(this);
  return seen.map(function (m, i) {
    var out = i + (m.validEnd ? "*" : " ") + " ";
    for (var i$1 = 0; i$1 < m.next.length; i$1 += 2)
      { out += (i$1 ? ", " : "") + m.next[i$1].name + "->" + seen.indexOf(m.next[i$1 + 1]); }
    return out
  }).join("\n")
};

Object.defineProperties( ContentMatch.prototype, prototypeAccessors$4 );

ContentMatch.empty = new ContentMatch(true);

var TokenStream = function TokenStream(string, nodeTypes) {
  this.string = string;
  this.nodeTypes = nodeTypes;
  this.inline = null;
  this.pos = 0;
  this.tokens = string.split(/\s*(?=\b|\W|$)/);
  if (this.tokens[this.tokens.length - 1] == "") { this.tokens.pop(); }
  if (this.tokens[0] == "") { this.tokens.shift(); }
};

var prototypeAccessors$1$2 = { next: { configurable: true } };

prototypeAccessors$1$2.next.get = function () { return this.tokens[this.pos] };

TokenStream.prototype.eat = function eat (tok) { return this.next == tok && (this.pos++ || true) };

TokenStream.prototype.err = function err (str) { throw new SyntaxError(str + " (in content expression '" + this.string + "')") };

Object.defineProperties( TokenStream.prototype, prototypeAccessors$1$2 );

function parseExpr(stream) {
  var exprs = [];
  do { exprs.push(parseExprSeq(stream)); }
  while (stream.eat("|"))
  return exprs.length == 1 ? exprs[0] : {type: "choice", exprs: exprs}
}

function parseExprSeq(stream) {
  var exprs = [];
  do { exprs.push(parseExprSubscript(stream)); }
  while (stream.next && stream.next != ")" && stream.next != "|")
  return exprs.length == 1 ? exprs[0] : {type: "seq", exprs: exprs}
}

function parseExprSubscript(stream) {
  var expr = parseExprAtom(stream);
  for (;;) {
    if (stream.eat("+"))
      { expr = {type: "plus", expr: expr}; }
    else if (stream.eat("*"))
      { expr = {type: "star", expr: expr}; }
    else if (stream.eat("?"))
      { expr = {type: "opt", expr: expr}; }
    else if (stream.eat("{"))
      { expr = parseExprRange(stream, expr); }
    else { break }
  }
  return expr
}

function parseNum(stream) {
  if (/\D/.test(stream.next)) { stream.err("Expected number, got '" + stream.next + "'"); }
  var result = Number(stream.next);
  stream.pos++;
  return result
}

function parseExprRange(stream, expr) {
  var min = parseNum(stream), max = min;
  if (stream.eat(",")) {
    if (stream.next != "}") { max = parseNum(stream); }
    else { max = -1; }
  }
  if (!stream.eat("}")) { stream.err("Unclosed braced range"); }
  return {type: "range", min: min, max: max, expr: expr}
}

function resolveName(stream, name) {
  var types = stream.nodeTypes, type = types[name];
  if (type) { return [type] }
  var result = [];
  for (var typeName in types) {
    var type$1 = types[typeName];
    if (type$1.groups.indexOf(name) > -1) { result.push(type$1); }
  }
  if (result.length == 0) { stream.err("No node type or group '" + name + "' found"); }
  return result
}

function parseExprAtom(stream) {
  if (stream.eat("(")) {
    var expr = parseExpr(stream);
    if (!stream.eat(")")) { stream.err("Missing closing paren"); }
    return expr
  } else if (!/\W/.test(stream.next)) {
    var exprs = resolveName(stream, stream.next).map(function (type) {
      if (stream.inline == null) { stream.inline = type.isInline; }
      else if (stream.inline != type.isInline) { stream.err("Mixing inline and block content"); }
      return {type: "name", value: type}
    });
    stream.pos++;
    return exprs.length == 1 ? exprs[0] : {type: "choice", exprs: exprs}
  } else {
    stream.err("Unexpected token '" + stream.next + "'");
  }
}

// The code below helps compile a regular-expression-like language
// into a deterministic finite automaton. For a good introduction to
// these concepts, see https://swtch.com/~rsc/regexp/regexp1.html

// : (Object) → [[{term: ?any, to: number}]]
// Construct an NFA from an expression as returned by the parser. The
// NFA is represented as an array of states, which are themselves
// arrays of edges, which are `{term, to}` objects. The first state is
// the entry state and the last node is the success state.
//
// Note that unlike typical NFAs, the edge ordering in this one is
// significant, in that it is used to contruct filler content when
// necessary.
function nfa(expr) {
  var nfa = [[]];
  connect(compile(expr, 0), node());
  return nfa

  function node() { return nfa.push([]) - 1 }
  function edge(from, to, term) {
    var edge = {term: term, to: to};
    nfa[from].push(edge);
    return edge
  }
  function connect(edges, to) { edges.forEach(function (edge) { return edge.to = to; }); }

  function compile(expr, from) {
    if (expr.type == "choice") {
      return expr.exprs.reduce(function (out, expr) { return out.concat(compile(expr, from)); }, [])
    } else if (expr.type == "seq") {
      for (var i = 0;; i++) {
        var next = compile(expr.exprs[i], from);
        if (i == expr.exprs.length - 1) { return next }
        connect(next, from = node());
      }
    } else if (expr.type == "star") {
      var loop = node();
      edge(from, loop);
      connect(compile(expr.expr, loop), loop);
      return [edge(loop)]
    } else if (expr.type == "plus") {
      var loop$1 = node();
      connect(compile(expr.expr, from), loop$1);
      connect(compile(expr.expr, loop$1), loop$1);
      return [edge(loop$1)]
    } else if (expr.type == "opt") {
      return [edge(from)].concat(compile(expr.expr, from))
    } else if (expr.type == "range") {
      var cur = from;
      for (var i$1 = 0; i$1 < expr.min; i$1++) {
        var next$1 = node();
        connect(compile(expr.expr, cur), next$1);
        cur = next$1;
      }
      if (expr.max == -1) {
        connect(compile(expr.expr, cur), cur);
      } else {
        for (var i$2 = expr.min; i$2 < expr.max; i$2++) {
          var next$2 = node();
          edge(cur, next$2);
          connect(compile(expr.expr, cur), next$2);
          cur = next$2;
        }
      }
      return [edge(cur)]
    } else if (expr.type == "name") {
      return [edge(from, null, expr.value)]
    }
  }
}

function cmp(a, b) { return b - a }

// Get the set of nodes reachable by null edges from `node`. Omit
// nodes with only a single null-out-edge, since they may lead to
// needless duplicated nodes.
function nullFrom(nfa, node) {
  var result = [];
  scan(node);
  return result.sort(cmp)

  function scan(node) {
    var edges = nfa[node];
    if (edges.length == 1 && !edges[0].term) { return scan(edges[0].to) }
    result.push(node);
    for (var i = 0; i < edges.length; i++) {
      var ref = edges[i];
      var term = ref.term;
      var to = ref.to;
      if (!term && result.indexOf(to) == -1) { scan(to); }
    }
  }
}

// : ([[{term: ?any, to: number}]]) → ContentMatch
// Compiles an NFA as produced by `nfa` into a DFA, modeled as a set
// of state objects (`ContentMatch` instances) with transitions
// between them.
function dfa(nfa) {
  var labeled = Object.create(null);
  return explore(nullFrom(nfa, 0))

  function explore(states) {
    var out = [];
    states.forEach(function (node) {
      nfa[node].forEach(function (ref) {
        var term = ref.term;
        var to = ref.to;

        if (!term) { return }
        var known = out.indexOf(term), set = known > -1 && out[known + 1];
        nullFrom(nfa, to).forEach(function (node) {
          if (!set) { out.push(term, set = []); }
          if (set.indexOf(node) == -1) { set.push(node); }
        });
      });
    });
    var state = labeled[states.join(",")] = new ContentMatch(states.indexOf(nfa.length - 1) > -1);
    for (var i = 0; i < out.length; i += 2) {
      var states$1 = out[i + 1].sort(cmp);
      state.next.push(out[i], labeled[states$1.join(",")] || explore(states$1));
    }
    return state
  }
}

function checkForDeadEnds(match, stream) {
  for (var i = 0, work = [match]; i < work.length; i++) {
    var state = work[i], dead = !state.validEnd, nodes = [];
    for (var j = 0; j < state.next.length; j += 2) {
      var node = state.next[j], next = state.next[j + 1];
      nodes.push(node.name);
      if (dead && !(node.isText || node.hasRequiredAttrs())) { dead = false; }
      if (work.indexOf(next) == -1) { work.push(next); }
    }
    if (dead) { stream.err("Only non-generatable nodes (" + nodes.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)"); }
  }
}

// For node types where all attrs have a default value (or which don't
// have any attributes), build up a single reusable default attribute
// object, and use it for all nodes that don't specify specific
// attributes.
function defaultAttrs(attrs) {
  var defaults = Object.create(null);
  for (var attrName in attrs) {
    var attr = attrs[attrName];
    if (!attr.hasDefault) { return null }
    defaults[attrName] = attr.default;
  }
  return defaults
}

function computeAttrs(attrs, value) {
  var built = Object.create(null);
  for (var name in attrs) {
    var given = value && value[name];
    if (given === undefined) {
      var attr = attrs[name];
      if (attr.hasDefault) { given = attr.default; }
      else { throw new RangeError("No value supplied for attribute " + name) }
    }
    built[name] = given;
  }
  return built
}

function initAttrs(attrs) {
  var result = Object.create(null);
  if (attrs) { for (var name in attrs) { result[name] = new Attribute(attrs[name]); } }
  return result
}

// ::- Node types are objects allocated once per `Schema` and used to
// [tag](#model.Node.type) `Node` instances. They contain information
// about the node type, such as its name and what kind of node it
// represents.
var NodeType = function NodeType(name, schema, spec) {
  // :: string
  // The name the node type has in this schema.
  this.name = name;

  // :: Schema
  // A link back to the `Schema` the node type belongs to.
  this.schema = schema;

  // :: NodeSpec
  // The spec that this type is based on
  this.spec = spec;

  this.groups = spec.group ? spec.group.split(" ") : [];
  this.attrs = initAttrs(spec.attrs);

  this.defaultAttrs = defaultAttrs(this.attrs);

  // :: ContentMatch
  // The starting match of the node type's content expression.
  this.contentMatch = null;

  // : ?[MarkType]
  // The set of marks allowed in this node. `null` means all marks
  // are allowed.
  this.markSet = null;

  // :: bool
  // True if this node type has inline content.
  this.inlineContent = null;

  // :: bool
  // True if this is a block type
  this.isBlock = !(spec.inline || name == "text");

  // :: bool
  // True if this is the text node type.
  this.isText = name == "text";
};

var prototypeAccessors$5 = { isInline: { configurable: true },isTextblock: { configurable: true },isLeaf: { configurable: true },isAtom: { configurable: true } };

// :: bool
// True if this is an inline type.
prototypeAccessors$5.isInline.get = function () { return !this.isBlock };

// :: bool
// True if this is a textblock type, a block that contains inline
// content.
prototypeAccessors$5.isTextblock.get = function () { return this.isBlock && this.inlineContent };

// :: bool
// True for node types that allow no content.
prototypeAccessors$5.isLeaf.get = function () { return this.contentMatch == ContentMatch.empty };

// :: bool
// True when this node is an atom, i.e. when it does not have
// directly editable content.
prototypeAccessors$5.isAtom.get = function () { return this.isLeaf || this.spec.atom };

// :: () → bool
// Tells you whether this node type has any required attributes.
NodeType.prototype.hasRequiredAttrs = function hasRequiredAttrs () {
  for (var n in this.attrs) { if (this.attrs[n].isRequired) { return true } }
  return false
};

NodeType.prototype.compatibleContent = function compatibleContent (other) {
  return this == other || this.contentMatch.compatible(other.contentMatch)
};

NodeType.prototype.computeAttrs = function computeAttrs$1 (attrs) {
  if (!attrs && this.defaultAttrs) { return this.defaultAttrs }
  else { return computeAttrs(this.attrs, attrs) }
};

// :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node
// Create a `Node` of this type. The given attributes are
// checked and defaulted (you can pass `null` to use the type's
// defaults entirely, if no required attributes exist). `content`
// may be a `Fragment`, a node, an array of nodes, or
// `null`. Similarly `marks` may be `null` to default to the empty
// set of marks.
NodeType.prototype.create = function create (attrs, content, marks) {
  if (this.isText) { throw new Error("NodeType.create can't construct text nodes") }
  return new Node(this, this.computeAttrs(attrs), Fragment.from(content), Mark.setFrom(marks))
};

// :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node
// Like [`create`](#model.NodeType.create), but check the given content
// against the node type's content restrictions, and throw an error
// if it doesn't match.
NodeType.prototype.createChecked = function createChecked (attrs, content, marks) {
  content = Fragment.from(content);
  if (!this.validContent(content))
    { throw new RangeError("Invalid content for node " + this.name) }
  return new Node(this, this.computeAttrs(attrs), content, Mark.setFrom(marks))
};

// :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → ?Node
// Like [`create`](#model.NodeType.create), but see if it is necessary to
// add nodes to the start or end of the given fragment to make it
// fit the node. If no fitting wrapping can be found, return null.
// Note that, due to the fact that required nodes can always be
// created, this will always succeed if you pass null or
// `Fragment.empty` as content.
NodeType.prototype.createAndFill = function createAndFill (attrs, content, marks) {
  attrs = this.computeAttrs(attrs);
  content = Fragment.from(content);
  if (content.size) {
    var before = this.contentMatch.fillBefore(content);
    if (!before) { return null }
    content = before.append(content);
  }
  var after = this.contentMatch.matchFragment(content).fillBefore(Fragment.empty, true);
  if (!after) { return null }
  return new Node(this, attrs, content.append(after), Mark.setFrom(marks))
};

// :: (Fragment) → bool
// Returns true if the given fragment is valid content for this node
// type with the given attributes.
NodeType.prototype.validContent = function validContent (content) {
  var result = this.contentMatch.matchFragment(content);
  if (!result || !result.validEnd) { return false }
  for (var i = 0; i < content.childCount; i++)
    { if (!this.allowsMarks(content.child(i).marks)) { return false } }
  return true
};

// :: (MarkType) → bool
// Check whether the given mark type is allowed in this node.
NodeType.prototype.allowsMarkType = function allowsMarkType (markType) {
  return this.markSet == null || this.markSet.indexOf(markType) > -1
};

// :: ([Mark]) → bool
// Test whether the given set of marks are allowed in this node.
NodeType.prototype.allowsMarks = function allowsMarks (marks) {
  if (this.markSet == null) { return true }
  for (var i = 0; i < marks.length; i++) { if (!this.allowsMarkType(marks[i].type)) { return false } }
  return true
};

// :: ([Mark]) → [Mark]
// Removes the marks that are not allowed in this node from the given set.
NodeType.prototype.allowedMarks = function allowedMarks (marks) {
  if (this.markSet == null) { return marks }
  var copy;
  for (var i = 0; i < marks.length; i++) {
    if (!this.allowsMarkType(marks[i].type)) {
      if (!copy) { copy = marks.slice(0, i); }
    } else if (copy) {
      copy.push(marks[i]);
    }
  }
  return !copy ? marks : copy.length ? copy : Mark.empty
};

NodeType.compile = function compile (nodes, schema) {
  var result = Object.create(null);
  nodes.forEach(function (name, spec) { return result[name] = new NodeType(name, schema, spec); });

  var topType = schema.spec.topNode || "doc";
  if (!result[topType]) { throw new RangeError("Schema is missing its top node type ('" + topType + "')") }
  if (!result.text) { throw new RangeError("Every schema needs a 'text' type") }
  for (var _ in result.text.attrs) { throw new RangeError("The text node type should not have attributes") }

  return result
};

Object.defineProperties( NodeType.prototype, prototypeAccessors$5 );

// Attribute descriptors

var Attribute = function Attribute(options) {
  this.hasDefault = Object.prototype.hasOwnProperty.call(options, "default");
  this.default = options.default;
};

var prototypeAccessors$1$3 = { isRequired: { configurable: true } };

prototypeAccessors$1$3.isRequired.get = function () {
  return !this.hasDefault
};

Object.defineProperties( Attribute.prototype, prototypeAccessors$1$3 );

// Marks

// ::- Like nodes, marks (which are associated with nodes to signify
// things like emphasis or being part of a link) are
// [tagged](#model.Mark.type) with type objects, which are
// instantiated once per `Schema`.
var MarkType = function MarkType(name, rank, schema, spec) {
  // :: string
  // The name of the mark type.
  this.name = name;

  // :: Schema
  // The schema that this mark type instance is part of.
  this.schema = schema;

  // :: MarkSpec
  // The spec on which the type is based.
  this.spec = spec;

  this.attrs = initAttrs(spec.attrs);

  this.rank = rank;
  this.excluded = null;
  var defaults = defaultAttrs(this.attrs);
  this.instance = defaults && new Mark(this, defaults);
};

// :: (?Object) → Mark
// Create a mark of this type. `attrs` may be `null` or an object
// containing only some of the mark's attributes. The others, if
// they have defaults, will be added.
MarkType.prototype.create = function create (attrs) {
  if (!attrs && this.instance) { return this.instance }
  return new Mark(this, computeAttrs(this.attrs, attrs))
};

MarkType.compile = function compile (marks, schema) {
  var result = Object.create(null), rank = 0;
  marks.forEach(function (name, spec) { return result[name] = new MarkType(name, rank++, schema, spec); });
  return result
};

// :: ([Mark]) → [Mark]
// When there is a mark of this type in the given set, a new set
// without it is returned. Otherwise, the input set is returned.
MarkType.prototype.removeFromSet = function removeFromSet (set) {
  for (var i = 0; i < set.length; i++) { if (set[i].type == this) {
    set = set.slice(0, i).concat(set.slice(i + 1));
    i--;
  } }
  return set
};

// :: ([Mark]) → ?Mark
// Tests whether there is a mark of this type in the given set.
MarkType.prototype.isInSet = function isInSet (set) {
  for (var i = 0; i < set.length; i++)
    { if (set[i].type == this) { return set[i] } }
};

// :: (MarkType) → bool
// Queries whether a given mark type is
// [excluded](#model.MarkSpec.excludes) by this one.
MarkType.prototype.excludes = function excludes (other) {
  return this.excluded.indexOf(other) > -1
};

// SchemaSpec:: interface
// An object describing a schema, as passed to the [`Schema`](#model.Schema)
// constructor.
//
//   nodes:: union<Object<NodeSpec>, OrderedMap<NodeSpec>>
//   The node types in this schema. Maps names to
//   [`NodeSpec`](#model.NodeSpec) objects that describe the node type
//   associated with that name. Their order is significant—it
//   determines which [parse rules](#model.NodeSpec.parseDOM) take
//   precedence by default, and which nodes come first in a given
//   [group](#model.NodeSpec.group).
//
//   marks:: ?union<Object<MarkSpec>, OrderedMap<MarkSpec>>
//   The mark types that exist in this schema. The order in which they
//   are provided determines the order in which [mark
//   sets](#model.Mark.addToSet) are sorted and in which [parse
//   rules](#model.MarkSpec.parseDOM) are tried.
//
//   topNode:: ?string
//   The name of the default top-level node for the schema. Defaults
//   to `"doc"`.

// NodeSpec:: interface
//
//   content:: ?string
//   The content expression for this node, as described in the [schema
//   guide](/docs/guide/#schema.content_expressions). When not given,
//   the node does not allow any content.
//
//   marks:: ?string
//   The marks that are allowed inside of this node. May be a
//   space-separated string referring to mark names or groups, `"_"`
//   to explicitly allow all marks, or `""` to disallow marks. When
//   not given, nodes with inline content default to allowing all
//   marks, other nodes default to not allowing marks.
//
//   group:: ?string
//   The group or space-separated groups to which this node belongs,
//   which can be referred to in the content expressions for the
//   schema.
//
//   inline:: ?bool
//   Should be set to true for inline nodes. (Implied for text nodes.)
//
//   atom:: ?bool
//   Can be set to true to indicate that, though this isn't a [leaf
//   node](#model.NodeType.isLeaf), it doesn't have directly editable
//   content and should be treated as a single unit in the view.
//
//   attrs:: ?Object<AttributeSpec>
//   The attributes that nodes of this type get.
//
//   selectable:: ?bool
//   Controls whether nodes of this type can be selected as a [node
//   selection](#state.NodeSelection). Defaults to true for non-text
//   nodes.
//
//   draggable:: ?bool
//   Determines whether nodes of this type can be dragged without
//   being selected. Defaults to false.
//
//   code:: ?bool
//   Can be used to indicate that this node contains code, which
//   causes some commands to behave differently.
//
//   defining:: ?bool
//   Determines whether this node is considered an important parent
//   node during replace operations (such as paste). Non-defining (the
//   default) nodes get dropped when their entire content is replaced,
//   whereas defining nodes persist and wrap the inserted content.
//   Likewise, in _inserted_ content the defining parents of the
//   content are preserved when possible. Typically,
//   non-default-paragraph textblock types, and possibly list items,
//   are marked as defining.
//
//   isolating:: ?bool
//   When enabled (default is false), the sides of nodes of this type
//   count as boundaries that regular editing operations, like
//   backspacing or lifting, won't cross. An example of a node that
//   should probably have this enabled is a table cell.
//
//   toDOM:: ?(node: Node) → DOMOutputSpec
//   Defines the default way a node of this type should be serialized
//   to DOM/HTML (as used by
//   [`DOMSerializer.fromSchema`](#model.DOMSerializer^fromSchema)).
//   Should return a DOM node or an [array
//   structure](#model.DOMOutputSpec) that describes one, with an
//   optional number zero (“hole”) in it to indicate where the node's
//   content should be inserted.
//
//   For text nodes, the default is to create a text DOM node. Though
//   it is possible to create a serializer where text is rendered
//   differently, this is not supported inside the editor, so you
//   shouldn't override that in your text node spec.
//
//   parseDOM:: ?[ParseRule]
//   Associates DOM parser information with this node, which can be
//   used by [`DOMParser.fromSchema`](#model.DOMParser^fromSchema) to
//   automatically derive a parser. The `node` field in the rules is
//   implied (the name of this node will be filled in automatically).
//   If you supply your own parser, you do not need to also specify
//   parsing rules in your schema.
//
//   toDebugString:: ?(node: Node) -> string
//   Defines the default way a node of this type should be serialized
//   to a string representation for debugging (e.g. in error messages).

// MarkSpec:: interface
//
//   attrs:: ?Object<AttributeSpec>
//   The attributes that marks of this type get.
//
//   inclusive:: ?bool
//   Whether this mark should be active when the cursor is positioned
//   at its end (or at its start when that is also the start of the
//   parent node). Defaults to true.
//
//   excludes:: ?string
//   Determines which other marks this mark can coexist with. Should
//   be a space-separated strings naming other marks or groups of marks.
//   When a mark is [added](#model.Mark.addToSet) to a set, all marks
//   that it excludes are removed in the process. If the set contains
//   any mark that excludes the new mark but is not, itself, excluded
//   by the new mark, the mark can not be added an the set. You can
//   use the value `"_"` to indicate that the mark excludes all
//   marks in the schema.
//
//   Defaults to only being exclusive with marks of the same type. You
//   can set it to an empty string (or any string not containing the
//   mark's own name) to allow multiple marks of a given type to
//   coexist (as long as they have different attributes).
//
//   group:: ?string
//   The group or space-separated groups to which this mark belongs.
//
//   spanning:: ?bool
//   Determines whether marks of this type can span multiple adjacent
//   nodes when serialized to DOM/HTML. Defaults to true.
//
//   toDOM:: ?(mark: Mark, inline: bool) → DOMOutputSpec
//   Defines the default way marks of this type should be serialized
//   to DOM/HTML. When the resulting spec contains a hole, that is
//   where the marked content is placed. Otherwise, it is appended to
//   the top node.
//
//   parseDOM:: ?[ParseRule]
//   Associates DOM parser information with this mark (see the
//   corresponding [node spec field](#model.NodeSpec.parseDOM)). The
//   `mark` field in the rules is implied.

// AttributeSpec:: interface
//
// Used to [define](#model.NodeSpec.attrs) attributes on nodes or
// marks.
//
//   default:: ?any
//   The default value for this attribute, to use when no explicit
//   value is provided. Attributes that have no default must be
//   provided whenever a node or mark of a type that has them is
//   created.

// ::- A document schema. Holds [node](#model.NodeType) and [mark
// type](#model.MarkType) objects for the nodes and marks that may
// occur in conforming documents, and provides functionality for
// creating and deserializing such documents.
var Schema = function Schema(spec) {
  // :: SchemaSpec
  // The [spec](#model.SchemaSpec) on which the schema is based,
  // with the added guarantee that its `nodes` and `marks`
  // properties are
  // [`OrderedMap`](https://github.com/marijnh/orderedmap) instances
  // (not raw objects).
  this.spec = {};
  for (var prop in spec) { this.spec[prop] = spec[prop]; }
  this.spec.nodes = orderedmap__WEBPACK_IMPORTED_MODULE_0__["default"].from(spec.nodes);
  this.spec.marks = orderedmap__WEBPACK_IMPORTED_MODULE_0__["default"].from(spec.marks);

  // :: Object<NodeType>
  // An object mapping the schema's node names to node type objects.
  this.nodes = NodeType.compile(this.spec.nodes, this);

  // :: Object<MarkType>
  // A map from mark names to mark type objects.
  this.marks = MarkType.compile(this.spec.marks, this);

  var contentExprCache = Object.create(null);
  for (var prop$1 in this.nodes) {
    if (prop$1 in this.marks)
      { throw new RangeError(prop$1 + " can not be both a node and a mark") }
    var type = this.nodes[prop$1], contentExpr = type.spec.content || "", markExpr = type.spec.marks;
    type.contentMatch = contentExprCache[contentExpr] ||
      (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));
    type.inlineContent = type.contentMatch.inlineContent;
    type.markSet = markExpr == "_" ? null :
      markExpr ? gatherMarks(this, markExpr.split(" ")) :
      markExpr == "" || !type.inlineContent ? [] : null;
  }
  for (var prop$2 in this.marks) {
    var type$1 = this.marks[prop$2], excl = type$1.spec.excludes;
    type$1.excluded = excl == null ? [type$1] : excl == "" ? [] : gatherMarks(this, excl.split(" "));
  }

  this.nodeFromJSON = this.nodeFromJSON.bind(this);
  this.markFromJSON = this.markFromJSON.bind(this);

  // :: NodeType
  // The type of the [default top node](#model.SchemaSpec.topNode)
  // for this schema.
  this.topNodeType = this.nodes[this.spec.topNode || "doc"];

  // :: Object
  // An object for storing whatever values modules may want to
  // compute and cache per schema. (If you want to store something
  // in it, try to use property names unlikely to clash.)
  this.cached = Object.create(null);
  this.cached.wrappings = Object.create(null);
};

// :: (union<string, NodeType>, ?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node
// Create a node in this schema. The `type` may be a string or a
// `NodeType` instance. Attributes will be extended
// with defaults, `content` may be a `Fragment`,
// `null`, a `Node`, or an array of nodes.
Schema.prototype.node = function node (type, attrs, content, marks) {
  if (typeof type == "string")
    { type = this.nodeType(type); }
  else if (!(type instanceof NodeType))
    { throw new RangeError("Invalid node type: " + type) }
  else if (type.schema != this)
    { throw new RangeError("Node type from different schema used (" + type.name + ")") }

  return type.createChecked(attrs, content, marks)
};

// :: (string, ?[Mark]) → Node
// Create a text node in the schema. Empty text nodes are not
// allowed.
Schema.prototype.text = function text (text$1, marks) {
  var type = this.nodes.text;
  return new TextNode(type, type.defaultAttrs, text$1, Mark.setFrom(marks))
};

// :: (union<string, MarkType>, ?Object) → Mark
// Create a mark with the given type and attributes.
Schema.prototype.mark = function mark (type, attrs) {
  if (typeof type == "string") { type = this.marks[type]; }
  return type.create(attrs)
};

// :: (Object) → Node
// Deserialize a node from its JSON representation. This method is
// bound.
Schema.prototype.nodeFromJSON = function nodeFromJSON (json) {
  return Node.fromJSON(this, json)
};

// :: (Object) → Mark
// Deserialize a mark from its JSON representation. This method is
// bound.
Schema.prototype.markFromJSON = function markFromJSON (json) {
  return Mark.fromJSON(this, json)
};

Schema.prototype.nodeType = function nodeType (name) {
  var found = this.nodes[name];
  if (!found) { throw new RangeError("Unknown node type: " + name) }
  return found
};

function gatherMarks(schema, marks) {
  var found = [];
  for (var i = 0; i < marks.length; i++) {
    var name = marks[i], mark = schema.marks[name], ok = mark;
    if (mark) {
      found.push(mark);
    } else {
      for (var prop in schema.marks) {
        var mark$1 = schema.marks[prop];
        if (name == "_" || (mark$1.spec.group && mark$1.spec.group.split(" ").indexOf(name) > -1))
          { found.push(ok = mark$1); }
      }
    }
    if (!ok) { throw new SyntaxError("Unknown mark type: '" + marks[i] + "'") }
  }
  return found
}

// ParseOptions:: interface
// These are the options recognized by the
// [`parse`](#model.DOMParser.parse) and
// [`parseSlice`](#model.DOMParser.parseSlice) methods.
//
//   preserveWhitespace:: ?union<bool, "full">
//   By default, whitespace is collapsed as per HTML's rules. Pass
//   `true` to preserve whitespace, but normalize newlines to
//   spaces, and `"full"` to preserve whitespace entirely.
//
//   findPositions:: ?[{node: dom.Node, offset: number}]
//   When given, the parser will, beside parsing the content,
//   record the document positions of the given DOM positions. It
//   will do so by writing to the objects, adding a `pos` property
//   that holds the document position. DOM positions that are not
//   in the parsed content will not be written to.
//
//   from:: ?number
//   The child node index to start parsing from.
//
//   to:: ?number
//   The child node index to stop parsing at.
//
//   topNode:: ?Node
//   By default, the content is parsed into the schema's default
//   [top node type](#model.Schema.topNodeType). You can pass this
//   option to use the type and attributes from a different node
//   as the top container.
//
//   topMatch:: ?ContentMatch
//   Provide the starting content match that content parsed into the
//   top node is matched against.
//
//   context:: ?ResolvedPos
//   A set of additional nodes to count as
//   [context](#model.ParseRule.context) when parsing, above the
//   given [top node](#model.ParseOptions.topNode).

// ParseRule:: interface
// A value that describes how to parse a given DOM node or inline
// style as a ProseMirror node or mark.
//
//   tag:: ?string
//   A CSS selector describing the kind of DOM elements to match. A
//   single rule should have _either_ a `tag` or a `style` property.
//
//   namespace:: ?string
//   The namespace to match. This should be used with `tag`.
//   Nodes are only matched when the namespace matches or this property
//   is null.
//
//   style:: ?string
//   A CSS property name to match. When given, this rule matches
//   inline styles that list that property. May also have the form
//   `"property=value"`, in which case the rule only matches if the
//   property's value exactly matches the given value. (For more
//   complicated filters, use [`getAttrs`](#model.ParseRule.getAttrs)
//   and return false to indicate that the match failed.) Rules
//   matching styles may only produce [marks](#model.ParseRule.mark),
//   not nodes.
//
//   priority:: ?number
//   Can be used to change the order in which the parse rules in a
//   schema are tried. Those with higher priority come first. Rules
//   without a priority are counted as having priority 50. This
//   property is only meaningful in a schema—when directly
//   constructing a parser, the order of the rule array is used.
//
//   consuming:: ?boolean
//   By default, when a rule matches an element or style, no further
//   rules get a chance to match it. By setting this to `false`, you
//   indicate that even when this rule matches, other rules that come
//   after it should also run.
//
//   context:: ?string
//   When given, restricts this rule to only match when the current
//   context—the parent nodes into which the content is being
//   parsed—matches this expression. Should contain one or more node
//   names or node group names followed by single or double slashes.
//   For example `"paragraph/"` means the rule only matches when the
//   parent node is a paragraph, `"blockquote/paragraph/"` restricts
//   it to be in a paragraph that is inside a blockquote, and
//   `"section//"` matches any position inside a section—a double
//   slash matches any sequence of ancestor nodes. To allow multiple
//   different contexts, they can be separated by a pipe (`|`)
//   character, as in `"blockquote/|list_item/"`.
//
//   node:: ?string
//   The name of the node type to create when this rule matches. Only
//   valid for rules with a `tag` property, not for style rules. Each
//   rule should have one of a `node`, `mark`, or `ignore` property
//   (except when it appears in a [node](#model.NodeSpec.parseDOM) or
//   [mark spec](#model.MarkSpec.parseDOM), in which case the `node`
//   or `mark` property will be derived from its position).
//
//   mark:: ?string
//   The name of the mark type to wrap the matched content in.
//
//   ignore:: ?bool
//   When true, ignore content that matches this rule.
//
//   closeParent:: ?bool
//   When true, finding an element that matches this rule will close
//   the current node.
//
//   skip:: ?bool
//   When true, ignore the node that matches this rule, but do parse
//   its content.
//
//   attrs:: ?Object
//   Attributes for the node or mark created by this rule. When
//   `getAttrs` is provided, it takes precedence.
//
//   getAttrs:: ?(union<dom.Node, string>) → ?union<Object, false>
//   A function used to compute the attributes for the node or mark
//   created by this rule. Can also be used to describe further
//   conditions the DOM element or style must match. When it returns
//   `false`, the rule won't match. When it returns null or undefined,
//   that is interpreted as an empty/default set of attributes.
//
//   Called with a DOM Element for `tag` rules, and with a string (the
//   style's value) for `style` rules.
//
//   contentElement:: ?union<string, (dom.Node) → dom.Node>
//   For `tag` rules that produce non-leaf nodes or marks, by default
//   the content of the DOM element is parsed as content of the mark
//   or node. If the child nodes are in a descendent node, this may be
//   a CSS selector string that the parser must use to find the actual
//   content element, or a function that returns the actual content
//   element to the parser.
//
//   getContent:: ?(dom.Node, schema: Schema) → Fragment
//   Can be used to override the content of a matched node. When
//   present, instead of parsing the node's child nodes, the result of
//   this function is used.
//
//   preserveWhitespace:: ?union<bool, "full">
//   Controls whether whitespace should be preserved when parsing the
//   content inside the matched element. `false` means whitespace may
//   be collapsed, `true` means that whitespace should be preserved
//   but newlines normalized to spaces, and `"full"` means that
//   newlines should also be preserved.

// ::- A DOM parser represents a strategy for parsing DOM content into
// a ProseMirror document conforming to a given schema. Its behavior
// is defined by an array of [rules](#model.ParseRule).
var DOMParser = function DOMParser(schema, rules) {
  var this$1 = this;

  // :: Schema
  // The schema into which the parser parses.
  this.schema = schema;
  // :: [ParseRule]
  // The set of [parse rules](#model.ParseRule) that the parser
  // uses, in order of precedence.
  this.rules = rules;
  this.tags = [];
  this.styles = [];

  rules.forEach(function (rule) {
    if (rule.tag) { this$1.tags.push(rule); }
    else if (rule.style) { this$1.styles.push(rule); }
  });

  // Only normalize list elements when lists in the schema can't directly contain themselves
  this.normalizeLists = !this.tags.some(function (r) {
    if (!/^(ul|ol)\b/.test(r.tag) || !r.node) { return false }
    var node = schema.nodes[r.node];
    return node.contentMatch.matchType(node)
  });
};

// :: (dom.Node, ?ParseOptions) → Node
// Parse a document from the content of a DOM node.
DOMParser.prototype.parse = function parse (dom, options) {
    if ( options === void 0 ) options = {};

  var context = new ParseContext(this, options, false);
  context.addAll(dom, null, options.from, options.to);
  return context.finish()
};

// :: (dom.Node, ?ParseOptions) → Slice
// Parses the content of the given DOM node, like
// [`parse`](#model.DOMParser.parse), and takes the same set of
// options. But unlike that method, which produces a whole node,
// this one returns a slice that is open at the sides, meaning that
// the schema constraints aren't applied to the start of nodes to
// the left of the input and the end of nodes at the end.
DOMParser.prototype.parseSlice = function parseSlice (dom, options) {
    if ( options === void 0 ) options = {};

  var context = new ParseContext(this, options, true);
  context.addAll(dom, null, options.from, options.to);
  return Slice.maxOpen(context.finish())
};

DOMParser.prototype.matchTag = function matchTag (dom, context, after) {
  for (var i = after ? this.tags.indexOf(after) + 1 : 0; i < this.tags.length; i++) {
    var rule = this.tags[i];
    if (matches(dom, rule.tag) &&
        (rule.namespace === undefined || dom.namespaceURI == rule.namespace) &&
        (!rule.context || context.matchesContext(rule.context))) {
      if (rule.getAttrs) {
        var result = rule.getAttrs(dom);
        if (result === false) { continue }
        rule.attrs = result;
      }
      return rule
    }
  }
};

DOMParser.prototype.matchStyle = function matchStyle (prop, value, context, after) {
  for (var i = after ? this.styles.indexOf(after) + 1 : 0; i < this.styles.length; i++) {
    var rule = this.styles[i];
    if (rule.style.indexOf(prop) != 0 ||
        rule.context && !context.matchesContext(rule.context) ||
        // Test that the style string either precisely matches the prop,
        // or has an '=' sign after the prop, followed by the given
        // value.
        rule.style.length > prop.length &&
        (rule.style.charCodeAt(prop.length) != 61 || rule.style.slice(prop.length + 1) != value))
      { continue }
    if (rule.getAttrs) {
      var result = rule.getAttrs(value);
      if (result === false) { continue }
      rule.attrs = result;
    }
    return rule
  }
};

// : (Schema) → [ParseRule]
DOMParser.schemaRules = function schemaRules (schema) {
  var result = [];
  function insert(rule) {
    var priority = rule.priority == null ? 50 : rule.priority, i = 0;
    for (; i < result.length; i++) {
      var next = result[i], nextPriority = next.priority == null ? 50 : next.priority;
      if (nextPriority < priority) { break }
    }
    result.splice(i, 0, rule);
  }

  var loop = function ( name ) {
    var rules = schema.marks[name].spec.parseDOM;
    if (rules) { rules.forEach(function (rule) {
      insert(rule = copy(rule));
      rule.mark = name;
    }); }
  };

    for (var name in schema.marks) loop( name );
  var loop$1 = function ( name ) {
    var rules$1 = schema.nodes[name$1].spec.parseDOM;
    if (rules$1) { rules$1.forEach(function (rule) {
      insert(rule = copy(rule));
      rule.node = name$1;
    }); }
  };

    for (var name$1 in schema.nodes) loop$1();
  return result
};

// :: (Schema) → DOMParser
// Construct a DOM parser using the parsing rules listed in a
// schema's [node specs](#model.NodeSpec.parseDOM), reordered by
// [priority](#model.ParseRule.priority).
DOMParser.fromSchema = function fromSchema (schema) {
  return schema.cached.domParser ||
    (schema.cached.domParser = new DOMParser(schema, DOMParser.schemaRules(schema)))
};

// : Object<bool> The block-level tags in HTML5
var blockTags = {
  address: true, article: true, aside: true, blockquote: true, canvas: true,
  dd: true, div: true, dl: true, fieldset: true, figcaption: true, figure: true,
  footer: true, form: true, h1: true, h2: true, h3: true, h4: true, h5: true,
  h6: true, header: true, hgroup: true, hr: true, li: true, noscript: true, ol: true,
  output: true, p: true, pre: true, section: true, table: true, tfoot: true, ul: true
};

// : Object<bool> The tags that we normally ignore.
var ignoreTags = {
  head: true, noscript: true, object: true, script: true, style: true, title: true
};

// : Object<bool> List tags.
var listTags = {ol: true, ul: true};

// Using a bitfield for node context options
var OPT_PRESERVE_WS = 1, OPT_PRESERVE_WS_FULL = 2, OPT_OPEN_LEFT = 4;

function wsOptionsFor(preserveWhitespace) {
  return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL : 0)
}

var NodeContext = function NodeContext(type, attrs, marks, pendingMarks, solid, match, options) {
  this.type = type;
  this.attrs = attrs;
  this.solid = solid;
  this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch);
  this.options = options;
  this.content = [];
  // Marks applied to this node itself
  this.marks = marks;
  // Marks applied to its children
  this.activeMarks = Mark.none;
  // Marks that can't apply here, but will be used in children if possible
  this.pendingMarks = pendingMarks;
  // Nested Marks with same type
  this.stashMarks = [];
};

NodeContext.prototype.findWrapping = function findWrapping (node) {
  if (!this.match) {
    if (!this.type) { return [] }
    var fill = this.type.contentMatch.fillBefore(Fragment.from(node));
    if (fill) {
      this.match = this.type.contentMatch.matchFragment(fill);
    } else {
      var start = this.type.contentMatch, wrap;
      if (wrap = start.findWrapping(node.type)) {
        this.match = start;
        return wrap
      } else {
        return null
      }
    }
  }
  return this.match.findWrapping(node.type)
};

NodeContext.prototype.finish = function finish (openEnd) {
  if (!(this.options & OPT_PRESERVE_WS)) { // Strip trailing whitespace
    var last = this.content[this.content.length - 1], m;
    if (last && last.isText && (m = /[ \t\r\n\u000c]+$/.exec(last.text))) {
      if (last.text.length == m[0].length) { this.content.pop(); }
      else { this.content[this.content.length - 1] = last.withText(last.text.slice(0, last.text.length - m[0].length)); }
    }
  }
  var content = Fragment.from(this.content);
  if (!openEnd && this.match)
    { content = content.append(this.match.fillBefore(Fragment.empty, true)); }
  return this.type ? this.type.create(this.attrs, content, this.marks) : content
};

NodeContext.prototype.popFromStashMark = function popFromStashMark (mark) {
  for (var i = this.stashMarks.length - 1; i >= 0; i--)
    { if (mark.eq(this.stashMarks[i])) { return this.stashMarks.splice(i, 1)[0] } }
};

NodeContext.prototype.applyPending = function applyPending (nextType) {
  for (var i = 0, pending = this.pendingMarks; i < pending.length; i++) {
    var mark = pending[i];
    if ((this.type ? this.type.allowsMarkType(mark.type) : markMayApply(mark.type, nextType)) &&
        !mark.isInSet(this.activeMarks)) {
      this.activeMarks = mark.addToSet(this.activeMarks);
      this.pendingMarks = mark.removeFromSet(this.pendingMarks);
    }
  }
};

NodeContext.prototype.inlineContext = function inlineContext (node) {
  if (this.type) { return this.type.inlineContent }
  if (this.content.length) { return this.content[0].isInline }
  return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase())
};

var ParseContext = function ParseContext(parser, options, open) {
  // : DOMParser The parser we are using.
  this.parser = parser;
  // : Object The options passed to this parse.
  this.options = options;
  this.isOpen = open;
  var topNode = options.topNode, topContext;
  var topOptions = wsOptionsFor(options.preserveWhitespace) | (open ? OPT_OPEN_LEFT : 0);
  if (topNode)
    { topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, Mark.none, true,
                                 options.topMatch || topNode.type.contentMatch, topOptions); }
  else if (open)
    { topContext = new NodeContext(null, null, Mark.none, Mark.none, true, null, topOptions); }
  else
    { topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, Mark.none, true, null, topOptions); }
  this.nodes = [topContext];
  // : [Mark] The current set of marks
  this.open = 0;
  this.find = options.findPositions;
  this.needsBlock = false;
};

var prototypeAccessors$6 = { top: { configurable: true },currentPos: { configurable: true } };

prototypeAccessors$6.top.get = function () {
  return this.nodes[this.open]
};

// : (dom.Node)
// Add a DOM node to the content. Text is inserted as text node,
// otherwise, the node is passed to `addElement` or, if it has a
// `style` attribute, `addElementWithStyles`.
ParseContext.prototype.addDOM = function addDOM (dom) {
  if (dom.nodeType == 3) {
    this.addTextNode(dom);
  } else if (dom.nodeType == 1) {
    var style = dom.getAttribute("style");
    var marks = style ? this.readStyles(parseStyles(style)) : null, top = this.top;
    if (marks != null) { for (var i = 0; i < marks.length; i++) { this.addPendingMark(marks[i]); } }
    this.addElement(dom);
    if (marks != null) { for (var i$1 = 0; i$1 < marks.length; i$1++) { this.removePendingMark(marks[i$1], top); } }
  }
};

ParseContext.prototype.addTextNode = function addTextNode (dom) {
  var value = dom.nodeValue;
  var top = this.top;
  if (top.options & OPT_PRESERVE_WS_FULL ||
      top.inlineContext(dom) ||
      /[^ \t\r\n\u000c]/.test(value)) {
    if (!(top.options & OPT_PRESERVE_WS)) {
      value = value.replace(/[ \t\r\n\u000c]+/g, " ");
      // If this starts with whitespace, and there is no node before it, or
      // a hard break, or a text node that ends with whitespace, strip the
      // leading space.
      if (/^[ \t\r\n\u000c]/.test(value) && this.open == this.nodes.length - 1) {
        var nodeBefore = top.content[top.content.length - 1];
        var domNodeBefore = dom.previousSibling;
        if (!nodeBefore ||
            (domNodeBefore && domNodeBefore.nodeName == 'BR') ||
            (nodeBefore.isText && /[ \t\r\n\u000c]$/.test(nodeBefore.text)))
          { value = value.slice(1); }
      }
    } else if (!(top.options & OPT_PRESERVE_WS_FULL)) {
      value = value.replace(/\r?\n|\r/g, " ");
    } else {
      value = value.replace(/\r\n?/g, "\n");
    }
    if (value) { this.insertNode(this.parser.schema.text(value)); }
    this.findInText(dom);
  } else {
    this.findInside(dom);
  }
};

// : (dom.Element, ?ParseRule)
// Try to find a handler for the given tag and use that to parse. If
// none is found, the element's content nodes are added directly.
ParseContext.prototype.addElement = function addElement (dom, matchAfter) {
  var name = dom.nodeName.toLowerCase(), ruleID;
  if (listTags.hasOwnProperty(name) && this.parser.normalizeLists) { normalizeList(dom); }
  var rule = (this.options.ruleFromNode && this.options.ruleFromNode(dom)) ||
      (ruleID = this.parser.matchTag(dom, this, matchAfter));
  if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {
    this.findInside(dom);
    this.ignoreFallback(dom);
  } else if (!rule || rule.skip || rule.closeParent) {
    if (rule && rule.closeParent) { this.open = Math.max(0, this.open - 1); }
    else if (rule && rule.skip.nodeType) { dom = rule.skip; }
    var sync, top = this.top, oldNeedsBlock = this.needsBlock;
    if (blockTags.hasOwnProperty(name)) {
      sync = true;
      if (!top.type) { this.needsBlock = true; }
    } else if (!dom.firstChild) {
      this.leafFallback(dom);
      return
    }
    this.addAll(dom);
    if (sync) { this.sync(top); }
    this.needsBlock = oldNeedsBlock;
  } else {
    this.addElementByRule(dom, rule, rule.consuming === false ? ruleID : null);
  }
};

// Called for leaf DOM nodes that would otherwise be ignored
ParseContext.prototype.leafFallback = function leafFallback (dom) {
  if (dom.nodeName == "BR" && this.top.type && this.top.type.inlineContent)
    { this.addTextNode(dom.ownerDocument.createTextNode("\n")); }
};

// Called for ignored nodes
ParseContext.prototype.ignoreFallback = function ignoreFallback (dom) {
  // Ignored BR nodes should at least create an inline context
  if (dom.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent))
    { this.findPlace(this.parser.schema.text("-")); }
};

// Run any style parser associated with the node's styles. Either
// return an array of marks, or null to indicate some of the styles
// had a rule with `ignore` set.
ParseContext.prototype.readStyles = function readStyles (styles) {
  var marks = Mark.none;
  style: for (var i = 0; i < styles.length; i += 2) {
    for (var after = null;;) {
      var rule = this.parser.matchStyle(styles[i], styles[i + 1], this, after);
      if (!rule) { continue style }
      if (rule.ignore) { return null }
      marks = this.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(marks);
      if (rule.consuming === false) { after = rule; }
      else { break }
    }
  }
  return marks
};

// : (dom.Element, ParseRule) → bool
// Look up a handler for the given node. If none are found, return
// false. Otherwise, apply it, use its return value to drive the way
// the node's content is wrapped, and return true.
ParseContext.prototype.addElementByRule = function addElementByRule (dom, rule, continueAfter) {
    var this$1 = this;

  var sync, nodeType, markType, mark;
  if (rule.node) {
    nodeType = this.parser.schema.nodes[rule.node];
    if (!nodeType.isLeaf) {
      sync = this.enter(nodeType, rule.attrs, rule.preserveWhitespace);
    } else if (!this.insertNode(nodeType.create(rule.attrs))) {
      this.leafFallback(dom);
    }
  } else {
    markType = this.parser.schema.marks[rule.mark];
    mark = markType.create(rule.attrs);
    this.addPendingMark(mark);
  }
  var startIn = this.top;

  if (nodeType && nodeType.isLeaf) {
    this.findInside(dom);
  } else if (continueAfter) {
    this.addElement(dom, continueAfter);
  } else if (rule.getContent) {
    this.findInside(dom);
    rule.getContent(dom, this.parser.schema).forEach(function (node) { return this$1.insertNode(node); });
  } else {
    var contentDOM = rule.contentElement;
    if (typeof contentDOM == "string") { contentDOM = dom.querySelector(contentDOM); }
    else if (typeof contentDOM == "function") { contentDOM = contentDOM(dom); }
    if (!contentDOM) { contentDOM = dom; }
    this.findAround(dom, contentDOM, true);
    this.addAll(contentDOM, sync);
  }
  if (sync) { this.sync(startIn); this.open--; }
  if (mark) { this.removePendingMark(mark, startIn); }
};

// : (dom.Node, ?NodeBuilder, ?number, ?number)
// Add all child nodes between `startIndex` and `endIndex` (or the
// whole node, if not given). If `sync` is passed, use it to
// synchronize after every block element.
ParseContext.prototype.addAll = function addAll (parent, sync, startIndex, endIndex) {
  var index = startIndex || 0;
  for (var dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild,
           end = endIndex == null ? null : parent.childNodes[endIndex];
       dom != end; dom = dom.nextSibling, ++index) {
    this.findAtPoint(parent, index);
    this.addDOM(dom);
    if (sync && blockTags.hasOwnProperty(dom.nodeName.toLowerCase()))
      { this.sync(sync); }
  }
  this.findAtPoint(parent, index);
};

// Try to find a way to fit the given node type into the current
// context. May add intermediate wrappers and/or leave non-solid
// nodes that we're in.
ParseContext.prototype.findPlace = function findPlace (node) {
  var route, sync;
  for (var depth = this.open; depth >= 0; depth--) {
    var cx = this.nodes[depth];
    var found = cx.findWrapping(node);
    if (found && (!route || route.length > found.length)) {
      route = found;
      sync = cx;
      if (!found.length) { break }
    }
    if (cx.solid) { break }
  }
  if (!route) { return false }
  this.sync(sync);
  for (var i = 0; i < route.length; i++)
    { this.enterInner(route[i], null, false); }
  return true
};

// : (Node) → ?Node
// Try to insert the given node, adjusting the context when needed.
ParseContext.prototype.insertNode = function insertNode (node) {
  if (node.isInline && this.needsBlock && !this.top.type) {
    var block = this.textblockFromContext();
    if (block) { this.enterInner(block); }
  }
  if (this.findPlace(node)) {
    this.closeExtra();
    var top = this.top;
    top.applyPending(node.type);
    if (top.match) { top.match = top.match.matchType(node.type); }
    var marks = top.activeMarks;
    for (var i = 0; i < node.marks.length; i++)
      { if (!top.type || top.type.allowsMarkType(node.marks[i].type))
        { marks = node.marks[i].addToSet(marks); } }
    top.content.push(node.mark(marks));
    return true
  }
  return false
};

// : (NodeType, ?Object) → bool
// Try to start a node of the given type, adjusting the context when
// necessary.
ParseContext.prototype.enter = function enter (type, attrs, preserveWS) {
  var ok = this.findPlace(type.create(attrs));
  if (ok) { this.enterInner(type, attrs, true, preserveWS); }
  return ok
};

// Open a node of the given type
ParseContext.prototype.enterInner = function enterInner (type, attrs, solid, preserveWS) {
  this.closeExtra();
  var top = this.top;
  top.applyPending(type);
  top.match = top.match && top.match.matchType(type, attrs);
  var options = preserveWS == null ? top.options & ~OPT_OPEN_LEFT : wsOptionsFor(preserveWS);
  if ((top.options & OPT_OPEN_LEFT) && top.content.length == 0) { options |= OPT_OPEN_LEFT; }
  this.nodes.push(new NodeContext(type, attrs, top.activeMarks, top.pendingMarks, solid, null, options));
  this.open++;
};

// Make sure all nodes above this.open are finished and added to
// their parents
ParseContext.prototype.closeExtra = function closeExtra (openEnd) {
  var i = this.nodes.length - 1;
  if (i > this.open) {
    for (; i > this.open; i--) { this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd)); }
    this.nodes.length = this.open + 1;
  }
};

ParseContext.prototype.finish = function finish () {
  this.open = 0;
  this.closeExtra(this.isOpen);
  return this.nodes[0].finish(this.isOpen || this.options.topOpen)
};

ParseContext.prototype.sync = function sync (to) {
  for (var i = this.open; i >= 0; i--) { if (this.nodes[i] == to) {
    this.open = i;
    return
  } }
};

prototypeAccessors$6.currentPos.get = function () {
  this.closeExtra();
  var pos = 0;
  for (var i = this.open; i >= 0; i--) {
    var content = this.nodes[i].content;
    for (var j = content.length - 1; j >= 0; j--)
      { pos += content[j].nodeSize; }
    if (i) { pos++; }
  }
  return pos
};

ParseContext.prototype.findAtPoint = function findAtPoint (parent, offset) {
  if (this.find) { for (var i = 0; i < this.find.length; i++) {
    if (this.find[i].node == parent && this.find[i].offset == offset)
      { this.find[i].pos = this.currentPos; }
  } }
};

ParseContext.prototype.findInside = function findInside (parent) {
  if (this.find) { for (var i = 0; i < this.find.length; i++) {
    if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node))
      { this.find[i].pos = this.currentPos; }
  } }
};

ParseContext.prototype.findAround = function findAround (parent, content, before) {
  if (parent != content && this.find) { for (var i = 0; i < this.find.length; i++) {
    if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {
      var pos = content.compareDocumentPosition(this.find[i].node);
      if (pos & (before ? 2 : 4))
        { this.find[i].pos = this.currentPos; }
    }
  } }
};

ParseContext.prototype.findInText = function findInText (textNode) {
  if (this.find) { for (var i = 0; i < this.find.length; i++) {
    if (this.find[i].node == textNode)
      { this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset); }
  } }
};

// : (string) → bool
// Determines whether the given [context
// string](#ParseRule.context) matches this context.
ParseContext.prototype.matchesContext = function matchesContext (context) {
    var this$1 = this;

  if (context.indexOf("|") > -1)
    { return context.split(/\s*\|\s*/).some(this.matchesContext, this) }

  var parts = context.split("/");
  var option = this.options.context;
  var useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);
  var minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);
  var match = function (i, depth) {
    for (; i >= 0; i--) {
      var part = parts[i];
      if (part == "") {
        if (i == parts.length - 1 || i == 0) { continue }
        for (; depth >= minDepth; depth--)
          { if (match(i - 1, depth)) { return true } }
        return false
      } else {
        var next = depth > 0 || (depth == 0 && useRoot) ? this$1.nodes[depth].type
            : option && depth >= minDepth ? option.node(depth - minDepth).type
            : null;
        if (!next || (next.name != part && next.groups.indexOf(part) == -1))
          { return false }
        depth--;
      }
    }
    return true
  };
  return match(parts.length - 1, this.open)
};

ParseContext.prototype.textblockFromContext = function textblockFromContext () {
  var $context = this.options.context;
  if ($context) { for (var d = $context.depth; d >= 0; d--) {
    var deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;
    if (deflt && deflt.isTextblock && deflt.defaultAttrs) { return deflt }
  } }
  for (var name in this.parser.schema.nodes) {
    var type = this.parser.schema.nodes[name];
    if (type.isTextblock && type.defaultAttrs) { return type }
  }
};

ParseContext.prototype.addPendingMark = function addPendingMark (mark) {
  var found = findSameMarkInSet(mark, this.top.pendingMarks);
  if (found) { this.top.stashMarks.push(found); }
  this.top.pendingMarks = mark.addToSet(this.top.pendingMarks);
};

ParseContext.prototype.removePendingMark = function removePendingMark (mark, upto) {
  for (var depth = this.open; depth >= 0; depth--) {
    var level = this.nodes[depth];
    var found = level.pendingMarks.lastIndexOf(mark);
    if (found > -1) {
      level.pendingMarks = mark.removeFromSet(level.pendingMarks);
    } else {
      level.activeMarks = mark.removeFromSet(level.activeMarks);
      var stashMark = level.popFromStashMark(mark);
      if (stashMark && level.type && level.type.allowsMarkType(stashMark.type))
        { level.activeMarks = stashMark.addToSet(level.activeMarks); }
    }
    if (level == upto) { break }
  }
};

Object.defineProperties( ParseContext.prototype, prototypeAccessors$6 );

// Kludge to work around directly nested list nodes produced by some
// tools and allowed by browsers to mean that the nested list is
// actually part of the list item above it.
function normalizeList(dom) {
  for (var child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {
    var name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;
    if (name && listTags.hasOwnProperty(name) && prevItem) {
      prevItem.appendChild(child);
      child = prevItem;
    } else if (name == "li") {
      prevItem = child;
    } else if (name) {
      prevItem = null;
    }
  }
}

// Apply a CSS selector.
function matches(dom, selector) {
  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector)
}

// : (string) → [string]
// Tokenize a style attribute into property/value pairs.
function parseStyles(style) {
  var re = /\s*([\w-]+)\s*:\s*([^;]+)/g, m, result = [];
  while (m = re.exec(style)) { result.push(m[1], m[2].trim()); }
  return result
}

function copy(obj) {
  var copy = {};
  for (var prop in obj) { copy[prop] = obj[prop]; }
  return copy
}

// Used when finding a mark at the top level of a fragment parse.
// Checks whether it would be reasonable to apply a given mark type to
// a given node, by looking at the way the mark occurs in the schema.
function markMayApply(markType, nodeType) {
  var nodes = nodeType.schema.nodes;
  var loop = function ( name ) {
    var parent = nodes[name];
    if (!parent.allowsMarkType(markType)) { return }
    var seen = [], scan = function (match) {
      seen.push(match);
      for (var i = 0; i < match.edgeCount; i++) {
        var ref = match.edge(i);
        var type = ref.type;
        var next = ref.next;
        if (type == nodeType) { return true }
        if (seen.indexOf(next) < 0 && scan(next)) { return true }
      }
    };
    if (scan(parent.contentMatch)) { return { v: true } }
  };

  for (var name in nodes) {
    var returned = loop( name );

    if ( returned ) return returned.v;
  }
}

function findSameMarkInSet(mark, set) {
  for (var i = 0; i < set.length; i++) {
    if (mark.eq(set[i])) { return set[i] }
  }
}

// DOMOutputSpec:: interface
// A description of a DOM structure. Can be either a string, which is
// interpreted as a text node, a DOM node, which is interpreted as
// itself, a `{dom: Node, contentDOM: ?Node}` object, or an array.
//
// An array describes a DOM element. The first value in the array
// should be a string—the name of the DOM element, optionally prefixed
// by a namespace URL and a space. If the second element is plain
// object, it is interpreted as a set of attributes for the element.
// Any elements after that (including the 2nd if it's not an attribute
// object) are interpreted as children of the DOM elements, and must
// either be valid `DOMOutputSpec` values, or the number zero.
//
// The number zero (pronounced “hole”) is used to indicate the place
// where a node's child nodes should be inserted. If it occurs in an
// output spec, it should be the only child element in its parent
// node.

// ::- A DOM serializer knows how to convert ProseMirror nodes and
// marks of various types to DOM nodes.
var DOMSerializer = function DOMSerializer(nodes, marks) {
  // :: Object<(node: Node) → DOMOutputSpec>
  // The node serialization functions.
  this.nodes = nodes || {};
  // :: Object<?(mark: Mark, inline: bool) → DOMOutputSpec>
  // The mark serialization functions.
  this.marks = marks || {};
};

// :: (Fragment, ?Object) → dom.DocumentFragment
// Serialize the content of this fragment to a DOM fragment. When
// not in the browser, the `document` option, containing a DOM
// document, should be passed so that the serializer can create
// nodes.
DOMSerializer.prototype.serializeFragment = function serializeFragment (fragment, options, target) {
    var this$1 = this;
    if ( options === void 0 ) options = {};

  if (!target) { target = doc(options).createDocumentFragment(); }

  var top = target, active = null;
  fragment.forEach(function (node) {
    if (active || node.marks.length) {
      if (!active) { active = []; }
      var keep = 0, rendered = 0;
      while (keep < active.length && rendered < node.marks.length) {
        var next = node.marks[rendered];
        if (!this$1.marks[next.type.name]) { rendered++; continue }
        if (!next.eq(active[keep]) || next.type.spec.spanning === false) { break }
        keep += 2; rendered++;
      }
      while (keep < active.length) {
        top = active.pop();
        active.pop();
      }
      while (rendered < node.marks.length) {
        var add = node.marks[rendered++];
        var markDOM = this$1.serializeMark(add, node.isInline, options);
        if (markDOM) {
          active.push(add, top);
          top.appendChild(markDOM.dom);
          top = markDOM.contentDOM || markDOM.dom;
        }
      }
    }
    top.appendChild(this$1.serializeNodeInner(node, options));
  });

  return target
};

DOMSerializer.prototype.serializeNodeInner = function serializeNodeInner (node, options) {
    if ( options === void 0 ) options = {};

  var ref =
      DOMSerializer.renderSpec(doc(options), this.nodes[node.type.name](node));
    var dom = ref.dom;
    var contentDOM = ref.contentDOM;
  if (contentDOM) {
    if (node.isLeaf)
      { throw new RangeError("Content hole not allowed in a leaf node spec") }
    if (options.onContent)
      { options.onContent(node, contentDOM, options); }
    else
      { this.serializeFragment(node.content, options, contentDOM); }
  }
  return dom
};

// :: (Node, ?Object) → dom.Node
// Serialize this node to a DOM node. This can be useful when you
// need to serialize a part of a document, as opposed to the whole
// document. To serialize a whole document, use
// [`serializeFragment`](#model.DOMSerializer.serializeFragment) on
// its [content](#model.Node.content).
DOMSerializer.prototype.serializeNode = function serializeNode (node, options) {
    if ( options === void 0 ) options = {};

  var dom = this.serializeNodeInner(node, options);
  for (var i = node.marks.length - 1; i >= 0; i--) {
    var wrap = this.serializeMark(node.marks[i], node.isInline, options);
    if (wrap) {
(wrap.contentDOM || wrap.dom).appendChild(dom);
      dom = wrap.dom;
    }
  }
  return dom
};

DOMSerializer.prototype.serializeMark = function serializeMark (mark, inline, options) {
    if ( options === void 0 ) options = {};

  var toDOM = this.marks[mark.type.name];
  return toDOM && DOMSerializer.renderSpec(doc(options), toDOM(mark, inline))
};

// :: (dom.Document, DOMOutputSpec) → {dom: dom.Node, contentDOM: ?dom.Node}
// Render an [output spec](#model.DOMOutputSpec) to a DOM node. If
// the spec has a hole (zero) in it, `contentDOM` will point at the
// node with the hole.
DOMSerializer.renderSpec = function renderSpec (doc, structure, xmlNS) {
    if ( xmlNS === void 0 ) xmlNS = null;

  if (typeof structure == "string")
    { return {dom: doc.createTextNode(structure)} }
  if (structure.nodeType != null)
    { return {dom: structure} }
  if (structure.dom && structure.dom.nodeType != null)
    { return structure }
  var tagName = structure[0], space = tagName.indexOf(" ");
  if (space > 0) {
    xmlNS = tagName.slice(0, space);
    tagName = tagName.slice(space + 1);
  }
  var contentDOM = null, dom = xmlNS ? doc.createElementNS(xmlNS, tagName) : doc.createElement(tagName);
  var attrs = structure[1], start = 1;
  if (attrs && typeof attrs == "object" && attrs.nodeType == null && !Array.isArray(attrs)) {
    start = 2;
    for (var name in attrs) { if (attrs[name] != null) {
      var space$1 = name.indexOf(" ");
      if (space$1 > 0) { dom.setAttributeNS(name.slice(0, space$1), name.slice(space$1 + 1), attrs[name]); }
      else { dom.setAttribute(name, attrs[name]); }
    } }
  }
  for (var i = start; i < structure.length; i++) {
    var child = structure[i];
    if (child === 0) {
      if (i < structure.length - 1 || i > start)
        { throw new RangeError("Content hole must be the only child of its parent node") }
      return {dom: dom, contentDOM: dom}
    } else {
      var ref = DOMSerializer.renderSpec(doc, child, xmlNS);
        var inner = ref.dom;
        var innerContent = ref.contentDOM;
      dom.appendChild(inner);
      if (innerContent) {
        if (contentDOM) { throw new RangeError("Multiple content holes") }
        contentDOM = innerContent;
      }
    }
  }
  return {dom: dom, contentDOM: contentDOM}
};

// :: (Schema) → DOMSerializer
// Build a serializer using the [`toDOM`](#model.NodeSpec.toDOM)
// properties in a schema's node and mark specs.
DOMSerializer.fromSchema = function fromSchema (schema) {
  return schema.cached.domSerializer ||
    (schema.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)))
};

// : (Schema) → Object<(node: Node) → DOMOutputSpec>
// Gather the serializers in a schema's node specs into an object.
// This can be useful as a base to build a custom serializer from.
DOMSerializer.nodesFromSchema = function nodesFromSchema (schema) {
  var result = gatherToDOM(schema.nodes);
  if (!result.text) { result.text = function (node) { return node.text; }; }
  return result
};

// : (Schema) → Object<(mark: Mark) → DOMOutputSpec>
// Gather the serializers in a schema's mark specs into an object.
DOMSerializer.marksFromSchema = function marksFromSchema (schema) {
  return gatherToDOM(schema.marks)
};

function gatherToDOM(obj) {
  var result = {};
  for (var name in obj) {
    var toDOM = obj[name].spec.toDOM;
    if (toDOM) { result[name] = toDOM; }
  }
  return result
}

function doc(options) {
  // declare global: window
  return options.document || window.document
}


//# sourceMappingURL=index.es.js.map


/***/ }),

/***/ "./node_modules/prosemirror-schema-basic/dist/index.es.js":
/*!****************************************************************!*\
  !*** ./node_modules/prosemirror-schema-basic/dist/index.es.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "marks": () => (/* binding */ marks),
/* harmony export */   "nodes": () => (/* binding */ nodes),
/* harmony export */   "schema": () => (/* binding */ schema)
/* harmony export */ });
/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-model */ "./node_modules/prosemirror-model/dist/index.es.js");


var pDOM = ["p", 0], blockquoteDOM = ["blockquote", 0], hrDOM = ["hr"],
      preDOM = ["pre", ["code", 0]], brDOM = ["br"];

// :: Object
// [Specs](#model.NodeSpec) for the nodes defined in this schema.
var nodes = {
  // :: NodeSpec The top level document node.
  doc: {
    content: "block+"
  },

  // :: NodeSpec A plain paragraph textblock. Represented in the DOM
  // as a `<p>` element.
  paragraph: {
    content: "inline*",
    group: "block",
    parseDOM: [{tag: "p"}],
    toDOM: function toDOM() { return pDOM }
  },

  // :: NodeSpec A blockquote (`<blockquote>`) wrapping one or more blocks.
  blockquote: {
    content: "block+",
    group: "block",
    defining: true,
    parseDOM: [{tag: "blockquote"}],
    toDOM: function toDOM() { return blockquoteDOM }
  },

  // :: NodeSpec A horizontal rule (`<hr>`).
  horizontal_rule: {
    group: "block",
    parseDOM: [{tag: "hr"}],
    toDOM: function toDOM() { return hrDOM }
  },

  // :: NodeSpec A heading textblock, with a `level` attribute that
  // should hold the number 1 to 6. Parsed and serialized as `<h1>` to
  // `<h6>` elements.
  heading: {
    attrs: {level: {default: 1}},
    content: "inline*",
    group: "block",
    defining: true,
    parseDOM: [{tag: "h1", attrs: {level: 1}},
               {tag: "h2", attrs: {level: 2}},
               {tag: "h3", attrs: {level: 3}},
               {tag: "h4", attrs: {level: 4}},
               {tag: "h5", attrs: {level: 5}},
               {tag: "h6", attrs: {level: 6}}],
    toDOM: function toDOM(node) { return ["h" + node.attrs.level, 0] }
  },

  // :: NodeSpec A code listing. Disallows marks or non-text inline
  // nodes by default. Represented as a `<pre>` element with a
  // `<code>` element inside of it.
  code_block: {
    content: "text*",
    marks: "",
    group: "block",
    code: true,
    defining: true,
    parseDOM: [{tag: "pre", preserveWhitespace: "full"}],
    toDOM: function toDOM() { return preDOM }
  },

  // :: NodeSpec The text node.
  text: {
    group: "inline"
  },

  // :: NodeSpec An inline image (`<img>`) node. Supports `src`,
  // `alt`, and `href` attributes. The latter two default to the empty
  // string.
  image: {
    inline: true,
    attrs: {
      src: {},
      alt: {default: null},
      title: {default: null}
    },
    group: "inline",
    draggable: true,
    parseDOM: [{tag: "img[src]", getAttrs: function getAttrs(dom) {
      return {
        src: dom.getAttribute("src"),
        title: dom.getAttribute("title"),
        alt: dom.getAttribute("alt")
      }
    }}],
    toDOM: function toDOM(node) { var ref = node.attrs;
    var src = ref.src;
    var alt = ref.alt;
    var title = ref.title; return ["img", {src: src, alt: alt, title: title}] }
  },

  // :: NodeSpec A hard line break, represented in the DOM as `<br>`.
  hard_break: {
    inline: true,
    group: "inline",
    selectable: false,
    parseDOM: [{tag: "br"}],
    toDOM: function toDOM() { return brDOM }
  }
};

var emDOM = ["em", 0], strongDOM = ["strong", 0], codeDOM = ["code", 0];

// :: Object [Specs](#model.MarkSpec) for the marks in the schema.
var marks = {
  // :: MarkSpec A link. Has `href` and `title` attributes. `title`
  // defaults to the empty string. Rendered and parsed as an `<a>`
  // element.
  link: {
    attrs: {
      href: {},
      title: {default: null}
    },
    inclusive: false,
    parseDOM: [{tag: "a[href]", getAttrs: function getAttrs(dom) {
      return {href: dom.getAttribute("href"), title: dom.getAttribute("title")}
    }}],
    toDOM: function toDOM(node) { var ref = node.attrs;
    var href = ref.href;
    var title = ref.title; return ["a", {href: href, title: title}, 0] }
  },

  // :: MarkSpec An emphasis mark. Rendered as an `<em>` element.
  // Has parse rules that also match `<i>` and `font-style: italic`.
  em: {
    parseDOM: [{tag: "i"}, {tag: "em"}, {style: "font-style=italic"}],
    toDOM: function toDOM() { return emDOM }
  },

  // :: MarkSpec A strong mark. Rendered as `<strong>`, parse rules
  // also match `<b>` and `font-weight: bold`.
  strong: {
    parseDOM: [{tag: "strong"},
               // This works around a Google Docs misbehavior where
               // pasted content will be inexplicably wrapped in `<b>`
               // tags with a font-weight normal.
               {tag: "b", getAttrs: function (node) { return node.style.fontWeight != "normal" && null; }},
               {style: "font-weight", getAttrs: function (value) { return /^(bold(er)?|[5-9]\d{2,})$/.test(value) && null; }}],
    toDOM: function toDOM() { return strongDOM }
  },

  // :: MarkSpec Code font mark. Represented as a `<code>` element.
  code: {
    parseDOM: [{tag: "code"}],
    toDOM: function toDOM() { return codeDOM }
  }
};

// :: Schema
// This schema roughly corresponds to the document schema used by
// [CommonMark](http://commonmark.org/), minus the list elements,
// which are defined in the [`prosemirror-schema-list`](#schema-list)
// module.
//
// To reuse elements from this schema, extend or read from its
// `spec.nodes` and `spec.marks` [properties](#model.Schema.spec).
var schema = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Schema({nodes: nodes, marks: marks});


//# sourceMappingURL=index.es.js.map


/***/ }),

/***/ "./node_modules/prosemirror-schema-list/dist/index.es.js":
/*!***************************************************************!*\
  !*** ./node_modules/prosemirror-schema-list/dist/index.es.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "liftListItem": () => (/* binding */ liftListItem),
/* harmony export */   "sinkListItem": () => (/* binding */ sinkListItem),
/* harmony export */   "splitListItem": () => (/* binding */ splitListItem),
/* harmony export */   "wrapInList": () => (/* binding */ wrapInList)
/* harmony export */ });
/* unused harmony exports addListNodes, bulletList, listItem, orderedList */
/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-transform */ "./node_modules/prosemirror-transform/dist/index.es.js");
/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-model */ "./node_modules/prosemirror-model/dist/index.es.js");



var olDOM = ["ol", 0], ulDOM = ["ul", 0], liDOM = ["li", 0];

// :: NodeSpec
// An ordered list [node spec](#model.NodeSpec). Has a single
// attribute, `order`, which determines the number at which the list
// starts counting, and defaults to 1. Represented as an `<ol>`
// element.
var orderedList = {
  attrs: {order: {default: 1}},
  parseDOM: [{tag: "ol", getAttrs: function getAttrs(dom) {
    return {order: dom.hasAttribute("start") ? +dom.getAttribute("start") : 1}
  }}],
  toDOM: function toDOM(node) {
    return node.attrs.order == 1 ? olDOM : ["ol", {start: node.attrs.order}, 0]
  }
};

// :: NodeSpec
// A bullet list node spec, represented in the DOM as `<ul>`.
var bulletList = {
  parseDOM: [{tag: "ul"}],
  toDOM: function toDOM() { return ulDOM }
};

// :: NodeSpec
// A list item (`<li>`) spec.
var listItem = {
  parseDOM: [{tag: "li"}],
  toDOM: function toDOM() { return liDOM },
  defining: true
};

function add(obj, props) {
  var copy = {};
  for (var prop in obj) { copy[prop] = obj[prop]; }
  for (var prop$1 in props) { copy[prop$1] = props[prop$1]; }
  return copy
}

// :: (OrderedMap<NodeSpec>, string, ?string) → OrderedMap<NodeSpec>
// Convenience function for adding list-related node types to a map
// specifying the nodes for a schema. Adds
// [`orderedList`](#schema-list.orderedList) as `"ordered_list"`,
// [`bulletList`](#schema-list.bulletList) as `"bullet_list"`, and
// [`listItem`](#schema-list.listItem) as `"list_item"`.
//
// `itemContent` determines the content expression for the list items.
// If you want the commands defined in this module to apply to your
// list structure, it should have a shape like `"paragraph block*"` or
// `"paragraph (ordered_list | bullet_list)*"`. `listGroup` can be
// given to assign a group name to the list node types, for example
// `"block"`.
function addListNodes(nodes, itemContent, listGroup) {
  return nodes.append({
    ordered_list: add(orderedList, {content: "list_item+", group: listGroup}),
    bullet_list: add(bulletList, {content: "list_item+", group: listGroup}),
    list_item: add(listItem, {content: itemContent})
  })
}

// :: (NodeType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool
// Returns a command function that wraps the selection in a list with
// the given type an attributes. If `dispatch` is null, only return a
// value to indicate whether this is possible, but don't actually
// perform the change.
function wrapInList(listType, attrs) {
  return function(state, dispatch) {
    var ref = state.selection;
    var $from = ref.$from;
    var $to = ref.$to;
    var range = $from.blockRange($to), doJoin = false, outerRange = range;
    if (!range) { return false }
    // This is at the top of an existing list item
    if (range.depth >= 2 && $from.node(range.depth - 1).type.compatibleContent(listType) && range.startIndex == 0) {
      // Don't do anything if this is the top of the list
      if ($from.index(range.depth - 1) == 0) { return false }
      var $insert = state.doc.resolve(range.start - 2);
      outerRange = new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.NodeRange($insert, $insert, range.depth);
      if (range.endIndex < range.parent.childCount)
        { range = new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.NodeRange($from, state.doc.resolve($to.end(range.depth)), range.depth); }
      doJoin = true;
    }
    var wrap = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.findWrapping)(outerRange, listType, attrs, range);
    if (!wrap) { return false }
    if (dispatch) { dispatch(doWrapInList(state.tr, range, wrap, doJoin, listType).scrollIntoView()); }
    return true
  }
}

function doWrapInList(tr, range, wrappers, joinBefore, listType) {
  var content = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty;
  for (var i = wrappers.length - 1; i >= 0; i--)
    { content = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content)); }

  tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceAroundStep(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end,
                                new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(content, 0, 0), wrappers.length, true));

  var found = 0;
  for (var i$1 = 0; i$1 < wrappers.length; i$1++) { if (wrappers[i$1].type == listType) { found = i$1 + 1; } }
  var splitDepth = wrappers.length - found;

  var splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0), parent = range.parent;
  for (var i$2 = range.startIndex, e = range.endIndex, first = true; i$2 < e; i$2++, first = false) {
    if (!first && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(tr.doc, splitPos, splitDepth)) {
      tr.split(splitPos, splitDepth);
      splitPos += 2 * splitDepth;
    }
    splitPos += parent.child(i$2).nodeSize;
  }
  return tr
}

// :: (NodeType) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool
// Build a command that splits a non-empty textblock at the top level
// of a list item by also splitting that list item.
function splitListItem(itemType) {
  return function(state, dispatch) {
    var ref = state.selection;
    var $from = ref.$from;
    var $to = ref.$to;
    var node = ref.node;
    if ((node && node.isBlock) || $from.depth < 2 || !$from.sameParent($to)) { return false }
    var grandParent = $from.node(-1);
    if (grandParent.type != itemType) { return false }
    if ($from.parent.content.size == 0 && $from.node(-1).childCount == $from.indexAfter(-1)) {
      // In an empty block. If this is a nested list, the wrapping
      // list item should be split. Otherwise, bail out and let next
      // command handle lifting.
      if ($from.depth == 2 || $from.node(-3).type != itemType ||
          $from.index(-2) != $from.node(-2).childCount - 1) { return false }
      if (dispatch) {
        var wrap = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty;
        var depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;
        // Build a fragment containing empty versions of the structure
        // from the outer list item to the parent node of the cursor
        for (var d = $from.depth - depthBefore; d >= $from.depth - 3; d--)
          { wrap = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from($from.node(d).copy(wrap)); }
        var depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1
            : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;
        // Add a second list item with an empty default start node
        wrap = wrap.append(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(itemType.createAndFill()));
        var start = $from.before($from.depth - (depthBefore - 1));
        var tr$1 = state.tr.replace(start, $from.after(-depthAfter), new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(wrap, 4 - depthBefore, 0));
        var sel = -1;
        tr$1.doc.nodesBetween(start, tr$1.doc.content.size, function (node, pos) {
          if (sel > -1) { return false }
          if (node.isTextblock && node.content.size == 0) { sel = pos + 1; }
        });
        if (sel > -1) { tr$1.setSelection(state.selection.constructor.near(tr$1.doc.resolve(sel))); }
        dispatch(tr$1.scrollIntoView());
      }
      return true
    }
    var nextType = $to.pos == $from.end() ? grandParent.contentMatchAt(0).defaultType : null;
    var tr = state.tr.delete($from.pos, $to.pos);
    var types = nextType && [null, {type: nextType}];
    if (!(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(tr.doc, $from.pos, 2, types)) { return false }
    if (dispatch) { dispatch(tr.split($from.pos, 2, types).scrollIntoView()); }
    return true
  }
}

// :: (NodeType) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool
// Create a command to lift the list item around the selection up into
// a wrapping list.
function liftListItem(itemType) {
  return function(state, dispatch) {
    var ref = state.selection;
    var $from = ref.$from;
    var $to = ref.$to;
    var range = $from.blockRange($to, function (node) { return node.childCount && node.firstChild.type == itemType; });
    if (!range) { return false }
    if (!dispatch) { return true }
    if ($from.node(range.depth - 1).type == itemType) // Inside a parent list
      { return liftToOuterList(state, dispatch, itemType, range) }
    else // Outer list node
      { return liftOutOfList(state, dispatch, range) }
  }
}

function liftToOuterList(state, dispatch, itemType, range) {
  var tr = state.tr, end = range.end, endOfList = range.$to.end(range.depth);
  if (end < endOfList) {
    // There are siblings after the lifted items, which must become
    // children of the last item
    tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceAroundStep(end - 1, endOfList, end, endOfList,
                                  new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true));
    range = new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.NodeRange(tr.doc.resolve(range.$from.pos), tr.doc.resolve(endOfList), range.depth);
  }
  dispatch(tr.lift(range, (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget)(range)).scrollIntoView());
  return true
}

function liftOutOfList(state, dispatch, range) {
  var tr = state.tr, list = range.parent;
  // Merge the list items into a single big item
  for (var pos = range.end, i = range.endIndex - 1, e = range.startIndex; i > e; i--) {
    pos -= list.child(i).nodeSize;
    tr.delete(pos - 1, pos + 1);
  }
  var $start = tr.doc.resolve(range.start), item = $start.nodeAfter;
  if (tr.mapping.map(range.end) != range.start + $start.nodeAfter.nodeSize) { return false }
  var atStart = range.startIndex == 0, atEnd = range.endIndex == list.childCount;
  var parent = $start.node(-1), indexBefore = $start.index(-1);
  if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1,
                         item.content.append(atEnd ? prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty : prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(list))))
    { return false }
  var start = $start.pos, end = start + item.nodeSize;
  // Strip off the surrounding list. At the sides where we're not at
  // the end of the list, the existing list is closed. At sides where
  // this is the end, it is overwritten to its end.
  tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceAroundStep(start - (atStart ? 1 : 0), end + (atEnd ? 1 : 0), start + 1, end - 1,
                                new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice((atStart ? prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty : prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(list.copy(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty)))
                                          .append(atEnd ? prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty : prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(list.copy(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty))),
                                          atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));
  dispatch(tr.scrollIntoView());
  return true
}

// :: (NodeType) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool
// Create a command to sink the list item around the selection down
// into an inner list.
function sinkListItem(itemType) {
  return function(state, dispatch) {
    var ref = state.selection;
    var $from = ref.$from;
    var $to = ref.$to;
    var range = $from.blockRange($to, function (node) { return node.childCount && node.firstChild.type == itemType; });
    if (!range) { return false }
    var startIndex = range.startIndex;
    if (startIndex == 0) { return false }
    var parent = range.parent, nodeBefore = parent.child(startIndex - 1);
    if (nodeBefore.type != itemType) { return false }

    if (dispatch) {
      var nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;
      var inner = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(nestedBefore ? itemType.create() : null);
      var slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(itemType.create(null, prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(parent.type.create(null, inner)))),
                            nestedBefore ? 3 : 1, 0);
      var before = range.start, after = range.end;
      dispatch(state.tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after,
                                                   before, after, slice, 1, true))
               .scrollIntoView());
    }
    return true
  }
}


//# sourceMappingURL=index.es.js.map


/***/ }),

/***/ "./node_modules/prosemirror-state/dist/index.es.js":
/*!*********************************************************!*\
  !*** ./node_modules/prosemirror-state/dist/index.es.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AllSelection": () => (/* binding */ AllSelection),
/* harmony export */   "EditorState": () => (/* binding */ EditorState),
/* harmony export */   "NodeSelection": () => (/* binding */ NodeSelection),
/* harmony export */   "Plugin": () => (/* binding */ Plugin),
/* harmony export */   "PluginKey": () => (/* binding */ PluginKey),
/* harmony export */   "Selection": () => (/* binding */ Selection),
/* harmony export */   "SelectionRange": () => (/* binding */ SelectionRange),
/* harmony export */   "TextSelection": () => (/* binding */ TextSelection),
/* harmony export */   "Transaction": () => (/* binding */ Transaction)
/* harmony export */ });
/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-model */ "./node_modules/prosemirror-model/dist/index.es.js");
/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-transform */ "./node_modules/prosemirror-transform/dist/index.es.js");



var classesById = Object.create(null);

// ::- Superclass for editor selections. Every selection type should
// extend this. Should not be instantiated directly.
var Selection = function Selection($anchor, $head, ranges) {
  // :: [SelectionRange]
  // The ranges covered by the selection.
  this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];
  // :: ResolvedPos
  // The resolved anchor of the selection (the side that stays in
  // place when the selection is modified).
  this.$anchor = $anchor;
  // :: ResolvedPos
  // The resolved head of the selection (the side that moves when
  // the selection is modified).
  this.$head = $head;
};

var prototypeAccessors = { anchor: { configurable: true },head: { configurable: true },from: { configurable: true },to: { configurable: true },$from: { configurable: true },$to: { configurable: true },empty: { configurable: true } };

// :: number
// The selection's anchor, as an unresolved position.
prototypeAccessors.anchor.get = function () { return this.$anchor.pos };

// :: number
// The selection's head.
prototypeAccessors.head.get = function () { return this.$head.pos };

// :: number
// The lower bound of the selection's main range.
prototypeAccessors.from.get = function () { return this.$from.pos };

// :: number
// The upper bound of the selection's main range.
prototypeAccessors.to.get = function () { return this.$to.pos };

// :: ResolvedPos
// The resolved lowerbound of the selection's main range.
prototypeAccessors.$from.get = function () {
  return this.ranges[0].$from
};

// :: ResolvedPos
// The resolved upper bound of the selection's main range.
prototypeAccessors.$to.get = function () {
  return this.ranges[0].$to
};

// :: bool
// Indicates whether the selection contains any content.
prototypeAccessors.empty.get = function () {
  var ranges = this.ranges;
  for (var i = 0; i < ranges.length; i++)
    { if (ranges[i].$from.pos != ranges[i].$to.pos) { return false } }
  return true
};

// eq:: (Selection) → bool
// Test whether the selection is the same as another selection.

// map:: (doc: Node, mapping: Mappable) → Selection
// Map this selection through a [mappable](#transform.Mappable) thing. `doc`
// should be the new document to which we are mapping.

// :: () → Slice
// Get the content of this selection as a slice.
Selection.prototype.content = function content () {
  return this.$from.node(0).slice(this.from, this.to, true)
};

// :: (Transaction, ?Slice)
// Replace the selection with a slice or, if no slice is given,
// delete the selection. Will append to the given transaction.
Selection.prototype.replace = function replace (tr, content) {
    if ( content === void 0 ) content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty;

  // Put the new selection at the position after the inserted
  // content. When that ended in an inline node, search backwards,
  // to get the position after that node. If not, search forward.
  var lastNode = content.content.lastChild, lastParent = null;
  for (var i = 0; i < content.openEnd; i++) {
    lastParent = lastNode;
    lastNode = lastNode.lastChild;
  }

  var mapFrom = tr.steps.length, ranges = this.ranges;
  for (var i$1 = 0; i$1 < ranges.length; i$1++) {
    var ref = ranges[i$1];
      var $from = ref.$from;
      var $to = ref.$to;
      var mapping = tr.mapping.slice(mapFrom);
    tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i$1 ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty : content);
    if (i$1 == 0)
      { selectionToInsertionEnd(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1); }
  }
};

// :: (Transaction, Node)
// Replace the selection with the given node, appending the changes
// to the given transaction.
Selection.prototype.replaceWith = function replaceWith (tr, node) {
  var mapFrom = tr.steps.length, ranges = this.ranges;
  for (var i = 0; i < ranges.length; i++) {
    var ref = ranges[i];
      var $from = ref.$from;
      var $to = ref.$to;
      var mapping = tr.mapping.slice(mapFrom);
    var from = mapping.map($from.pos), to = mapping.map($to.pos);
    if (i) {
      tr.deleteRange(from, to);
    } else {
      tr.replaceRangeWith(from, to, node);
      selectionToInsertionEnd(tr, mapFrom, node.isInline ? -1 : 1);
    }
  }
};

// toJSON:: () → Object
// Convert the selection to a JSON representation. When implementing
// this for a custom selection class, make sure to give the object a
// `type` property whose value matches the ID under which you
// [registered](#state.Selection^jsonID) your class.

// :: (ResolvedPos, number, ?bool) → ?Selection
// Find a valid cursor or leaf node selection starting at the given
// position and searching back if `dir` is negative, and forward if
// positive. When `textOnly` is true, only consider cursor
// selections. Will return null when no valid selection position is
// found.
Selection.findFrom = function findFrom ($pos, dir, textOnly) {
  var inner = $pos.parent.inlineContent ? new TextSelection($pos)
      : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);
  if (inner) { return inner }

  for (var depth = $pos.depth - 1; depth >= 0; depth--) {
    var found = dir < 0
        ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly)
        : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);
    if (found) { return found }
  }
};

// :: (ResolvedPos, ?number) → Selection
// Find a valid cursor or leaf node selection near the given
// position. Searches forward first by default, but if `bias` is
// negative, it will search backwards first.
Selection.near = function near ($pos, bias) {
    if ( bias === void 0 ) bias = 1;

  return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0))
};

// :: (Node) → Selection
// Find the cursor or leaf node selection closest to the start of
// the given document. Will return an
// [`AllSelection`](#state.AllSelection) if no valid position
// exists.
Selection.atStart = function atStart (doc) {
  return findSelectionIn(doc, doc, 0, 0, 1) || new AllSelection(doc)
};

// :: (Node) → Selection
// Find the cursor or leaf node selection closest to the end of the
// given document.
Selection.atEnd = function atEnd (doc) {
  return findSelectionIn(doc, doc, doc.content.size, doc.childCount, -1) || new AllSelection(doc)
};

// :: (Node, Object) → Selection
// Deserialize the JSON representation of a selection. Must be
// implemented for custom classes (as a static class method).
Selection.fromJSON = function fromJSON (doc, json) {
  if (!json || !json.type) { throw new RangeError("Invalid input for Selection.fromJSON") }
  var cls = classesById[json.type];
  if (!cls) { throw new RangeError(("No selection type " + (json.type) + " defined")) }
  return cls.fromJSON(doc, json)
};

// :: (string, constructor<Selection>)
// To be able to deserialize selections from JSON, custom selection
// classes must register themselves with an ID string, so that they
// can be disambiguated. Try to pick something that's unlikely to
// clash with classes from other modules.
Selection.jsonID = function jsonID (id, selectionClass) {
  if (id in classesById) { throw new RangeError("Duplicate use of selection JSON ID " + id) }
  classesById[id] = selectionClass;
  selectionClass.prototype.jsonID = id;
  return selectionClass
};

// :: () → SelectionBookmark
// Get a [bookmark](#state.SelectionBookmark) for this selection,
// which is a value that can be mapped without having access to a
// current document, and later resolved to a real selection for a
// given document again. (This is used mostly by the history to
// track and restore old selections.) The default implementation of
// this method just converts the selection to a text selection and
// returns the bookmark for that.
Selection.prototype.getBookmark = function getBookmark () {
  return TextSelection.between(this.$anchor, this.$head).getBookmark()
};

Object.defineProperties( Selection.prototype, prototypeAccessors );

// :: bool
// Controls whether, when a selection of this type is active in the
// browser, the selected range should be visible to the user. Defaults
// to `true`.
Selection.prototype.visible = true;

// SelectionBookmark:: interface
// A lightweight, document-independent representation of a selection.
// You can define a custom bookmark type for a custom selection class
// to make the history handle it well.
//
//   map:: (mapping: Mapping) → SelectionBookmark
//   Map the bookmark through a set of changes.
//
//   resolve:: (doc: Node) → Selection
//   Resolve the bookmark to a real selection again. This may need to
//   do some error checking and may fall back to a default (usually
//   [`TextSelection.between`](#state.TextSelection^between)) if
//   mapping made the bookmark invalid.

// ::- Represents a selected range in a document.
var SelectionRange = function SelectionRange($from, $to) {
  // :: ResolvedPos
  // The lower bound of the range.
  this.$from = $from;
  // :: ResolvedPos
  // The upper bound of the range.
  this.$to = $to;
};

// ::- A text selection represents a classical editor selection, with
// a head (the moving side) and anchor (immobile side), both of which
// point into textblock nodes. It can be empty (a regular cursor
// position).
var TextSelection = /*@__PURE__*/(function (Selection) {
  function TextSelection($anchor, $head) {
    if ( $head === void 0 ) $head = $anchor;

    Selection.call(this, $anchor, $head);
  }

  if ( Selection ) TextSelection.__proto__ = Selection;
  TextSelection.prototype = Object.create( Selection && Selection.prototype );
  TextSelection.prototype.constructor = TextSelection;

  var prototypeAccessors$1 = { $cursor: { configurable: true } };

  // :: ?ResolvedPos
  // Returns a resolved position if this is a cursor selection (an
  // empty text selection), and null otherwise.
  prototypeAccessors$1.$cursor.get = function () { return this.$anchor.pos == this.$head.pos ? this.$head : null };

  TextSelection.prototype.map = function map (doc, mapping) {
    var $head = doc.resolve(mapping.map(this.head));
    if (!$head.parent.inlineContent) { return Selection.near($head) }
    var $anchor = doc.resolve(mapping.map(this.anchor));
    return new TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head)
  };

  TextSelection.prototype.replace = function replace (tr, content) {
    if ( content === void 0 ) content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty;

    Selection.prototype.replace.call(this, tr, content);
    if (content == prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty) {
      var marks = this.$from.marksAcross(this.$to);
      if (marks) { tr.ensureMarks(marks); }
    }
  };

  TextSelection.prototype.eq = function eq (other) {
    return other instanceof TextSelection && other.anchor == this.anchor && other.head == this.head
  };

  TextSelection.prototype.getBookmark = function getBookmark () {
    return new TextBookmark(this.anchor, this.head)
  };

  TextSelection.prototype.toJSON = function toJSON () {
    return {type: "text", anchor: this.anchor, head: this.head}
  };

  TextSelection.fromJSON = function fromJSON (doc, json) {
    if (typeof json.anchor != "number" || typeof json.head != "number")
      { throw new RangeError("Invalid input for TextSelection.fromJSON") }
    return new TextSelection(doc.resolve(json.anchor), doc.resolve(json.head))
  };

  // :: (Node, number, ?number) → TextSelection
  // Create a text selection from non-resolved positions.
  TextSelection.create = function create (doc, anchor, head) {
    if ( head === void 0 ) head = anchor;

    var $anchor = doc.resolve(anchor);
    return new this($anchor, head == anchor ? $anchor : doc.resolve(head))
  };

  // :: (ResolvedPos, ResolvedPos, ?number) → Selection
  // Return a text selection that spans the given positions or, if
  // they aren't text positions, find a text selection near them.
  // `bias` determines whether the method searches forward (default)
  // or backwards (negative number) first. Will fall back to calling
  // [`Selection.near`](#state.Selection^near) when the document
  // doesn't contain a valid text position.
  TextSelection.between = function between ($anchor, $head, bias) {
    var dPos = $anchor.pos - $head.pos;
    if (!bias || dPos) { bias = dPos >= 0 ? 1 : -1; }
    if (!$head.parent.inlineContent) {
      var found = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);
      if (found) { $head = found.$head; }
      else { return Selection.near($head, bias) }
    }
    if (!$anchor.parent.inlineContent) {
      if (dPos == 0) {
        $anchor = $head;
      } else {
        $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;
        if (($anchor.pos < $head.pos) != (dPos < 0)) { $anchor = $head; }
      }
    }
    return new TextSelection($anchor, $head)
  };

  Object.defineProperties( TextSelection.prototype, prototypeAccessors$1 );

  return TextSelection;
}(Selection));

Selection.jsonID("text", TextSelection);

var TextBookmark = function TextBookmark(anchor, head) {
  this.anchor = anchor;
  this.head = head;
};
TextBookmark.prototype.map = function map (mapping) {
  return new TextBookmark(mapping.map(this.anchor), mapping.map(this.head))
};
TextBookmark.prototype.resolve = function resolve (doc) {
  return TextSelection.between(doc.resolve(this.anchor), doc.resolve(this.head))
};

// ::- A node selection is a selection that points at a single node.
// All nodes marked [selectable](#model.NodeSpec.selectable) can be
// the target of a node selection. In such a selection, `from` and
// `to` point directly before and after the selected node, `anchor`
// equals `from`, and `head` equals `to`..
var NodeSelection = /*@__PURE__*/(function (Selection) {
  function NodeSelection($pos) {
    var node = $pos.nodeAfter;
    var $end = $pos.node(0).resolve($pos.pos + node.nodeSize);
    Selection.call(this, $pos, $end);
    // :: Node The selected node.
    this.node = node;
  }

  if ( Selection ) NodeSelection.__proto__ = Selection;
  NodeSelection.prototype = Object.create( Selection && Selection.prototype );
  NodeSelection.prototype.constructor = NodeSelection;

  NodeSelection.prototype.map = function map (doc, mapping) {
    var ref = mapping.mapResult(this.anchor);
    var deleted = ref.deleted;
    var pos = ref.pos;
    var $pos = doc.resolve(pos);
    if (deleted) { return Selection.near($pos) }
    return new NodeSelection($pos)
  };

  NodeSelection.prototype.content = function content () {
    return new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(this.node), 0, 0)
  };

  NodeSelection.prototype.eq = function eq (other) {
    return other instanceof NodeSelection && other.anchor == this.anchor
  };

  NodeSelection.prototype.toJSON = function toJSON () {
    return {type: "node", anchor: this.anchor}
  };

  NodeSelection.prototype.getBookmark = function getBookmark () { return new NodeBookmark(this.anchor) };

  NodeSelection.fromJSON = function fromJSON (doc, json) {
    if (typeof json.anchor != "number")
      { throw new RangeError("Invalid input for NodeSelection.fromJSON") }
    return new NodeSelection(doc.resolve(json.anchor))
  };

  // :: (Node, number) → NodeSelection
  // Create a node selection from non-resolved positions.
  NodeSelection.create = function create (doc, from) {
    return new this(doc.resolve(from))
  };

  // :: (Node) → bool
  // Determines whether the given node may be selected as a node
  // selection.
  NodeSelection.isSelectable = function isSelectable (node) {
    return !node.isText && node.type.spec.selectable !== false
  };

  return NodeSelection;
}(Selection));

NodeSelection.prototype.visible = false;

Selection.jsonID("node", NodeSelection);

var NodeBookmark = function NodeBookmark(anchor) {
  this.anchor = anchor;
};
NodeBookmark.prototype.map = function map (mapping) {
  var ref = mapping.mapResult(this.anchor);
    var deleted = ref.deleted;
    var pos = ref.pos;
  return deleted ? new TextBookmark(pos, pos) : new NodeBookmark(pos)
};
NodeBookmark.prototype.resolve = function resolve (doc) {
  var $pos = doc.resolve(this.anchor), node = $pos.nodeAfter;
  if (node && NodeSelection.isSelectable(node)) { return new NodeSelection($pos) }
  return Selection.near($pos)
};

// ::- A selection type that represents selecting the whole document
// (which can not necessarily be expressed with a text selection, when
// there are for example leaf block nodes at the start or end of the
// document).
var AllSelection = /*@__PURE__*/(function (Selection) {
  function AllSelection(doc) {
    Selection.call(this, doc.resolve(0), doc.resolve(doc.content.size));
  }

  if ( Selection ) AllSelection.__proto__ = Selection;
  AllSelection.prototype = Object.create( Selection && Selection.prototype );
  AllSelection.prototype.constructor = AllSelection;

  AllSelection.prototype.replace = function replace (tr, content) {
    if ( content === void 0 ) content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty;

    if (content == prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty) {
      tr.delete(0, tr.doc.content.size);
      var sel = Selection.atStart(tr.doc);
      if (!sel.eq(tr.selection)) { tr.setSelection(sel); }
    } else {
      Selection.prototype.replace.call(this, tr, content);
    }
  };

  AllSelection.prototype.toJSON = function toJSON () { return {type: "all"} };

  AllSelection.fromJSON = function fromJSON (doc) { return new AllSelection(doc) };

  AllSelection.prototype.map = function map (doc) { return new AllSelection(doc) };

  AllSelection.prototype.eq = function eq (other) { return other instanceof AllSelection };

  AllSelection.prototype.getBookmark = function getBookmark () { return AllBookmark };

  return AllSelection;
}(Selection));

Selection.jsonID("all", AllSelection);

var AllBookmark = {
  map: function map() { return this },
  resolve: function resolve(doc) { return new AllSelection(doc) }
};

// FIXME we'll need some awareness of text direction when scanning for selections

// Try to find a selection inside the given node. `pos` points at the
// position where the search starts. When `text` is true, only return
// text selections.
function findSelectionIn(doc, node, pos, index, dir, text) {
  if (node.inlineContent) { return TextSelection.create(doc, pos) }
  for (var i = index - (dir > 0 ? 0 : 1); dir > 0 ? i < node.childCount : i >= 0; i += dir) {
    var child = node.child(i);
    if (!child.isAtom) {
      var inner = findSelectionIn(doc, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text);
      if (inner) { return inner }
    } else if (!text && NodeSelection.isSelectable(child)) {
      return NodeSelection.create(doc, pos - (dir < 0 ? child.nodeSize : 0))
    }
    pos += child.nodeSize * dir;
  }
}

function selectionToInsertionEnd(tr, startLen, bias) {
  var last = tr.steps.length - 1;
  if (last < startLen) { return }
  var step = tr.steps[last];
  if (!(step instanceof prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.ReplaceStep || step instanceof prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.ReplaceAroundStep)) { return }
  var map = tr.mapping.maps[last], end;
  map.forEach(function (_from, _to, _newFrom, newTo) { if (end == null) { end = newTo; } });
  tr.setSelection(Selection.near(tr.doc.resolve(end), bias));
}

var UPDATED_SEL = 1, UPDATED_MARKS = 2, UPDATED_SCROLL = 4;

// ::- An editor state transaction, which can be applied to a state to
// create an updated state. Use
// [`EditorState.tr`](#state.EditorState.tr) to create an instance.
//
// Transactions track changes to the document (they are a subclass of
// [`Transform`](#transform.Transform)), but also other state changes,
// like selection updates and adjustments of the set of [stored
// marks](#state.EditorState.storedMarks). In addition, you can store
// metadata properties in a transaction, which are extra pieces of
// information that client code or plugins can use to describe what a
// transacion represents, so that they can update their [own
// state](#state.StateField) accordingly.
//
// The [editor view](#view.EditorView) uses a few metadata properties:
// it will attach a property `"pointer"` with the value `true` to
// selection transactions directly caused by mouse or touch input, and
// a `"uiEvent"` property of that may be `"paste"`, `"cut"`, or `"drop"`.
var Transaction = /*@__PURE__*/(function (Transform) {
  function Transaction(state) {
    Transform.call(this, state.doc);
    // :: number
    // The timestamp associated with this transaction, in the same
    // format as `Date.now()`.
    this.time = Date.now();
    this.curSelection = state.selection;
    // The step count for which the current selection is valid.
    this.curSelectionFor = 0;
    // :: ?[Mark]
    // The stored marks set by this transaction, if any.
    this.storedMarks = state.storedMarks;
    // Bitfield to track which aspects of the state were updated by
    // this transaction.
    this.updated = 0;
    // Object used to store metadata properties for the transaction.
    this.meta = Object.create(null);
  }

  if ( Transform ) Transaction.__proto__ = Transform;
  Transaction.prototype = Object.create( Transform && Transform.prototype );
  Transaction.prototype.constructor = Transaction;

  var prototypeAccessors = { selection: { configurable: true },selectionSet: { configurable: true },storedMarksSet: { configurable: true },isGeneric: { configurable: true },scrolledIntoView: { configurable: true } };

  // :: Selection
  // The transaction's current selection. This defaults to the editor
  // selection [mapped](#state.Selection.map) through the steps in the
  // transaction, but can be overwritten with
  // [`setSelection`](#state.Transaction.setSelection).
  prototypeAccessors.selection.get = function () {
    if (this.curSelectionFor < this.steps.length) {
      this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));
      this.curSelectionFor = this.steps.length;
    }
    return this.curSelection
  };

  // :: (Selection) → Transaction
  // Update the transaction's current selection. Will determine the
  // selection that the editor gets when the transaction is applied.
  Transaction.prototype.setSelection = function setSelection (selection) {
    if (selection.$from.doc != this.doc)
      { throw new RangeError("Selection passed to setSelection must point at the current document") }
    this.curSelection = selection;
    this.curSelectionFor = this.steps.length;
    this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;
    this.storedMarks = null;
    return this
  };

  // :: bool
  // Whether the selection was explicitly updated by this transaction.
  prototypeAccessors.selectionSet.get = function () {
    return (this.updated & UPDATED_SEL) > 0
  };

  // :: (?[Mark]) → Transaction
  // Set the current stored marks.
  Transaction.prototype.setStoredMarks = function setStoredMarks (marks) {
    this.storedMarks = marks;
    this.updated |= UPDATED_MARKS;
    return this
  };

  // :: ([Mark]) → Transaction
  // Make sure the current stored marks or, if that is null, the marks
  // at the selection, match the given set of marks. Does nothing if
  // this is already the case.
  Transaction.prototype.ensureMarks = function ensureMarks (marks) {
    if (!prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Mark.sameSet(this.storedMarks || this.selection.$from.marks(), marks))
      { this.setStoredMarks(marks); }
    return this
  };

  // :: (Mark) → Transaction
  // Add a mark to the set of stored marks.
  Transaction.prototype.addStoredMark = function addStoredMark (mark) {
    return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()))
  };

  // :: (union<Mark, MarkType>) → Transaction
  // Remove a mark or mark type from the set of stored marks.
  Transaction.prototype.removeStoredMark = function removeStoredMark (mark) {
    return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()))
  };

  // :: bool
  // Whether the stored marks were explicitly set for this transaction.
  prototypeAccessors.storedMarksSet.get = function () {
    return (this.updated & UPDATED_MARKS) > 0
  };

  Transaction.prototype.addStep = function addStep (step, doc) {
    Transform.prototype.addStep.call(this, step, doc);
    this.updated = this.updated & ~UPDATED_MARKS;
    this.storedMarks = null;
  };

  // :: (number) → Transaction
  // Update the timestamp for the transaction.
  Transaction.prototype.setTime = function setTime (time) {
    this.time = time;
    return this
  };

  // :: (Slice) → Transaction
  // Replace the current selection with the given slice.
  Transaction.prototype.replaceSelection = function replaceSelection (slice) {
    this.selection.replace(this, slice);
    return this
  };

  // :: (Node, ?bool) → Transaction
  // Replace the selection with the given node. When `inheritMarks` is
  // true and the content is inline, it inherits the marks from the
  // place where it is inserted.
  Transaction.prototype.replaceSelectionWith = function replaceSelectionWith (node, inheritMarks) {
    var selection = this.selection;
    if (inheritMarks !== false)
      { node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : (selection.$from.marksAcross(selection.$to) || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Mark.none))); }
    selection.replaceWith(this, node);
    return this
  };

  // :: () → Transaction
  // Delete the selection.
  Transaction.prototype.deleteSelection = function deleteSelection () {
    this.selection.replace(this);
    return this
  };

  // :: (string, from: ?number, to: ?number) → Transaction
  // Replace the given range, or the selection if no range is given,
  // with a text node containing the given string.
  Transaction.prototype.insertText = function insertText (text, from, to) {
    if ( to === void 0 ) to = from;

    var schema = this.doc.type.schema;
    if (from == null) {
      if (!text) { return this.deleteSelection() }
      return this.replaceSelectionWith(schema.text(text), true)
    } else {
      if (!text) { return this.deleteRange(from, to) }
      var marks = this.storedMarks;
      if (!marks) {
        var $from = this.doc.resolve(from);
        marks = to == from ? $from.marks() : $from.marksAcross(this.doc.resolve(to));
      }
      this.replaceRangeWith(from, to, schema.text(text, marks));
      if (!this.selection.empty) { this.setSelection(Selection.near(this.selection.$to)); }
      return this
    }
  };

  // :: (union<string, Plugin, PluginKey>, any) → Transaction
  // Store a metadata property in this transaction, keyed either by
  // name or by plugin.
  Transaction.prototype.setMeta = function setMeta (key, value) {
    this.meta[typeof key == "string" ? key : key.key] = value;
    return this
  };

  // :: (union<string, Plugin, PluginKey>) → any
  // Retrieve a metadata property for a given name or plugin.
  Transaction.prototype.getMeta = function getMeta (key) {
    return this.meta[typeof key == "string" ? key : key.key]
  };

  // :: bool
  // Returns true if this transaction doesn't contain any metadata,
  // and can thus safely be extended.
  prototypeAccessors.isGeneric.get = function () {
    for (var _ in this.meta) { return false }
    return true
  };

  // :: () → Transaction
  // Indicate that the editor should scroll the selection into view
  // when updated to the state produced by this transaction.
  Transaction.prototype.scrollIntoView = function scrollIntoView () {
    this.updated |= UPDATED_SCROLL;
    return this
  };

  prototypeAccessors.scrolledIntoView.get = function () {
    return (this.updated & UPDATED_SCROLL) > 0
  };

  Object.defineProperties( Transaction.prototype, prototypeAccessors );

  return Transaction;
}(prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.Transform));

function bind(f, self) {
  return !self || !f ? f : f.bind(self)
}

var FieldDesc = function FieldDesc(name, desc, self) {
  this.name = name;
  this.init = bind(desc.init, self);
  this.apply = bind(desc.apply, self);
};

var baseFields = [
  new FieldDesc("doc", {
    init: function init(config) { return config.doc || config.schema.topNodeType.createAndFill() },
    apply: function apply(tr) { return tr.doc }
  }),

  new FieldDesc("selection", {
    init: function init(config, instance) { return config.selection || Selection.atStart(instance.doc) },
    apply: function apply(tr) { return tr.selection }
  }),

  new FieldDesc("storedMarks", {
    init: function init(config) { return config.storedMarks || null },
    apply: function apply(tr, _marks, _old, state) { return state.selection.$cursor ? tr.storedMarks : null }
  }),

  new FieldDesc("scrollToSelection", {
    init: function init() { return 0 },
    apply: function apply(tr, prev) { return tr.scrolledIntoView ? prev + 1 : prev }
  })
];

// Object wrapping the part of a state object that stays the same
// across transactions. Stored in the state's `config` property.
var Configuration = function Configuration(schema, plugins) {
  var this$1 = this;

  this.schema = schema;
  this.fields = baseFields.concat();
  this.plugins = [];
  this.pluginsByKey = Object.create(null);
  if (plugins) { plugins.forEach(function (plugin) {
    if (this$1.pluginsByKey[plugin.key])
      { throw new RangeError("Adding different instances of a keyed plugin (" + plugin.key + ")") }
    this$1.plugins.push(plugin);
    this$1.pluginsByKey[plugin.key] = plugin;
    if (plugin.spec.state)
      { this$1.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin)); }
  }); }
};

// ::- The state of a ProseMirror editor is represented by an object
// of this type. A state is a persistent data structure—it isn't
// updated, but rather a new state value is computed from an old one
// using the [`apply`](#state.EditorState.apply) method.
//
// A state holds a number of built-in fields, and plugins can
// [define](#state.PluginSpec.state) additional fields.
var EditorState = function EditorState(config) {
  this.config = config;
};

var prototypeAccessors$1 = { schema: { configurable: true },plugins: { configurable: true },tr: { configurable: true } };

// doc:: Node
// The current document.

// selection:: Selection
// The selection.

// storedMarks:: ?[Mark]
// A set of marks to apply to the next input. Will be null when
// no explicit marks have been set.

// :: Schema
// The schema of the state's document.
prototypeAccessors$1.schema.get = function () {
  return this.config.schema
};

// :: [Plugin]
// The plugins that are active in this state.
prototypeAccessors$1.plugins.get = function () {
  return this.config.plugins
};

// :: (Transaction) → EditorState
// Apply the given transaction to produce a new state.
EditorState.prototype.apply = function apply (tr) {
  return this.applyTransaction(tr).state
};

// : (Transaction) → bool
EditorState.prototype.filterTransaction = function filterTransaction (tr, ignore) {
    if ( ignore === void 0 ) ignore = -1;

  for (var i = 0; i < this.config.plugins.length; i++) { if (i != ignore) {
    var plugin = this.config.plugins[i];
    if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr, this))
      { return false }
  } }
  return true
};

// :: (Transaction) → {state: EditorState, transactions: [Transaction]}
// Verbose variant of [`apply`](#state.EditorState.apply) that
// returns the precise transactions that were applied (which might
// be influenced by the [transaction
// hooks](#state.PluginSpec.filterTransaction) of
// plugins) along with the new state.
EditorState.prototype.applyTransaction = function applyTransaction (rootTr) {
  if (!this.filterTransaction(rootTr)) { return {state: this, transactions: []} }

  var trs = [rootTr], newState = this.applyInner(rootTr), seen = null;
  // This loop repeatedly gives plugins a chance to respond to
  // transactions as new transactions are added, making sure to only
  // pass the transactions the plugin did not see before.
   for (;;) {
    var haveNew = false;
    for (var i = 0; i < this.config.plugins.length; i++) {
      var plugin = this.config.plugins[i];
      if (plugin.spec.appendTransaction) {
        var n = seen ? seen[i].n : 0, oldState = seen ? seen[i].state : this;
        var tr = n < trs.length &&
            plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState);
        if (tr && newState.filterTransaction(tr, i)) {
          tr.setMeta("appendedTransaction", rootTr);
          if (!seen) {
            seen = [];
            for (var j = 0; j < this.config.plugins.length; j++)
              { seen.push(j < i ? {state: newState, n: trs.length} : {state: this, n: 0}); }
          }
          trs.push(tr);
          newState = newState.applyInner(tr);
          haveNew = true;
        }
        if (seen) { seen[i] = {state: newState, n: trs.length}; }
      }
    }
    if (!haveNew) { return {state: newState, transactions: trs} }
  }
};

// : (Transaction) → EditorState
EditorState.prototype.applyInner = function applyInner (tr) {
  if (!tr.before.eq(this.doc)) { throw new RangeError("Applying a mismatched transaction") }
  var newInstance = new EditorState(this.config), fields = this.config.fields;
  for (var i = 0; i < fields.length; i++) {
    var field = fields[i];
    newInstance[field.name] = field.apply(tr, this[field.name], this, newInstance);
  }
  for (var i$1 = 0; i$1 < applyListeners.length; i$1++) { applyListeners[i$1](this, tr, newInstance); }
  return newInstance
};

// :: Transaction
// Start a [transaction](#state.Transaction) from this state.
prototypeAccessors$1.tr.get = function () { return new Transaction(this) };

// :: (Object) → EditorState
// Create a new state.
//
// config::- Configuration options. Must contain `schema` or `doc` (or both).
//
//    schema:: ?Schema
//    The schema to use (only relevant if no `doc` is specified).
//
//    doc:: ?Node
//    The starting document.
//
//    selection:: ?Selection
//    A valid selection in the document.
//
//    storedMarks:: ?[Mark]
//    The initial set of [stored marks](#state.EditorState.storedMarks).
//
//    plugins:: ?[Plugin]
//    The plugins that should be active in this state.
EditorState.create = function create (config) {
  var $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins);
  var instance = new EditorState($config);
  for (var i = 0; i < $config.fields.length; i++)
    { instance[$config.fields[i].name] = $config.fields[i].init(config, instance); }
  return instance
};

// :: (Object) → EditorState
// Create a new state based on this one, but with an adjusted set of
// active plugins. State fields that exist in both sets of plugins
// are kept unchanged. Those that no longer exist are dropped, and
// those that are new are initialized using their
// [`init`](#state.StateField.init) method, passing in the new
// configuration object..
//
// config::- configuration options
//
//   plugins:: [Plugin]
//   New set of active plugins.
EditorState.prototype.reconfigure = function reconfigure (config) {
  var $config = new Configuration(this.schema, config.plugins);
  var fields = $config.fields, instance = new EditorState($config);
  for (var i = 0; i < fields.length; i++) {
    var name = fields[i].name;
    instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config, instance);
  }
  return instance
};

// :: (?union<Object<Plugin>, string, number>) → Object
// Serialize this state to JSON. If you want to serialize the state
// of plugins, pass an object mapping property names to use in the
// resulting JSON object to plugin objects. The argument may also be
// a string or number, in which case it is ignored, to support the
// way `JSON.stringify` calls `toString` methods.
EditorState.prototype.toJSON = function toJSON (pluginFields) {
  var result = {doc: this.doc.toJSON(), selection: this.selection.toJSON()};
  if (this.storedMarks) { result.storedMarks = this.storedMarks.map(function (m) { return m.toJSON(); }); }
  if (pluginFields && typeof pluginFields == 'object') { for (var prop in pluginFields) {
    if (prop == "doc" || prop == "selection")
      { throw new RangeError("The JSON fields `doc` and `selection` are reserved") }
    var plugin = pluginFields[prop], state = plugin.spec.state;
    if (state && state.toJSON) { result[prop] = state.toJSON.call(plugin, this[plugin.key]); }
  } }
  return result
};

// :: (Object, Object, ?Object<Plugin>) → EditorState
// Deserialize a JSON representation of a state. `config` should
// have at least a `schema` field, and should contain array of
// plugins to initialize the state with. `pluginFields` can be used
// to deserialize the state of plugins, by associating plugin
// instances with the property names they use in the JSON object.
//
// config::- configuration options
//
//   schema:: Schema
//   The schema to use.
//
//   plugins:: ?[Plugin]
//   The set of active plugins.
EditorState.fromJSON = function fromJSON (config, json, pluginFields) {
  if (!json) { throw new RangeError("Invalid input for EditorState.fromJSON") }
  if (!config.schema) { throw new RangeError("Required config field 'schema' missing") }
  var $config = new Configuration(config.schema, config.plugins);
  var instance = new EditorState($config);
  $config.fields.forEach(function (field) {
    if (field.name == "doc") {
      instance.doc = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Node.fromJSON(config.schema, json.doc);
    } else if (field.name == "selection") {
      instance.selection = Selection.fromJSON(instance.doc, json.selection);
    } else if (field.name == "storedMarks") {
      if (json.storedMarks) { instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON); }
    } else {
      if (pluginFields) { for (var prop in pluginFields) {
        var plugin = pluginFields[prop], state = plugin.spec.state;
        if (plugin.key == field.name && state && state.fromJSON &&
            Object.prototype.hasOwnProperty.call(json, prop)) {
          // This field belongs to a plugin mapped to a JSON field, read it from there.
          instance[field.name] = state.fromJSON.call(plugin, config, json[prop], instance);
          return
        }
      } }
      instance[field.name] = field.init(config, instance);
    }
  });
  return instance
};

// Kludge to allow the view to track mappings between different
// instances of a state.
//
// FIXME this is no longer needed as of prosemirror-view 1.9.0,
// though due to backwards-compat we should probably keep it around
// for a while (if only as a no-op)
EditorState.addApplyListener = function addApplyListener (f) {
  applyListeners.push(f);
};
EditorState.removeApplyListener = function removeApplyListener (f) {
  var found = applyListeners.indexOf(f);
  if (found > -1) { applyListeners.splice(found, 1); }
};

Object.defineProperties( EditorState.prototype, prototypeAccessors$1 );

var applyListeners = [];

// PluginSpec:: interface
//
// This is the type passed to the [`Plugin`](#state.Plugin)
// constructor. It provides a definition for a plugin.
//
//   props:: ?EditorProps
//   The [view props](#view.EditorProps) added by this plugin. Props
//   that are functions will be bound to have the plugin instance as
//   their `this` binding.
//
//   state:: ?StateField<any>
//   Allows a plugin to define a [state field](#state.StateField), an
//   extra slot in the state object in which it can keep its own data.
//
//   key:: ?PluginKey
//   Can be used to make this a keyed plugin. You can have only one
//   plugin with a given key in a given state, but it is possible to
//   access the plugin's configuration and state through the key,
//   without having access to the plugin instance object.
//
//   view:: ?(EditorView) → Object
//   When the plugin needs to interact with the editor view, or
//   set something up in the DOM, use this field. The function
//   will be called when the plugin's state is associated with an
//   editor view.
//
//     return::-
//     Should return an object with the following optional
//     properties:
//
//       update:: ?(view: EditorView, prevState: EditorState)
//       Called whenever the view's state is updated.
//
//       destroy:: ?()
//       Called when the view is destroyed or receives a state
//       with different plugins.
//
//   filterTransaction:: ?(Transaction, EditorState) → bool
//   When present, this will be called before a transaction is
//   applied by the state, allowing the plugin to cancel it (by
//   returning false).
//
//   appendTransaction:: ?(transactions: [Transaction], oldState: EditorState, newState: EditorState) → ?Transaction
//   Allows the plugin to append another transaction to be applied
//   after the given array of transactions. When another plugin
//   appends a transaction after this was called, it is called again
//   with the new state and new transactions—but only the new
//   transactions, i.e. it won't be passed transactions that it
//   already saw.

function bindProps(obj, self, target) {
  for (var prop in obj) {
    var val = obj[prop];
    if (val instanceof Function) { val = val.bind(self); }
    else if (prop == "handleDOMEvents") { val = bindProps(val, self, {}); }
    target[prop] = val;
  }
  return target
}

// ::- Plugins bundle functionality that can be added to an editor.
// They are part of the [editor state](#state.EditorState) and
// may influence that state and the view that contains it.
var Plugin = function Plugin(spec) {
  // :: EditorProps
  // The [props](#view.EditorProps) exported by this plugin.
  this.props = {};
  if (spec.props) { bindProps(spec.props, this, this.props); }
  // :: Object
  // The plugin's [spec object](#state.PluginSpec).
  this.spec = spec;
  this.key = spec.key ? spec.key.key : createKey("plugin");
};

// :: (EditorState) → any
// Extract the plugin's state field from an editor state.
Plugin.prototype.getState = function getState (state) { return state[this.key] };

// StateField:: interface<T>
// A plugin spec may provide a state field (under its
// [`state`](#state.PluginSpec.state) property) of this type, which
// describes the state it wants to keep. Functions provided here are
// always called with the plugin instance as their `this` binding.
//
//   init:: (config: Object, instance: EditorState) → T
//   Initialize the value of the field. `config` will be the object
//   passed to [`EditorState.create`](#state.EditorState^create). Note
//   that `instance` is a half-initialized state instance, and will
//   not have values for plugin fields initialized after this one.
//
//   apply:: (tr: Transaction, value: T, oldState: EditorState, newState: EditorState) → T
//   Apply the given transaction to this state field, producing a new
//   field value. Note that the `newState` argument is again a partially
//   constructed state does not yet contain the state from plugins
//   coming after this one.
//
//   toJSON:: ?(value: T) → *
//   Convert this field to JSON. Optional, can be left off to disable
//   JSON serialization for the field.
//
//   fromJSON:: ?(config: Object, value: *, state: EditorState) → T
//   Deserialize the JSON representation of this field. Note that the
//   `state` argument is again a half-initialized state.

var keys = Object.create(null);

function createKey(name) {
  if (name in keys) { return name + "$" + ++keys[name] }
  keys[name] = 0;
  return name + "$"
}

// ::- A key is used to [tag](#state.PluginSpec.key)
// plugins in a way that makes it possible to find them, given an
// editor state. Assigning a key does mean only one plugin of that
// type can be active in a state.
var PluginKey = function PluginKey(name) {
if ( name === void 0 ) name = "key";
 this.key = createKey(name); };

// :: (EditorState) → ?Plugin
// Get the active plugin with this key, if any, from an editor
// state.
PluginKey.prototype.get = function get (state) { return state.config.pluginsByKey[this.key] };

// :: (EditorState) → ?any
// Get the plugin's state from an editor state.
PluginKey.prototype.getState = function getState (state) { return state[this.key] };


//# sourceMappingURL=index.es.js.map


/***/ }),

/***/ "./node_modules/prosemirror-transform/dist/index.es.js":
/*!*************************************************************!*\
  !*** ./node_modules/prosemirror-transform/dist/index.es.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Mapping": () => (/* binding */ Mapping),
/* harmony export */   "ReplaceAroundStep": () => (/* binding */ ReplaceAroundStep),
/* harmony export */   "ReplaceStep": () => (/* binding */ ReplaceStep),
/* harmony export */   "Transform": () => (/* binding */ Transform),
/* harmony export */   "canJoin": () => (/* binding */ canJoin),
/* harmony export */   "canSplit": () => (/* binding */ canSplit),
/* harmony export */   "dropPoint": () => (/* binding */ dropPoint),
/* harmony export */   "findWrapping": () => (/* binding */ findWrapping),
/* harmony export */   "joinPoint": () => (/* binding */ joinPoint),
/* harmony export */   "liftTarget": () => (/* binding */ liftTarget)
/* harmony export */ });
/* unused harmony exports AddMarkStep, MapResult, RemoveMarkStep, Step, StepMap, StepResult, TransformError, insertPoint, replaceStep */
/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-model */ "./node_modules/prosemirror-model/dist/index.es.js");


// Mappable:: interface
// There are several things that positions can be mapped through.
// Such objects conform to this interface.
//
//   map:: (pos: number, assoc: ?number) → number
//   Map a position through this object. When given, `assoc` (should
//   be -1 or 1, defaults to 1) determines with which side the
//   position is associated, which determines in which direction to
//   move when a chunk of content is inserted at the mapped position.
//
//   mapResult:: (pos: number, assoc: ?number) → MapResult
//   Map a position, and return an object containing additional
//   information about the mapping. The result's `deleted` field tells
//   you whether the position was deleted (completely enclosed in a
//   replaced range) during the mapping. When content on only one side
//   is deleted, the position itself is only considered deleted when
//   `assoc` points in the direction of the deleted content.

// Recovery values encode a range index and an offset. They are
// represented as numbers, because tons of them will be created when
// mapping, for example, a large number of decorations. The number's
// lower 16 bits provide the index, the remaining bits the offset.
//
// Note: We intentionally don't use bit shift operators to en- and
// decode these, since those clip to 32 bits, which we might in rare
// cases want to overflow. A 64-bit float can represent 48-bit
// integers precisely.

var lower16 = 0xffff;
var factor16 = Math.pow(2, 16);

function makeRecover(index, offset) { return index + offset * factor16 }
function recoverIndex(value) { return value & lower16 }
function recoverOffset(value) { return (value - (value & lower16)) / factor16 }

// ::- An object representing a mapped position with extra
// information.
var MapResult = function MapResult(pos, deleted, recover) {
  if ( deleted === void 0 ) deleted = false;
  if ( recover === void 0 ) recover = null;

  // :: number The mapped version of the position.
  this.pos = pos;
  // :: bool Tells you whether the position was deleted, that is,
  // whether the step removed its surroundings from the document.
  this.deleted = deleted;
  this.recover = recover;
};

// :: class extends Mappable
// A map describing the deletions and insertions made by a step, which
// can be used to find the correspondence between positions in the
// pre-step version of a document and the same position in the
// post-step version.
var StepMap = function StepMap(ranges, inverted) {
  if ( inverted === void 0 ) inverted = false;

  this.ranges = ranges;
  this.inverted = inverted;
};

StepMap.prototype.recover = function recover (value) {
  var diff = 0, index = recoverIndex(value);
  if (!this.inverted) { for (var i = 0; i < index; i++)
    { diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1]; } }
  return this.ranges[index * 3] + diff + recoverOffset(value)
};

// : (number, ?number) → MapResult
StepMap.prototype.mapResult = function mapResult (pos, assoc) {
  if ( assoc === void 0 ) assoc = 1;
 return this._map(pos, assoc, false) };

// : (number, ?number) → number
StepMap.prototype.map = function map (pos, assoc) {
  if ( assoc === void 0 ) assoc = 1;
 return this._map(pos, assoc, true) };

StepMap.prototype._map = function _map (pos, assoc, simple) {
  var diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
  for (var i = 0; i < this.ranges.length; i += 3) {
    var start = this.ranges[i] - (this.inverted ? diff : 0);
    if (start > pos) { break }
    var oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end = start + oldSize;
    if (pos <= end) {
      var side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc;
      var result = start + diff + (side < 0 ? 0 : newSize);
      if (simple) { return result }
      var recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(i / 3, pos - start);
      return new MapResult(result, assoc < 0 ? pos != start : pos != end, recover)
    }
    diff += newSize - oldSize;
  }
  return simple ? pos + diff : new MapResult(pos + diff)
};

StepMap.prototype.touches = function touches (pos, recover) {
  var diff = 0, index = recoverIndex(recover);
  var oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
  for (var i = 0; i < this.ranges.length; i += 3) {
    var start = this.ranges[i] - (this.inverted ? diff : 0);
    if (start > pos) { break }
    var oldSize = this.ranges[i + oldIndex], end = start + oldSize;
    if (pos <= end && i == index * 3) { return true }
    diff += this.ranges[i + newIndex] - oldSize;
  }
  return false
};

// :: ((oldStart: number, oldEnd: number, newStart: number, newEnd: number))
// Calls the given function on each of the changed ranges included in
// this map.
StepMap.prototype.forEach = function forEach (f) {
  var oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
  for (var i = 0, diff = 0; i < this.ranges.length; i += 3) {
    var start = this.ranges[i], oldStart = start - (this.inverted ? diff : 0), newStart = start + (this.inverted ? 0 : diff);
    var oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex];
    f(oldStart, oldStart + oldSize, newStart, newStart + newSize);
    diff += newSize - oldSize;
  }
};

// :: () → StepMap
// Create an inverted version of this map. The result can be used to
// map positions in the post-step document to the pre-step document.
StepMap.prototype.invert = function invert () {
  return new StepMap(this.ranges, !this.inverted)
};

StepMap.prototype.toString = function toString () {
  return (this.inverted ? "-" : "") + JSON.stringify(this.ranges)
};

// :: (n: number) → StepMap
// Create a map that moves all positions by offset `n` (which may be
// negative). This can be useful when applying steps meant for a
// sub-document to a larger document, or vice-versa.
StepMap.offset = function offset (n) {
  return n == 0 ? StepMap.empty : new StepMap(n < 0 ? [0, -n, 0] : [0, 0, n])
};

StepMap.empty = new StepMap([]);

// :: class extends Mappable
// A mapping represents a pipeline of zero or more [step
// maps](#transform.StepMap). It has special provisions for losslessly
// handling mapping positions through a series of steps in which some
// steps are inverted versions of earlier steps. (This comes up when
// ‘[rebasing](/docs/guide/#transform.rebasing)’ steps for
// collaboration or history management.)
var Mapping = function Mapping(maps, mirror, from, to) {
  // :: [StepMap]
  // The step maps in this mapping.
  this.maps = maps || [];
  // :: number
  // The starting position in the `maps` array, used when `map` or
  // `mapResult` is called.
  this.from = from || 0;
  // :: number
  // The end position in the `maps` array.
  this.to = to == null ? this.maps.length : to;
  this.mirror = mirror;
};

// :: (?number, ?number) → Mapping
// Create a mapping that maps only through a part of this one.
Mapping.prototype.slice = function slice (from, to) {
    if ( from === void 0 ) from = 0;
    if ( to === void 0 ) to = this.maps.length;

  return new Mapping(this.maps, this.mirror, from, to)
};

Mapping.prototype.copy = function copy () {
  return new Mapping(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to)
};

// :: (StepMap, ?number)
// Add a step map to the end of this mapping. If `mirrors` is
// given, it should be the index of the step map that is the mirror
// image of this one.
Mapping.prototype.appendMap = function appendMap (map, mirrors) {
  this.to = this.maps.push(map);
  if (mirrors != null) { this.setMirror(this.maps.length - 1, mirrors); }
};

// :: (Mapping)
// Add all the step maps in a given mapping to this one (preserving
// mirroring information).
Mapping.prototype.appendMapping = function appendMapping (mapping) {
  for (var i = 0, startSize = this.maps.length; i < mapping.maps.length; i++) {
    var mirr = mapping.getMirror(i);
    this.appendMap(mapping.maps[i], mirr != null && mirr < i ? startSize + mirr : null);
  }
};

// :: (number) → ?number
// Finds the offset of the step map that mirrors the map at the
// given offset, in this mapping (as per the second argument to
// `appendMap`).
Mapping.prototype.getMirror = function getMirror (n) {
  if (this.mirror) { for (var i = 0; i < this.mirror.length; i++)
    { if (this.mirror[i] == n) { return this.mirror[i + (i % 2 ? -1 : 1)] } } }
};

Mapping.prototype.setMirror = function setMirror (n, m) {
  if (!this.mirror) { this.mirror = []; }
  this.mirror.push(n, m);
};

// :: (Mapping)
// Append the inverse of the given mapping to this one.
Mapping.prototype.appendMappingInverted = function appendMappingInverted (mapping) {
  for (var i = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i >= 0; i--) {
    var mirr = mapping.getMirror(i);
    this.appendMap(mapping.maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : null);
  }
};

// :: () → Mapping
// Create an inverted version of this mapping.
Mapping.prototype.invert = function invert () {
  var inverse = new Mapping;
  inverse.appendMappingInverted(this);
  return inverse
};

// : (number, ?number) → number
// Map a position through this mapping.
Mapping.prototype.map = function map (pos, assoc) {
    if ( assoc === void 0 ) assoc = 1;

  if (this.mirror) { return this._map(pos, assoc, true) }
  for (var i = this.from; i < this.to; i++)
    { pos = this.maps[i].map(pos, assoc); }
  return pos
};

// : (number, ?number) → MapResult
// Map a position through this mapping, returning a mapping
// result.
Mapping.prototype.mapResult = function mapResult (pos, assoc) {
  if ( assoc === void 0 ) assoc = 1;
 return this._map(pos, assoc, false) };

Mapping.prototype._map = function _map (pos, assoc, simple) {
  var deleted = false;

  for (var i = this.from; i < this.to; i++) {
    var map = this.maps[i], result = map.mapResult(pos, assoc);
    if (result.recover != null) {
      var corr = this.getMirror(i);
      if (corr != null && corr > i && corr < this.to) {
        i = corr;
        pos = this.maps[corr].recover(result.recover);
        continue
      }
    }

    if (result.deleted) { deleted = true; }
    pos = result.pos;
  }

  return simple ? pos : new MapResult(pos, deleted)
};

function TransformError(message) {
  var err = Error.call(this, message);
  err.__proto__ = TransformError.prototype;
  return err
}

TransformError.prototype = Object.create(Error.prototype);
TransformError.prototype.constructor = TransformError;
TransformError.prototype.name = "TransformError";

// ::- Abstraction to build up and track an array of
// [steps](#transform.Step) representing a document transformation.
//
// Most transforming methods return the `Transform` object itself, so
// that they can be chained.
var Transform = function Transform(doc) {
  // :: Node
  // The current document (the result of applying the steps in the
  // transform).
  this.doc = doc;
  // :: [Step]
  // The steps in this transform.
  this.steps = [];
  // :: [Node]
  // The documents before each of the steps.
  this.docs = [];
  // :: Mapping
  // A mapping with the maps for each of the steps in this transform.
  this.mapping = new Mapping;
};

var prototypeAccessors = { before: { configurable: true },docChanged: { configurable: true } };

// :: Node The starting document.
prototypeAccessors.before.get = function () { return this.docs.length ? this.docs[0] : this.doc };

// :: (step: Step) → this
// Apply a new step in this transform, saving the result. Throws an
// error when the step fails.
Transform.prototype.step = function step (object) {
  var result = this.maybeStep(object);
  if (result.failed) { throw new TransformError(result.failed) }
  return this
};

// :: (Step) → StepResult
// Try to apply a step in this transformation, ignoring it if it
// fails. Returns the step result.
Transform.prototype.maybeStep = function maybeStep (step) {
  var result = step.apply(this.doc);
  if (!result.failed) { this.addStep(step, result.doc); }
  return result
};

// :: bool
// True when the document has been changed (when there are any
// steps).
prototypeAccessors.docChanged.get = function () {
  return this.steps.length > 0
};

Transform.prototype.addStep = function addStep (step, doc) {
  this.docs.push(this.doc);
  this.steps.push(step);
  this.mapping.appendMap(step.getMap());
  this.doc = doc;
};

Object.defineProperties( Transform.prototype, prototypeAccessors );

function mustOverride() { throw new Error("Override me") }

var stepsByID = Object.create(null);

// ::- A step object represents an atomic change. It generally applies
// only to the document it was created for, since the positions
// stored in it will only make sense for that document.
//
// New steps are defined by creating classes that extend `Step`,
// overriding the `apply`, `invert`, `map`, `getMap` and `fromJSON`
// methods, and registering your class with a unique
// JSON-serialization identifier using
// [`Step.jsonID`](#transform.Step^jsonID).
var Step = function Step () {};

Step.prototype.apply = function apply (_doc) { return mustOverride() };

// :: () → StepMap
// Get the step map that represents the changes made by this step,
// and which can be used to transform between positions in the old
// and the new document.
Step.prototype.getMap = function getMap () { return StepMap.empty };

// :: (doc: Node) → Step
// Create an inverted version of this step. Needs the document as it
// was before the step as argument.
Step.prototype.invert = function invert (_doc) { return mustOverride() };

// :: (mapping: Mappable) → ?Step
// Map this step through a mappable thing, returning either a
// version of that step with its positions adjusted, or `null` if
// the step was entirely deleted by the mapping.
Step.prototype.map = function map (_mapping) { return mustOverride() };

// :: (other: Step) → ?Step
// Try to merge this step with another one, to be applied directly
// after it. Returns the merged step when possible, null if the
// steps can't be merged.
Step.prototype.merge = function merge (_other) { return null };

// :: () → Object
// Create a JSON-serializeable representation of this step. When
// defining this for a custom subclass, make sure the result object
// includes the step type's [JSON id](#transform.Step^jsonID) under
// the `stepType` property.
Step.prototype.toJSON = function toJSON () { return mustOverride() };

// :: (Schema, Object) → Step
// Deserialize a step from its JSON representation. Will call
// through to the step class' own implementation of this method.
Step.fromJSON = function fromJSON (schema, json) {
  if (!json || !json.stepType) { throw new RangeError("Invalid input for Step.fromJSON") }
  var type = stepsByID[json.stepType];
  if (!type) { throw new RangeError(("No step type " + (json.stepType) + " defined")) }
  return type.fromJSON(schema, json)
};

// :: (string, constructor<Step>)
// To be able to serialize steps to JSON, each step needs a string
// ID to attach to its JSON representation. Use this method to
// register an ID for your step classes. Try to pick something
// that's unlikely to clash with steps from other modules.
Step.jsonID = function jsonID (id, stepClass) {
  if (id in stepsByID) { throw new RangeError("Duplicate use of step JSON ID " + id) }
  stepsByID[id] = stepClass;
  stepClass.prototype.jsonID = id;
  return stepClass
};

// ::- The result of [applying](#transform.Step.apply) a step. Contains either a
// new document or a failure value.
var StepResult = function StepResult(doc, failed) {
  // :: ?Node The transformed document.
  this.doc = doc;
  // :: ?string Text providing information about a failed step.
  this.failed = failed;
};

// :: (Node) → StepResult
// Create a successful step result.
StepResult.ok = function ok (doc) { return new StepResult(doc, null) };

// :: (string) → StepResult
// Create a failed step result.
StepResult.fail = function fail (message) { return new StepResult(null, message) };

// :: (Node, number, number, Slice) → StepResult
// Call [`Node.replace`](#model.Node.replace) with the given
// arguments. Create a successful result if it succeeds, and a
// failed one if it throws a `ReplaceError`.
StepResult.fromReplace = function fromReplace (doc, from, to, slice) {
  try {
    return StepResult.ok(doc.replace(from, to, slice))
  } catch (e) {
    if (e instanceof prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.ReplaceError) { return StepResult.fail(e.message) }
    throw e
  }
};

// ::- Replace a part of the document with a slice of new content.
var ReplaceStep = /*@__PURE__*/(function (Step) {
  function ReplaceStep(from, to, slice, structure) {
    Step.call(this);
    // :: number
    // The start position of the replaced range.
    this.from = from;
    // :: number
    // The end position of the replaced range.
    this.to = to;
    // :: Slice
    // The slice to insert.
    this.slice = slice;
    this.structure = !!structure;
  }

  if ( Step ) ReplaceStep.__proto__ = Step;
  ReplaceStep.prototype = Object.create( Step && Step.prototype );
  ReplaceStep.prototype.constructor = ReplaceStep;

  ReplaceStep.prototype.apply = function apply (doc) {
    if (this.structure && contentBetween(doc, this.from, this.to))
      { return StepResult.fail("Structure replace would overwrite content") }
    return StepResult.fromReplace(doc, this.from, this.to, this.slice)
  };

  ReplaceStep.prototype.getMap = function getMap () {
    return new StepMap([this.from, this.to - this.from, this.slice.size])
  };

  ReplaceStep.prototype.invert = function invert (doc) {
    return new ReplaceStep(this.from, this.from + this.slice.size, doc.slice(this.from, this.to))
  };

  ReplaceStep.prototype.map = function map (mapping) {
    var from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from.deleted && to.deleted) { return null }
    return new ReplaceStep(from.pos, Math.max(from.pos, to.pos), this.slice)
  };

  ReplaceStep.prototype.merge = function merge (other) {
    if (!(other instanceof ReplaceStep) || other.structure || this.structure) { return null }

    if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {
      var slice = this.slice.size + other.slice.size == 0 ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty
          : new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);
      return new ReplaceStep(this.from, this.to + (other.to - other.from), slice, this.structure)
    } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {
      var slice$1 = this.slice.size + other.slice.size == 0 ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty
          : new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);
      return new ReplaceStep(other.from, this.to, slice$1, this.structure)
    } else {
      return null
    }
  };

  ReplaceStep.prototype.toJSON = function toJSON () {
    var json = {stepType: "replace", from: this.from, to: this.to};
    if (this.slice.size) { json.slice = this.slice.toJSON(); }
    if (this.structure) { json.structure = true; }
    return json
  };

  ReplaceStep.fromJSON = function fromJSON (schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      { throw new RangeError("Invalid input for ReplaceStep.fromJSON") }
    return new ReplaceStep(json.from, json.to, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.fromJSON(schema, json.slice), !!json.structure)
  };

  return ReplaceStep;
}(Step));

Step.jsonID("replace", ReplaceStep);

// ::- Replace a part of the document with a slice of content, but
// preserve a range of the replaced content by moving it into the
// slice.
var ReplaceAroundStep = /*@__PURE__*/(function (Step) {
  function ReplaceAroundStep(from, to, gapFrom, gapTo, slice, insert, structure) {
    Step.call(this);
    // :: number
    // The start position of the replaced range.
    this.from = from;
    // :: number
    // The end position of the replaced range.
    this.to = to;
    // :: number
    // The start of preserved range.
    this.gapFrom = gapFrom;
    // :: number
    // The end of preserved range.
    this.gapTo = gapTo;
    // :: Slice
    // The slice to insert.
    this.slice = slice;
    // :: number
    // The position in the slice where the preserved range should be
    // inserted.
    this.insert = insert;
    this.structure = !!structure;
  }

  if ( Step ) ReplaceAroundStep.__proto__ = Step;
  ReplaceAroundStep.prototype = Object.create( Step && Step.prototype );
  ReplaceAroundStep.prototype.constructor = ReplaceAroundStep;

  ReplaceAroundStep.prototype.apply = function apply (doc) {
    if (this.structure && (contentBetween(doc, this.from, this.gapFrom) ||
                           contentBetween(doc, this.gapTo, this.to)))
      { return StepResult.fail("Structure gap-replace would overwrite content") }

    var gap = doc.slice(this.gapFrom, this.gapTo);
    if (gap.openStart || gap.openEnd)
      { return StepResult.fail("Gap is not a flat range") }
    var inserted = this.slice.insertAt(this.insert, gap.content);
    if (!inserted) { return StepResult.fail("Content does not fit in gap") }
    return StepResult.fromReplace(doc, this.from, this.to, inserted)
  };

  ReplaceAroundStep.prototype.getMap = function getMap () {
    return new StepMap([this.from, this.gapFrom - this.from, this.insert,
                        this.gapTo, this.to - this.gapTo, this.slice.size - this.insert])
  };

  ReplaceAroundStep.prototype.invert = function invert (doc) {
    var gap = this.gapTo - this.gapFrom;
    return new ReplaceAroundStep(this.from, this.from + this.slice.size + gap,
                                 this.from + this.insert, this.from + this.insert + gap,
                                 doc.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from),
                                 this.gapFrom - this.from, this.structure)
  };

  ReplaceAroundStep.prototype.map = function map (mapping) {
    var from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    var gapFrom = mapping.map(this.gapFrom, -1), gapTo = mapping.map(this.gapTo, 1);
    if ((from.deleted && to.deleted) || gapFrom < from.pos || gapTo > to.pos) { return null }
    return new ReplaceAroundStep(from.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure)
  };

  ReplaceAroundStep.prototype.toJSON = function toJSON () {
    var json = {stepType: "replaceAround", from: this.from, to: this.to,
                gapFrom: this.gapFrom, gapTo: this.gapTo, insert: this.insert};
    if (this.slice.size) { json.slice = this.slice.toJSON(); }
    if (this.structure) { json.structure = true; }
    return json
  };

  ReplaceAroundStep.fromJSON = function fromJSON (schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number" ||
        typeof json.gapFrom != "number" || typeof json.gapTo != "number" || typeof json.insert != "number")
      { throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON") }
    return new ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo,
                                 prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.fromJSON(schema, json.slice), json.insert, !!json.structure)
  };

  return ReplaceAroundStep;
}(Step));

Step.jsonID("replaceAround", ReplaceAroundStep);

function contentBetween(doc, from, to) {
  var $from = doc.resolve(from), dist = to - from, depth = $from.depth;
  while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {
    depth--;
    dist--;
  }
  if (dist > 0) {
    var next = $from.node(depth).maybeChild($from.indexAfter(depth));
    while (dist > 0) {
      if (!next || next.isLeaf) { return true }
      next = next.firstChild;
      dist--;
    }
  }
  return false
}

function canCut(node, start, end) {
  return (start == 0 || node.canReplace(start, node.childCount)) &&
    (end == node.childCount || node.canReplace(0, end))
}

// :: (NodeRange) → ?number
// Try to find a target depth to which the content in the given range
// can be lifted. Will not go across
// [isolating](#model.NodeSpec.isolating) parent nodes.
function liftTarget(range) {
  var parent = range.parent;
  var content = parent.content.cutByIndex(range.startIndex, range.endIndex);
  for (var depth = range.depth;; --depth) {
    var node = range.$from.node(depth);
    var index = range.$from.index(depth), endIndex = range.$to.indexAfter(depth);
    if (depth < range.depth && node.canReplace(index, endIndex, content))
      { return depth }
    if (depth == 0 || node.type.spec.isolating || !canCut(node, index, endIndex)) { break }
  }
}

// :: (NodeRange, number) → this
// Split the content in the given range off from its parent, if there
// is sibling content before or after it, and move it up the tree to
// the depth specified by `target`. You'll probably want to use
// [`liftTarget`](#transform.liftTarget) to compute `target`, to make
// sure the lift is valid.
Transform.prototype.lift = function(range, target) {
  var $from = range.$from;
  var $to = range.$to;
  var depth = range.depth;

  var gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);
  var start = gapStart, end = gapEnd;

  var before = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, openStart = 0;
  for (var d = depth, splitting = false; d > target; d--)
    { if (splitting || $from.index(d) > 0) {
      splitting = true;
      before = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from($from.node(d).copy(before));
      openStart++;
    } else {
      start--;
    } }
  var after = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, openEnd = 0;
  for (var d$1 = depth, splitting$1 = false; d$1 > target; d$1--)
    { if (splitting$1 || $to.after(d$1 + 1) < $to.end(d$1)) {
      splitting$1 = true;
      after = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from($to.node(d$1).copy(after));
      openEnd++;
    } else {
      end++;
    } }

  return this.step(new ReplaceAroundStep(start, end, gapStart, gapEnd,
                                         new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(before.append(after), openStart, openEnd),
                                         before.size - openStart, true))
};

// :: (NodeRange, NodeType, ?Object, ?NodeRange) → ?[{type: NodeType, attrs: ?Object}]
// Try to find a valid way to wrap the content in the given range in a
// node of the given type. May introduce extra nodes around and inside
// the wrapper node, if necessary. Returns null if no valid wrapping
// could be found. When `innerRange` is given, that range's content is
// used as the content to fit into the wrapping, instead of the
// content of `range`.
function findWrapping(range, nodeType, attrs, innerRange) {
  if ( innerRange === void 0 ) innerRange = range;

  var around = findWrappingOutside(range, nodeType);
  var inner = around && findWrappingInside(innerRange, nodeType);
  if (!inner) { return null }
  return around.map(withAttrs).concat({type: nodeType, attrs: attrs}).concat(inner.map(withAttrs))
}

function withAttrs(type) { return {type: type, attrs: null} }

function findWrappingOutside(range, type) {
  var parent = range.parent;
  var startIndex = range.startIndex;
  var endIndex = range.endIndex;
  var around = parent.contentMatchAt(startIndex).findWrapping(type);
  if (!around) { return null }
  var outer = around.length ? around[0] : type;
  return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null
}

function findWrappingInside(range, type) {
  var parent = range.parent;
  var startIndex = range.startIndex;
  var endIndex = range.endIndex;
  var inner = parent.child(startIndex);
  var inside = type.contentMatch.findWrapping(inner.type);
  if (!inside) { return null }
  var lastType = inside.length ? inside[inside.length - 1] : type;
  var innerMatch = lastType.contentMatch;
  for (var i = startIndex; innerMatch && i < endIndex; i++)
    { innerMatch = innerMatch.matchType(parent.child(i).type); }
  if (!innerMatch || !innerMatch.validEnd) { return null }
  return inside
}

// :: (NodeRange, [{type: NodeType, attrs: ?Object}]) → this
// Wrap the given [range](#model.NodeRange) in the given set of wrappers.
// The wrappers are assumed to be valid in this position, and should
// probably be computed with [`findWrapping`](#transform.findWrapping).
Transform.prototype.wrap = function(range, wrappers) {
  var content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty;
  for (var i = wrappers.length - 1; i >= 0; i--)
    { content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content)); }

  var start = range.start, end = range.end;
  return this.step(new ReplaceAroundStep(start, end, start, end, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(content, 0, 0), wrappers.length, true))
};

// :: (number, ?number, NodeType, ?Object) → this
// Set the type of all textblocks (partly) between `from` and `to` to
// the given node type with the given attributes.
Transform.prototype.setBlockType = function(from, to, type, attrs) {
  var this$1 = this;
  if ( to === void 0 ) to = from;

  if (!type.isTextblock) { throw new RangeError("Type given to setBlockType should be a textblock") }
  var mapFrom = this.steps.length;
  this.doc.nodesBetween(from, to, function (node, pos) {
    if (node.isTextblock && !node.hasMarkup(type, attrs) && canChangeType(this$1.doc, this$1.mapping.slice(mapFrom).map(pos), type)) {
      // Ensure all markup that isn't allowed in the new node type is cleared
      this$1.clearIncompatible(this$1.mapping.slice(mapFrom).map(pos, 1), type);
      var mapping = this$1.mapping.slice(mapFrom);
      var startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1);
      this$1.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1,
                                      new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(type.create(attrs, null, node.marks)), 0, 0), 1, true));
      return false
    }
  });
  return this
};

function canChangeType(doc, pos, type) {
  var $pos = doc.resolve(pos), index = $pos.index();
  return $pos.parent.canReplaceWith(index, index + 1, type)
}

// :: (number, ?NodeType, ?Object, ?[Mark]) → this
// Change the type, attributes, and/or marks of the node at `pos`.
// When `type` isn't given, the existing node type is preserved,
Transform.prototype.setNodeMarkup = function(pos, type, attrs, marks) {
  var node = this.doc.nodeAt(pos);
  if (!node) { throw new RangeError("No node at given position") }
  if (!type) { type = node.type; }
  var newNode = type.create(attrs, null, marks || node.marks);
  if (node.isLeaf)
    { return this.replaceWith(pos, pos + node.nodeSize, newNode) }

  if (!type.validContent(node.content))
    { throw new RangeError("Invalid content for node type " + type.name) }

  return this.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1,
                                         new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(newNode), 0, 0), 1, true))
};

// :: (Node, number, number, ?[?{type: NodeType, attrs: ?Object}]) → bool
// Check whether splitting at the given position is allowed.
function canSplit(doc, pos, depth, typesAfter) {
  if ( depth === void 0 ) depth = 1;

  var $pos = doc.resolve(pos), base = $pos.depth - depth;
  var innerType = (typesAfter && typesAfter[typesAfter.length - 1]) || $pos.parent;
  if (base < 0 || $pos.parent.type.spec.isolating ||
      !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) ||
      !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)))
    { return false }
  for (var d = $pos.depth - 1, i = depth - 2; d > base; d--, i--) {
    var node = $pos.node(d), index$1 = $pos.index(d);
    if (node.type.spec.isolating) { return false }
    var rest = node.content.cutByIndex(index$1, node.childCount);
    var after = (typesAfter && typesAfter[i]) || node;
    if (after != node) { rest = rest.replaceChild(0, after.type.create(after.attrs)); }
    if (!node.canReplace(index$1 + 1, node.childCount) || !after.type.validContent(rest))
      { return false }
  }
  var index = $pos.indexAfter(base);
  var baseType = typesAfter && typesAfter[0];
  return $pos.node(base).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base + 1).type)
}

// :: (number, ?number, ?[?{type: NodeType, attrs: ?Object}]) → this
// Split the node at the given position, and optionally, if `depth` is
// greater than one, any number of nodes above that. By default, the
// parts split off will inherit the node type of the original node.
// This can be changed by passing an array of types and attributes to
// use after the split.
Transform.prototype.split = function(pos, depth, typesAfter) {
  if ( depth === void 0 ) depth = 1;

  var $pos = this.doc.resolve(pos), before = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, after = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty;
  for (var d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {
    before = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from($pos.node(d).copy(before));
    var typeAfter = typesAfter && typesAfter[i];
    after = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after));
  }
  return this.step(new ReplaceStep(pos, pos, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(before.append(after), depth, depth), true))
};

// :: (Node, number) → bool
// Test whether the blocks before and after a given position can be
// joined.
function canJoin(doc, pos) {
  var $pos = doc.resolve(pos), index = $pos.index();
  return joinable($pos.nodeBefore, $pos.nodeAfter) &&
    $pos.parent.canReplace(index, index + 1)
}

function joinable(a, b) {
  return a && b && !a.isLeaf && a.canAppend(b)
}

// :: (Node, number, ?number) → ?number
// Find an ancestor of the given position that can be joined to the
// block before (or after if `dir` is positive). Returns the joinable
// point, if any.
function joinPoint(doc, pos, dir) {
  if ( dir === void 0 ) dir = -1;

  var $pos = doc.resolve(pos);
  for (var d = $pos.depth;; d--) {
    var before = (void 0), after = (void 0), index = $pos.index(d);
    if (d == $pos.depth) {
      before = $pos.nodeBefore;
      after = $pos.nodeAfter;
    } else if (dir > 0) {
      before = $pos.node(d + 1);
      index++;
      after = $pos.node(d).maybeChild(index);
    } else {
      before = $pos.node(d).maybeChild(index - 1);
      after = $pos.node(d + 1);
    }
    if (before && !before.isTextblock && joinable(before, after) &&
        $pos.node(d).canReplace(index, index + 1)) { return pos }
    if (d == 0) { break }
    pos = dir < 0 ? $pos.before(d) : $pos.after(d);
  }
}

// :: (number, ?number) → this
// Join the blocks around the given position. If depth is 2, their
// last and first siblings are also joined, and so on.
Transform.prototype.join = function(pos, depth) {
  if ( depth === void 0 ) depth = 1;

  var step = new ReplaceStep(pos - depth, pos + depth, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty, true);
  return this.step(step)
};

// :: (Node, number, NodeType) → ?number
// Try to find a point where a node of the given type can be inserted
// near `pos`, by searching up the node hierarchy when `pos` itself
// isn't a valid place but is at the start or end of a node. Return
// null if no position was found.
function insertPoint(doc, pos, nodeType) {
  var $pos = doc.resolve(pos);
  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType)) { return pos }

  if ($pos.parentOffset == 0)
    { for (var d = $pos.depth - 1; d >= 0; d--) {
      var index = $pos.index(d);
      if ($pos.node(d).canReplaceWith(index, index, nodeType)) { return $pos.before(d + 1) }
      if (index > 0) { return null }
    } }
  if ($pos.parentOffset == $pos.parent.content.size)
    { for (var d$1 = $pos.depth - 1; d$1 >= 0; d$1--) {
      var index$1 = $pos.indexAfter(d$1);
      if ($pos.node(d$1).canReplaceWith(index$1, index$1, nodeType)) { return $pos.after(d$1 + 1) }
      if (index$1 < $pos.node(d$1).childCount) { return null }
    } }
}

// :: (Node, number, Slice) → ?number
// Finds a position at or around the given position where the given
// slice can be inserted. Will look at parent nodes' nearest boundary
// and try there, even if the original position wasn't directly at the
// start or end of that node. Returns null when no position was found.
function dropPoint(doc, pos, slice) {
  var $pos = doc.resolve(pos);
  if (!slice.content.size) { return pos }
  var content = slice.content;
  for (var i = 0; i < slice.openStart; i++) { content = content.firstChild.content; }
  for (var pass = 1; pass <= (slice.openStart == 0 && slice.size ? 2 : 1); pass++) {
    for (var d = $pos.depth; d >= 0; d--) {
      var bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;
      var insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);
      var parent = $pos.node(d), fits = false;
      if (pass == 1) {
        fits = parent.canReplace(insertPos, insertPos, content);
      } else {
        var wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type);
        fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);
      }
      if (fits)
        { return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1) }
    }
  }
  return null
}

function mapFragment(fragment, f, parent) {
  var mapped = [];
  for (var i = 0; i < fragment.childCount; i++) {
    var child = fragment.child(i);
    if (child.content.size) { child = child.copy(mapFragment(child.content, f, child)); }
    if (child.isInline) { child = f(child, parent, i); }
    mapped.push(child);
  }
  return prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.fromArray(mapped)
}

// ::- Add a mark to all inline content between two positions.
var AddMarkStep = /*@__PURE__*/(function (Step) {
  function AddMarkStep(from, to, mark) {
    Step.call(this);
    // :: number
    // The start of the marked range.
    this.from = from;
    // :: number
    // The end of the marked range.
    this.to = to;
    // :: Mark
    // The mark to add.
    this.mark = mark;
  }

  if ( Step ) AddMarkStep.__proto__ = Step;
  AddMarkStep.prototype = Object.create( Step && Step.prototype );
  AddMarkStep.prototype.constructor = AddMarkStep;

  AddMarkStep.prototype.apply = function apply (doc) {
    var this$1 = this;

    var oldSlice = doc.slice(this.from, this.to), $from = doc.resolve(this.from);
    var parent = $from.node($from.sharedDepth(this.to));
    var slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(mapFragment(oldSlice.content, function (node, parent) {
      if (!node.isAtom || !parent.type.allowsMarkType(this$1.mark.type)) { return node }
      return node.mark(this$1.mark.addToSet(node.marks))
    }, parent), oldSlice.openStart, oldSlice.openEnd);
    return StepResult.fromReplace(doc, this.from, this.to, slice)
  };

  AddMarkStep.prototype.invert = function invert () {
    return new RemoveMarkStep(this.from, this.to, this.mark)
  };

  AddMarkStep.prototype.map = function map (mapping) {
    var from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from.deleted && to.deleted || from.pos >= to.pos) { return null }
    return new AddMarkStep(from.pos, to.pos, this.mark)
  };

  AddMarkStep.prototype.merge = function merge (other) {
    if (other instanceof AddMarkStep &&
        other.mark.eq(this.mark) &&
        this.from <= other.to && this.to >= other.from)
      { return new AddMarkStep(Math.min(this.from, other.from),
                             Math.max(this.to, other.to), this.mark) }
  };

  AddMarkStep.prototype.toJSON = function toJSON () {
    return {stepType: "addMark", mark: this.mark.toJSON(),
            from: this.from, to: this.to}
  };

  AddMarkStep.fromJSON = function fromJSON (schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      { throw new RangeError("Invalid input for AddMarkStep.fromJSON") }
    return new AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark))
  };

  return AddMarkStep;
}(Step));

Step.jsonID("addMark", AddMarkStep);

// ::- Remove a mark from all inline content between two positions.
var RemoveMarkStep = /*@__PURE__*/(function (Step) {
  function RemoveMarkStep(from, to, mark) {
    Step.call(this);
    // :: number
    // The start of the unmarked range.
    this.from = from;
    // :: number
    // The end of the unmarked range.
    this.to = to;
    // :: Mark
    // The mark to remove.
    this.mark = mark;
  }

  if ( Step ) RemoveMarkStep.__proto__ = Step;
  RemoveMarkStep.prototype = Object.create( Step && Step.prototype );
  RemoveMarkStep.prototype.constructor = RemoveMarkStep;

  RemoveMarkStep.prototype.apply = function apply (doc) {
    var this$1 = this;

    var oldSlice = doc.slice(this.from, this.to);
    var slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(mapFragment(oldSlice.content, function (node) {
      return node.mark(this$1.mark.removeFromSet(node.marks))
    }), oldSlice.openStart, oldSlice.openEnd);
    return StepResult.fromReplace(doc, this.from, this.to, slice)
  };

  RemoveMarkStep.prototype.invert = function invert () {
    return new AddMarkStep(this.from, this.to, this.mark)
  };

  RemoveMarkStep.prototype.map = function map (mapping) {
    var from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from.deleted && to.deleted || from.pos >= to.pos) { return null }
    return new RemoveMarkStep(from.pos, to.pos, this.mark)
  };

  RemoveMarkStep.prototype.merge = function merge (other) {
    if (other instanceof RemoveMarkStep &&
        other.mark.eq(this.mark) &&
        this.from <= other.to && this.to >= other.from)
      { return new RemoveMarkStep(Math.min(this.from, other.from),
                                Math.max(this.to, other.to), this.mark) }
  };

  RemoveMarkStep.prototype.toJSON = function toJSON () {
    return {stepType: "removeMark", mark: this.mark.toJSON(),
            from: this.from, to: this.to}
  };

  RemoveMarkStep.fromJSON = function fromJSON (schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      { throw new RangeError("Invalid input for RemoveMarkStep.fromJSON") }
    return new RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark))
  };

  return RemoveMarkStep;
}(Step));

Step.jsonID("removeMark", RemoveMarkStep);

// :: (number, number, Mark) → this
// Add the given mark to the inline content between `from` and `to`.
Transform.prototype.addMark = function(from, to, mark) {
  var this$1 = this;

  var removed = [], added = [], removing = null, adding = null;
  this.doc.nodesBetween(from, to, function (node, pos, parent) {
    if (!node.isInline) { return }
    var marks = node.marks;
    if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {
      var start = Math.max(pos, from), end = Math.min(pos + node.nodeSize, to);
      var newSet = mark.addToSet(marks);

      for (var i = 0; i < marks.length; i++) {
        if (!marks[i].isInSet(newSet)) {
          if (removing && removing.to == start && removing.mark.eq(marks[i]))
            { removing.to = end; }
          else
            { removed.push(removing = new RemoveMarkStep(start, end, marks[i])); }
        }
      }

      if (adding && adding.to == start)
        { adding.to = end; }
      else
        { added.push(adding = new AddMarkStep(start, end, mark)); }
    }
  });

  removed.forEach(function (s) { return this$1.step(s); });
  added.forEach(function (s) { return this$1.step(s); });
  return this
};

// :: (number, number, ?union<Mark, MarkType>) → this
// Remove marks from inline nodes between `from` and `to`. When `mark`
// is a single mark, remove precisely that mark. When it is a mark type,
// remove all marks of that type. When it is null, remove all marks of
// any type.
Transform.prototype.removeMark = function(from, to, mark) {
  var this$1 = this;
  if ( mark === void 0 ) mark = null;

  var matched = [], step = 0;
  this.doc.nodesBetween(from, to, function (node, pos) {
    if (!node.isInline) { return }
    step++;
    var toRemove = null;
    if (mark instanceof prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.MarkType) {
      var set = node.marks, found;
      while (found = mark.isInSet(set)) {
(toRemove || (toRemove = [])).push(found);
        set = found.removeFromSet(set);
      }
    } else if (mark) {
      if (mark.isInSet(node.marks)) { toRemove = [mark]; }
    } else {
      toRemove = node.marks;
    }
    if (toRemove && toRemove.length) {
      var end = Math.min(pos + node.nodeSize, to);
      for (var i = 0; i < toRemove.length; i++) {
        var style = toRemove[i], found$1 = (void 0);
        for (var j = 0; j < matched.length; j++) {
          var m = matched[j];
          if (m.step == step - 1 && style.eq(matched[j].style)) { found$1 = m; }
        }
        if (found$1) {
          found$1.to = end;
          found$1.step = step;
        } else {
          matched.push({style: style, from: Math.max(pos, from), to: end, step: step});
        }
      }
    }
  });
  matched.forEach(function (m) { return this$1.step(new RemoveMarkStep(m.from, m.to, m.style)); });
  return this
};

// :: (number, NodeType, ?ContentMatch) → this
// Removes all marks and nodes from the content of the node at `pos`
// that don't match the given new parent node type. Accepts an
// optional starting [content match](#model.ContentMatch) as third
// argument.
Transform.prototype.clearIncompatible = function(pos, parentType, match) {
  if ( match === void 0 ) match = parentType.contentMatch;

  var node = this.doc.nodeAt(pos);
  var delSteps = [], cur = pos + 1;
  for (var i = 0; i < node.childCount; i++) {
    var child = node.child(i), end = cur + child.nodeSize;
    var allowed = match.matchType(child.type, child.attrs);
    if (!allowed) {
      delSteps.push(new ReplaceStep(cur, end, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty));
    } else {
      match = allowed;
      for (var j = 0; j < child.marks.length; j++) { if (!parentType.allowsMarkType(child.marks[j].type))
        { this.step(new RemoveMarkStep(cur, end, child.marks[j])); } }
    }
    cur = end;
  }
  if (!match.validEnd) {
    var fill = match.fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true);
    this.replace(cur, cur, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(fill, 0, 0));
  }
  for (var i$1 = delSteps.length - 1; i$1 >= 0; i$1--) { this.step(delSteps[i$1]); }
  return this
};

// :: (Node, number, ?number, ?Slice) → ?Step
// ‘Fit’ a slice into a given position in the document, producing a
// [step](#transform.Step) that inserts it. Will return null if
// there's no meaningful way to insert the slice here, or inserting it
// would be a no-op (an empty slice over an empty range).
function replaceStep(doc, from, to, slice) {
  if ( to === void 0 ) to = from;
  if ( slice === void 0 ) slice = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty;

  if (from == to && !slice.size) { return null }

  var $from = doc.resolve(from), $to = doc.resolve(to);
  // Optimization -- avoid work if it's obvious that it's not needed.
  if (fitsTrivially($from, $to, slice)) { return new ReplaceStep(from, to, slice) }
  return new Fitter($from, $to, slice).fit()
}

// :: (number, ?number, ?Slice) → this
// Replace the part of the document between `from` and `to` with the
// given `slice`.
Transform.prototype.replace = function(from, to, slice) {
  if ( to === void 0 ) to = from;
  if ( slice === void 0 ) slice = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty;

  var step = replaceStep(this.doc, from, to, slice);
  if (step) { this.step(step); }
  return this
};

// :: (number, number, union<Fragment, Node, [Node]>) → this
// Replace the given range with the given content, which may be a
// fragment, node, or array of nodes.
Transform.prototype.replaceWith = function(from, to, content) {
  return this.replace(from, to, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(content), 0, 0))
};

// :: (number, number) → this
// Delete the content between the given positions.
Transform.prototype.delete = function(from, to) {
  return this.replace(from, to, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty)
};

// :: (number, union<Fragment, Node, [Node]>) → this
// Insert the given content at the given position.
Transform.prototype.insert = function(pos, content) {
  return this.replaceWith(pos, pos, content)
};

function fitsTrivially($from, $to, slice) {
  return !slice.openStart && !slice.openEnd && $from.start() == $to.start() &&
    $from.parent.canReplace($from.index(), $to.index(), slice.content)
}

// Algorithm for 'placing' the elements of a slice into a gap:
//
// We consider the content of each node that is open to the left to be
// independently placeable. I.e. in <p("foo"), p("bar")>, when the
// paragraph on the left is open, "foo" can be placed (somewhere on
// the left side of the replacement gap) independently from p("bar").
//
// This class tracks the state of the placement progress in the
// following properties:
//
//  - `frontier` holds a stack of `{type, match}` objects that
//    represent the open side of the replacement. It starts at
//    `$from`, then moves forward as content is placed, and is finally
//    reconciled with `$to`.
//
//  - `unplaced` is a slice that represents the content that hasn't
//    been placed yet.
//
//  - `placed` is a fragment of placed content. Its open-start value
//    is implicit in `$from`, and its open-end value in `frontier`.
var Fitter = function Fitter($from, $to, slice) {
  this.$to = $to;
  this.$from = $from;
  this.unplaced = slice;

  this.frontier = [];
  for (var i = 0; i <= $from.depth; i++) {
    var node = $from.node(i);
    this.frontier.push({
      type: node.type,
      match: node.contentMatchAt($from.indexAfter(i))
    });
  }

  this.placed = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty;
  for (var i$1 = $from.depth; i$1 > 0; i$1--)
    { this.placed = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from($from.node(i$1).copy(this.placed)); }
};

var prototypeAccessors$1 = { depth: { configurable: true } };

prototypeAccessors$1.depth.get = function () { return this.frontier.length - 1 };

Fitter.prototype.fit = function fit () {
  // As long as there's unplaced content, try to place some of it.
  // If that fails, either increase the open score of the unplaced
  // slice, or drop nodes from it, and then try again.
  while (this.unplaced.size) {
    var fit = this.findFittable();
    if (fit) { this.placeNodes(fit); }
    else { this.openMore() || this.dropNode(); }
  }
  // When there's inline content directly after the frontier _and_
  // directly after `this.$to`, we must generate a `ReplaceAround`
  // step that pulls that content into the node after the frontier.
  // That means the fitting must be done to the end of the textblock
  // node after `this.$to`, not `this.$to` itself.
  var moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;
  var $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));
  if (!$to) { return null }

  // If closing to `$to` succeeded, create a step
  var content = this.placed, openStart = $from.depth, openEnd = $to.depth;
  while (openStart && openEnd && content.childCount == 1) { // Normalize by dropping open parent nodes
    content = content.firstChild.content;
    openStart--; openEnd--;
  }
  var slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(content, openStart, openEnd);
  if (moveInline > -1)
    { return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice, placedSize) }
  if (slice.size || $from.pos != this.$to.pos) // Don't generate no-op steps
    { return new ReplaceStep($from.pos, $to.pos, slice) }
};

// Find a position on the start spine of `this.unplaced` that has
// content that can be moved somewhere on the frontier. Returns two
// depths, one for the slice and one for the frontier.
Fitter.prototype.findFittable = function findFittable () {
  // Only try wrapping nodes (pass 2) after finding a place without
  // wrapping failed.
  for (var pass = 1; pass <= 2; pass++) {
    for (var sliceDepth = this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {
      var fragment = (void 0), parent = (void 0);
      if (sliceDepth) {
        parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;
        fragment = parent.content;
      } else {
        fragment = this.unplaced.content;
      }
      var first = fragment.firstChild;
      for (var frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {
        var ref = this.frontier[frontierDepth];
          var type = ref.type;
          var match = ref.match;
          var wrap = (void 0), inject = (void 0);
        // In pass 1, if the next node matches, or there is no next
        // node but the parents look compatible, we've found a
        // place.
        if (pass == 1 && (first ? match.matchType(first.type) || (inject = match.fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(first), false))
                          : type.compatibleContent(parent.type)))
          { return {sliceDepth: sliceDepth, frontierDepth: frontierDepth, parent: parent, inject: inject} }
        // In pass 2, look for a set of wrapping nodes that make
        // `first` fit here.
        else if (pass == 2 && first && (wrap = match.findWrapping(first.type)))
          { return {sliceDepth: sliceDepth, frontierDepth: frontierDepth, parent: parent, wrap: wrap} }
        // Don't continue looking further up if the parent node
        // would fit here.
        if (parent && match.matchType(parent.type)) { break }
      }
    }
  }
};

Fitter.prototype.openMore = function openMore () {
  var ref = this.unplaced;
    var content = ref.content;
    var openStart = ref.openStart;
    var openEnd = ref.openEnd;
  var inner = contentAt(content, openStart);
  if (!inner.childCount || inner.firstChild.isLeaf) { return false }
  this.unplaced = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(content, openStart + 1,
                            Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0));
  return true
};

Fitter.prototype.dropNode = function dropNode () {
  var ref = this.unplaced;
    var content = ref.content;
    var openStart = ref.openStart;
    var openEnd = ref.openEnd;
  var inner = contentAt(content, openStart);
  if (inner.childCount <= 1 && openStart > 0) {
    var openAtEnd = content.size - openStart <= openStart + inner.size;
    this.unplaced = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1,
                              openAtEnd ? openStart - 1 : openEnd);
  } else {
    this.unplaced = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(dropFromFragment(content, openStart, 1), openStart, openEnd);
  }
};

// : ({sliceDepth: number, frontierDepth: number, parent: ?Node, wrap: ?[NodeType], inject: ?Fragment})
// Move content from the unplaced slice at `sliceDepth` to the
// frontier node at `frontierDepth`. Close that frontier node when
// applicable.
Fitter.prototype.placeNodes = function placeNodes (ref) {
    var sliceDepth = ref.sliceDepth;
    var frontierDepth = ref.frontierDepth;
    var parent = ref.parent;
    var inject = ref.inject;
    var wrap = ref.wrap;

  while (this.depth > frontierDepth) { this.closeFrontierNode(); }
  if (wrap) { for (var i = 0; i < wrap.length; i++) { this.openFrontierNode(wrap[i]); } }

  var slice = this.unplaced, fragment = parent ? parent.content : slice.content;
  var openStart = slice.openStart - sliceDepth;
  var taken = 0, add = [];
  var ref$1 = this.frontier[frontierDepth];
    var match = ref$1.match;
    var type = ref$1.type;
  if (inject) {
    for (var i$1 = 0; i$1 < inject.childCount; i$1++) { add.push(inject.child(i$1)); }
    match = match.matchFragment(inject);
  }
  // Computes the amount of (end) open nodes at the end of the
  // fragment. When 0, the parent is open, but no more. When
  // negative, nothing is open.
  var openEndCount = (fragment.size + sliceDepth) - (slice.content.size - slice.openEnd);
  // Scan over the fragment, fitting as many child nodes as
  // possible.
  while (taken < fragment.childCount) {
    var next = fragment.child(taken), matches = match.matchType(next.type);
    if (!matches) { break }
    taken++;
    if (taken > 1 || openStart == 0 || next.content.size) { // Drop empty open nodes
      match = matches;
      add.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0,
                              taken == fragment.childCount ? openEndCount : -1));
    }
  }
  var toEnd = taken == fragment.childCount;
  if (!toEnd) { openEndCount = -1; }

  this.placed = addToFragment(this.placed, frontierDepth, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(add));
  this.frontier[frontierDepth].match = match;

  // If the parent types match, and the entire node was moved, and
  // it's not open, close this frontier node right away.
  if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1)
    { this.closeFrontierNode(); }

  // Add new frontier nodes for any open nodes at the end.
  for (var i$2 = 0, cur = fragment; i$2 < openEndCount; i$2++) {
    var node = cur.lastChild;
    this.frontier.push({type: node.type, match: node.contentMatchAt(node.childCount)});
    cur = node.content;
  }

  // Update `this.unplaced`. Drop the entire node from which we
  // placed it we got to its end, otherwise just drop the placed
  // nodes.
  this.unplaced = !toEnd ? new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(dropFromFragment(slice.content, sliceDepth, taken), slice.openStart, slice.openEnd)
    : sliceDepth == 0 ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty
    : new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(dropFromFragment(slice.content, sliceDepth - 1, 1),
                sliceDepth - 1, openEndCount < 0 ? slice.openEnd : sliceDepth - 1);
};

Fitter.prototype.mustMoveInline = function mustMoveInline () {
  if (!this.$to.parent.isTextblock || this.$to.end() == this.$to.pos) { return -1 }
  var top = this.frontier[this.depth], level;
  if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) ||
      (this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth)) { return -1 }

  var ref = this.$to;
    var depth = ref.depth;
    var after = this.$to.after(depth);
  while (depth > 1 && after == this.$to.end(--depth)) { ++after; }
  return after
};

Fitter.prototype.findCloseLevel = function findCloseLevel ($to) {
  scan: for (var i = Math.min(this.depth, $to.depth); i >= 0; i--) {
    var ref = this.frontier[i];
      var match = ref.match;
      var type = ref.type;
    var dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1));
    var fit = contentAfterFits($to, i, type, match, dropInner);
    if (!fit) { continue }
    for (var d = i - 1; d >= 0; d--) {
      var ref$1 = this.frontier[d];
        var match$1 = ref$1.match;
        var type$1 = ref$1.type;
      var matches = contentAfterFits($to, d, type$1, match$1, true);
      if (!matches || matches.childCount) { continue scan }
    }
    return {depth: i, fit: fit, move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to}
  }
};

Fitter.prototype.close = function close ($to) {
  var close = this.findCloseLevel($to);
  if (!close) { return null }

  while (this.depth > close.depth) { this.closeFrontierNode(); }
  if (close.fit.childCount) { this.placed = addToFragment(this.placed, close.depth, close.fit); }
  $to = close.move;
  for (var d = close.depth + 1; d <= $to.depth; d++) {
    var node = $to.node(d), add = node.type.contentMatch.fillBefore(node.content, true, $to.index(d));
    this.openFrontierNode(node.type, node.attrs, add);
  }
  return $to
};

Fitter.prototype.openFrontierNode = function openFrontierNode (type, attrs, content) {
  var top = this.frontier[this.depth];
  top.match = top.match.matchType(type);
  this.placed = addToFragment(this.placed, this.depth, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(type.create(attrs, content)));
  this.frontier.push({type: type, match: type.contentMatch});
};

Fitter.prototype.closeFrontierNode = function closeFrontierNode () {
  var open = this.frontier.pop();
  var add = open.match.fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true);
  if (add.childCount) { this.placed = addToFragment(this.placed, this.frontier.length, add); }
};

Object.defineProperties( Fitter.prototype, prototypeAccessors$1 );

function dropFromFragment(fragment, depth, count) {
  if (depth == 0) { return fragment.cutByIndex(count) }
  return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)))
}

function addToFragment(fragment, depth, content) {
  if (depth == 0) { return fragment.append(content) }
  return fragment.replaceChild(fragment.childCount - 1,
                               fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)))
}

function contentAt(fragment, depth) {
  for (var i = 0; i < depth; i++) { fragment = fragment.firstChild.content; }
  return fragment
}

function closeNodeStart(node, openStart, openEnd) {
  if (openStart <= 0) { return node }
  var frag = node.content;
  if (openStart > 1)
    { frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0)); }
  if (openStart > 0) {
    frag = node.type.contentMatch.fillBefore(frag).append(frag);
    if (openEnd <= 0) { frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true)); }
  }
  return node.copy(frag)
}

function contentAfterFits($to, depth, type, match, open) {
  var node = $to.node(depth), index = open ? $to.indexAfter(depth) : $to.index(depth);
  if (index == node.childCount && !type.compatibleContent(node.type)) { return null }
  var fit = match.fillBefore(node.content, true, index);
  return fit && !invalidMarks(type, node.content, index) ? fit : null
}

function invalidMarks(type, fragment, start) {
  for (var i = start; i < fragment.childCount; i++)
    { if (!type.allowsMarks(fragment.child(i).marks)) { return true } }
  return false
}

// :: (number, number, Slice) → this
// Replace a range of the document with a given slice, using `from`,
// `to`, and the slice's [`openStart`](#model.Slice.openStart) property
// as hints, rather than fixed start and end points. This method may
// grow the replaced area or close open nodes in the slice in order to
// get a fit that is more in line with WYSIWYG expectations, by
// dropping fully covered parent nodes of the replaced region when
// they are marked [non-defining](#model.NodeSpec.defining), or
// including an open parent node from the slice that _is_ marked as
// [defining](#model.NodeSpec.defining).
//
// This is the method, for example, to handle paste. The similar
// [`replace`](#transform.Transform.replace) method is a more
// primitive tool which will _not_ move the start and end of its given
// range, and is useful in situations where you need more precise
// control over what happens.
Transform.prototype.replaceRange = function(from, to, slice) {
  if (!slice.size) { return this.deleteRange(from, to) }

  var $from = this.doc.resolve(from), $to = this.doc.resolve(to);
  if (fitsTrivially($from, $to, slice))
    { return this.step(new ReplaceStep(from, to, slice)) }

  var targetDepths = coveredDepths($from, this.doc.resolve(to));
  // Can't replace the whole document, so remove 0 if it's present
  if (targetDepths[targetDepths.length - 1] == 0) { targetDepths.pop(); }
  // Negative numbers represent not expansion over the whole node at
  // that depth, but replacing from $from.before(-D) to $to.pos.
  var preferredTarget = -($from.depth + 1);
  targetDepths.unshift(preferredTarget);
  // This loop picks a preferred target depth, if one of the covering
  // depths is not outside of a defining node, and adds negative
  // depths for any depth that has $from at its start and does not
  // cross a defining node.
  for (var d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {
    var spec = $from.node(d).type.spec;
    if (spec.defining || spec.isolating) { break }
    if (targetDepths.indexOf(d) > -1) { preferredTarget = d; }
    else if ($from.before(d) == pos) { targetDepths.splice(1, 0, -d); }
  }
  // Try to fit each possible depth of the slice into each possible
  // target depth, starting with the preferred depths.
  var preferredTargetIndex = targetDepths.indexOf(preferredTarget);

  var leftNodes = [], preferredDepth = slice.openStart;
  for (var content = slice.content, i = 0;; i++) {
    var node = content.firstChild;
    leftNodes.push(node);
    if (i == slice.openStart) { break }
    content = node.content;
  }
  // Back up if the node directly above openStart, or the node above
  // that separated only by a non-defining textblock node, is defining.
  if (preferredDepth > 0 && leftNodes[preferredDepth - 1].type.spec.defining &&
      $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 1].type)
    { preferredDepth -= 1; }
  else if (preferredDepth >= 2 && leftNodes[preferredDepth - 1].isTextblock && leftNodes[preferredDepth - 2].type.spec.defining &&
           $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 2].type)
    { preferredDepth -= 2; }

  for (var j = slice.openStart; j >= 0; j--) {
    var openDepth = (j + preferredDepth + 1) % (slice.openStart + 1);
    var insert = leftNodes[openDepth];
    if (!insert) { continue }
    for (var i$1 = 0; i$1 < targetDepths.length; i$1++) {
      // Loop over possible expansion levels, starting with the
      // preferred one
      var targetDepth = targetDepths[(i$1 + preferredTargetIndex) % targetDepths.length], expand = true;
      if (targetDepth < 0) { expand = false; targetDepth = -targetDepth; }
      var parent = $from.node(targetDepth - 1), index = $from.index(targetDepth - 1);
      if (parent.canReplaceWith(index, index, insert.type, insert.marks))
        { return this.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to,
                            new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(closeFragment(slice.content, 0, slice.openStart, openDepth),
                                      openDepth, slice.openEnd)) }
    }
  }

  var startSteps = this.steps.length;
  for (var i$2 = targetDepths.length - 1; i$2 >= 0; i$2--) {
    this.replace(from, to, slice);
    if (this.steps.length > startSteps) { break }
    var depth = targetDepths[i$2];
    if (depth < 0) { continue }
    from = $from.before(depth); to = $to.after(depth);
  }
  return this
};

function closeFragment(fragment, depth, oldOpen, newOpen, parent) {
  if (depth < oldOpen) {
    var first = fragment.firstChild;
    fragment = fragment.replaceChild(0, first.copy(closeFragment(first.content, depth + 1, oldOpen, newOpen, first)));
  }
  if (depth > newOpen) {
    var match = parent.contentMatchAt(0);
    var start = match.fillBefore(fragment).append(fragment);
    fragment = start.append(match.matchFragment(start).fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true));
  }
  return fragment
}

// :: (number, number, Node) → this
// Replace the given range with a node, but use `from` and `to` as
// hints, rather than precise positions. When from and to are the same
// and are at the start or end of a parent node in which the given
// node doesn't fit, this method may _move_ them out towards a parent
// that does allow the given node to be placed. When the given range
// completely covers a parent node, this method may completely replace
// that parent node.
Transform.prototype.replaceRangeWith = function(from, to, node) {
  if (!node.isInline && from == to && this.doc.resolve(from).parent.content.size) {
    var point = insertPoint(this.doc, from, node.type);
    if (point != null) { from = to = point; }
  }
  return this.replaceRange(from, to, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(node), 0, 0))
};

// :: (number, number) → this
// Delete the given range, expanding it to cover fully covered
// parent nodes until a valid replace is found.
Transform.prototype.deleteRange = function(from, to) {
  var $from = this.doc.resolve(from), $to = this.doc.resolve(to);
  var covered = coveredDepths($from, $to);
  for (var i = 0; i < covered.length; i++) {
    var depth = covered[i], last = i == covered.length - 1;
    if ((last && depth == 0) || $from.node(depth).type.contentMatch.validEnd)
      { return this.delete($from.start(depth), $to.end(depth)) }
    if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))
      { return this.delete($from.before(depth), $to.after(depth)) }
  }
  for (var d = 1; d <= $from.depth && d <= $to.depth; d++) {
    if (from - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d)
      { return this.delete($from.before(d), to) }
  }
  return this.delete(from, to)
};

// : (ResolvedPos, ResolvedPos) → [number]
// Returns an array of all depths for which $from - $to spans the
// whole content of the nodes at that depth.
function coveredDepths($from, $to) {
  var result = [], minDepth = Math.min($from.depth, $to.depth);
  for (var d = minDepth; d >= 0; d--) {
    var start = $from.start(d);
    if (start < $from.pos - ($from.depth - d) ||
        $to.end(d) > $to.pos + ($to.depth - d) ||
        $from.node(d).type.spec.isolating ||
        $to.node(d).type.spec.isolating) { break }
    if (start == $to.start(d) ||
        (d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent &&
         d && $to.start(d - 1) == start - 1))
      { result.push(d); }
  }
  return result
}


//# sourceMappingURL=index.es.js.map


/***/ }),

/***/ "./node_modules/prosemirror-view/dist/index.es.js":
/*!********************************************************!*\
  !*** ./node_modules/prosemirror-view/dist/index.es.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Decoration": () => (/* binding */ Decoration),
/* harmony export */   "DecorationSet": () => (/* binding */ DecorationSet),
/* harmony export */   "EditorView": () => (/* binding */ EditorView),
/* harmony export */   "__endComposition": () => (/* binding */ endComposition),
/* harmony export */   "__parseFromClipboard": () => (/* binding */ parseFromClipboard),
/* harmony export */   "__serializeForClipboard": () => (/* binding */ serializeForClipboard)
/* harmony export */ });
/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.es.js");
/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-model */ "./node_modules/prosemirror-model/dist/index.es.js");
/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-transform */ "./node_modules/prosemirror-transform/dist/index.es.js");




var result = {};

if (typeof navigator != "undefined" && typeof document != "undefined") {
  var ie_edge = /Edge\/(\d+)/.exec(navigator.userAgent);
  var ie_upto10 = /MSIE \d/.test(navigator.userAgent);
  var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);

  result.mac = /Mac/.test(navigator.platform);
  var ie = result.ie = !!(ie_upto10 || ie_11up || ie_edge);
  result.ie_version = ie_upto10 ? document.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : null;
  result.gecko = !ie && /gecko\/(\d+)/i.test(navigator.userAgent);
  result.gecko_version = result.gecko && +(/Firefox\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1];
  var chrome = !ie && /Chrome\/(\d+)/.exec(navigator.userAgent);
  result.chrome = !!chrome;
  result.chrome_version = chrome && +chrome[1];
  // Is true for both iOS and iPadOS for convenience
  result.safari = !ie && /Apple Computer/.test(navigator.vendor);
  result.ios = result.safari && (/Mobile\/\w+/.test(navigator.userAgent) || navigator.maxTouchPoints > 2);
  result.android = /Android \d/.test(navigator.userAgent);
  result.webkit = "webkitFontSmoothing" in document.documentElement.style;
  result.webkit_version = result.webkit && +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1];
}

var domIndex = function(node) {
  for (var index = 0;; index++) {
    node = node.previousSibling;
    if (!node) { return index }
  }
};

var parentNode = function(node) {
  var parent = node.assignedSlot || node.parentNode;
  return parent && parent.nodeType == 11 ? parent.host : parent
};

var reusedRange = null;

// Note that this will always return the same range, because DOM range
// objects are every expensive, and keep slowing down subsequent DOM
// updates, for some reason.
var textRange = function(node, from, to) {
  var range = reusedRange || (reusedRange = document.createRange());
  range.setEnd(node, to == null ? node.nodeValue.length : to);
  range.setStart(node, from || 0);
  return range
};

// Scans forward and backward through DOM positions equivalent to the
// given one to see if the two are in the same place (i.e. after a
// text node vs at the end of that text node)
var isEquivalentPosition = function(node, off, targetNode, targetOff) {
  return targetNode && (scanFor(node, off, targetNode, targetOff, -1) ||
                        scanFor(node, off, targetNode, targetOff, 1))
};

var atomElements = /^(img|br|input|textarea|hr)$/i;

function scanFor(node, off, targetNode, targetOff, dir) {
  for (;;) {
    if (node == targetNode && off == targetOff) { return true }
    if (off == (dir < 0 ? 0 : nodeSize(node))) {
      var parent = node.parentNode;
      if (parent.nodeType != 1 || hasBlockDesc(node) || atomElements.test(node.nodeName) || node.contentEditable == "false")
        { return false }
      off = domIndex(node) + (dir < 0 ? 0 : 1);
      node = parent;
    } else if (node.nodeType == 1) {
      node = node.childNodes[off + (dir < 0 ? -1 : 0)];
      if (node.contentEditable == "false") { return false }
      off = dir < 0 ? nodeSize(node) : 0;
    } else {
      return false
    }
  }
}

function nodeSize(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length
}

function isOnEdge(node, offset, parent) {
  for (var atStart = offset == 0, atEnd = offset == nodeSize(node); atStart || atEnd;) {
    if (node == parent) { return true }
    var index = domIndex(node);
    node = node.parentNode;
    if (!node) { return false }
    atStart = atStart && index == 0;
    atEnd = atEnd && index == nodeSize(node);
  }
}

function hasBlockDesc(dom) {
  var desc;
  for (var cur = dom; cur; cur = cur.parentNode) { if (desc = cur.pmViewDesc) { break } }
  return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom)
}

// Work around Chrome issue https://bugs.chromium.org/p/chromium/issues/detail?id=447523
// (isCollapsed inappropriately returns true in shadow dom)
var selectionCollapsed = function(domSel) {
  var collapsed = domSel.isCollapsed;
  if (collapsed && result.chrome && domSel.rangeCount && !domSel.getRangeAt(0).collapsed)
    { collapsed = false; }
  return collapsed
};

function keyEvent(keyCode, key) {
  var event = document.createEvent("Event");
  event.initEvent("keydown", true, true);
  event.keyCode = keyCode;
  event.key = event.code = key;
  return event
}

function windowRect(doc) {
  return {left: 0, right: doc.documentElement.clientWidth,
          top: 0, bottom: doc.documentElement.clientHeight}
}

function getSide(value, side) {
  return typeof value == "number" ? value : value[side]
}

function clientRect(node) {
  var rect = node.getBoundingClientRect();
  // Adjust for elements with style "transform: scale()"
  var scaleX = (rect.width / node.offsetWidth) || 1;
  var scaleY = (rect.height / node.offsetHeight) || 1;
  // Make sure scrollbar width isn't included in the rectangle
  return {left: rect.left, right: rect.left + node.clientWidth * scaleX,
          top: rect.top, bottom: rect.top + node.clientHeight * scaleY}
}

function scrollRectIntoView(view, rect, startDOM) {
  var scrollThreshold = view.someProp("scrollThreshold") || 0, scrollMargin = view.someProp("scrollMargin") || 5;
  var doc = view.dom.ownerDocument;
  for (var parent = startDOM || view.dom;; parent = parentNode(parent)) {
    if (!parent) { break }
    if (parent.nodeType != 1) { continue }
    var atTop = parent == doc.body || parent.nodeType != 1;
    var bounding = atTop ? windowRect(doc) : clientRect(parent);
    var moveX = 0, moveY = 0;
    if (rect.top < bounding.top + getSide(scrollThreshold, "top"))
      { moveY = -(bounding.top - rect.top + getSide(scrollMargin, "top")); }
    else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, "bottom"))
      { moveY = rect.bottom - bounding.bottom + getSide(scrollMargin, "bottom"); }
    if (rect.left < bounding.left + getSide(scrollThreshold, "left"))
      { moveX = -(bounding.left - rect.left + getSide(scrollMargin, "left")); }
    else if (rect.right > bounding.right - getSide(scrollThreshold, "right"))
      { moveX = rect.right - bounding.right + getSide(scrollMargin, "right"); }
    if (moveX || moveY) {
      if (atTop) {
        doc.defaultView.scrollBy(moveX, moveY);
      } else {
        var startX = parent.scrollLeft, startY = parent.scrollTop;
        if (moveY) { parent.scrollTop += moveY; }
        if (moveX) { parent.scrollLeft += moveX; }
        var dX = parent.scrollLeft - startX, dY = parent.scrollTop - startY;
        rect = {left: rect.left - dX, top: rect.top - dY, right: rect.right - dX, bottom: rect.bottom - dY};
      }
    }
    if (atTop) { break }
  }
}

// Store the scroll position of the editor's parent nodes, along with
// the top position of an element near the top of the editor, which
// will be used to make sure the visible viewport remains stable even
// when the size of the content above changes.
function storeScrollPos(view) {
  var rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);
  var refDOM, refTop;
  for (var x = (rect.left + rect.right) / 2, y = startY + 1;
       y < Math.min(innerHeight, rect.bottom); y += 5) {
    var dom = view.root.elementFromPoint(x, y);
    if (dom == view.dom || !view.dom.contains(dom)) { continue }
    var localRect = dom.getBoundingClientRect();
    if (localRect.top >= startY - 20) {
      refDOM = dom;
      refTop = localRect.top;
      break
    }
  }
  return {refDOM: refDOM, refTop: refTop, stack: scrollStack(view.dom)}
}

function scrollStack(dom) {
  var stack = [], doc = dom.ownerDocument;
  for (; dom; dom = parentNode(dom)) {
    stack.push({dom: dom, top: dom.scrollTop, left: dom.scrollLeft});
    if (dom == doc) { break }
  }
  return stack
}

// Reset the scroll position of the editor's parent nodes to that what
// it was before, when storeScrollPos was called.
function resetScrollPos(ref) {
  var refDOM = ref.refDOM;
  var refTop = ref.refTop;
  var stack = ref.stack;

  var newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;
  restoreScrollStack(stack, newRefTop == 0 ? 0 : newRefTop - refTop);
}

function restoreScrollStack(stack, dTop) {
  for (var i = 0; i < stack.length; i++) {
    var ref = stack[i];
    var dom = ref.dom;
    var top = ref.top;
    var left = ref.left;
    if (dom.scrollTop != top + dTop) { dom.scrollTop = top + dTop; }
    if (dom.scrollLeft != left) { dom.scrollLeft = left; }
  }
}

var preventScrollSupported = null;
// Feature-detects support for .focus({preventScroll: true}), and uses
// a fallback kludge when not supported.
function focusPreventScroll(dom) {
  if (dom.setActive) { return dom.setActive() } // in IE
  if (preventScrollSupported) { return dom.focus(preventScrollSupported) }

  var stored = scrollStack(dom);
  dom.focus(preventScrollSupported == null ? {
    get preventScroll() {
      preventScrollSupported = {preventScroll: true};
      return true
    }
  } : undefined);
  if (!preventScrollSupported) {
    preventScrollSupported = false;
    restoreScrollStack(stored, 0);
  }
}

function findOffsetInNode(node, coords) {
  var closest, dxClosest = 2e8, coordsClosest, offset = 0;
  var rowBot = coords.top, rowTop = coords.top;
  for (var child = node.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++) {
    var rects = (void 0);
    if (child.nodeType == 1) { rects = child.getClientRects(); }
    else if (child.nodeType == 3) { rects = textRange(child).getClientRects(); }
    else { continue }

    for (var i = 0; i < rects.length; i++) {
      var rect = rects[i];
      if (rect.top <= rowBot && rect.bottom >= rowTop) {
        rowBot = Math.max(rect.bottom, rowBot);
        rowTop = Math.min(rect.top, rowTop);
        var dx = rect.left > coords.left ? rect.left - coords.left
            : rect.right < coords.left ? coords.left - rect.right : 0;
        if (dx < dxClosest) {
          closest = child;
          dxClosest = dx;
          coordsClosest = dx && closest.nodeType == 3 ? {left: rect.right < coords.left ? rect.right : rect.left, top: coords.top} : coords;
          if (child.nodeType == 1 && dx)
            { offset = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0); }
          continue
        }
      }
      if (!closest && (coords.left >= rect.right && coords.top >= rect.top ||
                       coords.left >= rect.left && coords.top >= rect.bottom))
        { offset = childIndex + 1; }
    }
  }
  if (closest && closest.nodeType == 3) { return findOffsetInText(closest, coordsClosest) }
  if (!closest || (dxClosest && closest.nodeType == 1)) { return {node: node, offset: offset} }
  return findOffsetInNode(closest, coordsClosest)
}

function findOffsetInText(node, coords) {
  var len = node.nodeValue.length;
  var range = document.createRange();
  for (var i = 0; i < len; i++) {
    range.setEnd(node, i + 1);
    range.setStart(node, i);
    var rect = singleRect(range, 1);
    if (rect.top == rect.bottom) { continue }
    if (inRect(coords, rect))
      { return {node: node, offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0)} }
  }
  return {node: node, offset: 0}
}

function inRect(coords, rect) {
  return coords.left >= rect.left - 1 && coords.left <= rect.right + 1&&
    coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1
}

function targetKludge(dom, coords) {
  var parent = dom.parentNode;
  if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left)
    { return parent }
  return dom
}

function posFromElement(view, elt, coords) {
  var ref = findOffsetInNode(elt, coords);
  var node = ref.node;
  var offset = ref.offset;
  var bias = -1;
  if (node.nodeType == 1 && !node.firstChild) {
    var rect = node.getBoundingClientRect();
    bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;
  }
  return view.docView.posFromDOM(node, offset, bias)
}

function posFromCaret(view, node, offset, coords) {
  // Browser (in caretPosition/RangeFromPoint) will agressively
  // normalize towards nearby inline nodes. Since we are interested in
  // positions between block nodes too, we first walk up the hierarchy
  // of nodes to see if there are block nodes that the coordinates
  // fall outside of. If so, we take the position before/after that
  // block. If not, we call `posFromDOM` on the raw node/offset.
  var outside = -1;
  for (var cur = node;;) {
    if (cur == view.dom) { break }
    var desc = view.docView.nearestDesc(cur, true);
    if (!desc) { return null }
    if (desc.node.isBlock && desc.parent) {
      var rect = desc.dom.getBoundingClientRect();
      if (rect.left > coords.left || rect.top > coords.top) { outside = desc.posBefore; }
      else if (rect.right < coords.left || rect.bottom < coords.top) { outside = desc.posAfter; }
      else { break }
    }
    cur = desc.dom.parentNode;
  }
  return outside > -1 ? outside : view.docView.posFromDOM(node, offset)
}

function elementFromPoint(element, coords, box) {
  var len = element.childNodes.length;
  if (len && box.top < box.bottom) {
    for (var startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i = startI;;) {
      var child = element.childNodes[i];
      if (child.nodeType == 1) {
        var rects = child.getClientRects();
        for (var j = 0; j < rects.length; j++) {
          var rect = rects[j];
          if (inRect(coords, rect)) { return elementFromPoint(child, coords, rect) }
        }
      }
      if ((i = (i + 1) % len) == startI) { break }
    }
  }
  return element
}

// Given an x,y position on the editor, get the position in the document.
function posAtCoords(view, coords) {
  var assign, assign$1;

  var doc = view.dom.ownerDocument, node, offset;
  if (doc.caretPositionFromPoint) {
    try { // Firefox throws for this call in hard-to-predict circumstances (#994)
      var pos$1 = doc.caretPositionFromPoint(coords.left, coords.top);
      if (pos$1) { ((assign = pos$1, node = assign.offsetNode, offset = assign.offset)); }
    } catch (_) {}
  }
  if (!node && doc.caretRangeFromPoint) {
    var range = doc.caretRangeFromPoint(coords.left, coords.top);
    if (range) { ((assign$1 = range, node = assign$1.startContainer, offset = assign$1.startOffset)); }
  }

  var elt = (view.root.elementFromPoint ? view.root : doc).elementFromPoint(coords.left, coords.top + 1), pos;
  if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {
    var box = view.dom.getBoundingClientRect();
    if (!inRect(coords, box)) { return null }
    elt = elementFromPoint(view.dom, coords, box);
    if (!elt) { return null }
  }
  // Safari's caretRangeFromPoint returns nonsense when on a draggable element
  if (result.safari) {
    for (var p = elt; node && p; p = parentNode(p))
      { if (p.draggable) { node = offset = null; } }
  }
  elt = targetKludge(elt, coords);
  if (node) {
    if (result.gecko && node.nodeType == 1) {
      // Firefox will sometimes return offsets into <input> nodes, which
      // have no actual children, from caretPositionFromPoint (#953)
      offset = Math.min(offset, node.childNodes.length);
      // It'll also move the returned position before image nodes,
      // even if those are behind it.
      if (offset < node.childNodes.length) {
        var next = node.childNodes[offset], box$1;
        if (next.nodeName == "IMG" && (box$1 = next.getBoundingClientRect()).right <= coords.left &&
            box$1.bottom > coords.top)
          { offset++; }
      }
    }
    // Suspiciously specific kludge to work around caret*FromPoint
    // never returning a position at the end of the document
    if (node == view.dom && offset == node.childNodes.length - 1 && node.lastChild.nodeType == 1 &&
        coords.top > node.lastChild.getBoundingClientRect().bottom)
      { pos = view.state.doc.content.size; }
    // Ignore positions directly after a BR, since caret*FromPoint
    // 'round up' positions that would be more accurately placed
    // before the BR node.
    else if (offset == 0 || node.nodeType != 1 || node.childNodes[offset - 1].nodeName != "BR")
      { pos = posFromCaret(view, node, offset, coords); }
  }
  if (pos == null) { pos = posFromElement(view, elt, coords); }

  var desc = view.docView.nearestDesc(elt, true);
  return {pos: pos, inside: desc ? desc.posAtStart - desc.border : -1}
}

function singleRect(object, bias) {
  var rects = object.getClientRects();
  return !rects.length ? object.getBoundingClientRect() : rects[bias < 0 ? 0 : rects.length - 1]
}

var BIDI = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;

// : (EditorView, number, number) → {left: number, top: number, right: number, bottom: number}
// Given a position in the document model, get a bounding box of the
// character at that position, relative to the window.
function coordsAtPos(view, pos, side) {
  var ref = view.docView.domFromPos(pos, side < 0 ? -1 : 1);
  var node = ref.node;
  var offset = ref.offset;

  var supportEmptyRange = result.webkit || result.gecko;
  if (node.nodeType == 3) {
    // These browsers support querying empty text ranges. Prefer that in
    // bidi context or when at the end of a node.
    if (supportEmptyRange && (BIDI.test(node.nodeValue) || (side < 0 ? !offset : offset == node.nodeValue.length))) {
      var rect = singleRect(textRange(node, offset, offset), side);
      // Firefox returns bad results (the position before the space)
      // when querying a position directly after line-broken
      // whitespace. Detect this situation and and kludge around it
      if (result.gecko && offset && /\s/.test(node.nodeValue[offset - 1]) && offset < node.nodeValue.length) {
        var rectBefore = singleRect(textRange(node, offset - 1, offset - 1), -1);
        if (rectBefore.top == rect.top) {
          var rectAfter = singleRect(textRange(node, offset, offset + 1), -1);
          if (rectAfter.top != rect.top)
            { return flattenV(rectAfter, rectAfter.left < rectBefore.left) }
        }
      }
      return rect
    } else {
      var from = offset, to = offset, takeSide = side < 0 ? 1 : -1;
      if (side < 0 && !offset) { to++; takeSide = -1; }
      else if (side >= 0 && offset == node.nodeValue.length) { from--; takeSide = 1; }
      else if (side < 0) { from--; }
      else { to ++; }
      return flattenV(singleRect(textRange(node, from, to), takeSide), takeSide < 0)
    }
  }

  // Return a horizontal line in block context
  if (!view.state.doc.resolve(pos).parent.inlineContent) {
    if (offset && (side < 0 || offset == nodeSize(node))) {
      var before = node.childNodes[offset - 1];
      if (before.nodeType == 1) { return flattenH(before.getBoundingClientRect(), false) }
    }
    if (offset < nodeSize(node)) {
      var after = node.childNodes[offset];
      if (after.nodeType == 1) { return flattenH(after.getBoundingClientRect(), true) }
    }
    return flattenH(node.getBoundingClientRect(), side >= 0)
  }

  // Inline, not in text node (this is not Bidi-safe)
  if (offset && (side < 0 || offset == nodeSize(node))) {
    var before$1 = node.childNodes[offset - 1];
    var target = before$1.nodeType == 3 ? textRange(before$1, nodeSize(before$1) - (supportEmptyRange ? 0 : 1))
        // BR nodes tend to only return the rectangle before them.
        // Only use them if they are the last element in their parent
        : before$1.nodeType == 1 && (before$1.nodeName != "BR" || !before$1.nextSibling) ? before$1 : null;
    if (target) { return flattenV(singleRect(target, 1), false) }
  }
  if (offset < nodeSize(node)) {
    var after$1 = node.childNodes[offset];
    while (after$1.pmViewDesc && after$1.pmViewDesc.ignoreForCoords) { after$1 = after$1.nextSibling; }
    var target$1 = !after$1 ? null : after$1.nodeType == 3 ? textRange(after$1, 0, (supportEmptyRange ? 0 : 1))
        : after$1.nodeType == 1 ? after$1 : null;
    if (target$1) { return flattenV(singleRect(target$1, -1), true) }
  }
  // All else failed, just try to get a rectangle for the target node
  return flattenV(singleRect(node.nodeType == 3 ? textRange(node) : node, -side), side >= 0)
}

function flattenV(rect, left) {
  if (rect.width == 0) { return rect }
  var x = left ? rect.left : rect.right;
  return {top: rect.top, bottom: rect.bottom, left: x, right: x}
}

function flattenH(rect, top) {
  if (rect.height == 0) { return rect }
  var y = top ? rect.top : rect.bottom;
  return {top: y, bottom: y, left: rect.left, right: rect.right}
}

function withFlushedState(view, state, f) {
  var viewState = view.state, active = view.root.activeElement;
  if (viewState != state) { view.updateState(state); }
  if (active != view.dom) { view.focus(); }
  try {
    return f()
  } finally {
    if (viewState != state) { view.updateState(viewState); }
    if (active != view.dom && active) { active.focus(); }
  }
}

// : (EditorView, number, number)
// Whether vertical position motion in a given direction
// from a position would leave a text block.
function endOfTextblockVertical(view, state, dir) {
  var sel = state.selection;
  var $pos = dir == "up" ? sel.$from : sel.$to;
  return withFlushedState(view, state, function () {
    var ref = view.docView.domFromPos($pos.pos, dir == "up" ? -1 : 1);
    var dom = ref.node;
    for (;;) {
      var nearest = view.docView.nearestDesc(dom, true);
      if (!nearest) { break }
      if (nearest.node.isBlock) { dom = nearest.dom; break }
      dom = nearest.dom.parentNode;
    }
    var coords = coordsAtPos(view, $pos.pos, 1);
    for (var child = dom.firstChild; child; child = child.nextSibling) {
      var boxes = (void 0);
      if (child.nodeType == 1) { boxes = child.getClientRects(); }
      else if (child.nodeType == 3) { boxes = textRange(child, 0, child.nodeValue.length).getClientRects(); }
      else { continue }
      for (var i = 0; i < boxes.length; i++) {
        var box = boxes[i];
        if (box.bottom > box.top + 1 &&
            (dir == "up" ? coords.top - box.top > (box.bottom - coords.top) * 2
             : box.bottom - coords.bottom > (coords.bottom - box.top) * 2))
          { return false }
      }
    }
    return true
  })
}

var maybeRTL = /[\u0590-\u08ac]/;

function endOfTextblockHorizontal(view, state, dir) {
  var ref = state.selection;
  var $head = ref.$head;
  if (!$head.parent.isTextblock) { return false }
  var offset = $head.parentOffset, atStart = !offset, atEnd = offset == $head.parent.content.size;
  var sel = view.root.getSelection();
  // If the textblock is all LTR, or the browser doesn't support
  // Selection.modify (Edge), fall back to a primitive approach
  if (!maybeRTL.test($head.parent.textContent) || !sel.modify)
    { return dir == "left" || dir == "backward" ? atStart : atEnd }

  return withFlushedState(view, state, function () {
    // This is a huge hack, but appears to be the best we can
    // currently do: use `Selection.modify` to move the selection by
    // one character, and see if that moves the cursor out of the
    // textblock (or doesn't move it at all, when at the start/end of
    // the document).
    var oldRange = sel.getRangeAt(0), oldNode = sel.focusNode, oldOff = sel.focusOffset;
    var oldBidiLevel = sel.caretBidiLevel; // Only for Firefox
    sel.modify("move", dir, "character");
    var parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;
    var result = !parentDOM.contains(sel.focusNode.nodeType == 1 ? sel.focusNode : sel.focusNode.parentNode) ||
        (oldNode == sel.focusNode && oldOff == sel.focusOffset);
    // Restore the previous selection
    sel.removeAllRanges();
    sel.addRange(oldRange);
    if (oldBidiLevel != null) { sel.caretBidiLevel = oldBidiLevel; }
    return result
  })
}

var cachedState = null, cachedDir = null, cachedResult = false;
function endOfTextblock(view, state, dir) {
  if (cachedState == state && cachedDir == dir) { return cachedResult }
  cachedState = state; cachedDir = dir;
  return cachedResult = dir == "up" || dir == "down"
    ? endOfTextblockVertical(view, state, dir)
    : endOfTextblockHorizontal(view, state, dir)
}

// NodeView:: interface
//
// By default, document nodes are rendered using the result of the
// [`toDOM`](#model.NodeSpec.toDOM) method of their spec, and managed
// entirely by the editor. For some use cases, such as embedded
// node-specific editing interfaces, you want more control over
// the behavior of a node's in-editor representation, and need to
// [define](#view.EditorProps.nodeViews) a custom node view.
//
// Mark views only support `dom` and `contentDOM`, and don't support
// any of the node view methods.
//
// Objects returned as node views must conform to this interface.
//
//   dom:: ?dom.Node
//   The outer DOM node that represents the document node. When not
//   given, the default strategy is used to create a DOM node.
//
//   contentDOM:: ?dom.Node
//   The DOM node that should hold the node's content. Only meaningful
//   if the node view also defines a `dom` property and if its node
//   type is not a leaf node type. When this is present, ProseMirror
//   will take care of rendering the node's children into it. When it
//   is not present, the node view itself is responsible for rendering
//   (or deciding not to render) its child nodes.
//
//   update:: ?(node: Node, decorations: [Decoration], innerDecorations: DecorationSource) → bool
//   When given, this will be called when the view is updating itself.
//   It will be given a node (possibly of a different type), an array
//   of active decorations around the node (which are automatically
//   drawn, and the node view may ignore if it isn't interested in
//   them), and a [decoration source](#view.DecorationSource) that
//   represents any decorations that apply to the content of the node
//   (which again may be ignored). It should return true if it was
//   able to update to that node, and false otherwise. If the node
//   view has a `contentDOM` property (or no `dom` property), updating
//   its child nodes will be handled by ProseMirror.
//
//   selectNode:: ?()
//   Can be used to override the way the node's selected status (as a
//   node selection) is displayed.
//
//   deselectNode:: ?()
//   When defining a `selectNode` method, you should also provide a
//   `deselectNode` method to remove the effect again.
//
//   setSelection:: ?(anchor: number, head: number, root: dom.Document)
//   This will be called to handle setting the selection inside the
//   node. The `anchor` and `head` positions are relative to the start
//   of the node. By default, a DOM selection will be created between
//   the DOM positions corresponding to those positions, but if you
//   override it you can do something else.
//
//   stopEvent:: ?(event: dom.Event) → bool
//   Can be used to prevent the editor view from trying to handle some
//   or all DOM events that bubble up from the node view. Events for
//   which this returns true are not handled by the editor.
//
//   ignoreMutation:: ?(dom.MutationRecord) → bool
//   Called when a DOM
//   [mutation](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver)
//   or a selection change happens within the view. When the change is
//   a selection change, the record will have a `type` property of
//   `"selection"` (which doesn't occur for native mutation records).
//   Return false if the editor should re-read the selection or
//   re-parse the range around the mutation, true if it can safely be
//   ignored.
//
//   destroy:: ?()
//   Called when the node view is removed from the editor or the whole
//   editor is destroyed. (Not available for marks.)

// View descriptions are data structures that describe the DOM that is
// used to represent the editor's content. They are used for:
//
// - Incremental redrawing when the document changes
//
// - Figuring out what part of the document a given DOM position
//   corresponds to
//
// - Wiring in custom implementations of the editing interface for a
//   given node
//
// They form a doubly-linked mutable tree, starting at `view.docView`.

var NOT_DIRTY = 0, CHILD_DIRTY = 1, CONTENT_DIRTY = 2, NODE_DIRTY = 3;

// Superclass for the various kinds of descriptions. Defines their
// basic structure and shared methods.
var ViewDesc = function ViewDesc(parent, children, dom, contentDOM) {
  this.parent = parent;
  this.children = children;
  this.dom = dom;
  // An expando property on the DOM node provides a link back to its
  // description.
  dom.pmViewDesc = this;
  // This is the node that holds the child views. It may be null for
  // descs that don't have children.
  this.contentDOM = contentDOM;
  this.dirty = NOT_DIRTY;
};

var prototypeAccessors = { size: { configurable: true },border: { configurable: true },posBefore: { configurable: true },posAtStart: { configurable: true },posAfter: { configurable: true },posAtEnd: { configurable: true },contentLost: { configurable: true },domAtom: { configurable: true },ignoreForCoords: { configurable: true } };

// Used to check whether a given description corresponds to a
// widget/mark/node.
ViewDesc.prototype.matchesWidget = function matchesWidget () { return false };
ViewDesc.prototype.matchesMark = function matchesMark () { return false };
ViewDesc.prototype.matchesNode = function matchesNode () { return false };
ViewDesc.prototype.matchesHack = function matchesHack (_nodeName) { return false };

// : () → ?ParseRule
// When parsing in-editor content (in domchange.js), we allow
// descriptions to determine the parse rules that should be used to
// parse them.
ViewDesc.prototype.parseRule = function parseRule () { return null };

// : (dom.Event) → bool
// Used by the editor's event handler to ignore events that come
// from certain descs.
ViewDesc.prototype.stopEvent = function stopEvent () { return false };

// The size of the content represented by this desc.
prototypeAccessors.size.get = function () {
  var size = 0;
  for (var i = 0; i < this.children.length; i++) { size += this.children[i].size; }
  return size
};

// For block nodes, this represents the space taken up by their
// start/end tokens.
prototypeAccessors.border.get = function () { return 0 };

ViewDesc.prototype.destroy = function destroy () {
  this.parent = null;
  if (this.dom.pmViewDesc == this) { this.dom.pmViewDesc = null; }
  for (var i = 0; i < this.children.length; i++)
    { this.children[i].destroy(); }
};

ViewDesc.prototype.posBeforeChild = function posBeforeChild (child) {
  for (var i = 0, pos = this.posAtStart; i < this.children.length; i++) {
    var cur = this.children[i];
    if (cur == child) { return pos }
    pos += cur.size;
  }
};

prototypeAccessors.posBefore.get = function () {
  return this.parent.posBeforeChild(this)
};

prototypeAccessors.posAtStart.get = function () {
  return this.parent ? this.parent.posBeforeChild(this) + this.border : 0
};

prototypeAccessors.posAfter.get = function () {
  return this.posBefore + this.size
};

prototypeAccessors.posAtEnd.get = function () {
  return this.posAtStart + this.size - 2 * this.border
};

// : (dom.Node, number, ?number) → number
ViewDesc.prototype.localPosFromDOM = function localPosFromDOM (dom, offset, bias) {
  // If the DOM position is in the content, use the child desc after
  // it to figure out a position.
  if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {
    if (bias < 0) {
      var domBefore, desc;
      if (dom == this.contentDOM) {
        domBefore = dom.childNodes[offset - 1];
      } else {
        while (dom.parentNode != this.contentDOM) { dom = dom.parentNode; }
        domBefore = dom.previousSibling;
      }
      while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this)) { domBefore = domBefore.previousSibling; }
      return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart
    } else {
      var domAfter, desc$1;
      if (dom == this.contentDOM) {
        domAfter = dom.childNodes[offset];
      } else {
        while (dom.parentNode != this.contentDOM) { dom = dom.parentNode; }
        domAfter = dom.nextSibling;
      }
      while (domAfter && !((desc$1 = domAfter.pmViewDesc) && desc$1.parent == this)) { domAfter = domAfter.nextSibling; }
      return domAfter ? this.posBeforeChild(desc$1) : this.posAtEnd
    }
  }
  // Otherwise, use various heuristics, falling back on the bias
  // parameter, to determine whether to return the position at the
  // start or at the end of this view desc.
  var atEnd;
  if (dom == this.dom && this.contentDOM) {
    atEnd = offset > domIndex(this.contentDOM);
  } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {
    atEnd = dom.compareDocumentPosition(this.contentDOM) & 2;
  } else if (this.dom.firstChild) {
    if (offset == 0) { for (var search = dom;; search = search.parentNode) {
      if (search == this.dom) { atEnd = false; break }
      if (search.parentNode.firstChild != search) { break }
    } }
    if (atEnd == null && offset == dom.childNodes.length) { for (var search$1 = dom;; search$1 = search$1.parentNode) {
      if (search$1 == this.dom) { atEnd = true; break }
      if (search$1.parentNode.lastChild != search$1) { break }
    } }
  }
  return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart
};

// Scan up the dom finding the first desc that is a descendant of
// this one.
ViewDesc.prototype.nearestDesc = function nearestDesc (dom, onlyNodes) {
  for (var first = true, cur = dom; cur; cur = cur.parentNode) {
    var desc = this.getDesc(cur);
    if (desc && (!onlyNodes || desc.node)) {
      // If dom is outside of this desc's nodeDOM, don't count it.
      if (first && desc.nodeDOM &&
          !(desc.nodeDOM.nodeType == 1 ? desc.nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : desc.nodeDOM == dom))
        { first = false; }
      else
        { return desc }
    }
  }
};

ViewDesc.prototype.getDesc = function getDesc (dom) {
  var desc = dom.pmViewDesc;
  for (var cur = desc; cur; cur = cur.parent) { if (cur == this) { return desc } }
};

ViewDesc.prototype.posFromDOM = function posFromDOM (dom, offset, bias) {
  for (var scan = dom; scan; scan = scan.parentNode) {
    var desc = this.getDesc(scan);
    if (desc) { return desc.localPosFromDOM(dom, offset, bias) }
  }
  return -1
};

// : (number) → ?NodeViewDesc
// Find the desc for the node after the given pos, if any. (When a
// parent node overrode rendering, there might not be one.)
ViewDesc.prototype.descAt = function descAt (pos) {
  for (var i = 0, offset = 0; i < this.children.length; i++) {
    var child = this.children[i], end = offset + child.size;
    if (offset == pos && end != offset) {
      while (!child.border && child.children.length) { child = child.children[0]; }
      return child
    }
    if (pos < end) { return child.descAt(pos - offset - child.border) }
    offset = end;
  }
};

// : (number, number) → {node: dom.Node, offset: number}
ViewDesc.prototype.domFromPos = function domFromPos (pos, side) {
  if (!this.contentDOM) { return {node: this.dom, offset: 0} }
  // First find the position in the child array
  var i = 0, offset = 0;
  for (var curPos = 0; i < this.children.length; i++) {
    var child = this.children[i], end = curPos + child.size;
    if (end > pos || child instanceof TrailingHackViewDesc) { offset = pos - curPos; break }
    curPos = end;
  }
  // If this points into the middle of a child, call through
  if (offset) { return this.children[i].domFromPos(offset - this.children[i].border, side) }
  // Go back if there were any zero-length widgets with side >= 0 before this point
  for (var prev = (void 0); i && !(prev = this.children[i - 1]).size && prev instanceof WidgetViewDesc && prev.widget.type.side >= 0; i--) {}
  // Scan towards the first useable node
  if (side <= 0) {
    var prev$1, enter = true;
    for (;; i--, enter = false) {
      prev$1 = i ? this.children[i - 1] : null;
      if (!prev$1 || prev$1.dom.parentNode == this.contentDOM) { break }
    }
    if (prev$1 && side && enter && !prev$1.border && !prev$1.domAtom) { return prev$1.domFromPos(prev$1.size, side) }
    return {node: this.contentDOM, offset: prev$1 ? domIndex(prev$1.dom) + 1 : 0}
  } else {
    var next, enter$1 = true;
    for (;; i++, enter$1 = false) {
      next = i < this.children.length ? this.children[i] : null;
      if (!next || next.dom.parentNode == this.contentDOM) { break }
    }
    if (next && enter$1 && !next.border && !next.domAtom) { return next.domFromPos(0, side) }
    return {node: this.contentDOM, offset: next ? domIndex(next.dom) : this.contentDOM.childNodes.length}
  }
};

// Used to find a DOM range in a single parent for a given changed
// range.
ViewDesc.prototype.parseRange = function parseRange (from, to, base) {
    if ( base === void 0 ) base = 0;

  if (this.children.length == 0)
    { return {node: this.contentDOM, from: from, to: to, fromOffset: 0, toOffset: this.contentDOM.childNodes.length} }

  var fromOffset = -1, toOffset = -1;
  for (var offset = base, i = 0;; i++) {
    var child = this.children[i], end = offset + child.size;
    if (fromOffset == -1 && from <= end) {
      var childBase = offset + child.border;
      // FIXME maybe descend mark views to parse a narrower range?
      if (from >= childBase && to <= end - child.border && child.node &&
          child.contentDOM && this.contentDOM.contains(child.contentDOM))
        { return child.parseRange(from, to, childBase) }

      from = offset;
      for (var j = i; j > 0; j--) {
        var prev = this.children[j - 1];
        if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {
          fromOffset = domIndex(prev.dom) + 1;
          break
        }
        from -= prev.size;
      }
      if (fromOffset == -1) { fromOffset = 0; }
    }
    if (fromOffset > -1 && (end > to || i == this.children.length - 1)) {
      to = end;
      for (var j$1 = i + 1; j$1 < this.children.length; j$1++) {
        var next = this.children[j$1];
        if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {
          toOffset = domIndex(next.dom);
          break
        }
        to += next.size;
      }
      if (toOffset == -1) { toOffset = this.contentDOM.childNodes.length; }
      break
    }
    offset = end;
  }
  return {node: this.contentDOM, from: from, to: to, fromOffset: fromOffset, toOffset: toOffset}
};

ViewDesc.prototype.emptyChildAt = function emptyChildAt (side) {
  if (this.border || !this.contentDOM || !this.children.length) { return false }
  var child = this.children[side < 0 ? 0 : this.children.length - 1];
  return child.size == 0 || child.emptyChildAt(side)
};

// : (number) → dom.Node
ViewDesc.prototype.domAfterPos = function domAfterPos (pos) {
  var ref = this.domFromPos(pos, 0);
    var node = ref.node;
    var offset = ref.offset;
  if (node.nodeType != 1 || offset == node.childNodes.length)
    { throw new RangeError("No node after pos " + pos) }
  return node.childNodes[offset]
};

// : (number, number, dom.Document)
// View descs are responsible for setting any selection that falls
// entirely inside of them, so that custom implementations can do
// custom things with the selection. Note that this falls apart when
// a selection starts in such a node and ends in another, in which
// case we just use whatever domFromPos produces as a best effort.
ViewDesc.prototype.setSelection = function setSelection (anchor, head, root, force) {
  // If the selection falls entirely in a child, give it to that child
  var from = Math.min(anchor, head), to = Math.max(anchor, head);
  for (var i = 0, offset = 0; i < this.children.length; i++) {
    var child = this.children[i], end = offset + child.size;
    if (from > offset && to < end)
      { return child.setSelection(anchor - offset - child.border, head - offset - child.border, root, force) }
    offset = end;
  }

  var anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);
  var headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);
  var domSel = root.getSelection();

  var brKludge = false;
  // On Firefox, using Selection.collapse to put the cursor after a
  // BR node for some reason doesn't always work (#1073). On Safari,
  // the cursor sometimes inexplicable visually lags behind its
  // reported position in such situations (#1092).
  if ((result.gecko || result.safari) && anchor == head) {
    var node = anchorDOM.node;
      var offset$1 = anchorDOM.offset;
    if (node.nodeType == 3) {
      brKludge = offset$1 && node.nodeValue[offset$1 - 1] == "\n";
      // Issue #1128
      if (brKludge && offset$1 == node.nodeValue.length) {
        for (var scan = node, after = (void 0); scan; scan = scan.parentNode) {
          if (after = scan.nextSibling) {
            if (after.nodeName == "BR")
              { anchorDOM = headDOM = {node: after.parentNode, offset: domIndex(after) + 1}; }
            break
          }
          var desc = scan.pmViewDesc;
          if (desc && desc.node && desc.node.isBlock) { break }
        }
      }
    } else {
      var prev = node.childNodes[offset$1 - 1];
      brKludge = prev && (prev.nodeName == "BR" || prev.contentEditable == "false");
    }
  }
  // Firefox can act strangely when the selection is in front of an
  // uneditable node. See #1163 and https://bugzilla.mozilla.org/show_bug.cgi?id=1709536
  if (result.gecko && domSel.focusNode && domSel.focusNode != headDOM.node && domSel.focusNode.nodeType == 1) {
    var after$1 = domSel.focusNode.childNodes[domSel.focusOffset];
    if (after$1 && after$1.contentEditable == "false") { force = true; }
  }

  if (!(force || brKludge && result.safari) &&
      isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset) &&
      isEquivalentPosition(headDOM.node, headDOM.offset, domSel.focusNode, domSel.focusOffset))
    { return }

  // Selection.extend can be used to create an 'inverted' selection
  // (one where the focus is before the anchor), but not all
  // browsers support it yet.
  var domSelExtended = false;
  if ((domSel.extend || anchor == head) && !brKludge) {
    domSel.collapse(anchorDOM.node, anchorDOM.offset);
    try {
      if (anchor != head) { domSel.extend(headDOM.node, headDOM.offset); }
      domSelExtended = true;
    } catch (err) {
      // In some cases with Chrome the selection is empty after calling
      // collapse, even when it should be valid. This appears to be a bug, but
      // it is difficult to isolate. If this happens fallback to the old path
      // without using extend.
      if (!(err instanceof DOMException)) { throw err }
      // declare global: DOMException
    }
  }
  if (!domSelExtended) {
    if (anchor > head) { var tmp = anchorDOM; anchorDOM = headDOM; headDOM = tmp; }
    var range = document.createRange();
    range.setEnd(headDOM.node, headDOM.offset);
    range.setStart(anchorDOM.node, anchorDOM.offset);
    domSel.removeAllRanges();
    domSel.addRange(range);
  }
};

// : (dom.MutationRecord) → bool
ViewDesc.prototype.ignoreMutation = function ignoreMutation (mutation) {
  return !this.contentDOM && mutation.type != "selection"
};

prototypeAccessors.contentLost.get = function () {
  return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM)
};

// Remove a subtree of the element tree that has been touched
// by a DOM change, so that the next update will redraw it.
ViewDesc.prototype.markDirty = function markDirty (from, to) {
  for (var offset = 0, i = 0; i < this.children.length; i++) {
    var child = this.children[i], end = offset + child.size;
    if (offset == end ? from <= end && to >= offset : from < end && to > offset) {
      var startInside = offset + child.border, endInside = end - child.border;
      if (from >= startInside && to <= endInside) {
        this.dirty = from == offset || to == end ? CONTENT_DIRTY : CHILD_DIRTY;
        if (from == startInside && to == endInside &&
            (child.contentLost || child.dom.parentNode != this.contentDOM)) { child.dirty = NODE_DIRTY; }
        else { child.markDirty(from - startInside, to - startInside); }
        return
      } else {
        child.dirty = child.dom == child.contentDOM && child.dom.parentNode == this.contentDOM ? CONTENT_DIRTY : NODE_DIRTY;
      }
    }
    offset = end;
  }
  this.dirty = CONTENT_DIRTY;
};

ViewDesc.prototype.markParentsDirty = function markParentsDirty () {
  var level = 1;
  for (var node = this.parent; node; node = node.parent, level++) {
    var dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;
    if (node.dirty < dirty) { node.dirty = dirty; }
  }
};

prototypeAccessors.domAtom.get = function () { return false };

prototypeAccessors.ignoreForCoords.get = function () { return false };

Object.defineProperties( ViewDesc.prototype, prototypeAccessors );

// Reused array to avoid allocating fresh arrays for things that will
// stay empty anyway.
var nothing = [];

// A widget desc represents a widget decoration, which is a DOM node
// drawn between the document nodes.
var WidgetViewDesc = /*@__PURE__*/(function (ViewDesc) {
  function WidgetViewDesc(parent, widget, view, pos) {
    var self, dom = widget.type.toDOM;
    if (typeof dom == "function") { dom = dom(view, function () {
      if (!self) { return pos }
      if (self.parent) { return self.parent.posBeforeChild(self) }
    }); }
    if (!widget.type.spec.raw) {
      if (dom.nodeType != 1) {
        var wrap = document.createElement("span");
        wrap.appendChild(dom);
        dom = wrap;
      }
      dom.contentEditable = false;
      dom.classList.add("ProseMirror-widget");
    }
    ViewDesc.call(this, parent, nothing, dom, null);
    this.widget = widget;
    self = this;
  }

  if ( ViewDesc ) WidgetViewDesc.__proto__ = ViewDesc;
  WidgetViewDesc.prototype = Object.create( ViewDesc && ViewDesc.prototype );
  WidgetViewDesc.prototype.constructor = WidgetViewDesc;

  var prototypeAccessors$1 = { domAtom: { configurable: true } };

  WidgetViewDesc.prototype.matchesWidget = function matchesWidget (widget) {
    return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type)
  };

  WidgetViewDesc.prototype.parseRule = function parseRule () { return {ignore: true} };

  WidgetViewDesc.prototype.stopEvent = function stopEvent (event) {
    var stop = this.widget.spec.stopEvent;
    return stop ? stop(event) : false
  };

  WidgetViewDesc.prototype.ignoreMutation = function ignoreMutation (mutation) {
    return mutation.type != "selection" || this.widget.spec.ignoreSelection
  };

  prototypeAccessors$1.domAtom.get = function () { return true };

  Object.defineProperties( WidgetViewDesc.prototype, prototypeAccessors$1 );

  return WidgetViewDesc;
}(ViewDesc));

var CompositionViewDesc = /*@__PURE__*/(function (ViewDesc) {
  function CompositionViewDesc(parent, dom, textDOM, text) {
    ViewDesc.call(this, parent, nothing, dom, null);
    this.textDOM = textDOM;
    this.text = text;
  }

  if ( ViewDesc ) CompositionViewDesc.__proto__ = ViewDesc;
  CompositionViewDesc.prototype = Object.create( ViewDesc && ViewDesc.prototype );
  CompositionViewDesc.prototype.constructor = CompositionViewDesc;

  var prototypeAccessors$2 = { size: { configurable: true } };

  prototypeAccessors$2.size.get = function () { return this.text.length };

  CompositionViewDesc.prototype.localPosFromDOM = function localPosFromDOM (dom, offset) {
    if (dom != this.textDOM) { return this.posAtStart + (offset ? this.size : 0) }
    return this.posAtStart + offset
  };

  CompositionViewDesc.prototype.domFromPos = function domFromPos (pos) {
    return {node: this.textDOM, offset: pos}
  };

  CompositionViewDesc.prototype.ignoreMutation = function ignoreMutation (mut) {
    return mut.type === 'characterData' && mut.target.nodeValue == mut.oldValue
   };

  Object.defineProperties( CompositionViewDesc.prototype, prototypeAccessors$2 );

  return CompositionViewDesc;
}(ViewDesc));

// A mark desc represents a mark. May have multiple children,
// depending on how the mark is split. Note that marks are drawn using
// a fixed nesting order, for simplicity and predictability, so in
// some cases they will be split more often than would appear
// necessary.
var MarkViewDesc = /*@__PURE__*/(function (ViewDesc) {
  function MarkViewDesc(parent, mark, dom, contentDOM) {
    ViewDesc.call(this, parent, [], dom, contentDOM);
    this.mark = mark;
  }

  if ( ViewDesc ) MarkViewDesc.__proto__ = ViewDesc;
  MarkViewDesc.prototype = Object.create( ViewDesc && ViewDesc.prototype );
  MarkViewDesc.prototype.constructor = MarkViewDesc;

  MarkViewDesc.create = function create (parent, mark, inline, view) {
    var custom = view.nodeViews[mark.type.name];
    var spec = custom && custom(mark, view, inline);
    if (!spec || !spec.dom)
      { spec = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline)); }
    return new MarkViewDesc(parent, mark, spec.dom, spec.contentDOM || spec.dom)
  };

  MarkViewDesc.prototype.parseRule = function parseRule () { return {mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM} };

  MarkViewDesc.prototype.matchesMark = function matchesMark (mark) { return this.dirty != NODE_DIRTY && this.mark.eq(mark) };

  MarkViewDesc.prototype.markDirty = function markDirty (from, to) {
    ViewDesc.prototype.markDirty.call(this, from, to);
    // Move dirty info to nearest node view
    if (this.dirty != NOT_DIRTY) {
      var parent = this.parent;
      while (!parent.node) { parent = parent.parent; }
      if (parent.dirty < this.dirty) { parent.dirty = this.dirty; }
      this.dirty = NOT_DIRTY;
    }
  };

  MarkViewDesc.prototype.slice = function slice (from, to, view) {
    var copy = MarkViewDesc.create(this.parent, this.mark, true, view);
    var nodes = this.children, size = this.size;
    if (to < size) { nodes = replaceNodes(nodes, to, size, view); }
    if (from > 0) { nodes = replaceNodes(nodes, 0, from, view); }
    for (var i = 0; i < nodes.length; i++) { nodes[i].parent = copy; }
    copy.children = nodes;
    return copy
  };

  return MarkViewDesc;
}(ViewDesc));

// Node view descs are the main, most common type of view desc, and
// correspond to an actual node in the document. Unlike mark descs,
// they populate their child array themselves.
var NodeViewDesc = /*@__PURE__*/(function (ViewDesc) {
  function NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos) {
    ViewDesc.call(this, parent, node.isLeaf ? nothing : [], dom, contentDOM);
    this.nodeDOM = nodeDOM;
    this.node = node;
    this.outerDeco = outerDeco;
    this.innerDeco = innerDeco;
    if (contentDOM) { this.updateChildren(view, pos); }
  }

  if ( ViewDesc ) NodeViewDesc.__proto__ = ViewDesc;
  NodeViewDesc.prototype = Object.create( ViewDesc && ViewDesc.prototype );
  NodeViewDesc.prototype.constructor = NodeViewDesc;

  var prototypeAccessors$3 = { size: { configurable: true },border: { configurable: true },domAtom: { configurable: true } };

  // By default, a node is rendered using the `toDOM` method from the
  // node type spec. But client code can use the `nodeViews` spec to
  // supply a custom node view, which can influence various aspects of
  // the way the node works.
  //
  // (Using subclassing for this was intentionally decided against,
  // since it'd require exposing a whole slew of finicky
  // implementation details to the user code that they probably will
  // never need.)
  NodeViewDesc.create = function create (parent, node, outerDeco, innerDeco, view, pos) {
    var assign;

    var custom = view.nodeViews[node.type.name], descObj;
    var spec = custom && custom(node, view, function () {
      // (This is a function that allows the custom view to find its
      // own position)
      if (!descObj) { return pos }
      if (descObj.parent) { return descObj.parent.posBeforeChild(descObj) }
    }, outerDeco, innerDeco);

    var dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;
    if (node.isText) {
      if (!dom) { dom = document.createTextNode(node.text); }
      else if (dom.nodeType != 3) { throw new RangeError("Text must be rendered as a DOM text node") }
    } else if (!dom) {
((assign = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.DOMSerializer.renderSpec(document, node.type.spec.toDOM(node)), dom = assign.dom, contentDOM = assign.contentDOM));
    }
    if (!contentDOM && !node.isText && dom.nodeName != "BR") { // Chrome gets confused by <br contenteditable=false>
      if (!dom.hasAttribute("contenteditable")) { dom.contentEditable = false; }
      if (node.type.spec.draggable) { dom.draggable = true; }
    }

    var nodeDOM = dom;
    dom = applyOuterDeco(dom, outerDeco, node);

    if (spec)
      { return descObj = new CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM,
                                              spec, view, pos + 1) }
    else if (node.isText)
      { return new TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) }
    else
      { return new NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos + 1) }
  };

  NodeViewDesc.prototype.parseRule = function parseRule () {
    var this$1 = this;

    // Experimental kludge to allow opt-in re-parsing of nodes
    if (this.node.type.spec.reparseInView) { return null }
    // FIXME the assumption that this can always return the current
    // attrs means that if the user somehow manages to change the
    // attrs in the dom, that won't be picked up. Not entirely sure
    // whether this is a problem
    var rule = {node: this.node.type.name, attrs: this.node.attrs};
    if (this.node.type.spec.code) { rule.preserveWhitespace = "full"; }
    if (this.contentDOM && !this.contentLost) { rule.contentElement = this.contentDOM; }
    else { rule.getContent = function () { return this$1.contentDOM ? prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty : this$1.node.content; }; }
    return rule
  };

  NodeViewDesc.prototype.matchesNode = function matchesNode (node, outerDeco, innerDeco) {
    return this.dirty == NOT_DIRTY && node.eq(this.node) &&
      sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco)
  };

  prototypeAccessors$3.size.get = function () { return this.node.nodeSize };

  prototypeAccessors$3.border.get = function () { return this.node.isLeaf ? 0 : 1 };

  // Syncs `this.children` to match `this.node.content` and the local
  // decorations, possibly introducing nesting for marks. Then, in a
  // separate step, syncs the DOM inside `this.contentDOM` to
  // `this.children`.
  NodeViewDesc.prototype.updateChildren = function updateChildren (view, pos) {
    var this$1 = this;

    var inline = this.node.inlineContent, off = pos;
    var composition = view.composing && this.localCompositionInfo(view, pos);
    var localComposition = composition && composition.pos > -1 ? composition : null;
    var compositionInChild = composition && composition.pos < 0;
    var updater = new ViewTreeUpdater(this, localComposition && localComposition.node);
    iterDeco(this.node, this.innerDeco, function (widget, i, insideNode) {
      if (widget.spec.marks)
        { updater.syncToMarks(widget.spec.marks, inline, view); }
      else if (widget.type.side >= 0 && !insideNode)
        { updater.syncToMarks(i == this$1.node.childCount ? prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Mark.none : this$1.node.child(i).marks, inline, view); }
      // If the next node is a desc matching this widget, reuse it,
      // otherwise insert the widget as a new view desc.
      updater.placeWidget(widget, view, off);
    }, function (child, outerDeco, innerDeco, i) {
      // Make sure the wrapping mark descs match the node's marks.
      updater.syncToMarks(child.marks, inline, view);
      // Try several strategies for drawing this node
      var compIndex;
      if (updater.findNodeMatch(child, outerDeco, innerDeco, i)) ; else if (compositionInChild && view.state.selection.from > off &&
                 view.state.selection.to < off + child.nodeSize &&
                 (compIndex = updater.findIndexWithChild(composition.node)) > -1 &&
                 updater.updateNodeAt(child, outerDeco, innerDeco, compIndex, view)) ; else if (updater.updateNextNode(child, outerDeco, innerDeco, view, i)) ; else {
        // Add it as a new view
        updater.addNode(child, outerDeco, innerDeco, view, off);
      }
      off += child.nodeSize;
    });
    // Drop all remaining descs after the current position.
    updater.syncToMarks(nothing, inline, view);
    if (this.node.isTextblock) { updater.addTextblockHacks(); }
    updater.destroyRest();

    // Sync the DOM if anything changed
    if (updater.changed || this.dirty == CONTENT_DIRTY) {
      // May have to protect focused DOM from being changed if a composition is active
      if (localComposition) { this.protectLocalComposition(view, localComposition); }
      renderDescs(this.contentDOM, this.children, view);
      if (result.ios) { iosHacks(this.dom); }
    }
  };

  NodeViewDesc.prototype.localCompositionInfo = function localCompositionInfo (view, pos) {
    // Only do something if both the selection and a focused text node
    // are inside of this node
    var ref = view.state.selection;
    var from = ref.from;
    var to = ref.to;
    if (!(view.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection) || from < pos || to > pos + this.node.content.size) { return }
    var sel = view.root.getSelection();
    var textNode = nearbyTextNode(sel.focusNode, sel.focusOffset);
    if (!textNode || !this.dom.contains(textNode.parentNode)) { return }

    if (this.node.inlineContent) {
      // Find the text in the focused node in the node, stop if it's not
      // there (may have been modified through other means, in which
      // case it should overwritten)
      var text = textNode.nodeValue;
      var textPos = findTextInFragment(this.node.content, text, from - pos, to - pos);
      return textPos < 0 ? null : {node: textNode, pos: textPos, text: text}
    } else {
      return {node: textNode, pos: -1}
    }
  };

  NodeViewDesc.prototype.protectLocalComposition = function protectLocalComposition (view, ref) {
    var node = ref.node;
    var pos = ref.pos;
    var text = ref.text;

    // The node is already part of a local view desc, leave it there
    if (this.getDesc(node)) { return }

    // Create a composition view for the orphaned nodes
    var topNode = node;
    for (;; topNode = topNode.parentNode) {
      if (topNode.parentNode == this.contentDOM) { break }
      while (topNode.previousSibling) { topNode.parentNode.removeChild(topNode.previousSibling); }
      while (topNode.nextSibling) { topNode.parentNode.removeChild(topNode.nextSibling); }
      if (topNode.pmViewDesc) { topNode.pmViewDesc = null; }
    }
    var desc = new CompositionViewDesc(this, topNode, node, text);
    view.compositionNodes.push(desc);

    // Patch up this.children to contain the composition view
    this.children = replaceNodes(this.children, pos, pos + text.length, view, desc);
  };

  // : (Node, [Decoration], DecorationSource, EditorView) → bool
  // If this desc be updated to match the given node decoration,
  // do so and return true.
  NodeViewDesc.prototype.update = function update (node, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY ||
        !node.sameMarkup(this.node)) { return false }
    this.updateInner(node, outerDeco, innerDeco, view);
    return true
  };

  NodeViewDesc.prototype.updateInner = function updateInner (node, outerDeco, innerDeco, view) {
    this.updateOuterDeco(outerDeco);
    this.node = node;
    this.innerDeco = innerDeco;
    if (this.contentDOM) { this.updateChildren(view, this.posAtStart); }
    this.dirty = NOT_DIRTY;
  };

  NodeViewDesc.prototype.updateOuterDeco = function updateOuterDeco (outerDeco) {
    if (sameOuterDeco(outerDeco, this.outerDeco)) { return }
    var needsWrap = this.nodeDOM.nodeType != 1;
    var oldDOM = this.dom;
    this.dom = patchOuterDeco(this.dom, this.nodeDOM,
                              computeOuterDeco(this.outerDeco, this.node, needsWrap),
                              computeOuterDeco(outerDeco, this.node, needsWrap));
    if (this.dom != oldDOM) {
      oldDOM.pmViewDesc = null;
      this.dom.pmViewDesc = this;
    }
    this.outerDeco = outerDeco;
  };

  // Mark this node as being the selected node.
  NodeViewDesc.prototype.selectNode = function selectNode () {
    this.nodeDOM.classList.add("ProseMirror-selectednode");
    if (this.contentDOM || !this.node.type.spec.draggable) { this.dom.draggable = true; }
  };

  // Remove selected node marking from this node.
  NodeViewDesc.prototype.deselectNode = function deselectNode () {
    this.nodeDOM.classList.remove("ProseMirror-selectednode");
    if (this.contentDOM || !this.node.type.spec.draggable) { this.dom.removeAttribute("draggable"); }
  };

  prototypeAccessors$3.domAtom.get = function () { return this.node.isAtom };

  Object.defineProperties( NodeViewDesc.prototype, prototypeAccessors$3 );

  return NodeViewDesc;
}(ViewDesc));

// Create a view desc for the top-level document node, to be exported
// and used by the view class.
function docViewDesc(doc, outerDeco, innerDeco, dom, view) {
  applyOuterDeco(dom, outerDeco, doc);
  return new NodeViewDesc(null, doc, outerDeco, innerDeco, dom, dom, dom, view, 0)
}

var TextViewDesc = /*@__PURE__*/(function (NodeViewDesc) {
  function TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) {
    NodeViewDesc.call(this, parent, node, outerDeco, innerDeco, dom, null, nodeDOM, view);
  }

  if ( NodeViewDesc ) TextViewDesc.__proto__ = NodeViewDesc;
  TextViewDesc.prototype = Object.create( NodeViewDesc && NodeViewDesc.prototype );
  TextViewDesc.prototype.constructor = TextViewDesc;

  var prototypeAccessors$4 = { domAtom: { configurable: true } };

  TextViewDesc.prototype.parseRule = function parseRule () {
    var skip = this.nodeDOM.parentNode;
    while (skip && skip != this.dom && !skip.pmIsDeco) { skip = skip.parentNode; }
    return {skip: skip || true}
  };

  TextViewDesc.prototype.update = function update (node, outerDeco, _, view) {
    if (this.dirty == NODE_DIRTY || (this.dirty != NOT_DIRTY && !this.inParent()) ||
        !node.sameMarkup(this.node)) { return false }
    this.updateOuterDeco(outerDeco);
    if ((this.dirty != NOT_DIRTY || node.text != this.node.text) && node.text != this.nodeDOM.nodeValue) {
      this.nodeDOM.nodeValue = node.text;
      if (view.trackWrites == this.nodeDOM) { view.trackWrites = null; }
    }
    this.node = node;
    this.dirty = NOT_DIRTY;
    return true
  };

  TextViewDesc.prototype.inParent = function inParent () {
    var parentDOM = this.parent.contentDOM;
    for (var n = this.nodeDOM; n; n = n.parentNode) { if (n == parentDOM) { return true } }
    return false
  };

  TextViewDesc.prototype.domFromPos = function domFromPos (pos) {
    return {node: this.nodeDOM, offset: pos}
  };

  TextViewDesc.prototype.localPosFromDOM = function localPosFromDOM (dom, offset, bias) {
    if (dom == this.nodeDOM) { return this.posAtStart + Math.min(offset, this.node.text.length) }
    return NodeViewDesc.prototype.localPosFromDOM.call(this, dom, offset, bias)
  };

  TextViewDesc.prototype.ignoreMutation = function ignoreMutation (mutation) {
    return mutation.type != "characterData" && mutation.type != "selection"
  };

  TextViewDesc.prototype.slice = function slice (from, to, view) {
    var node = this.node.cut(from, to), dom = document.createTextNode(node.text);
    return new TextViewDesc(this.parent, node, this.outerDeco, this.innerDeco, dom, dom, view)
  };

  TextViewDesc.prototype.markDirty = function markDirty (from, to) {
    NodeViewDesc.prototype.markDirty.call(this, from, to);
    if (this.dom != this.nodeDOM && (from == 0 || to == this.nodeDOM.nodeValue.length))
      { this.dirty = NODE_DIRTY; }
  };

  prototypeAccessors$4.domAtom.get = function () { return false };

  Object.defineProperties( TextViewDesc.prototype, prototypeAccessors$4 );

  return TextViewDesc;
}(NodeViewDesc));

// A dummy desc used to tag trailing BR or IMG nodes created to work
// around contentEditable terribleness.
var TrailingHackViewDesc = /*@__PURE__*/(function (ViewDesc) {
  function TrailingHackViewDesc () {
    ViewDesc.apply(this, arguments);
  }

  if ( ViewDesc ) TrailingHackViewDesc.__proto__ = ViewDesc;
  TrailingHackViewDesc.prototype = Object.create( ViewDesc && ViewDesc.prototype );
  TrailingHackViewDesc.prototype.constructor = TrailingHackViewDesc;

  var prototypeAccessors$5 = { domAtom: { configurable: true },ignoreForCoords: { configurable: true } };

  TrailingHackViewDesc.prototype.parseRule = function parseRule () { return {ignore: true} };
  TrailingHackViewDesc.prototype.matchesHack = function matchesHack (nodeName) { return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName };
  prototypeAccessors$5.domAtom.get = function () { return true };
  prototypeAccessors$5.ignoreForCoords.get = function () { return this.dom.nodeName == "IMG" };

  Object.defineProperties( TrailingHackViewDesc.prototype, prototypeAccessors$5 );

  return TrailingHackViewDesc;
}(ViewDesc));

// A separate subclass is used for customized node views, so that the
// extra checks only have to be made for nodes that are actually
// customized.
var CustomNodeViewDesc = /*@__PURE__*/(function (NodeViewDesc) {
  function CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos) {
    NodeViewDesc.call(this, parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos);
    this.spec = spec;
  }

  if ( NodeViewDesc ) CustomNodeViewDesc.__proto__ = NodeViewDesc;
  CustomNodeViewDesc.prototype = Object.create( NodeViewDesc && NodeViewDesc.prototype );
  CustomNodeViewDesc.prototype.constructor = CustomNodeViewDesc;

  // A custom `update` method gets to decide whether the update goes
  // through. If it does, and there's a `contentDOM` node, our logic
  // updates the children.
  CustomNodeViewDesc.prototype.update = function update (node, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY) { return false }
    if (this.spec.update) {
      var result = this.spec.update(node, outerDeco, innerDeco);
      if (result) { this.updateInner(node, outerDeco, innerDeco, view); }
      return result
    } else if (!this.contentDOM && !node.isLeaf) {
      return false
    } else {
      return NodeViewDesc.prototype.update.call(this, node, outerDeco, innerDeco, view)
    }
  };

  CustomNodeViewDesc.prototype.selectNode = function selectNode () {
    this.spec.selectNode ? this.spec.selectNode() : NodeViewDesc.prototype.selectNode.call(this);
  };

  CustomNodeViewDesc.prototype.deselectNode = function deselectNode () {
    this.spec.deselectNode ? this.spec.deselectNode() : NodeViewDesc.prototype.deselectNode.call(this);
  };

  CustomNodeViewDesc.prototype.setSelection = function setSelection (anchor, head, root, force) {
    this.spec.setSelection ? this.spec.setSelection(anchor, head, root)
      : NodeViewDesc.prototype.setSelection.call(this, anchor, head, root, force);
  };

  CustomNodeViewDesc.prototype.destroy = function destroy () {
    if (this.spec.destroy) { this.spec.destroy(); }
    NodeViewDesc.prototype.destroy.call(this);
  };

  CustomNodeViewDesc.prototype.stopEvent = function stopEvent (event) {
    return this.spec.stopEvent ? this.spec.stopEvent(event) : false
  };

  CustomNodeViewDesc.prototype.ignoreMutation = function ignoreMutation (mutation) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : NodeViewDesc.prototype.ignoreMutation.call(this, mutation)
  };

  return CustomNodeViewDesc;
}(NodeViewDesc));

// : (dom.Node, [ViewDesc])
// Sync the content of the given DOM node with the nodes associated
// with the given array of view descs, recursing into mark descs
// because this should sync the subtree for a whole node at a time.
function renderDescs(parentDOM, descs, view) {
  var dom = parentDOM.firstChild, written = false;
  for (var i = 0; i < descs.length; i++) {
    var desc = descs[i], childDOM = desc.dom;
    if (childDOM.parentNode == parentDOM) {
      while (childDOM != dom) { dom = rm(dom); written = true; }
      dom = dom.nextSibling;
    } else {
      written = true;
      parentDOM.insertBefore(childDOM, dom);
    }
    if (desc instanceof MarkViewDesc) {
      var pos = dom ? dom.previousSibling : parentDOM.lastChild;
      renderDescs(desc.contentDOM, desc.children, view);
      dom = pos ? pos.nextSibling : parentDOM.firstChild;
    }
  }
  while (dom) { dom = rm(dom); written = true; }
  if (written && view.trackWrites == parentDOM) { view.trackWrites = null; }
}

function OuterDecoLevel(nodeName) {
  if (nodeName) { this.nodeName = nodeName; }
}
OuterDecoLevel.prototype = Object.create(null);

var noDeco = [new OuterDecoLevel];

function computeOuterDeco(outerDeco, node, needsWrap) {
  if (outerDeco.length == 0) { return noDeco }

  var top = needsWrap ? noDeco[0] : new OuterDecoLevel, result = [top];

  for (var i = 0; i < outerDeco.length; i++) {
    var attrs = outerDeco[i].type.attrs;
    if (!attrs) { continue }
    if (attrs.nodeName)
      { result.push(top = new OuterDecoLevel(attrs.nodeName)); }

    for (var name in attrs) {
      var val = attrs[name];
      if (val == null) { continue }
      if (needsWrap && result.length == 1)
        { result.push(top = new OuterDecoLevel(node.isInline ? "span" : "div")); }
      if (name == "class") { top.class = (top.class ? top.class + " " : "") + val; }
      else if (name == "style") { top.style = (top.style ? top.style + ";" : "") + val; }
      else if (name != "nodeName") { top[name] = val; }
    }
  }

  return result
}

function patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {
  // Shortcut for trivial case
  if (prevComputed == noDeco && curComputed == noDeco) { return nodeDOM }

  var curDOM = nodeDOM;
  for (var i = 0; i < curComputed.length; i++) {
    var deco = curComputed[i], prev = prevComputed[i];
    if (i) {
      var parent = (void 0);
      if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM &&
          (parent = curDOM.parentNode) && parent.tagName.toLowerCase() == deco.nodeName) {
        curDOM = parent;
      } else {
        parent = document.createElement(deco.nodeName);
        parent.pmIsDeco = true;
        parent.appendChild(curDOM);
        prev = noDeco[0];
        curDOM = parent;
      }
    }
    patchAttributes(curDOM, prev || noDeco[0], deco);
  }
  return curDOM
}

function patchAttributes(dom, prev, cur) {
  for (var name in prev)
    { if (name != "class" && name != "style" && name != "nodeName" && !(name in cur))
      { dom.removeAttribute(name); } }
  for (var name$1 in cur)
    { if (name$1 != "class" && name$1 != "style" && name$1 != "nodeName" && cur[name$1] != prev[name$1])
      { dom.setAttribute(name$1, cur[name$1]); } }
  if (prev.class != cur.class) {
    var prevList = prev.class ? prev.class.split(" ").filter(Boolean) : nothing;
    var curList = cur.class ? cur.class.split(" ").filter(Boolean) : nothing;
    for (var i = 0; i < prevList.length; i++) { if (curList.indexOf(prevList[i]) == -1)
      { dom.classList.remove(prevList[i]); } }
    for (var i$1 = 0; i$1 < curList.length; i$1++) { if (prevList.indexOf(curList[i$1]) == -1)
      { dom.classList.add(curList[i$1]); } }
  }
  if (prev.style != cur.style) {
    if (prev.style) {
      var prop = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, m;
      while (m = prop.exec(prev.style))
        { dom.style.removeProperty(m[1]); }
    }
    if (cur.style)
      { dom.style.cssText += cur.style; }
  }
}

function applyOuterDeco(dom, deco, node) {
  return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node, dom.nodeType != 1))
}

// : ([Decoration], [Decoration]) → bool
function sameOuterDeco(a, b) {
  if (a.length != b.length) { return false }
  for (var i = 0; i < a.length; i++) { if (!a[i].type.eq(b[i].type)) { return false } }
  return true
}

// Remove a DOM node and return its next sibling.
function rm(dom) {
  var next = dom.nextSibling;
  dom.parentNode.removeChild(dom);
  return next
}

// Helper class for incrementally updating a tree of mark descs and
// the widget and node descs inside of them.
var ViewTreeUpdater = function ViewTreeUpdater(top, lockedNode) {
  this.top = top;
  this.lock = lockedNode;
  // Index into `this.top`'s child array, represents the current
  // update position.
  this.index = 0;
  // When entering a mark, the current top and index are pushed
  // onto this.
  this.stack = [];
  // Tracks whether anything was changed
  this.changed = false;

  this.preMatch = preMatch(top.node.content, top.children);
};

// Destroy and remove the children between the given indices in
// `this.top`.
ViewTreeUpdater.prototype.destroyBetween = function destroyBetween (start, end) {
  if (start == end) { return }
  for (var i = start; i < end; i++) { this.top.children[i].destroy(); }
  this.top.children.splice(start, end - start);
  this.changed = true;
};

// Destroy all remaining children in `this.top`.
ViewTreeUpdater.prototype.destroyRest = function destroyRest () {
  this.destroyBetween(this.index, this.top.children.length);
};

// : ([Mark], EditorView)
// Sync the current stack of mark descs with the given array of
// marks, reusing existing mark descs when possible.
ViewTreeUpdater.prototype.syncToMarks = function syncToMarks (marks, inline, view) {
  var keep = 0, depth = this.stack.length >> 1;
  var maxKeep = Math.min(depth, marks.length);
  while (keep < maxKeep &&
         (keep == depth - 1 ? this.top : this.stack[(keep + 1) << 1]).matchesMark(marks[keep]) && marks[keep].type.spec.spanning !== false)
    { keep++; }

  while (keep < depth) {
    this.destroyRest();
    this.top.dirty = NOT_DIRTY;
    this.index = this.stack.pop();
    this.top = this.stack.pop();
    depth--;
  }
  while (depth < marks.length) {
    this.stack.push(this.top, this.index + 1);
    var found = -1;
    for (var i = this.index; i < Math.min(this.index + 3, this.top.children.length); i++) {
      if (this.top.children[i].matchesMark(marks[depth])) { found = i; break }
    }
    if (found > -1) {
      if (found > this.index) {
        this.changed = true;
        this.destroyBetween(this.index, found);
      }
      this.top = this.top.children[this.index];
    } else {
      var markDesc = MarkViewDesc.create(this.top, marks[depth], inline, view);
      this.top.children.splice(this.index, 0, markDesc);
      this.top = markDesc;
      this.changed = true;
    }
    this.index = 0;
    depth++;
  }
};

// : (Node, [Decoration], DecorationSource) → bool
// Try to find a node desc matching the given data. Skip over it and
// return true when successful.
ViewTreeUpdater.prototype.findNodeMatch = function findNodeMatch (node, outerDeco, innerDeco, index) {
  var children = this.top.children, found = -1;
  if (index >= this.preMatch.index) {
    for (var i = this.index; i < children.length; i++) { if (children[i].matchesNode(node, outerDeco, innerDeco)) {
      found = i;
      break
    } }
  } else {
    for (var i$1 = this.index, e = Math.min(children.length, i$1 + 1); i$1 < e; i$1++) {
      var child = children[i$1];
      if (child.matchesNode(node, outerDeco, innerDeco) && !this.preMatch.matched.has(child)) {
        found = i$1;
        break
      }
    }
  }
  if (found < 0) { return false }
  this.destroyBetween(this.index, found);
  this.index++;
  return true
};

ViewTreeUpdater.prototype.updateNodeAt = function updateNodeAt (node, outerDeco, innerDeco, index, view) {
  var child = this.top.children[index];
  if (!child.update(node, outerDeco, innerDeco, view)) { return false }
  this.destroyBetween(this.index, index);
  this.index = index + 1;
  return true
};

ViewTreeUpdater.prototype.findIndexWithChild = function findIndexWithChild (domNode) {
  for (;;) {
    var parent = domNode.parentNode;
    if (!parent) { return -1 }
    if (parent == this.top.contentDOM) {
      var desc = domNode.pmViewDesc;
      if (desc) { for (var i = this.index; i < this.top.children.length; i++) {
        if (this.top.children[i] == desc) { return i }
      } }
      return -1
    }
    domNode = parent;
  }
};

// : (Node, [Decoration], DecorationSource, EditorView, Fragment, number) → bool
// Try to update the next node, if any, to the given data. Checks
// pre-matches to avoid overwriting nodes that could still be used.
ViewTreeUpdater.prototype.updateNextNode = function updateNextNode (node, outerDeco, innerDeco, view, index) {
  for (var i = this.index; i < this.top.children.length; i++) {
    var next = this.top.children[i];
    if (next instanceof NodeViewDesc) {
      var preMatch = this.preMatch.matched.get(next);
      if (preMatch != null && preMatch != index) { return false }
      var nextDOM = next.dom;

      // Can't update if nextDOM is or contains this.lock, except if
      // it's a text node whose content already matches the new text
      // and whose decorations match the new ones.
      var locked = this.lock && (nextDOM == this.lock || nextDOM.nodeType == 1 && nextDOM.contains(this.lock.parentNode)) &&
          !(node.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node.text &&
            next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));
      if (!locked && next.update(node, outerDeco, innerDeco, view)) {
        this.destroyBetween(this.index, i);
        if (next.dom != nextDOM) { this.changed = true; }
        this.index++;
        return true
      }
      break
    }
  }
  return false
};

// : (Node, [Decoration], DecorationSource, EditorView)
// Insert the node as a newly created node desc.
ViewTreeUpdater.prototype.addNode = function addNode (node, outerDeco, innerDeco, view, pos) {
  this.top.children.splice(this.index++, 0, NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos));
  this.changed = true;
};

ViewTreeUpdater.prototype.placeWidget = function placeWidget (widget, view, pos) {
  var next = this.index < this.top.children.length ? this.top.children[this.index] : null;
  if (next && next.matchesWidget(widget) && (widget == next.widget || !next.widget.type.toDOM.parentNode)) {
    this.index++;
  } else {
    var desc = new WidgetViewDesc(this.top, widget, view, pos);
    this.top.children.splice(this.index++, 0, desc);
    this.changed = true;
  }
};

// Make sure a textblock looks and behaves correctly in
// contentEditable.
ViewTreeUpdater.prototype.addTextblockHacks = function addTextblockHacks () {
  var lastChild = this.top.children[this.index - 1];
  while (lastChild instanceof MarkViewDesc) { lastChild = lastChild.children[lastChild.children.length - 1]; }

  if (!lastChild || // Empty textblock
      !(lastChild instanceof TextViewDesc) ||
      /\n$/.test(lastChild.node.text)) {
    // Avoid bugs in Safari's cursor drawing (#1165) and Chrome's mouse selection (#1152)
    if ((result.safari || result.chrome) && lastChild && lastChild.dom.contentEditable == "false")
      { this.addHackNode("IMG"); }
    this.addHackNode("BR");
  }
};

ViewTreeUpdater.prototype.addHackNode = function addHackNode (nodeName) {
  if (this.index < this.top.children.length && this.top.children[this.index].matchesHack(nodeName)) {
    this.index++;
  } else {
    var dom = document.createElement(nodeName);
    if (nodeName == "IMG") { dom.className = "ProseMirror-separator"; }
    if (nodeName == "BR") { dom.className = "ProseMirror-trailingBreak"; }
    this.top.children.splice(this.index++, 0, new TrailingHackViewDesc(this.top, nothing, dom, null));
    this.changed = true;
  }
};

// : (Fragment, [ViewDesc]) → {index: number, matched: Map<ViewDesc, number>}
// Iterate from the end of the fragment and array of descs to find
// directly matching ones, in order to avoid overeagerly reusing those
// for other nodes. Returns the fragment index of the first node that
// is part of the sequence of matched nodes at the end of the
// fragment.
function preMatch(frag, descs) {
  var fI = frag.childCount, dI = descs.length, matched = new Map;
  for (; fI > 0 && dI > 0; dI--) {
    var desc = descs[dI - 1], node = desc.node;
    if (!node) { continue }
    if (node != frag.child(fI - 1)) { break }
    --fI;
    matched.set(desc, fI);
  }
  return {index: fI, matched: matched}
}

function compareSide(a, b) { return a.type.side - b.type.side }

// : (ViewDesc, DecorationSource, (Decoration, number), (Node, [Decoration], DecorationSource, number))
// This function abstracts iterating over the nodes and decorations in
// a fragment. Calls `onNode` for each node, with its local and child
// decorations. Splits text nodes when there is a decoration starting
// or ending inside of them. Calls `onWidget` for each widget.
function iterDeco(parent, deco, onWidget, onNode) {
  var locals = deco.locals(parent), offset = 0;
  // Simple, cheap variant for when there are no local decorations
  if (locals.length == 0) {
    for (var i = 0; i < parent.childCount; i++) {
      var child = parent.child(i);
      onNode(child, locals, deco.forChild(offset, child), i);
      offset += child.nodeSize;
    }
    return
  }

  var decoIndex = 0, active = [], restNode = null;
  for (var parentIndex = 0;;) {
    if (decoIndex < locals.length && locals[decoIndex].to == offset) {
      var widget = locals[decoIndex++], widgets = (void 0);
      while (decoIndex < locals.length && locals[decoIndex].to == offset)
        { (widgets || (widgets = [widget])).push(locals[decoIndex++]); }
      if (widgets) {
        widgets.sort(compareSide);
        for (var i$1 = 0; i$1 < widgets.length; i$1++) { onWidget(widgets[i$1], parentIndex, !!restNode); }
      } else {
        onWidget(widget, parentIndex, !!restNode);
      }
    }

    var child$1 = (void 0), index = (void 0);
    if (restNode) {
      index = -1;
      child$1 = restNode;
      restNode = null;
    } else if (parentIndex < parent.childCount) {
      index = parentIndex;
      child$1 = parent.child(parentIndex++);
    } else {
      break
    }

    for (var i$2 = 0; i$2 < active.length; i$2++) { if (active[i$2].to <= offset) { active.splice(i$2--, 1); } }
    while (decoIndex < locals.length && locals[decoIndex].from <= offset && locals[decoIndex].to > offset)
      { active.push(locals[decoIndex++]); }

    var end = offset + child$1.nodeSize;
    if (child$1.isText) {
      var cutAt = end;
      if (decoIndex < locals.length && locals[decoIndex].from < cutAt) { cutAt = locals[decoIndex].from; }
      for (var i$3 = 0; i$3 < active.length; i$3++) { if (active[i$3].to < cutAt) { cutAt = active[i$3].to; } }
      if (cutAt < end) {
        restNode = child$1.cut(cutAt - offset);
        child$1 = child$1.cut(0, cutAt - offset);
        end = cutAt;
        index = -1;
      }
    }

    var outerDeco = !active.length ? nothing
        : child$1.isInline && !child$1.isLeaf ? active.filter(function (d) { return !d.inline; })
        : active.slice();
    onNode(child$1, outerDeco, deco.forChild(offset, child$1), index);
    offset = end;
  }
}

// List markers in Mobile Safari will mysteriously disappear
// sometimes. This works around that.
function iosHacks(dom) {
  if (dom.nodeName == "UL" || dom.nodeName == "OL") {
    var oldCSS = dom.style.cssText;
    dom.style.cssText = oldCSS + "; list-style: square !important";
    window.getComputedStyle(dom).listStyle;
    dom.style.cssText = oldCSS;
  }
}

function nearbyTextNode(node, offset) {
  for (;;) {
    if (node.nodeType == 3) { return node }
    if (node.nodeType == 1 && offset > 0) {
      if (node.childNodes.length > offset && node.childNodes[offset].nodeType == 3)
        { return node.childNodes[offset] }
      node = node.childNodes[offset - 1];
      offset = nodeSize(node);
    } else if (node.nodeType == 1 && offset < node.childNodes.length) {
      node = node.childNodes[offset];
      offset = 0;
    } else {
      return null
    }
  }
}

// Find a piece of text in an inline fragment, overlapping from-to
function findTextInFragment(frag, text, from, to) {
  for (var i = 0, pos = 0; i < frag.childCount && pos <= to;) {
    var child = frag.child(i++), childStart = pos;
    pos += child.nodeSize;
    if (!child.isText) { continue }
    var str = child.text;
    while (i < frag.childCount) {
      var next = frag.child(i++);
      pos += next.nodeSize;
      if (!next.isText) { break }
      str += next.text;
    }
    if (pos >= from) {
      var found = str.lastIndexOf(text, to - childStart);
      if (found >= 0 && found + text.length + childStart >= from)
        { return childStart + found }
    }
  }
  return -1
}

// Replace range from-to in an array of view descs with replacement
// (may be null to just delete). This goes very much against the grain
// of the rest of this code, which tends to create nodes with the
// right shape in one go, rather than messing with them after
// creation, but is necessary in the composition hack.
function replaceNodes(nodes, from, to, view, replacement) {
  var result = [];
  for (var i = 0, off = 0; i < nodes.length; i++) {
    var child = nodes[i], start = off, end = off += child.size;
    if (start >= to || end <= from) {
      result.push(child);
    } else {
      if (start < from) { result.push(child.slice(0, from - start, view)); }
      if (replacement) {
        result.push(replacement);
        replacement = null;
      }
      if (end > to) { result.push(child.slice(to - start, child.size, view)); }
    }
  }
  return result
}

function selectionFromDOM(view, origin) {
  var domSel = view.root.getSelection(), doc = view.state.doc;
  if (!domSel.focusNode) { return null }
  var nearestDesc = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc && nearestDesc.size == 0;
  var head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);
  if (head < 0) { return null }
  var $head = doc.resolve(head), $anchor, selection;
  if (selectionCollapsed(domSel)) {
    $anchor = $head;
    while (nearestDesc && !nearestDesc.node) { nearestDesc = nearestDesc.parent; }
    if (nearestDesc && nearestDesc.node.isAtom && prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.isSelectable(nearestDesc.node) && nearestDesc.parent
        && !(nearestDesc.node.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc.dom))) {
      var pos = nearestDesc.posBefore;
      selection = new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection(head == pos ? $head : doc.resolve(pos));
    }
  } else {
    var anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);
    if (anchor < 0) { return null }
    $anchor = doc.resolve(anchor);
  }

  if (!selection) {
    var bias = origin == "pointer" || (view.state.selection.head < $head.pos && !inWidget) ? 1 : -1;
    selection = selectionBetween(view, $anchor, $head, bias);
  }
  return selection
}

function editorOwnsSelection(view) {
  return view.editable ? view.hasFocus() :
    hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom)
}

function selectionToDOM(view, force) {
  var sel = view.state.selection;
  syncNodeSelection(view, sel);

  if (!editorOwnsSelection(view)) { return }

  if (!force && view.mouseDown && view.mouseDown.allowDefault) {
    view.mouseDown.delayedSelectionSync = true;
    view.domObserver.setCurSelection();
    return
  }

  view.domObserver.disconnectSelection();

  if (view.cursorWrapper) {
    selectCursorWrapper(view);
  } else {
    var anchor = sel.anchor;
    var head = sel.head;
    var resetEditableFrom, resetEditableTo;
    if (brokenSelectBetweenUneditable && !(sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection)) {
      if (!sel.$from.parent.inlineContent)
        { resetEditableFrom = temporarilyEditableNear(view, sel.from); }
      if (!sel.empty && !sel.$from.parent.inlineContent)
        { resetEditableTo = temporarilyEditableNear(view, sel.to); }
    }
    view.docView.setSelection(anchor, head, view.root, force);
    if (brokenSelectBetweenUneditable) {
      if (resetEditableFrom) { resetEditable(resetEditableFrom); }
      if (resetEditableTo) { resetEditable(resetEditableTo); }
    }
    if (sel.visible) {
      view.dom.classList.remove("ProseMirror-hideselection");
    } else {
      view.dom.classList.add("ProseMirror-hideselection");
      if ("onselectionchange" in document) { removeClassOnSelectionChange(view); }
    }
  }

  view.domObserver.setCurSelection();
  view.domObserver.connectSelection();
}

// Kludge to work around Webkit not allowing a selection to start/end
// between non-editable block nodes. We briefly make something
// editable, set the selection, then set it uneditable again.

var brokenSelectBetweenUneditable = result.safari || result.chrome && result.chrome_version < 63;

function temporarilyEditableNear(view, pos) {
  var ref = view.docView.domFromPos(pos, 0);
  var node = ref.node;
  var offset = ref.offset;
  var after = offset < node.childNodes.length ? node.childNodes[offset] : null;
  var before = offset ? node.childNodes[offset - 1] : null;
  if (result.safari && after && after.contentEditable == "false") { return setEditable(after) }
  if ((!after || after.contentEditable == "false") && (!before || before.contentEditable == "false")) {
    if (after) { return setEditable(after) }
    else if (before) { return setEditable(before) }
  }
}

function setEditable(element) {
  element.contentEditable = "true";
  if (result.safari && element.draggable) { element.draggable = false; element.wasDraggable = true; }
  return element
}

function resetEditable(element) {
  element.contentEditable = "false";
  if (element.wasDraggable) { element.draggable = true; element.wasDraggable = null; }
}

function removeClassOnSelectionChange(view) {
  var doc = view.dom.ownerDocument;
  doc.removeEventListener("selectionchange", view.hideSelectionGuard);
  var domSel = view.root.getSelection();
  var node = domSel.anchorNode, offset = domSel.anchorOffset;
  doc.addEventListener("selectionchange", view.hideSelectionGuard = function () {
    if (domSel.anchorNode != node || domSel.anchorOffset != offset) {
      doc.removeEventListener("selectionchange", view.hideSelectionGuard);
      setTimeout(function () {
        if (!editorOwnsSelection(view) || view.state.selection.visible)
          { view.dom.classList.remove("ProseMirror-hideselection"); }
      }, 20);
    }
  });
}

function selectCursorWrapper(view) {
  var domSel = view.root.getSelection(), range = document.createRange();
  var node = view.cursorWrapper.dom, img = node.nodeName == "IMG";
  if (img) { range.setEnd(node.parentNode, domIndex(node) + 1); }
  else { range.setEnd(node, 0); }
  range.collapse(false);
  domSel.removeAllRanges();
  domSel.addRange(range);
  // Kludge to kill 'control selection' in IE11 when selecting an
  // invisible cursor wrapper, since that would result in those weird
  // resize handles and a selection that considers the absolutely
  // positioned wrapper, rather than the root editable node, the
  // focused element.
  if (!img && !view.state.selection.visible && result.ie && result.ie_version <= 11) {
    node.disabled = true;
    node.disabled = false;
  }
}

function syncNodeSelection(view, sel) {
  if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection) {
    var desc = view.docView.descAt(sel.from);
    if (desc != view.lastSelectedViewDesc) {
      clearNodeSelection(view);
      if (desc) { desc.selectNode(); }
      view.lastSelectedViewDesc = desc;
    }
  } else {
    clearNodeSelection(view);
  }
}

// Clear all DOM statefulness of the last node selection.
function clearNodeSelection(view) {
  if (view.lastSelectedViewDesc) {
    if (view.lastSelectedViewDesc.parent)
      { view.lastSelectedViewDesc.deselectNode(); }
    view.lastSelectedViewDesc = null;
  }
}

function selectionBetween(view, $anchor, $head, bias) {
  return view.someProp("createSelectionBetween", function (f) { return f(view, $anchor, $head); })
    || prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.between($anchor, $head, bias)
}

function hasFocusAndSelection(view) {
  if (view.editable && view.root.activeElement != view.dom) { return false }
  return hasSelection(view)
}

function hasSelection(view) {
  var sel = view.root.getSelection();
  if (!sel.anchorNode) { return false }
  try {
    // Firefox will raise 'permission denied' errors when accessing
    // properties of `sel.anchorNode` when it's in a generated CSS
    // element.
    return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) &&
      (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode))
  } catch(_) {
    return false
  }
}

function anchorInRightPlace(view) {
  var anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);
  var domSel = view.root.getSelection();
  return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset)
}

function moveSelectionBlock(state, dir) {
  var ref = state.selection;
  var $anchor = ref.$anchor;
  var $head = ref.$head;
  var $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);
  var $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;
  return $start && prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.findFrom($start, dir)
}

function apply(view, sel) {
  view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());
  return true
}

function selectHorizontally(view, dir, mods) {
  var sel = view.state.selection;
  if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection) {
    if (!sel.empty || mods.indexOf("s") > -1) {
      return false
    } else if (view.endOfTextblock(dir > 0 ? "right" : "left")) {
      var next = moveSelectionBlock(view.state, dir);
      if (next && (next instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection)) { return apply(view, next) }
      return false
    } else if (!(result.mac && mods.indexOf("m") > -1)) {
      var $head = sel.$head, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;
      if (!node || node.isText) { return false }
      var nodePos = dir < 0 ? $head.pos - node.nodeSize : $head.pos;
      if (!(node.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM)) { return false }
      if (prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.isSelectable(node)) {
        return apply(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node.nodeSize) : $head))
      } else if (result.webkit) {
        // Chrome and Safari will introduce extra pointless cursor
        // positions around inline uneditable nodes, so we have to
        // take over and move the cursor past them (#937)
        return apply(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node.nodeSize)))
      } else {
        return false
      }
    }
  } else if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection && sel.node.isInline) {
    return apply(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection(dir > 0 ? sel.$to : sel.$from))
  } else {
    var next$1 = moveSelectionBlock(view.state, dir);
    if (next$1) { return apply(view, next$1) }
    return false
  }
}

function nodeLen(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length
}

function isIgnorable(dom) {
  var desc = dom.pmViewDesc;
  return desc && desc.size == 0 && (dom.nextSibling || dom.nodeName != "BR")
}

// Make sure the cursor isn't directly after one or more ignored
// nodes, which will confuse the browser's cursor motion logic.
function skipIgnoredNodesLeft(view) {
  var sel = view.root.getSelection();
  var node = sel.focusNode, offset = sel.focusOffset;
  if (!node) { return }
  var moveNode, moveOffset, force = false;
  // Gecko will do odd things when the selection is directly in front
  // of a non-editable node, so in that case, move it into the next
  // node if possible. Issue prosemirror/prosemirror#832.
  if (result.gecko && node.nodeType == 1 && offset < nodeLen(node) && isIgnorable(node.childNodes[offset])) { force = true; }
  for (;;) {
    if (offset > 0) {
      if (node.nodeType != 1) {
        break
      } else {
        var before = node.childNodes[offset - 1];
        if (isIgnorable(before)) {
          moveNode = node;
          moveOffset = --offset;
        } else if (before.nodeType == 3) {
          node = before;
          offset = node.nodeValue.length;
        } else { break }
      }
    } else if (isBlockNode(node)) {
      break
    } else {
      var prev = node.previousSibling;
      while (prev && isIgnorable(prev)) {
        moveNode = node.parentNode;
        moveOffset = domIndex(prev);
        prev = prev.previousSibling;
      }
      if (!prev) {
        node = node.parentNode;
        if (node == view.dom) { break }
        offset = 0;
      } else {
        node = prev;
        offset = nodeLen(node);
      }
    }
  }
  if (force) { setSelFocus(view, sel, node, offset); }
  else if (moveNode) { setSelFocus(view, sel, moveNode, moveOffset); }
}

// Make sure the cursor isn't directly before one or more ignored
// nodes.
function skipIgnoredNodesRight(view) {
  var sel = view.root.getSelection();
  var node = sel.focusNode, offset = sel.focusOffset;
  if (!node) { return }
  var len = nodeLen(node);
  var moveNode, moveOffset;
  for (;;) {
    if (offset < len) {
      if (node.nodeType != 1) { break }
      var after = node.childNodes[offset];
      if (isIgnorable(after)) {
        moveNode = node;
        moveOffset = ++offset;
      }
      else { break }
    } else if (isBlockNode(node)) {
      break
    } else {
      var next = node.nextSibling;
      while (next && isIgnorable(next)) {
        moveNode = next.parentNode;
        moveOffset = domIndex(next) + 1;
        next = next.nextSibling;
      }
      if (!next) {
        node = node.parentNode;
        if (node == view.dom) { break }
        offset = len = 0;
      } else {
        node = next;
        offset = 0;
        len = nodeLen(node);
      }
    }
  }
  if (moveNode) { setSelFocus(view, sel, moveNode, moveOffset); }
}

function isBlockNode(dom) {
  var desc = dom.pmViewDesc;
  return desc && desc.node && desc.node.isBlock
}

function setSelFocus(view, sel, node, offset) {
  if (selectionCollapsed(sel)) {
    var range = document.createRange();
    range.setEnd(node, offset);
    range.setStart(node, offset);
    sel.removeAllRanges();
    sel.addRange(range);
  } else if (sel.extend) {
    sel.extend(node, offset);
  }
  view.domObserver.setCurSelection();
  var state = view.state;
  // If no state update ends up happening, reset the selection.
  setTimeout(function () {
    if (view.state == state) { selectionToDOM(view); }
  }, 50);
}

// : (EditorState, number)
// Check whether vertical selection motion would involve node
// selections. If so, apply it (if not, the result is left to the
// browser)
function selectVertically(view, dir, mods) {
  var sel = view.state.selection;
  if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection && !sel.empty || mods.indexOf("s") > -1) { return false }
  if (result.mac && mods.indexOf("m") > -1) { return false }
  var $from = sel.$from;
  var $to = sel.$to;

  if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? "up" : "down")) {
    var next = moveSelectionBlock(view.state, dir);
    if (next && (next instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection))
      { return apply(view, next) }
  }
  if (!$from.parent.inlineContent) {
    var side = dir < 0 ? $from : $to;
    var beyond = sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.AllSelection ? prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near(side, dir) : prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.findFrom(side, dir);
    return beyond ? apply(view, beyond) : false
  }
  return false
}

function stopNativeHorizontalDelete(view, dir) {
  if (!(view.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection)) { return true }
  var ref = view.state.selection;
  var $head = ref.$head;
  var $anchor = ref.$anchor;
  var empty = ref.empty;
  if (!$head.sameParent($anchor)) { return true }
  if (!empty) { return false }
  if (view.endOfTextblock(dir > 0 ? "forward" : "backward")) { return true }
  var nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);
  if (nextNode && !nextNode.isText) {
    var tr = view.state.tr;
    if (dir < 0) { tr.delete($head.pos - nextNode.nodeSize, $head.pos); }
    else { tr.delete($head.pos, $head.pos + nextNode.nodeSize); }
    view.dispatch(tr);
    return true
  }
  return false
}

function switchEditable(view, node, state) {
  view.domObserver.stop();
  node.contentEditable = state;
  view.domObserver.start();
}

// Issue #867 / #1090 / https://bugs.chromium.org/p/chromium/issues/detail?id=903821
// In which Safari (and at some point in the past, Chrome) does really
// wrong things when the down arrow is pressed when the cursor is
// directly at the start of a textblock and has an uneditable node
// after it
function safariDownArrowBug(view) {
  if (!result.safari || view.state.selection.$head.parentOffset > 0) { return }
  var ref = view.root.getSelection();
  var focusNode = ref.focusNode;
  var focusOffset = ref.focusOffset;
  if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 &&
      focusNode.firstChild && focusNode.firstChild.contentEditable == "false") {
    var child = focusNode.firstChild;
    switchEditable(view, child, true);
    setTimeout(function () { return switchEditable(view, child, false); }, 20);
  }
}

// A backdrop key mapping used to make sure we always suppress keys
// that have a dangerous default effect, even if the commands they are
// bound to return false, and to make sure that cursor-motion keys
// find a cursor (as opposed to a node selection) when pressed. For
// cursor-motion keys, the code in the handlers also takes care of
// block selections.

function getMods(event) {
  var result = "";
  if (event.ctrlKey) { result += "c"; }
  if (event.metaKey) { result += "m"; }
  if (event.altKey) { result += "a"; }
  if (event.shiftKey) { result += "s"; }
  return result
}

function captureKeyDown(view, event) {
  var code = event.keyCode, mods = getMods(event);
  if (code == 8 || (result.mac && code == 72 && mods == "c")) { // Backspace, Ctrl-h on Mac
    return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodesLeft(view)
  } else if (code == 46 || (result.mac && code == 68 && mods == "c")) { // Delete, Ctrl-d on Mac
    return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodesRight(view)
  } else if (code == 13 || code == 27) { // Enter, Esc
    return true
  } else if (code == 37) { // Left arrow
    return selectHorizontally(view, -1, mods) || skipIgnoredNodesLeft(view)
  } else if (code == 39) { // Right arrow
    return selectHorizontally(view, 1, mods) || skipIgnoredNodesRight(view)
  } else if (code == 38) { // Up arrow
    return selectVertically(view, -1, mods) || skipIgnoredNodesLeft(view)
  } else if (code == 40) { // Down arrow
    return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodesRight(view)
  } else if (mods == (result.mac ? "m" : "c") &&
             (code == 66 || code == 73 || code == 89 || code == 90)) { // Mod-[biyz]
    return true
  }
  return false
}

// Note that all referencing and parsing is done with the
// start-of-operation selection and document, since that's the one
// that the DOM represents. If any changes came in in the meantime,
// the modification is mapped over those before it is applied, in
// readDOMChange.

function parseBetween(view, from_, to_) {
  var ref = view.docView.parseRange(from_, to_);
  var parent = ref.node;
  var fromOffset = ref.fromOffset;
  var toOffset = ref.toOffset;
  var from = ref.from;
  var to = ref.to;

  var domSel = view.root.getSelection(), find = null, anchor = domSel.anchorNode;
  if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {
    find = [{node: anchor, offset: domSel.anchorOffset}];
    if (!selectionCollapsed(domSel))
      { find.push({node: domSel.focusNode, offset: domSel.focusOffset}); }
  }
  // Work around issue in Chrome where backspacing sometimes replaces
  // the deleted content with a random BR node (issues #799, #831)
  if (result.chrome && view.lastKeyCode === 8) {
    for (var off = toOffset; off > fromOffset; off--) {
      var node = parent.childNodes[off - 1], desc = node.pmViewDesc;
      if (node.nodeName == "BR" && !desc) { toOffset = off; break }
      if (!desc || desc.size) { break }
    }
  }
  var startDoc = view.state.doc;
  var parser = view.someProp("domParser") || prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.DOMParser.fromSchema(view.state.schema);
  var $from = startDoc.resolve(from);

  var sel = null, doc = parser.parse(parent, {
    topNode: $from.parent,
    topMatch: $from.parent.contentMatchAt($from.index()),
    topOpen: true,
    from: fromOffset,
    to: toOffset,
    preserveWhitespace: $from.parent.type.spec.code ? "full" : true,
    editableContent: true,
    findPositions: find,
    ruleFromNode: ruleFromNode,
    context: $from
  });
  if (find && find[0].pos != null) {
    var anchor$1 = find[0].pos, head = find[1] && find[1].pos;
    if (head == null) { head = anchor$1; }
    sel = {anchor: anchor$1 + from, head: head + from};
  }
  return {doc: doc, sel: sel, from: from, to: to}
}

function ruleFromNode(dom) {
  var desc = dom.pmViewDesc;
  if (desc) {
    return desc.parseRule()
  } else if (dom.nodeName == "BR" && dom.parentNode) {
    // Safari replaces the list item or table cell with a BR
    // directly in the list node (?!) if you delete the last
    // character in a list item or table cell (#708, #862)
    if (result.safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {
      var skip = document.createElement("div");
      skip.appendChild(document.createElement("li"));
      return {skip: skip}
    } else if (dom.parentNode.lastChild == dom || result.safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {
      return {ignore: true}
    }
  } else if (dom.nodeName == "IMG" && dom.getAttribute("mark-placeholder")) {
    return {ignore: true}
  }
}

function readDOMChange(view, from, to, typeOver, addedNodes) {
  if (from < 0) {
    var origin = view.lastSelectionTime > Date.now() - 50 ? view.lastSelectionOrigin : null;
    var newSel = selectionFromDOM(view, origin);
    if (newSel && !view.state.selection.eq(newSel)) {
      var tr$1 = view.state.tr.setSelection(newSel);
      if (origin == "pointer") { tr$1.setMeta("pointer", true); }
      else if (origin == "key") { tr$1.scrollIntoView(); }
      view.dispatch(tr$1);
    }
    return
  }

  var $before = view.state.doc.resolve(from);
  var shared = $before.sharedDepth(to);
  from = $before.before(shared + 1);
  to = view.state.doc.resolve(to).after(shared + 1);

  var sel = view.state.selection;
  var parse = parseBetween(view, from, to);
  // Chrome sometimes leaves the cursor before the inserted text when
  // composing after a cursor wrapper. This moves it forward.
  if (result.chrome && view.cursorWrapper && parse.sel && parse.sel.anchor == view.cursorWrapper.deco.from) {
    var text = view.cursorWrapper.deco.type.toDOM.nextSibling;
    var size = text && text.nodeValue ? text.nodeValue.length : 1;
    parse.sel = {anchor: parse.sel.anchor + size, head: parse.sel.anchor + size};
  }

  var doc = view.state.doc, compare = doc.slice(parse.from, parse.to);
  var preferredPos, preferredSide;
  // Prefer anchoring to end when Backspace is pressed
  if (view.lastKeyCode === 8 && Date.now() - 100 < view.lastKeyCodeTime) {
    preferredPos = view.state.selection.to;
    preferredSide = "end";
  } else {
    preferredPos = view.state.selection.from;
    preferredSide = "start";
  }
  view.lastKeyCode = null;

  var change = findDiff(compare.content, parse.doc.content, parse.from, preferredPos, preferredSide);
  if (!change) {
    if (typeOver && sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) &&
        !view.composing && !(parse.sel && parse.sel.anchor != parse.sel.head)) {
      change = {start: sel.from, endA: sel.to, endB: sel.to};
    } else if ((result.ios && view.lastIOSEnter > Date.now() - 225 || result.android) &&
               addedNodes.some(function (n) { return n.nodeName == "DIV" || n.nodeName == "P"; }) &&
               view.someProp("handleKeyDown", function (f) { return f(view, keyEvent(13, "Enter")); })) {
      view.lastIOSEnter = 0;
      return
    } else {
      if (parse.sel) {
        var sel$1 = resolveSelection(view, view.state.doc, parse.sel);
        if (sel$1 && !sel$1.eq(view.state.selection)) { view.dispatch(view.state.tr.setSelection(sel$1)); }
      }
      return
    }
  }
  view.domChangeCount++;
  // Handle the case where overwriting a selection by typing matches
  // the start or end of the selected content, creating a change
  // that's smaller than what was actually overwritten.
  if (view.state.selection.from < view.state.selection.to &&
      change.start == change.endB &&
      view.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection) {
    if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2) {
      change.start = view.state.selection.from;
    } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2) {
      change.endB += (view.state.selection.to - change.endA);
      change.endA = view.state.selection.to;
    }
  }

  // IE11 will insert a non-breaking space _ahead_ of the space after
  // the cursor space when adding a space before another space. When
  // that happened, adjust the change to cover the space instead.
  if (result.ie && result.ie_version <= 11 && change.endB == change.start + 1 &&
      change.endA == change.start && change.start > parse.from &&
      parse.doc.textBetween(change.start - parse.from - 1, change.start - parse.from + 1) == " \u00a0") {
    change.start--;
    change.endA--;
    change.endB--;
  }

  var $from = parse.doc.resolveNoCache(change.start - parse.from);
  var $to = parse.doc.resolveNoCache(change.endB - parse.from);
  var inlineChange = $from.sameParent($to) && $from.parent.inlineContent;
  var nextSel;
  // If this looks like the effect of pressing Enter (or was recorded
  // as being an iOS enter press), just dispatch an Enter key instead.
  if (((result.ios && view.lastIOSEnter > Date.now() - 225 &&
        (!inlineChange || addedNodes.some(function (n) { return n.nodeName == "DIV" || n.nodeName == "P"; }))) ||
       (!inlineChange && $from.pos < parse.doc.content.size &&
        (nextSel = prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.findFrom(parse.doc.resolve($from.pos + 1), 1, true)) &&
        nextSel.head == $to.pos)) &&
      view.someProp("handleKeyDown", function (f) { return f(view, keyEvent(13, "Enter")); })) {
    view.lastIOSEnter = 0;
    return
  }
  // Same for backspace
  if (view.state.selection.anchor > change.start &&
      looksLikeJoin(doc, change.start, change.endA, $from, $to) &&
      view.someProp("handleKeyDown", function (f) { return f(view, keyEvent(8, "Backspace")); })) {
    if (result.android && result.chrome) { view.domObserver.suppressSelectionUpdates(); } // #820
    return
  }

  // Chrome Android will occasionally, during composition, delete the
  // entire composition and then immediately insert it again. This is
  // used to detect that situation.
  if (result.chrome && result.android && change.toB == change.from)
    { view.lastAndroidDelete = Date.now(); }

  // This tries to detect Android virtual keyboard
  // enter-and-pick-suggestion action. That sometimes (see issue
  // #1059) first fires a DOM mutation, before moving the selection to
  // the newly created block. And then, because ProseMirror cleans up
  // the DOM selection, it gives up moving the selection entirely,
  // leaving the cursor in the wrong place. When that happens, we drop
  // the new paragraph from the initial change, and fire a simulated
  // enter key afterwards.
  if (result.android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth &&
      parse.sel && parse.sel.anchor == parse.sel.head && parse.sel.head == change.endA) {
    change.endB -= 2;
    $to = parse.doc.resolveNoCache(change.endB - parse.from);
    setTimeout(function () {
      view.someProp("handleKeyDown", function (f) { return f(view, keyEvent(13, "Enter")); });
    }, 20);
  }

  var chFrom = change.start, chTo = change.endA;

  var tr, storedMarks, markChange, $from1;
  if (inlineChange) {
    if ($from.pos == $to.pos) { // Deletion
      // IE11 sometimes weirdly moves the DOM selection around after
      // backspacing out the first element in a textblock
      if (result.ie && result.ie_version <= 11 && $from.parentOffset == 0) {
        view.domObserver.suppressSelectionUpdates();
        setTimeout(function () { return selectionToDOM(view); }, 20);
      }
      tr = view.state.tr.delete(chFrom, chTo);
      storedMarks = doc.resolve(change.start).marksAcross(doc.resolve(change.endA));
    } else if ( // Adding or removing a mark
      change.endA == change.endB && ($from1 = doc.resolve(change.start)) &&
      (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset),
                                 $from1.parent.content.cut($from1.parentOffset, change.endA - $from1.start())))
    ) {
      tr = view.state.tr;
      if (markChange.type == "add") { tr.addMark(chFrom, chTo, markChange.mark); }
      else { tr.removeMark(chFrom, chTo, markChange.mark); }
    } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {
      // Both positions in the same text node -- simply insert text
      var text$1 = $from.parent.textBetween($from.parentOffset, $to.parentOffset);
      if (view.someProp("handleTextInput", function (f) { return f(view, chFrom, chTo, text$1); })) { return }
      tr = view.state.tr.insertText(text$1, chFrom, chTo);
    }
  }

  if (!tr)
    { tr = view.state.tr.replace(chFrom, chTo, parse.doc.slice(change.start - parse.from, change.endB - parse.from)); }
  if (parse.sel) {
    var sel$2 = resolveSelection(view, tr.doc, parse.sel);
    // Chrome Android will sometimes, during composition, report the
    // selection in the wrong place. If it looks like that is
    // happening, don't update the selection.
    // Edge just doesn't move the cursor forward when you start typing
    // in an empty block or between br nodes.
    if (sel$2 && !(result.chrome && result.android && view.composing && sel$2.empty &&
                 (change.start != change.endB || view.lastAndroidDelete < Date.now() - 100) &&
                 (sel$2.head == chFrom || sel$2.head == tr.mapping.map(chTo) - 1) ||
                 result.ie && sel$2.empty && sel$2.head == chFrom))
      { tr.setSelection(sel$2); }
  }
  if (storedMarks) { tr.ensureMarks(storedMarks); }
  view.dispatch(tr.scrollIntoView());
}

function resolveSelection(view, doc, parsedSel) {
  if (Math.max(parsedSel.anchor, parsedSel.head) > doc.content.size) { return null }
  return selectionBetween(view, doc.resolve(parsedSel.anchor), doc.resolve(parsedSel.head))
}

// : (Fragment, Fragment) → ?{mark: Mark, type: string}
// Given two same-length, non-empty fragments of inline content,
// determine whether the first could be created from the second by
// removing or adding a single mark type.
function isMarkChange(cur, prev) {
  var curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks;
  var added = curMarks, removed = prevMarks, type, mark, update;
  for (var i = 0; i < prevMarks.length; i++) { added = prevMarks[i].removeFromSet(added); }
  for (var i$1 = 0; i$1 < curMarks.length; i$1++) { removed = curMarks[i$1].removeFromSet(removed); }
  if (added.length == 1 && removed.length == 0) {
    mark = added[0];
    type = "add";
    update = function (node) { return node.mark(mark.addToSet(node.marks)); };
  } else if (added.length == 0 && removed.length == 1) {
    mark = removed[0];
    type = "remove";
    update = function (node) { return node.mark(mark.removeFromSet(node.marks)); };
  } else {
    return null
  }
  var updated = [];
  for (var i$2 = 0; i$2 < prev.childCount; i$2++) { updated.push(update(prev.child(i$2))); }
  if (prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(updated).eq(cur)) { return {mark: mark, type: type} }
}

function looksLikeJoin(old, start, end, $newStart, $newEnd) {
  if (!$newStart.parent.isTextblock ||
      // The content must have shrunk
      end - start <= $newEnd.pos - $newStart.pos ||
      // newEnd must point directly at or after the end of the block that newStart points into
      skipClosingAndOpening($newStart, true, false) < $newEnd.pos)
    { return false }

  var $start = old.resolve(start);
  // Start must be at the end of a block
  if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock)
    { return false }
  var $next = old.resolve(skipClosingAndOpening($start, true, true));
  // The next textblock must start before end and end near it
  if (!$next.parent.isTextblock || $next.pos > end ||
      skipClosingAndOpening($next, true, false) < end)
    { return false }

  // The fragments after the join point must match
  return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content)
}

function skipClosingAndOpening($pos, fromEnd, mayOpen) {
  var depth = $pos.depth, end = fromEnd ? $pos.end() : $pos.pos;
  while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {
    depth--;
    end++;
    fromEnd = false;
  }
  if (mayOpen) {
    var next = $pos.node(depth).maybeChild($pos.indexAfter(depth));
    while (next && !next.isLeaf) {
      next = next.firstChild;
      end++;
    }
  }
  return end
}

function findDiff(a, b, pos, preferredPos, preferredSide) {
  var start = a.findDiffStart(b, pos);
  if (start == null) { return null }
  var ref = a.findDiffEnd(b, pos + a.size, pos + b.size);
  var endA = ref.a;
  var endB = ref.b;
  if (preferredSide == "end") {
    var adjust = Math.max(0, start - Math.min(endA, endB));
    preferredPos -= endA + adjust - start;
  }
  if (endA < start && a.size < b.size) {
    var move = preferredPos <= start && preferredPos >= endA ? start - preferredPos : 0;
    start -= move;
    endB = start + (endB - endA);
    endA = start;
  } else if (endB < start) {
    var move$1 = preferredPos <= start && preferredPos >= endB ? start - preferredPos : 0;
    start -= move$1;
    endA = start + (endA - endB);
    endB = start;
  }
  return {start: start, endA: endA, endB: endB}
}

function serializeForClipboard(view, slice) {
  var context = [];
  var content = slice.content;
  var openStart = slice.openStart;
  var openEnd = slice.openEnd;
  while (openStart > 1 && openEnd > 1 && content.childCount == 1 && content.firstChild.childCount == 1) {
    openStart--;
    openEnd--;
    var node = content.firstChild;
    context.push(node.type.name, node.attrs != node.type.defaultAttrs ? node.attrs : null);
    content = node.content;
  }

  var serializer = view.someProp("clipboardSerializer") || prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.DOMSerializer.fromSchema(view.state.schema);
  var doc = detachedDoc(), wrap = doc.createElement("div");
  wrap.appendChild(serializer.serializeFragment(content, {document: doc}));

  var firstChild = wrap.firstChild, needsWrap;
  while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {
    for (var i = needsWrap.length - 1; i >= 0; i--) {
      var wrapper = doc.createElement(needsWrap[i]);
      while (wrap.firstChild) { wrapper.appendChild(wrap.firstChild); }
      wrap.appendChild(wrapper);
      if (needsWrap[i] != "tbody") {
        openStart++;
        openEnd++;
      }
    }
    firstChild = wrap.firstChild;
  }

  if (firstChild && firstChild.nodeType == 1)
    { firstChild.setAttribute("data-pm-slice", (openStart + " " + openEnd + " " + (JSON.stringify(context)))); }

  var text = view.someProp("clipboardTextSerializer", function (f) { return f(slice); }) ||
      slice.content.textBetween(0, slice.content.size, "\n\n");

  return {dom: wrap, text: text}
}

// : (EditorView, string, string, ?bool, ResolvedPos) → ?Slice
// Read a slice of content from the clipboard (or drop data).
function parseFromClipboard(view, text, html, plainText, $context) {
  var dom, inCode = $context.parent.type.spec.code, slice;
  if (!html && !text) { return null }
  var asText = text && (plainText || inCode || !html);
  if (asText) {
    view.someProp("transformPastedText", function (f) { text = f(text, inCode || plainText); });
    if (inCode) { return text ? new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(view.state.schema.text(text.replace(/\r\n?/g, "\n"))), 0, 0) : prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice.empty }
    var parsed = view.someProp("clipboardTextParser", function (f) { return f(text, $context, plainText); });
    if (parsed) {
      slice = parsed;
    } else {
      var marks = $context.marks();
      var ref = view.state;
      var schema = ref.schema;
      var serializer = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.DOMSerializer.fromSchema(schema);
      dom = document.createElement("div");
      text.split(/(?:\r\n?|\n)+/).forEach(function (block) {
        var p = dom.appendChild(document.createElement("p"));
        if (block) { p.appendChild(serializer.serializeNode(schema.text(block, marks))); }
      });
    }
  } else {
    view.someProp("transformPastedHTML", function (f) { html = f(html); });
    dom = readHTML(html);
    if (result.webkit) { restoreReplacedSpaces(dom); }
  }

  var contextNode = dom && dom.querySelector("[data-pm-slice]");
  var sliceData = contextNode && /^(\d+) (\d+) (.*)/.exec(contextNode.getAttribute("data-pm-slice"));
  if (!slice) {
    var parser = view.someProp("clipboardParser") || view.someProp("domParser") || prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.DOMParser.fromSchema(view.state.schema);
    slice = parser.parseSlice(dom, {preserveWhitespace: !!(asText || sliceData), context: $context});
  }
  if (sliceData) {
    slice = addContext(closeSlice(slice, +sliceData[1], +sliceData[2]), sliceData[3]);
  } else { // HTML wasn't created by ProseMirror. Make sure top-level siblings are coherent
    slice = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice.maxOpen(normalizeSiblings(slice.content, $context), true);
    if (slice.openStart || slice.openEnd) {
      var openStart = 0, openEnd = 0;
      for (var node = slice.content.firstChild; openStart < slice.openStart && !node.type.spec.isolating;
           openStart++, node = node.firstChild) {}
      for (var node$1 = slice.content.lastChild; openEnd < slice.openEnd && !node$1.type.spec.isolating;
           openEnd++, node$1 = node$1.lastChild) {}
      slice = closeSlice(slice, openStart, openEnd);
    }
  }

  view.someProp("transformPasted", function (f) { slice = f(slice); });
  return slice
}

// Takes a slice parsed with parseSlice, which means there hasn't been
// any content-expression checking done on the top nodes, tries to
// find a parent node in the current context that might fit the nodes,
// and if successful, rebuilds the slice so that it fits into that parent.
//
// This addresses the problem that Transform.replace expects a
// coherent slice, and will fail to place a set of siblings that don't
// fit anywhere in the schema.
function normalizeSiblings(fragment, $context) {
  if (fragment.childCount < 2) { return fragment }
  var loop = function ( d ) {
    var parent = $context.node(d);
    var match = parent.contentMatchAt($context.index(d));
    var lastWrap = (void 0), result = [];
    fragment.forEach(function (node) {
      if (!result) { return }
      var wrap = match.findWrapping(node.type), inLast;
      if (!wrap) { return result = null }
      if (inLast = result.length && lastWrap.length && addToSibling(wrap, lastWrap, node, result[result.length - 1], 0)) {
        result[result.length - 1] = inLast;
      } else {
        if (result.length) { result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length); }
        var wrapped = withWrappers(node, wrap);
        result.push(wrapped);
        match = match.matchType(wrapped.type, wrapped.attrs);
        lastWrap = wrap;
      }
    });
    if (result) { return { v: prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(result) } }
  };

  for (var d = $context.depth; d >= 0; d--) {
    var returned = loop( d );

    if ( returned ) return returned.v;
  }
  return fragment
}

function withWrappers(node, wrap, from) {
  if ( from === void 0 ) from = 0;

  for (var i = wrap.length - 1; i >= from; i--)
    { node = wrap[i].create(null, prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(node)); }
  return node
}

// Used to group adjacent nodes wrapped in similar parents by
// normalizeSiblings into the same parent node
function addToSibling(wrap, lastWrap, node, sibling, depth) {
  if (depth < wrap.length && depth < lastWrap.length && wrap[depth] == lastWrap[depth]) {
    var inner = addToSibling(wrap, lastWrap, node, sibling.lastChild, depth + 1);
    if (inner) { return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner)) }
    var match = sibling.contentMatchAt(sibling.childCount);
    if (match.matchType(depth == wrap.length - 1 ? node.type : wrap[depth + 1]))
      { return sibling.copy(sibling.content.append(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(withWrappers(node, wrap, depth + 1)))) }
  }
}

function closeRight(node, depth) {
  if (depth == 0) { return node }
  var fragment = node.content.replaceChild(node.childCount - 1, closeRight(node.lastChild, depth - 1));
  var fill = node.contentMatchAt(node.childCount).fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty, true);
  return node.copy(fragment.append(fill))
}

function closeRange(fragment, side, from, to, depth, openEnd) {
  var node = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node.content;
  if (depth < to - 1) { inner = closeRange(inner, side, from, to, depth + 1, openEnd); }
  if (depth >= from)
    { inner = side < 0 ? node.contentMatchAt(0).fillBefore(inner, fragment.childCount > 1 || openEnd <= depth).append(inner)
      : inner.append(node.contentMatchAt(node.childCount).fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty, true)); }
  return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node.copy(inner))
}

function closeSlice(slice, openStart, openEnd) {
  if (openStart < slice.openStart)
    { slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(closeRange(slice.content, -1, openStart, slice.openStart, 0, slice.openEnd), openStart, slice.openEnd); }
  if (openEnd < slice.openEnd)
    { slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(closeRange(slice.content, 1, openEnd, slice.openEnd, 0, 0), slice.openStart, openEnd); }
  return slice
}

// Trick from jQuery -- some elements must be wrapped in other
// elements for innerHTML to work. I.e. if you do `div.innerHTML =
// "<td>..</td>"` the table cells are ignored.
var wrapMap = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};

var _detachedDoc = null;
function detachedDoc() {
  return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument("title"))
}

function readHTML(html) {
  var metas = /^(\s*<meta [^>]*>)*/.exec(html);
  if (metas) { html = html.slice(metas[0].length); }
  var elt = detachedDoc().createElement("div");
  var firstTag = /<([a-z][^>\s]+)/i.exec(html), wrap;
  if (wrap = firstTag && wrapMap[firstTag[1].toLowerCase()])
    { html = wrap.map(function (n) { return "<" + n + ">"; }).join("") + html + wrap.map(function (n) { return "</" + n + ">"; }).reverse().join(""); }
  elt.innerHTML = html;
  if (wrap) { for (var i = 0; i < wrap.length; i++) { elt = elt.querySelector(wrap[i]) || elt; } }
  return elt
}

// Webkit browsers do some hard-to-predict replacement of regular
// spaces with non-breaking spaces when putting content on the
// clipboard. This tries to convert such non-breaking spaces (which
// will be wrapped in a plain span on Chrome, a span with class
// Apple-converted-space on Safari) back to regular spaces.
function restoreReplacedSpaces(dom) {
  var nodes = dom.querySelectorAll(result.chrome ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (var i = 0; i < nodes.length; i++) {
    var node = nodes[i];
    if (node.childNodes.length == 1 && node.textContent == "\u00a0" && node.parentNode)
      { node.parentNode.replaceChild(dom.ownerDocument.createTextNode(" "), node); }
  }
}

function addContext(slice, context) {
  if (!slice.size) { return slice }
  var schema = slice.content.firstChild.type.schema, array;
  try { array = JSON.parse(context); }
  catch(e) { return slice }
  var content = slice.content;
  var openStart = slice.openStart;
  var openEnd = slice.openEnd;
  for (var i = array.length - 2; i >= 0; i -= 2) {
    var type = schema.nodes[array[i]];
    if (!type || type.hasRequiredAttrs()) { break }
    content = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(type.create(array[i + 1], content));
    openStart++; openEnd++;
  }
  return new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(content, openStart, openEnd)
}

var observeOptions = {
  childList: true,
  characterData: true,
  characterDataOldValue: true,
  attributes: true,
  attributeOldValue: true,
  subtree: true
};
// IE11 has very broken mutation observers, so we also listen to DOMCharacterDataModified
var useCharData = result.ie && result.ie_version <= 11;

var SelectionState = function SelectionState() {
  this.anchorNode = this.anchorOffset = this.focusNode = this.focusOffset = null;
};

SelectionState.prototype.set = function set (sel) {
  this.anchorNode = sel.anchorNode; this.anchorOffset = sel.anchorOffset;
  this.focusNode = sel.focusNode; this.focusOffset = sel.focusOffset;
};

SelectionState.prototype.eq = function eq (sel) {
  return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset &&
    sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset
};

var DOMObserver = function DOMObserver(view, handleDOMChange) {
  var this$1 = this;

  this.view = view;
  this.handleDOMChange = handleDOMChange;
  this.queue = [];
  this.flushingSoon = -1;
  this.observer = window.MutationObserver &&
    new window.MutationObserver(function (mutations) {
      for (var i = 0; i < mutations.length; i++) { this$1.queue.push(mutations[i]); }
      // IE11 will sometimes (on backspacing out a single character
      // text node after a BR node) call the observer callback
      // before actually updating the DOM, which will cause
      // ProseMirror to miss the change (see #930)
      if (result.ie && result.ie_version <= 11 && mutations.some(
        function (m) { return m.type == "childList" && m.removedNodes.length ||
             m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length; }))
        { this$1.flushSoon(); }
      else
        { this$1.flush(); }
    });
  this.currentSelection = new SelectionState;
  if (useCharData) {
    this.onCharData = function (e) {
      this$1.queue.push({target: e.target, type: "characterData", oldValue: e.prevValue});
      this$1.flushSoon();
    };
  }
  this.onSelectionChange = this.onSelectionChange.bind(this);
  this.suppressingSelectionUpdates = false;
};

DOMObserver.prototype.flushSoon = function flushSoon () {
    var this$1 = this;

  if (this.flushingSoon < 0)
    { this.flushingSoon = window.setTimeout(function () { this$1.flushingSoon = -1; this$1.flush(); }, 20); }
};

DOMObserver.prototype.forceFlush = function forceFlush () {
  if (this.flushingSoon > -1) {
    window.clearTimeout(this.flushingSoon);
    this.flushingSoon = -1;
    this.flush();
  }
};

DOMObserver.prototype.start = function start () {
  if (this.observer)
    { this.observer.observe(this.view.dom, observeOptions); }
  if (useCharData)
    { this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData); }
  this.connectSelection();
};

DOMObserver.prototype.stop = function stop () {
    var this$1 = this;

  if (this.observer) {
    var take = this.observer.takeRecords();
    if (take.length) {
      for (var i = 0; i < take.length; i++) { this.queue.push(take[i]); }
      window.setTimeout(function () { return this$1.flush(); }, 20);
    }
    this.observer.disconnect();
  }
  if (useCharData) { this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData); }
  this.disconnectSelection();
};

DOMObserver.prototype.connectSelection = function connectSelection () {
  this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
};

DOMObserver.prototype.disconnectSelection = function disconnectSelection () {
  this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
};

DOMObserver.prototype.suppressSelectionUpdates = function suppressSelectionUpdates () {
    var this$1 = this;

  this.suppressingSelectionUpdates = true;
  setTimeout(function () { return this$1.suppressingSelectionUpdates = false; }, 50);
};

DOMObserver.prototype.onSelectionChange = function onSelectionChange () {
  if (!hasFocusAndSelection(this.view)) { return }
  if (this.suppressingSelectionUpdates) { return selectionToDOM(this.view) }
  // Deletions on IE11 fire their events in the wrong order, giving
  // us a selection change event before the DOM changes are
  // reported.
  if (result.ie && result.ie_version <= 11 && !this.view.state.selection.empty) {
    var sel = this.view.root.getSelection();
    // Selection.isCollapsed isn't reliable on IE
    if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
      { return this.flushSoon() }
  }
  this.flush();
};

DOMObserver.prototype.setCurSelection = function setCurSelection () {
  this.currentSelection.set(this.view.root.getSelection());
};

DOMObserver.prototype.ignoreSelectionChange = function ignoreSelectionChange (sel) {
  if (sel.rangeCount == 0) { return true }
  var container = sel.getRangeAt(0).commonAncestorContainer;
  var desc = this.view.docView.nearestDesc(container);
  if (desc && desc.ignoreMutation({type: "selection", target: container.nodeType == 3 ? container.parentNode : container})) {
    this.setCurSelection();
    return true
  }
};

DOMObserver.prototype.flush = function flush () {
  if (!this.view.docView || this.flushingSoon > -1) { return }
  var mutations = this.observer ? this.observer.takeRecords() : [];
  if (this.queue.length) {
    mutations = this.queue.concat(mutations);
    this.queue.length = 0;
  }

  var sel = this.view.root.getSelection();
  var newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasSelection(this.view) && !this.ignoreSelectionChange(sel);

  var from = -1, to = -1, typeOver = false, added = [];
  if (this.view.editable) {
    for (var i = 0; i < mutations.length; i++) {
      var result$1 = this.registerMutation(mutations[i], added);
      if (result$1) {
        from = from < 0 ? result$1.from : Math.min(result$1.from, from);
        to = to < 0 ? result$1.to : Math.max(result$1.to, to);
        if (result$1.typeOver) { typeOver = true; }
      }
    }
  }

  if (result.gecko && added.length > 1) {
    var brs = added.filter(function (n) { return n.nodeName == "BR"; });
    if (brs.length == 2) {
      var a = brs[0];
        var b = brs[1];
      if (a.parentNode && a.parentNode.parentNode == b.parentNode) { b.remove(); }
      else { a.remove(); }
    }
  }

  if (from > -1 || newSel) {
    if (from > -1) {
      this.view.docView.markDirty(from, to);
      checkCSS(this.view);
    }
    this.handleDOMChange(from, to, typeOver, added);
    if (this.view.docView.dirty) { this.view.updateState(this.view.state); }
    else if (!this.currentSelection.eq(sel)) { selectionToDOM(this.view); }
    this.currentSelection.set(sel);
  }
};

DOMObserver.prototype.registerMutation = function registerMutation (mut, added) {
  // Ignore mutations inside nodes that were already noted as inserted
  if (added.indexOf(mut.target) > -1) { return null }
  var desc = this.view.docView.nearestDesc(mut.target);
  if (mut.type == "attributes" &&
      (desc == this.view.docView || mut.attributeName == "contenteditable" ||
       // Firefox sometimes fires spurious events for null/empty styles
       (mut.attributeName == "style" && !mut.oldValue && !mut.target.getAttribute("style"))))
    { return null }
  if (!desc || desc.ignoreMutation(mut)) { return null }

  if (mut.type == "childList") {
    for (var i = 0; i < mut.addedNodes.length; i++) { added.push(mut.addedNodes[i]); }
    if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target))
      { return {from: desc.posBefore, to: desc.posAfter} }
    var prev = mut.previousSibling, next = mut.nextSibling;
    if (result.ie && result.ie_version <= 11 && mut.addedNodes.length) {
      // IE11 gives us incorrect next/prev siblings for some
      // insertions, so if there are added nodes, recompute those
      for (var i$1 = 0; i$1 < mut.addedNodes.length; i$1++) {
        var ref = mut.addedNodes[i$1];
          var previousSibling = ref.previousSibling;
          var nextSibling = ref.nextSibling;
        if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0) { prev = previousSibling; }
        if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0) { next = nextSibling; }
      }
    }
    var fromOffset = prev && prev.parentNode == mut.target
        ? domIndex(prev) + 1 : 0;
    var from = desc.localPosFromDOM(mut.target, fromOffset, -1);
    var toOffset = next && next.parentNode == mut.target
        ? domIndex(next) : mut.target.childNodes.length;
    var to = desc.localPosFromDOM(mut.target, toOffset, 1);
    return {from: from, to: to}
  } else if (mut.type == "attributes") {
    return {from: desc.posAtStart - desc.border, to: desc.posAtEnd + desc.border}
  } else { // "characterData"
    return {
      from: desc.posAtStart,
      to: desc.posAtEnd,
      // An event was generated for a text change that didn't change
      // any text. Mark the dom change to fall back to assuming the
      // selection was typed over with an identical value if it can't
      // find another change.
      typeOver: mut.target.nodeValue == mut.oldValue
    }
  }
};

var cssChecked = false;

function checkCSS(view) {
  if (cssChecked) { return }
  cssChecked = true;
  if (getComputedStyle(view.dom).whiteSpace == "normal")
    { console["warn"]("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."); }
}

// A collection of DOM events that occur within the editor, and callback functions
// to invoke when the event fires.
var handlers = {}, editHandlers = {};

function initInput(view) {
  view.shiftKey = false;
  view.mouseDown = null;
  view.lastKeyCode = null;
  view.lastKeyCodeTime = 0;
  view.lastClick = {time: 0, x: 0, y: 0, type: ""};
  view.lastSelectionOrigin = null;
  view.lastSelectionTime = 0;

  view.lastIOSEnter = 0;
  view.lastIOSEnterFallbackTimeout = null;
  view.lastAndroidDelete = 0;

  view.composing = false;
  view.composingTimeout = null;
  view.compositionNodes = [];
  view.compositionEndedAt = -2e8;

  view.domObserver = new DOMObserver(view, function (from, to, typeOver, added) { return readDOMChange(view, from, to, typeOver, added); });
  view.domObserver.start();
  // Used by hacks like the beforeinput handler to check whether anything happened in the DOM
  view.domChangeCount = 0;

  view.eventHandlers = Object.create(null);
  var loop = function ( event ) {
    var handler = handlers[event];
    view.dom.addEventListener(event, view.eventHandlers[event] = function (event) {
      if (eventBelongsToView(view, event) && !runCustomHandler(view, event) &&
          (view.editable || !(event.type in editHandlers)))
        { handler(view, event); }
    });
  };

  for (var event in handlers) loop( event );
  // On Safari, for reasons beyond my understanding, adding an input
  // event handler makes an issue where the composition vanishes when
  // you press enter go away.
  if (result.safari) { view.dom.addEventListener("input", function () { return null; }); }

  ensureListeners(view);
}

function setSelectionOrigin(view, origin) {
  view.lastSelectionOrigin = origin;
  view.lastSelectionTime = Date.now();
}

function destroyInput(view) {
  view.domObserver.stop();
  for (var type in view.eventHandlers)
    { view.dom.removeEventListener(type, view.eventHandlers[type]); }
  clearTimeout(view.composingTimeout);
  clearTimeout(view.lastIOSEnterFallbackTimeout);
}

function ensureListeners(view) {
  view.someProp("handleDOMEvents", function (currentHandlers) {
    for (var type in currentHandlers) { if (!view.eventHandlers[type])
      { view.dom.addEventListener(type, view.eventHandlers[type] = function (event) { return runCustomHandler(view, event); }); } }
  });
}

function runCustomHandler(view, event) {
  return view.someProp("handleDOMEvents", function (handlers) {
    var handler = handlers[event.type];
    return handler ? handler(view, event) || event.defaultPrevented : false
  })
}

function eventBelongsToView(view, event) {
  if (!event.bubbles) { return true }
  if (event.defaultPrevented) { return false }
  for (var node = event.target; node != view.dom; node = node.parentNode)
    { if (!node || node.nodeType == 11 ||
        (node.pmViewDesc && node.pmViewDesc.stopEvent(event)))
      { return false } }
  return true
}

function dispatchEvent(view, event) {
  if (!runCustomHandler(view, event) && handlers[event.type] &&
      (view.editable || !(event.type in editHandlers)))
    { handlers[event.type](view, event); }
}

editHandlers.keydown = function (view, event) {
  view.shiftKey = event.keyCode == 16 || event.shiftKey;
  if (inOrNearComposition(view, event)) { return }
  if (event.keyCode != 229) { view.domObserver.forceFlush(); }
  view.lastKeyCode = event.keyCode;
  view.lastKeyCodeTime = Date.now();
  // On iOS, if we preventDefault enter key presses, the virtual
  // keyboard gets confused. So the hack here is to set a flag that
  // makes the DOM change code recognize that what just happens should
  // be replaced by whatever the Enter key handlers do.
  if (result.ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {
    var now = Date.now();
    view.lastIOSEnter = now;
    view.lastIOSEnterFallbackTimeout = setTimeout(function () {
      if (view.lastIOSEnter == now) {
        view.someProp("handleKeyDown", function (f) { return f(view, keyEvent(13, "Enter")); });
        view.lastIOSEnter = 0;
      }
    }, 200);
  } else if (view.someProp("handleKeyDown", function (f) { return f(view, event); }) || captureKeyDown(view, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "key");
  }
};

editHandlers.keyup = function (view, e) {
  if (e.keyCode == 16) { view.shiftKey = false; }
};

editHandlers.keypress = function (view, event) {
  if (inOrNearComposition(view, event) || !event.charCode ||
      event.ctrlKey && !event.altKey || result.mac && event.metaKey) { return }

  if (view.someProp("handleKeyPress", function (f) { return f(view, event); })) {
    event.preventDefault();
    return
  }

  var sel = view.state.selection;
  if (!(sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection) || !sel.$from.sameParent(sel.$to)) {
    var text = String.fromCharCode(event.charCode);
    if (!view.someProp("handleTextInput", function (f) { return f(view, sel.$from.pos, sel.$to.pos, text); }))
      { view.dispatch(view.state.tr.insertText(text).scrollIntoView()); }
    event.preventDefault();
  }
};

function eventCoords(event) { return {left: event.clientX, top: event.clientY} }

function isNear(event, click) {
  var dx = click.x - event.clientX, dy = click.y - event.clientY;
  return dx * dx + dy * dy < 100
}

function runHandlerOnContext(view, propName, pos, inside, event) {
  if (inside == -1) { return false }
  var $pos = view.state.doc.resolve(inside);
  var loop = function ( i ) {
    if (view.someProp(propName, function (f) { return i > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i), event, true)
                                                    : f(view, pos, $pos.node(i), $pos.before(i), event, false); }))
      { return { v: true } }
  };

  for (var i = $pos.depth + 1; i > 0; i--) {
    var returned = loop( i );

    if ( returned ) return returned.v;
  }
  return false
}

function updateSelection(view, selection, origin) {
  if (!view.focused) { view.focus(); }
  var tr = view.state.tr.setSelection(selection);
  if (origin == "pointer") { tr.setMeta("pointer", true); }
  view.dispatch(tr);
}

function selectClickedLeaf(view, inside) {
  if (inside == -1) { return false }
  var $pos = view.state.doc.resolve(inside), node = $pos.nodeAfter;
  if (node && node.isAtom && prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.isSelectable(node)) {
    updateSelection(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection($pos), "pointer");
    return true
  }
  return false
}

function selectClickedNode(view, inside) {
  if (inside == -1) { return false }
  var sel = view.state.selection, selectedNode, selectAt;
  if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection) { selectedNode = sel.node; }

  var $pos = view.state.doc.resolve(inside);
  for (var i = $pos.depth + 1; i > 0; i--) {
    var node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
    if (prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.isSelectable(node)) {
      if (selectedNode && sel.$from.depth > 0 &&
          i >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos)
        { selectAt = $pos.before(sel.$from.depth); }
      else
        { selectAt = $pos.before(i); }
      break
    }
  }

  if (selectAt != null) {
    updateSelection(view, prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.create(view.state.doc, selectAt), "pointer");
    return true
  } else {
    return false
  }
}

function handleSingleClick(view, pos, inside, event, selectNode) {
  return runHandlerOnContext(view, "handleClickOn", pos, inside, event) ||
    view.someProp("handleClick", function (f) { return f(view, pos, event); }) ||
    (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside))
}

function handleDoubleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleDoubleClickOn", pos, inside, event) ||
    view.someProp("handleDoubleClick", function (f) { return f(view, pos, event); })
}

function handleTripleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleTripleClickOn", pos, inside, event) ||
    view.someProp("handleTripleClick", function (f) { return f(view, pos, event); }) ||
    defaultTripleClick(view, inside, event)
}

function defaultTripleClick(view, inside, event) {
  if (event.button != 0) { return false }
  var doc = view.state.doc;
  if (inside == -1) {
    if (doc.inlineContent) {
      updateSelection(view, prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(doc, 0, doc.content.size), "pointer");
      return true
    }
    return false
  }

  var $pos = doc.resolve(inside);
  for (var i = $pos.depth + 1; i > 0; i--) {
    var node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
    var nodePos = $pos.before(i);
    if (node.inlineContent)
      { updateSelection(view, prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(doc, nodePos + 1, nodePos + 1 + node.content.size), "pointer"); }
    else if (prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.isSelectable(node))
      { updateSelection(view, prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.create(doc, nodePos), "pointer"); }
    else
      { continue }
    return true
  }
}

function forceDOMFlush(view) {
  return endComposition(view)
}

var selectNodeModifier = result.mac ? "metaKey" : "ctrlKey";

handlers.mousedown = function (view, event) {
  view.shiftKey = event.shiftKey;
  var flushed = forceDOMFlush(view);
  var now = Date.now(), type = "singleClick";
  if (now - view.lastClick.time < 500 && isNear(event, view.lastClick) && !event[selectNodeModifier]) {
    if (view.lastClick.type == "singleClick") { type = "doubleClick"; }
    else if (view.lastClick.type == "doubleClick") { type = "tripleClick"; }
  }
  view.lastClick = {time: now, x: event.clientX, y: event.clientY, type: type};

  var pos = view.posAtCoords(eventCoords(event));
  if (!pos) { return }

  if (type == "singleClick") {
    if (view.mouseDown) { view.mouseDown.done(); }
    view.mouseDown = new MouseDown(view, pos, event, flushed);
  } else if ((type == "doubleClick" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "pointer");
  }
};

var MouseDown = function MouseDown(view, pos, event, flushed) {
  var this$1 = this;

  this.view = view;
  this.startDoc = view.state.doc;
  this.pos = pos;
  this.event = event;
  this.flushed = flushed;
  this.selectNode = event[selectNodeModifier];
  this.allowDefault = event.shiftKey;
  this.delayedSelectionSync = false;

  var targetNode, targetPos;
  if (pos.inside > -1) {
    targetNode = view.state.doc.nodeAt(pos.inside);
    targetPos = pos.inside;
  } else {
    var $pos = view.state.doc.resolve(pos.pos);
    targetNode = $pos.parent;
    targetPos = $pos.depth ? $pos.before() : 0;
  }

  this.mightDrag = null;

  var target = flushed ? null : event.target;
  var targetDesc = target ? view.docView.nearestDesc(target, true) : null;
  this.target = targetDesc ? targetDesc.dom : null;

  var ref = view.state;
  var selection = ref.selection;
  if (event.button == 0 &&
      targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false ||
      selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection && selection.from <= targetPos && selection.to > targetPos)
    { this.mightDrag = {node: targetNode,
                      pos: targetPos,
                      addAttr: this.target && !this.target.draggable,
                      setUneditable: this.target && result.gecko && !this.target.hasAttribute("contentEditable")}; }

  if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {
    this.view.domObserver.stop();
    if (this.mightDrag.addAttr) { this.target.draggable = true; }
    if (this.mightDrag.setUneditable)
      { setTimeout(function () {
        if (this$1.view.mouseDown == this$1) { this$1.target.setAttribute("contentEditable", "false"); }
      }, 20); }
    this.view.domObserver.start();
  }

  view.root.addEventListener("mouseup", this.up = this.up.bind(this));
  view.root.addEventListener("mousemove", this.move = this.move.bind(this));
  setSelectionOrigin(view, "pointer");
};

MouseDown.prototype.done = function done () {
    var this$1 = this;

  this.view.root.removeEventListener("mouseup", this.up);
  this.view.root.removeEventListener("mousemove", this.move);
  if (this.mightDrag && this.target) {
    this.view.domObserver.stop();
    if (this.mightDrag.addAttr) { this.target.removeAttribute("draggable"); }
    if (this.mightDrag.setUneditable) { this.target.removeAttribute("contentEditable"); }
    this.view.domObserver.start();
  }
  if (this.delayedSelectionSync) { setTimeout(function () { return selectionToDOM(this$1.view); }); }
  this.view.mouseDown = null;
};

MouseDown.prototype.up = function up (event) {
  this.done();

  if (!this.view.dom.contains(event.target.nodeType == 3 ? event.target.parentNode : event.target))
    { return }

  var pos = this.pos;
  if (this.view.state.doc != this.startDoc) { pos = this.view.posAtCoords(eventCoords(event)); }

  if (this.allowDefault || !pos) {
    setSelectionOrigin(this.view, "pointer");
  } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {
    event.preventDefault();
  } else if (event.button == 0 &&
             (this.flushed ||
              // Safari ignores clicks on draggable elements
              (result.safari && this.mightDrag && !this.mightDrag.node.isAtom) ||
              // Chrome will sometimes treat a node selection as a
              // cursor, but still report that the node is selected
              // when asked through getSelection. You'll then get a
              // situation where clicking at the point where that
              // (hidden) cursor is doesn't change the selection, and
              // thus doesn't get a reaction from ProseMirror. This
              // works around that.
              (result.chrome && !(this.view.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection) &&
               Math.min(Math.abs(pos.pos - this.view.state.selection.from),
                        Math.abs(pos.pos - this.view.state.selection.to)) <= 2))) {
    updateSelection(this.view, prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near(this.view.state.doc.resolve(pos.pos)), "pointer");
    event.preventDefault();
  } else {
    setSelectionOrigin(this.view, "pointer");
  }
};

MouseDown.prototype.move = function move (event) {
  if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 ||
                             Math.abs(this.event.y - event.clientY) > 4))
    { this.allowDefault = true; }
  setSelectionOrigin(this.view, "pointer");
  if (event.buttons == 0) { this.done(); }
};

handlers.touchdown = function (view) {
  forceDOMFlush(view);
  setSelectionOrigin(view, "pointer");
};

handlers.contextmenu = function (view) { return forceDOMFlush(view); };

function inOrNearComposition(view, event) {
  if (view.composing) { return true }
  // See https://www.stum.de/2016/06/24/handling-ime-events-in-javascript/.
  // On Japanese input method editors (IMEs), the Enter key is used to confirm character
  // selection. On Safari, when Enter is pressed, compositionend and keydown events are
  // emitted. The keydown event triggers newline insertion, which we don't want.
  // This method returns true if the keydown event should be ignored.
  // We only ignore it once, as pressing Enter a second time *should* insert a newline.
  // Furthermore, the keydown event timestamp must be close to the compositionEndedAt timestamp.
  // This guards against the case where compositionend is triggered without the keyboard
  // (e.g. character confirmation may be done with the mouse), and keydown is triggered
  // afterwards- we wouldn't want to ignore the keydown event in this case.
  if (result.safari && Math.abs(event.timeStamp - view.compositionEndedAt) < 500) {
    view.compositionEndedAt = -2e8;
    return true
  }
  return false
}

// Drop active composition after 5 seconds of inactivity on Android
var timeoutComposition = result.android ? 5000 : -1;

editHandlers.compositionstart = editHandlers.compositionupdate = function (view) {
  if (!view.composing) {
    view.domObserver.flush();
    var state = view.state;
    var $pos = state.selection.$from;
    if (state.selection.empty &&
        (state.storedMarks ||
         (!$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some(function (m) { return m.type.spec.inclusive === false; })))) {
      // Need to wrap the cursor in mark nodes different from the ones in the DOM context
      view.markCursor = view.state.storedMarks || $pos.marks();
      endComposition(view, true);
      view.markCursor = null;
    } else {
      endComposition(view);
      // In firefox, if the cursor is after but outside a marked node,
      // the inserted text won't inherit the marks. So this moves it
      // inside if necessary.
      if (result.gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {
        var sel = view.root.getSelection();
        for (var node = sel.focusNode, offset = sel.focusOffset; node && node.nodeType == 1 && offset != 0;) {
          var before = offset < 0 ? node.lastChild : node.childNodes[offset - 1];
          if (!before) { break }
          if (before.nodeType == 3) {
            sel.collapse(before, before.nodeValue.length);
            break
          } else {
            node = before;
            offset = -1;
          }
        }
      }
    }
    view.composing = true;
  }
  scheduleComposeEnd(view, timeoutComposition);
};

editHandlers.compositionend = function (view, event) {
  if (view.composing) {
    view.composing = false;
    view.compositionEndedAt = event.timeStamp;
    scheduleComposeEnd(view, 20);
  }
};

function scheduleComposeEnd(view, delay) {
  clearTimeout(view.composingTimeout);
  if (delay > -1) { view.composingTimeout = setTimeout(function () { return endComposition(view); }, delay); }
}

function clearComposition(view) {
  if (view.composing) {
    view.composing = false;
    view.compositionEndedAt = timestampFromCustomEvent();
  }
  while (view.compositionNodes.length > 0) { view.compositionNodes.pop().markParentsDirty(); }
}

function timestampFromCustomEvent() {
  var event = document.createEvent("Event");
  event.initEvent("event", true, true);
  return event.timeStamp
}

function endComposition(view, forceUpdate) {
  view.domObserver.forceFlush();
  clearComposition(view);
  if (forceUpdate || view.docView.dirty) {
    var sel = selectionFromDOM(view);
    if (sel && !sel.eq(view.state.selection)) { view.dispatch(view.state.tr.setSelection(sel)); }
    else { view.updateState(view.state); }
    return true
  }
  return false
}

function captureCopy(view, dom) {
  // The extra wrapper is somehow necessary on IE/Edge to prevent the
  // content from being mangled when it is put onto the clipboard
  if (!view.dom.parentNode) { return }
  var wrap = view.dom.parentNode.appendChild(document.createElement("div"));
  wrap.appendChild(dom);
  wrap.style.cssText = "position: fixed; left: -10000px; top: 10px";
  var sel = getSelection(), range = document.createRange();
  range.selectNodeContents(dom);
  // Done because IE will fire a selectionchange moving the selection
  // to its start when removeAllRanges is called and the editor still
  // has focus (which will mess up the editor's selection state).
  view.dom.blur();
  sel.removeAllRanges();
  sel.addRange(range);
  setTimeout(function () {
    if (wrap.parentNode) { wrap.parentNode.removeChild(wrap); }
    view.focus();
  }, 50);
}

// This is very crude, but unfortunately both these browsers _pretend_
// that they have a clipboard API—all the objects and methods are
// there, they just don't work, and they are hard to test.
var brokenClipboardAPI = (result.ie && result.ie_version < 15) ||
      (result.ios && result.webkit_version < 604);

handlers.copy = editHandlers.cut = function (view, e) {
  var sel = view.state.selection, cut = e.type == "cut";
  if (sel.empty) { return }

  // IE and Edge's clipboard interface is completely broken
  var data = brokenClipboardAPI ? null : e.clipboardData;
  var slice = sel.content();
  var ref = serializeForClipboard(view, slice);
  var dom = ref.dom;
  var text = ref.text;
  if (data) {
    e.preventDefault();
    data.clearData();
    data.setData("text/html", dom.innerHTML);
    data.setData("text/plain", text);
  } else {
    captureCopy(view, dom);
  }
  if (cut) { view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut")); }
};

function sliceSingleNode(slice) {
  return slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1 ? slice.content.firstChild : null
}

function capturePaste(view, e) {
  if (!view.dom.parentNode) { return }
  var plainText = view.shiftKey || view.state.selection.$from.parent.type.spec.code;
  var target = view.dom.parentNode.appendChild(document.createElement(plainText ? "textarea" : "div"));
  if (!plainText) { target.contentEditable = "true"; }
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.focus();
  setTimeout(function () {
    view.focus();
    if (target.parentNode) { target.parentNode.removeChild(target); }
    if (plainText) { doPaste(view, target.value, null, e); }
    else { doPaste(view, target.textContent, target.innerHTML, e); }
  }, 50);
}

function doPaste(view, text, html, e) {
  var slice = parseFromClipboard(view, text, html, view.shiftKey, view.state.selection.$from);
  if (view.someProp("handlePaste", function (f) { return f(view, e, slice || prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice.empty); })) { return true }
  if (!slice) { return false }

  var singleNode = sliceSingleNode(slice);
  var tr = singleNode ? view.state.tr.replaceSelectionWith(singleNode, view.shiftKey) : view.state.tr.replaceSelection(slice);
  view.dispatch(tr.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste"));
  return true
}

editHandlers.paste = function (view, e) {
  var data = brokenClipboardAPI ? null : e.clipboardData;
  if (data && doPaste(view, data.getData("text/plain"), data.getData("text/html"), e)) { e.preventDefault(); }
  else { capturePaste(view, e); }
};

var Dragging = function Dragging(slice, move) {
  this.slice = slice;
  this.move = move;
};

var dragCopyModifier = result.mac ? "altKey" : "ctrlKey";

handlers.dragstart = function (view, e) {
  var mouseDown = view.mouseDown;
  if (mouseDown) { mouseDown.done(); }
  if (!e.dataTransfer) { return }

  var sel = view.state.selection;
  var pos = sel.empty ? null : view.posAtCoords(eventCoords(e));
  if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection ? sel.to - 1: sel.to)) ; else if (mouseDown && mouseDown.mightDrag) {
    view.dispatch(view.state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos)));
  } else if (e.target && e.target.nodeType == 1) {
    var desc = view.docView.nearestDesc(e.target, true);
    if (desc && desc.node.type.spec.draggable && desc != view.docView)
      { view.dispatch(view.state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.create(view.state.doc, desc.posBefore))); }
  }
  var slice = view.state.selection.content();
  var ref = serializeForClipboard(view, slice);
  var dom = ref.dom;
  var text = ref.text;
  e.dataTransfer.clearData();
  e.dataTransfer.setData(brokenClipboardAPI ? "Text" : "text/html", dom.innerHTML);
  // See https://github.com/ProseMirror/prosemirror/issues/1156
  e.dataTransfer.effectAllowed = "copyMove";
  if (!brokenClipboardAPI) { e.dataTransfer.setData("text/plain", text); }
  view.dragging = new Dragging(slice, !e[dragCopyModifier]);
};

handlers.dragend = function (view) {
  var dragging = view.dragging;
  window.setTimeout(function () {
    if (view.dragging == dragging)  { view.dragging = null; }
  }, 50);
};

editHandlers.dragover = editHandlers.dragenter = function (_, e) { return e.preventDefault(); };

editHandlers.drop = function (view, e) {
  var dragging = view.dragging;
  view.dragging = null;

  if (!e.dataTransfer) { return }

  var eventPos = view.posAtCoords(eventCoords(e));
  if (!eventPos) { return }
  var $mouse = view.state.doc.resolve(eventPos.pos);
  if (!$mouse) { return }
  var slice = dragging && dragging.slice;
  if (slice) {
    view.someProp("transformPasted", function (f) { slice = f(slice); });
  } else {
    slice = parseFromClipboard(view, e.dataTransfer.getData(brokenClipboardAPI ? "Text" : "text/plain"),
                               brokenClipboardAPI ? null : e.dataTransfer.getData("text/html"), false, $mouse);
  }
  var move = dragging && !e[dragCopyModifier];
  if (view.someProp("handleDrop", function (f) { return f(view, e, slice || prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice.empty, move); })) {
    e.preventDefault();
    return
  }
  if (!slice) { return }

  e.preventDefault();
  var insertPos = slice ? (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_2__.dropPoint)(view.state.doc, $mouse.pos, slice) : $mouse.pos;
  if (insertPos == null) { insertPos = $mouse.pos; }

  var tr = view.state.tr;
  if (move) { tr.deleteSelection(); }

  var pos = tr.mapping.map(insertPos);
  var isNode = slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1;
  var beforeInsert = tr.doc;
  if (isNode)
    { tr.replaceRangeWith(pos, pos, slice.content.firstChild); }
  else
    { tr.replaceRange(pos, pos, slice); }
  if (tr.doc.eq(beforeInsert)) { return }

  var $pos = tr.doc.resolve(pos);
  if (isNode && prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.isSelectable(slice.content.firstChild) &&
      $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice.content.firstChild)) {
    tr.setSelection(new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection($pos));
  } else {
    var end = tr.mapping.map(insertPos);
    tr.mapping.maps[tr.mapping.maps.length - 1].forEach(function (_from, _to, _newFrom, newTo) { return end = newTo; });
    tr.setSelection(selectionBetween(view, $pos, tr.doc.resolve(end)));
  }
  view.focus();
  view.dispatch(tr.setMeta("uiEvent", "drop"));
};

handlers.focus = function (view) {
  if (!view.focused) {
    view.domObserver.stop();
    view.dom.classList.add("ProseMirror-focused");
    view.domObserver.start();
    view.focused = true;
    setTimeout(function () {
      if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.root.getSelection()))
        { selectionToDOM(view); }
    }, 20);
  }
};

handlers.blur = function (view, e) {
  if (view.focused) {
    view.domObserver.stop();
    view.dom.classList.remove("ProseMirror-focused");
    view.domObserver.start();
    if (e.relatedTarget && view.dom.contains(e.relatedTarget))
      { view.domObserver.currentSelection.set({}); }
    view.focused = false;
  }
};

handlers.beforeinput = function (view, event) {
  // We should probably do more with beforeinput events, but support
  // is so spotty that I'm still waiting to see where they are going.

  // Very specific hack to deal with backspace sometimes failing on
  // Chrome Android when after an uneditable node.
  if (result.chrome && result.android && event.inputType == "deleteContentBackward") {
    var domChangeCount = view.domChangeCount;
    setTimeout(function () {
      if (view.domChangeCount != domChangeCount) { return } // Event already had some effect
      // This bug tends to close the virtual keyboard, so we refocus
      view.dom.blur();
      view.focus();
      if (view.someProp("handleKeyDown", function (f) { return f(view, keyEvent(8, "Backspace")); })) { return }
      var ref = view.state.selection;
      var $cursor = ref.$cursor;
      // Crude approximation of backspace behavior when no command handled it
      if ($cursor && $cursor.pos > 0) { view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView()); }
    }, 50);
  }
};

// Make sure all handlers get registered
for (var prop in editHandlers) { handlers[prop] = editHandlers[prop]; }

function compareObjs(a, b) {
  if (a == b) { return true }
  for (var p in a) { if (a[p] !== b[p]) { return false } }
  for (var p$1 in b) { if (!(p$1 in a)) { return false } }
  return true
}

var WidgetType = function WidgetType(toDOM, spec) {
  this.spec = spec || noSpec;
  this.side = this.spec.side || 0;
  this.toDOM = toDOM;
};

WidgetType.prototype.map = function map (mapping, span, offset, oldOffset) {
  var ref = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);
    var pos = ref.pos;
    var deleted = ref.deleted;
  return deleted ? null : new Decoration(pos - offset, pos - offset, this)
};

WidgetType.prototype.valid = function valid () { return true };

WidgetType.prototype.eq = function eq (other) {
  return this == other ||
    (other instanceof WidgetType &&
     (this.spec.key && this.spec.key == other.spec.key ||
      this.toDOM == other.toDOM && compareObjs(this.spec, other.spec)))
};

var InlineType = function InlineType(attrs, spec) {
  this.spec = spec || noSpec;
  this.attrs = attrs;
};

InlineType.prototype.map = function map (mapping, span, offset, oldOffset) {
  var from = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset;
  var to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset;
  return from >= to ? null : new Decoration(from, to, this)
};

InlineType.prototype.valid = function valid (_, span) { return span.from < span.to };

InlineType.prototype.eq = function eq (other) {
  return this == other ||
    (other instanceof InlineType && compareObjs(this.attrs, other.attrs) &&
     compareObjs(this.spec, other.spec))
};

InlineType.is = function is (span) { return span.type instanceof InlineType };

var NodeType = function NodeType(attrs, spec) {
  this.spec = spec || noSpec;
  this.attrs = attrs;
};

NodeType.prototype.map = function map (mapping, span, offset, oldOffset) {
  var from = mapping.mapResult(span.from + oldOffset, 1);
  if (from.deleted) { return null }
  var to = mapping.mapResult(span.to + oldOffset, -1);
  if (to.deleted || to.pos <= from.pos) { return null }
  return new Decoration(from.pos - offset, to.pos - offset, this)
};

NodeType.prototype.valid = function valid (node, span) {
  var ref = node.content.findIndex(span.from);
    var index = ref.index;
    var offset = ref.offset;
    var child;
  return offset == span.from && !(child = node.child(index)).isText && offset + child.nodeSize == span.to
};

NodeType.prototype.eq = function eq (other) {
  return this == other ||
    (other instanceof NodeType && compareObjs(this.attrs, other.attrs) &&
     compareObjs(this.spec, other.spec))
};

// ::- Decoration objects can be provided to the view through the
// [`decorations` prop](#view.EditorProps.decorations). They come in
// several variants—see the static members of this class for details.
var Decoration = function Decoration(from, to, type) {
  // :: number
  // The start position of the decoration.
  this.from = from;
  // :: number
  // The end position. Will be the same as `from` for [widget
  // decorations](#view.Decoration^widget).
  this.to = to;
  this.type = type;
};

var prototypeAccessors$1 = { spec: { configurable: true },inline: { configurable: true } };

Decoration.prototype.copy = function copy (from, to) {
  return new Decoration(from, to, this.type)
};

Decoration.prototype.eq = function eq (other, offset) {
    if ( offset === void 0 ) offset = 0;

  return this.type.eq(other.type) && this.from + offset == other.from && this.to + offset == other.to
};

Decoration.prototype.map = function map (mapping, offset, oldOffset) {
  return this.type.map(mapping, this, offset, oldOffset)
};

// :: (number, union<(view: EditorView, getPos: () → number) → dom.Node, dom.Node>, ?Object) → Decoration
// Creates a widget decoration, which is a DOM node that's shown in
// the document at the given position. It is recommended that you
// delay rendering the widget by passing a function that will be
// called when the widget is actually drawn in a view, but you can
// also directly pass a DOM node. `getPos` can be used to find the
// widget's current document position.
//
// spec::- These options are supported:
//
//   side:: ?number
//   Controls which side of the document position this widget is
//   associated with. When negative, it is drawn before a cursor
//   at its position, and content inserted at that position ends
//   up after the widget. When zero (the default) or positive, the
//   widget is drawn after the cursor and content inserted there
//   ends up before the widget.
//
//   When there are multiple widgets at a given position, their
//   `side` values determine the order in which they appear. Those
//   with lower values appear first. The ordering of widgets with
//   the same `side` value is unspecified.
//
//   When `marks` is null, `side` also determines the marks that
//   the widget is wrapped in—those of the node before when
//   negative, those of the node after when positive.
//
//   marks:: ?[Mark]
//   The precise set of marks to draw around the widget.
//
//   stopEvent:: ?(event: dom.Event) → bool
//   Can be used to control which DOM events, when they bubble out
//   of this widget, the editor view should ignore.
//
//   ignoreSelection:: ?bool
//   When set (defaults to false), selection changes inside the
//   widget are ignored, and don't cause ProseMirror to try and
//   re-sync the selection with its selection state.
//
//   key:: ?string
//   When comparing decorations of this type (in order to decide
//   whether it needs to be redrawn), ProseMirror will by default
//   compare the widget DOM node by identity. If you pass a key,
//   that key will be compared instead, which can be useful when
//   you generate decorations on the fly and don't want to store
//   and reuse DOM nodes. Make sure that any widgets with the same
//   key are interchangeable—if widgets differ in, for example,
//   the behavior of some event handler, they should get
//   different keys.
Decoration.widget = function widget (pos, toDOM, spec) {
  return new Decoration(pos, pos, new WidgetType(toDOM, spec))
};

// :: (number, number, DecorationAttrs, ?Object) → Decoration
// Creates an inline decoration, which adds the given attributes to
// each inline node between `from` and `to`.
//
// spec::- These options are recognized:
//
//   inclusiveStart:: ?bool
//   Determines how the left side of the decoration is
//   [mapped](#transform.Position_Mapping) when content is
//   inserted directly at that position. By default, the decoration
//   won't include the new content, but you can set this to `true`
//   to make it inclusive.
//
//   inclusiveEnd:: ?bool
//   Determines how the right side of the decoration is mapped.
//   See
//   [`inclusiveStart`](#view.Decoration^inline^spec.inclusiveStart).
Decoration.inline = function inline (from, to, attrs, spec) {
  return new Decoration(from, to, new InlineType(attrs, spec))
};

// :: (number, number, DecorationAttrs, ?Object) → Decoration
// Creates a node decoration. `from` and `to` should point precisely
// before and after a node in the document. That node, and only that
// node, will receive the given attributes.
//
// spec::-
//
// Optional information to store with the decoration. It
// is also used when comparing decorators for equality.
Decoration.node = function node (from, to, attrs, spec) {
  return new Decoration(from, to, new NodeType(attrs, spec))
};

// :: Object
// The spec provided when creating this decoration. Can be useful
// if you've stored extra information in that object.
prototypeAccessors$1.spec.get = function () { return this.type.spec };

prototypeAccessors$1.inline.get = function () { return this.type instanceof InlineType };

Object.defineProperties( Decoration.prototype, prototypeAccessors$1 );

// DecorationAttrs:: interface
// A set of attributes to add to a decorated node. Most properties
// simply directly correspond to DOM attributes of the same name,
// which will be set to the property's value. These are exceptions:
//
//   class:: ?string
//   A CSS class name or a space-separated set of class names to be
//   _added_ to the classes that the node already had.
//
//   style:: ?string
//   A string of CSS to be _added_ to the node's existing `style` property.
//
//   nodeName:: ?string
//   When non-null, the target node is wrapped in a DOM element of
//   this type (and the other attributes are applied to this element).

var none = [], noSpec = {};

// :: class extends DecorationSource
// A collection of [decorations](#view.Decoration), organized in
// such a way that the drawing algorithm can efficiently use and
// compare them. This is a persistent data structure—it is not
// modified, updates create a new value.
var DecorationSet = function DecorationSet(local, children) {
  this.local = local && local.length ? local : none;
  this.children = children && children.length ? children : none;
};

// :: (Node, [Decoration]) → DecorationSet
// Create a set of decorations, using the structure of the given
// document.
DecorationSet.create = function create (doc, decorations) {
  return decorations.length ? buildTree(decorations, doc, 0, noSpec) : empty
};

// :: (?number, ?number, ?(spec: Object) → bool) → [Decoration]
// Find all decorations in this set which touch the given range
// (including decorations that start or end directly at the
// boundaries) and match the given predicate on their spec. When
// `start` and `end` are omitted, all decorations in the set are
// considered. When `predicate` isn't given, all decorations are
// assumed to match.
DecorationSet.prototype.find = function find (start, end, predicate) {
  var result = [];
  this.findInner(start == null ? 0 : start, end == null ? 1e9 : end, result, 0, predicate);
  return result
};

DecorationSet.prototype.findInner = function findInner (start, end, result, offset, predicate) {
  for (var i = 0; i < this.local.length; i++) {
    var span = this.local[i];
    if (span.from <= end && span.to >= start && (!predicate || predicate(span.spec)))
      { result.push(span.copy(span.from + offset, span.to + offset)); }
  }
  for (var i$1 = 0; i$1 < this.children.length; i$1 += 3) {
    if (this.children[i$1] < end && this.children[i$1 + 1] > start) {
      var childOff = this.children[i$1] + 1;
      this.children[i$1 + 2].findInner(start - childOff, end - childOff, result, offset + childOff, predicate);
    }
  }
};

// :: (Mapping, Node, ?Object) → DecorationSet
// Map the set of decorations in response to a change in the
// document.
//
// options::- An optional set of options.
//
//   onRemove:: ?(decorationSpec: Object)
//   When given, this function will be called for each decoration
//   that gets dropped as a result of the mapping, passing the
//   spec of that decoration.
DecorationSet.prototype.map = function map (mapping, doc, options) {
  if (this == empty || mapping.maps.length == 0) { return this }
  return this.mapInner(mapping, doc, 0, 0, options || noSpec)
};

DecorationSet.prototype.mapInner = function mapInner (mapping, node, offset, oldOffset, options) {
  var newLocal;
  for (var i = 0; i < this.local.length; i++) {
    var mapped = this.local[i].map(mapping, offset, oldOffset);
    if (mapped && mapped.type.valid(node, mapped)) { (newLocal || (newLocal = [])).push(mapped); }
    else if (options.onRemove) { options.onRemove(this.local[i].spec); }
  }

  if (this.children.length)
    { return mapChildren(this.children, newLocal, mapping, node, offset, oldOffset, options) }
  else
    { return newLocal ? new DecorationSet(newLocal.sort(byPos)) : empty }
};

// :: (Node, [Decoration]) → DecorationSet
// Add the given array of decorations to the ones in the set,
// producing a new set. Needs access to the current document to
// create the appropriate tree structure.
DecorationSet.prototype.add = function add (doc, decorations) {
  if (!decorations.length) { return this }
  if (this == empty) { return DecorationSet.create(doc, decorations) }
  return this.addInner(doc, decorations, 0)
};

DecorationSet.prototype.addInner = function addInner (doc, decorations, offset) {
    var this$1 = this;

  var children, childIndex = 0;
  doc.forEach(function (childNode, childOffset) {
    var baseOffset = childOffset + offset, found;
    if (!(found = takeSpansForNode(decorations, childNode, baseOffset))) { return }

    if (!children) { children = this$1.children.slice(); }
    while (childIndex < children.length && children[childIndex] < childOffset) { childIndex += 3; }
    if (children[childIndex] == childOffset)
      { children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found, baseOffset + 1); }
    else
      { children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found, childNode, baseOffset + 1, noSpec)); }
    childIndex += 3;
  });

  var local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset);
  for (var i = 0; i < local.length; i++) { if (!local[i].type.valid(doc, local[i])) { local.splice(i--, 1); } }

  return new DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local,
                           children || this.children)
};

// :: ([Decoration]) → DecorationSet
// Create a new set that contains the decorations in this set, minus
// the ones in the given array.
DecorationSet.prototype.remove = function remove (decorations) {
  if (decorations.length == 0 || this == empty) { return this }
  return this.removeInner(decorations, 0)
};

DecorationSet.prototype.removeInner = function removeInner (decorations, offset) {
  var children = this.children, local = this.local;
  for (var i = 0; i < children.length; i += 3) {
    var found = (void 0), from = children[i] + offset, to = children[i + 1] + offset;
    for (var j = 0, span = (void 0); j < decorations.length; j++) { if (span = decorations[j]) {
      if (span.from > from && span.to < to) {
        decorations[j] = null
        ;(found || (found = [])).push(span);
      }
    } }
    if (!found) { continue }
    if (children == this.children) { children = this.children.slice(); }
    var removed = children[i + 2].removeInner(found, from + 1);
    if (removed != empty) {
      children[i + 2] = removed;
    } else {
      children.splice(i, 3);
      i -= 3;
    }
  }
  if (local.length) { for (var i$1 = 0, span$1 = (void 0); i$1 < decorations.length; i$1++) { if (span$1 = decorations[i$1]) {
    for (var j$1 = 0; j$1 < local.length; j$1++) { if (local[j$1].eq(span$1, offset)) {
      if (local == this.local) { local = this.local.slice(); }
      local.splice(j$1--, 1);
    } }
  } } }
  if (children == this.children && local == this.local) { return this }
  return local.length || children.length ? new DecorationSet(local, children) : empty
};

DecorationSet.prototype.forChild = function forChild (offset, node) {
  if (this == empty) { return this }
  if (node.isLeaf) { return DecorationSet.empty }

  var child, local;
  for (var i = 0; i < this.children.length; i += 3) { if (this.children[i] >= offset) {
    if (this.children[i] == offset) { child = this.children[i + 2]; }
    break
  } }
  var start = offset + 1, end = start + node.content.size;
  for (var i$1 = 0; i$1 < this.local.length; i$1++) {
    var dec = this.local[i$1];
    if (dec.from < end && dec.to > start && (dec.type instanceof InlineType)) {
      var from = Math.max(start, dec.from) - start, to = Math.min(end, dec.to) - start;
      if (from < to) { (local || (local = [])).push(dec.copy(from, to)); }
    }
  }
  if (local) {
    var localSet = new DecorationSet(local.sort(byPos));
    return child ? new DecorationGroup([localSet, child]) : localSet
  }
  return child || empty
};

DecorationSet.prototype.eq = function eq (other) {
  if (this == other) { return true }
  if (!(other instanceof DecorationSet) ||
      this.local.length != other.local.length ||
      this.children.length != other.children.length) { return false }
  for (var i = 0; i < this.local.length; i++)
    { if (!this.local[i].eq(other.local[i])) { return false } }
  for (var i$1 = 0; i$1 < this.children.length; i$1 += 3)
    { if (this.children[i$1] != other.children[i$1] ||
        this.children[i$1 + 1] != other.children[i$1 + 1] ||
        !this.children[i$1 + 2].eq(other.children[i$1 + 2])) { return false } }
  return true
};

DecorationSet.prototype.locals = function locals (node) {
  return removeOverlap(this.localsInner(node))
};

DecorationSet.prototype.localsInner = function localsInner (node) {
  if (this == empty) { return none }
  if (node.inlineContent || !this.local.some(InlineType.is)) { return this.local }
  var result = [];
  for (var i = 0; i < this.local.length; i++) {
    if (!(this.local[i].type instanceof InlineType))
      { result.push(this.local[i]); }
  }
  return result
};

// DecorationSource:: interface
// An object that can [provide](#view.EditorProps.decorations)
// decorations. Implemented by [`DecorationSet`](#view.DecorationSet),
// and passed to [node views](#view.EditorProps.nodeViews).
//
//   map:: (Mapping, Node) → DecorationSource
//   Map the set of decorations in response to a change in the
//   document.

var empty = new DecorationSet();

// :: DecorationSet
// The empty set of decorations.
DecorationSet.empty = empty;

DecorationSet.removeOverlap = removeOverlap;

// :- An abstraction that allows the code dealing with decorations to
// treat multiple DecorationSet objects as if it were a single object
// with (a subset of) the same interface.
var DecorationGroup = function DecorationGroup(members) {
  this.members = members;
};

DecorationGroup.prototype.map = function map (mapping, doc) {
  var mappedDecos = this.members.map(
    function (member) { return member.map(mapping, doc, noSpec); }
  );
  return DecorationGroup.from(mappedDecos)
};

DecorationGroup.prototype.forChild = function forChild (offset, child) {
  if (child.isLeaf) { return DecorationSet.empty }
  var found = [];
  for (var i = 0; i < this.members.length; i++) {
    var result = this.members[i].forChild(offset, child);
    if (result == empty) { continue }
    if (result instanceof DecorationGroup) { found = found.concat(result.members); }
    else { found.push(result); }
  }
  return DecorationGroup.from(found)
};

DecorationGroup.prototype.eq = function eq (other) {
  if (!(other instanceof DecorationGroup) ||
      other.members.length != this.members.length) { return false }
  for (var i = 0; i < this.members.length; i++)
    { if (!this.members[i].eq(other.members[i])) { return false } }
  return true
};

DecorationGroup.prototype.locals = function locals (node) {
  var result, sorted = true;
  for (var i = 0; i < this.members.length; i++) {
    var locals = this.members[i].localsInner(node);
    if (!locals.length) { continue }
    if (!result) {
      result = locals;
    } else {
      if (sorted) {
        result = result.slice();
        sorted = false;
      }
      for (var j = 0; j < locals.length; j++) { result.push(locals[j]); }
    }
  }
  return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none
};

// : ([DecorationSet]) → union<DecorationSet, DecorationGroup>
// Create a group for the given array of decoration sets, or return
// a single set when possible.
DecorationGroup.from = function from (members) {
  switch (members.length) {
    case 0: return empty
    case 1: return members[0]
    default: return new DecorationGroup(members)
  }
};

function mapChildren(oldChildren, newLocal, mapping, node, offset, oldOffset, options) {
  var children = oldChildren.slice();

  // Mark the children that are directly touched by changes, and
  // move those that are after the changes.
  var shift = function (oldStart, oldEnd, newStart, newEnd) {
    for (var i = 0; i < children.length; i += 3) {
      var end = children[i + 1], dSize = (void 0);
      if (end == -1 || oldStart > end + oldOffset) { continue }
      if (oldEnd >= children[i] + oldOffset) {
        children[i + 1] = -1;
      } else if (newStart >= offset && (dSize = (newEnd - newStart) - (oldEnd - oldStart))) {
        children[i] += dSize;
        children[i + 1] += dSize;
      }
    }
  };
  for (var i = 0; i < mapping.maps.length; i++) { mapping.maps[i].forEach(shift); }

  // Find the child nodes that still correspond to a single node,
  // recursively call mapInner on them and update their positions.
  var mustRebuild = false;
  for (var i$1 = 0; i$1 < children.length; i$1 += 3) { if (children[i$1 + 1] == -1) { // Touched nodes
    var from = mapping.map(oldChildren[i$1] + oldOffset), fromLocal = from - offset;
    if (fromLocal < 0 || fromLocal >= node.content.size) {
      mustRebuild = true;
      continue
    }
    // Must read oldChildren because children was tagged with -1
    var to = mapping.map(oldChildren[i$1 + 1] + oldOffset, -1), toLocal = to - offset;
    var ref = node.content.findIndex(fromLocal);
    var index = ref.index;
    var childOffset = ref.offset;
    var childNode = node.maybeChild(index);
    if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {
      var mapped = children[i$1 + 2].mapInner(mapping, childNode, from + 1, oldChildren[i$1] + oldOffset + 1, options);
      if (mapped != empty) {
        children[i$1] = fromLocal;
        children[i$1 + 1] = toLocal;
        children[i$1 + 2] = mapped;
      } else {
        children[i$1 + 1] = -2;
        mustRebuild = true;
      }
    } else {
      mustRebuild = true;
    }
  } }

  // Remaining children must be collected and rebuilt into the appropriate structure
  if (mustRebuild) {
    var decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal || [], mapping,
                                                       offset, oldOffset, options);
    var built = buildTree(decorations, node, 0, options);
    newLocal = built.local;
    for (var i$2 = 0; i$2 < children.length; i$2 += 3) { if (children[i$2 + 1] < 0) {
      children.splice(i$2, 3);
      i$2 -= 3;
    } }
    for (var i$3 = 0, j = 0; i$3 < built.children.length; i$3 += 3) {
      var from$1 = built.children[i$3];
      while (j < children.length && children[j] < from$1) { j += 3; }
      children.splice(j, 0, built.children[i$3], built.children[i$3 + 1], built.children[i$3 + 2]);
    }
  }

  return new DecorationSet(newLocal && newLocal.sort(byPos), children)
}

function moveSpans(spans, offset) {
  if (!offset || !spans.length) { return spans }
  var result = [];
  for (var i = 0; i < spans.length; i++) {
    var span = spans[i];
    result.push(new Decoration(span.from + offset, span.to + offset, span.type));
  }
  return result
}

function mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset, oldOffset, options) {
  // Gather all decorations from the remaining marked children
  function gather(set, oldOffset) {
    for (var i = 0; i < set.local.length; i++) {
      var mapped = set.local[i].map(mapping, offset, oldOffset);
      if (mapped) { decorations.push(mapped); }
      else if (options.onRemove) { options.onRemove(set.local[i].spec); }
    }
    for (var i$1 = 0; i$1 < set.children.length; i$1 += 3)
      { gather(set.children[i$1 + 2], set.children[i$1] + oldOffset + 1); }
  }
  for (var i = 0; i < children.length; i += 3) { if (children[i + 1] == -1)
    { gather(children[i + 2], oldChildren[i] + oldOffset + 1); } }

  return decorations
}

function takeSpansForNode(spans, node, offset) {
  if (node.isLeaf) { return null }
  var end = offset + node.nodeSize, found = null;
  for (var i = 0, span = (void 0); i < spans.length; i++) {
    if ((span = spans[i]) && span.from > offset && span.to < end) {
(found || (found = [])).push(span);
      spans[i] = null;
    }
  }
  return found
}

function withoutNulls(array) {
  var result = [];
  for (var i = 0; i < array.length; i++)
    { if (array[i] != null) { result.push(array[i]); } }
  return result
}

// : ([Decoration], Node, number) → DecorationSet
// Build up a tree that corresponds to a set of decorations. `offset`
// is a base offset that should be subtracted from the `from` and `to`
// positions in the spans (so that we don't have to allocate new spans
// for recursive calls).
function buildTree(spans, node, offset, options) {
  var children = [], hasNulls = false;
  node.forEach(function (childNode, localStart) {
    var found = takeSpansForNode(spans, childNode, localStart + offset);
    if (found) {
      hasNulls = true;
      var subtree = buildTree(found, childNode, offset + localStart + 1, options);
      if (subtree != empty)
        { children.push(localStart, localStart + childNode.nodeSize, subtree); }
    }
  });
  var locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset).sort(byPos);
  for (var i = 0; i < locals.length; i++) { if (!locals[i].type.valid(node, locals[i])) {
    if (options.onRemove) { options.onRemove(locals[i].spec); }
    locals.splice(i--, 1);
  } }
  return locals.length || children.length ? new DecorationSet(locals, children) : empty
}

// : (Decoration, Decoration) → number
// Used to sort decorations so that ones with a low start position
// come first, and within a set with the same start position, those
// with an smaller end position come first.
function byPos(a, b) {
  return a.from - b.from || a.to - b.to
}

// : ([Decoration]) → [Decoration]
// Scan a sorted array of decorations for partially overlapping spans,
// and split those so that only fully overlapping spans are left (to
// make subsequent rendering easier). Will return the input array if
// no partially overlapping spans are found (the common case).
function removeOverlap(spans) {
  var working = spans;
  for (var i = 0; i < working.length - 1; i++) {
    var span = working[i];
    if (span.from != span.to) { for (var j = i + 1; j < working.length; j++) {
      var next = working[j];
      if (next.from == span.from) {
        if (next.to != span.to) {
          if (working == spans) { working = spans.slice(); }
          // Followed by a partially overlapping larger span. Split that
          // span.
          working[j] = next.copy(next.from, span.to);
          insertAhead(working, j + 1, next.copy(span.to, next.to));
        }
        continue
      } else {
        if (next.from < span.to) {
          if (working == spans) { working = spans.slice(); }
          // The end of this one overlaps with a subsequent span. Split
          // this one.
          working[i] = span.copy(span.from, next.from);
          insertAhead(working, j, span.copy(next.from, span.to));
        }
        break
      }
    } }
  }
  return working
}

function insertAhead(array, i, deco) {
  while (i < array.length && byPos(deco, array[i]) > 0) { i++; }
  array.splice(i, 0, deco);
}

// : (EditorView) → union<DecorationSet, DecorationGroup>
// Get the decorations associated with the current props of a view.
function viewDecorations(view) {
  var found = [];
  view.someProp("decorations", function (f) {
    var result = f(view.state);
    if (result && result != empty) { found.push(result); }
  });
  if (view.cursorWrapper)
    { found.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco])); }
  return DecorationGroup.from(found)
}

// ::- An editor view manages the DOM structure that represents an
// editable document. Its state and behavior are determined by its
// [props](#view.DirectEditorProps).
var EditorView = function EditorView(place, props) {
  this._props = props;
  // :: EditorState
  // The view's current [state](#state.EditorState).
  this.state = props.state;

  this.directPlugins = props.plugins || [];
  this.directPlugins.forEach(checkStateComponent);

  this.dispatch = this.dispatch.bind(this);

  this._root = null;
  this.focused = false;
  // Kludge used to work around a Chrome bug
  this.trackWrites = null;

  // :: dom.Element
  // An editable DOM node containing the document. (You probably
  // should not directly interfere with its content.)
  this.dom = (place && place.mount) || document.createElement("div");
  if (place) {
    if (place.appendChild) { place.appendChild(this.dom); }
    else if (place.apply) { place(this.dom); }
    else if (place.mount) { this.mounted = true; }
  }

  // :: bool
  // Indicates whether the editor is currently [editable](#view.EditorProps.editable).
  this.editable = getEditable(this);
  this.markCursor = null;
  this.cursorWrapper = null;
  updateCursorWrapper(this);
  this.nodeViews = buildNodeViews(this);
  this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);

  this.lastSelectedViewDesc = null;
  // :: ?{slice: Slice, move: bool}
  // When editor content is being dragged, this object contains
  // information about the dragged slice and whether it is being
  // copied or moved. At any other time, it is null.
  this.dragging = null;

  initInput(this);

  this.prevDirectPlugins = [];
  this.pluginViews = [];
  this.updatePluginViews();
};

var prototypeAccessors$2 = { props: { configurable: true },root: { configurable: true } };

// composing:: boolean
// Holds `true` when a
// [composition](https://developer.mozilla.org/en-US/docs/Mozilla/IME_handling_guide)
// is active.

// :: DirectEditorProps
// The view's current [props](#view.EditorProps).
prototypeAccessors$2.props.get = function () {
  if (this._props.state != this.state) {
    var prev = this._props;
    this._props = {};
    for (var name in prev) { this._props[name] = prev[name]; }
    this._props.state = this.state;
  }
  return this._props
};

// :: (DirectEditorProps)
// Update the view's props. Will immediately cause an update to
// the DOM.
EditorView.prototype.update = function update (props) {
  if (props.handleDOMEvents != this._props.handleDOMEvents) { ensureListeners(this); }
  this._props = props;
  if (props.plugins) {
    props.plugins.forEach(checkStateComponent);
    this.directPlugins = props.plugins;
  }
  this.updateStateInner(props.state, true);
};

// :: (DirectEditorProps)
// Update the view by updating existing props object with the object
// given as argument. Equivalent to `view.update(Object.assign({},
// view.props, props))`.
EditorView.prototype.setProps = function setProps (props) {
  var updated = {};
  for (var name in this._props) { updated[name] = this._props[name]; }
  updated.state = this.state;
  for (var name$1 in props) { updated[name$1] = props[name$1]; }
  this.update(updated);
};

// :: (EditorState)
// Update the editor's `state` prop, without touching any of the
// other props.
EditorView.prototype.updateState = function updateState (state) {
  this.updateStateInner(state, this.state.plugins != state.plugins);
};

EditorView.prototype.updateStateInner = function updateStateInner (state, reconfigured) {
    var this$1 = this;

  var prev = this.state, redraw = false, updateSel = false;
  // When stored marks are added, stop composition, so that they can
  // be displayed.
  if (state.storedMarks && this.composing) {
    clearComposition(this);
    updateSel = true;
  }
  this.state = state;
  if (reconfigured) {
    var nodeViews = buildNodeViews(this);
    if (changedNodeViews(nodeViews, this.nodeViews)) {
      this.nodeViews = nodeViews;
      redraw = true;
    }
    ensureListeners(this);
  }

  this.editable = getEditable(this);
  updateCursorWrapper(this);
  var innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this);

  var scroll = reconfigured ? "reset"
      : state.scrollToSelection > prev.scrollToSelection ? "to selection" : "preserve";
  var updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);
  if (updateDoc || !state.selection.eq(prev.selection)) { updateSel = true; }
  var oldScrollPos = scroll == "preserve" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);

  if (updateSel) {
    this.domObserver.stop();
    // Work around an issue in Chrome, IE, and Edge where changing
    // the DOM around an active selection puts it into a broken
    // state where the thing the user sees differs from the
    // selection reported by the Selection object (#710, #973,
    // #1011, #1013, #1035).
    var forceSelUpdate = updateDoc && (result.ie || result.chrome) && !this.composing &&
        !prev.selection.empty && !state.selection.empty && selectionContextChanged(prev.selection, state.selection);
    if (updateDoc) {
      // If the node that the selection points into is written to,
      // Chrome sometimes starts misreporting the selection, so this
      // tracks that and forces a selection reset when our update
      // did write to the node.
      var chromeKludge = result.chrome ? (this.trackWrites = this.root.getSelection().focusNode) : null;
      if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {
        this.docView.updateOuterDeco([]);
        this.docView.destroy();
        this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);
      }
      if (chromeKludge && !this.trackWrites) { forceSelUpdate = true; }
    }
    // Work around for an issue where an update arriving right between
    // a DOM selection change and the "selectionchange" event for it
    // can cause a spurious DOM selection update, disrupting mouse
    // drag selection.
    if (forceSelUpdate ||
        !(this.mouseDown && this.domObserver.currentSelection.eq(this.root.getSelection()) && anchorInRightPlace(this))) {
      selectionToDOM(this, forceSelUpdate);
    } else {
      syncNodeSelection(this, state.selection);
      this.domObserver.setCurSelection();
    }
    this.domObserver.start();
  }

  this.updatePluginViews(prev);

  if (scroll == "reset") {
    this.dom.scrollTop = 0;
  } else if (scroll == "to selection") {
    var startDOM = this.root.getSelection().focusNode;
    if (this.someProp("handleScrollToSelection", function (f) { return f(this$1); }))
      ; // Handled
    else if (state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection)
      { scrollRectIntoView(this, this.docView.domAfterPos(state.selection.from).getBoundingClientRect(), startDOM); }
    else
      { scrollRectIntoView(this, this.coordsAtPos(state.selection.head, 1), startDOM); }
  } else if (oldScrollPos) {
    resetScrollPos(oldScrollPos);
  }
};

EditorView.prototype.destroyPluginViews = function destroyPluginViews () {
  var view;
  while (view = this.pluginViews.pop()) { if (view.destroy) { view.destroy(); } }
};

EditorView.prototype.updatePluginViews = function updatePluginViews (prevState) {
  if (!prevState || prevState.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
    this.prevDirectPlugins = this.directPlugins;
    this.destroyPluginViews();
    for (var i = 0; i < this.directPlugins.length; i++) {
      var plugin = this.directPlugins[i];
      if (plugin.spec.view) { this.pluginViews.push(plugin.spec.view(this)); }
    }
    for (var i$1 = 0; i$1 < this.state.plugins.length; i$1++) {
      var plugin$1 = this.state.plugins[i$1];
      if (plugin$1.spec.view) { this.pluginViews.push(plugin$1.spec.view(this)); }
    }
  } else {
    for (var i$2 = 0; i$2 < this.pluginViews.length; i$2++) {
      var pluginView = this.pluginViews[i$2];
      if (pluginView.update) { pluginView.update(this, prevState); }
    }
  }
};

// :: (string, ?(prop: *) → *) → *
// Goes over the values of a prop, first those provided directly,
// then those from plugins given to the view, then from plugins in
// the state (in order), and calls `f` every time a non-undefined
// value is found. When `f` returns a truthy value, that is
// immediately returned. When `f` isn't provided, it is treated as
// the identity function (the prop value is returned directly).
EditorView.prototype.someProp = function someProp (propName, f) {
  var prop = this._props && this._props[propName], value;
  if (prop != null && (value = f ? f(prop) : prop)) { return value }
  for (var i = 0; i < this.directPlugins.length; i++) {
    var prop$1 = this.directPlugins[i].props[propName];
    if (prop$1 != null && (value = f ? f(prop$1) : prop$1)) { return value }
  }
  var plugins = this.state.plugins;
  if (plugins) { for (var i$1 = 0; i$1 < plugins.length; i$1++) {
    var prop$2 = plugins[i$1].props[propName];
    if (prop$2 != null && (value = f ? f(prop$2) : prop$2)) { return value }
  } }
};

// :: () → bool
// Query whether the view has focus.
EditorView.prototype.hasFocus = function hasFocus () {
  return this.root.activeElement == this.dom
};

// :: ()
// Focus the editor.
EditorView.prototype.focus = function focus () {
  this.domObserver.stop();
  if (this.editable) { focusPreventScroll(this.dom); }
  selectionToDOM(this);
  this.domObserver.start();
};

// :: union<dom.Document, dom.DocumentFragment>
// Get the document root in which the editor exists. This will
// usually be the top-level `document`, but might be a [shadow
// DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
// root if the editor is inside one.
prototypeAccessors$2.root.get = function () {
  var cached = this._root;
  if (cached == null) { for (var search = this.dom.parentNode; search; search = search.parentNode) {
    if (search.nodeType == 9 || (search.nodeType == 11 && search.host)) {
      if (!search.getSelection) { Object.getPrototypeOf(search).getSelection = function () { return document.getSelection(); }; }
      return this._root = search
    }
  } }
  return cached || document
};

// :: ({left: number, top: number}) → ?{pos: number, inside: number}
// Given a pair of viewport coordinates, return the document
// position that corresponds to them. May return null if the given
// coordinates aren't inside of the editor. When an object is
// returned, its `pos` property is the position nearest to the
// coordinates, and its `inside` property holds the position of the
// inner node that the position falls inside of, or -1 if it is at
// the top level, not in any node.
EditorView.prototype.posAtCoords = function posAtCoords$1 (coords) {
  return posAtCoords(this, coords)
};

// :: (number, number) → {left: number, right: number, top: number, bottom: number}
// Returns the viewport rectangle at a given document position.
// `left` and `right` will be the same number, as this returns a
// flat cursor-ish rectangle. If the position is between two things
// that aren't directly adjacent, `side` determines which element is
// used. When < 0, the element before the position is used,
// otherwise the element after.
EditorView.prototype.coordsAtPos = function coordsAtPos$1 (pos, side) {
    if ( side === void 0 ) side = 1;

  return coordsAtPos(this, pos, side)
};

// :: (number, number) → {node: dom.Node, offset: number}
// Find the DOM position that corresponds to the given document
// position. When `side` is negative, find the position as close as
// possible to the content before the position. When positive,
// prefer positions close to the content after the position. When
// zero, prefer as shallow a position as possible.
//
// Note that you should **not** mutate the editor's internal DOM,
// only inspect it (and even that is usually not necessary).
EditorView.prototype.domAtPos = function domAtPos (pos, side) {
    if ( side === void 0 ) side = 0;

  return this.docView.domFromPos(pos, side)
};

// :: (number) → ?dom.Node
// Find the DOM node that represents the document node after the
// given position. May return `null` when the position doesn't point
// in front of a node or if the node is inside an opaque node view.
//
// This is intended to be able to call things like
// `getBoundingClientRect` on that DOM node. Do **not** mutate the
// editor DOM directly, or add styling this way, since that will be
// immediately overriden by the editor as it redraws the node.
EditorView.prototype.nodeDOM = function nodeDOM (pos) {
  var desc = this.docView.descAt(pos);
  return desc ? desc.nodeDOM : null
};

// :: (dom.Node, number, ?number) → number
// Find the document position that corresponds to a given DOM
// position. (Whenever possible, it is preferable to inspect the
// document structure directly, rather than poking around in the
// DOM, but sometimes—for example when interpreting an event
// target—you don't have a choice.)
//
// The `bias` parameter can be used to influence which side of a DOM
// node to use when the position is inside a leaf node.
EditorView.prototype.posAtDOM = function posAtDOM (node, offset, bias) {
    if ( bias === void 0 ) bias = -1;

  var pos = this.docView.posFromDOM(node, offset, bias);
  if (pos == null) { throw new RangeError("DOM position not inside the editor") }
  return pos
};

// :: (union<"up", "down", "left", "right", "forward", "backward">, ?EditorState) → bool
// Find out whether the selection is at the end of a textblock when
// moving in a given direction. When, for example, given `"left"`,
// it will return true if moving left from the current cursor
// position would leave that position's parent textblock. Will apply
// to the view's current state by default, but it is possible to
// pass a different state.
EditorView.prototype.endOfTextblock = function endOfTextblock$1 (dir, state) {
  return endOfTextblock(this, state || this.state, dir)
};

// :: ()
// Removes the editor from the DOM and destroys all [node
// views](#view.NodeView).
EditorView.prototype.destroy = function destroy () {
  if (!this.docView) { return }
  destroyInput(this);
  this.destroyPluginViews();
  if (this.mounted) {
    this.docView.update(this.state.doc, [], viewDecorations(this), this);
    this.dom.textContent = "";
  } else if (this.dom.parentNode) {
    this.dom.parentNode.removeChild(this.dom);
  }
  this.docView.destroy();
  this.docView = null;
};

// Used for testing.
EditorView.prototype.dispatchEvent = function dispatchEvent$1 (event) {
  return dispatchEvent(this, event)
};

// :: (Transaction)
// Dispatch a transaction. Will call
// [`dispatchTransaction`](#view.DirectEditorProps.dispatchTransaction)
// when given, and otherwise defaults to applying the transaction to
// the current state and calling
// [`updateState`](#view.EditorView.updateState) with the result.
// This method is bound to the view instance, so that it can be
// easily passed around.
EditorView.prototype.dispatch = function dispatch (tr) {
  var dispatchTransaction = this._props.dispatchTransaction;
  if (dispatchTransaction) { dispatchTransaction.call(this, tr); }
  else { this.updateState(this.state.apply(tr)); }
};

Object.defineProperties( EditorView.prototype, prototypeAccessors$2 );

function computeDocDeco(view) {
  var attrs = Object.create(null);
  attrs.class = "ProseMirror";
  attrs.contenteditable = String(view.editable);
  attrs.translate = "no";

  view.someProp("attributes", function (value) {
    if (typeof value == "function") { value = value(view.state); }
    if (value) { for (var attr in value) {
      if (attr == "class")
        { attrs.class += " " + value[attr]; }
      else if (!attrs[attr] && attr != "contenteditable" && attr != "nodeName")
        { attrs[attr] = String(value[attr]); }
    } }
  });

  return [Decoration.node(0, view.state.doc.content.size, attrs)]
}

function updateCursorWrapper(view) {
  if (view.markCursor) {
    var dom = document.createElement("img");
    dom.className = "ProseMirror-separator";
    dom.setAttribute("mark-placeholder", "true");
    view.cursorWrapper = {dom: dom, deco: Decoration.widget(view.state.selection.head, dom, {raw: true, marks: view.markCursor})};
  } else {
    view.cursorWrapper = null;
  }
}

function getEditable(view) {
  return !view.someProp("editable", function (value) { return value(view.state) === false; })
}

function selectionContextChanged(sel1, sel2) {
  var depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));
  return sel1.$anchor.start(depth) != sel2.$anchor.start(depth)
}

function buildNodeViews(view) {
  var result = {};
  view.someProp("nodeViews", function (obj) {
    for (var prop in obj) { if (!Object.prototype.hasOwnProperty.call(result, prop))
      { result[prop] = obj[prop]; } }
  });
  return result
}

function changedNodeViews(a, b) {
  var nA = 0, nB = 0;
  for (var prop in a) {
    if (a[prop] != b[prop]) { return true }
    nA++;
  }
  for (var _ in b) { nB++; }
  return nA != nB
}

function checkStateComponent(plugin) {
  if (plugin.spec.state || plugin.spec.filterTransaction || plugin.spec.appendTransaction)
    { throw new RangeError("Plugins passed directly to the view must not have a state component") }
}

// EditorProps:: interface
//
// Props are configuration values that can be passed to an editor view
// or included in a plugin. This interface lists the supported props.
//
// The various event-handling functions may all return `true` to
// indicate that they handled the given event. The view will then take
// care to call `preventDefault` on the event, except with
// `handleDOMEvents`, where the handler itself is responsible for that.
//
// How a prop is resolved depends on the prop. Handler functions are
// called one at a time, starting with the base props and then
// searching through the plugins (in order of appearance) until one of
// them returns true. For some props, the first plugin that yields a
// value gets precedence.
//
//   handleDOMEvents:: ?Object<(view: EditorView, event: dom.Event) → bool>
//   Can be an object mapping DOM event type names to functions that
//   handle them. Such functions will be called before any handling
//   ProseMirror does of events fired on the editable DOM element.
//   Contrary to the other event handling props, when returning true
//   from such a function, you are responsible for calling
//   `preventDefault` yourself (or not, if you want to allow the
//   default behavior).
//
//   handleKeyDown:: ?(view: EditorView, event: dom.KeyboardEvent) → bool
//   Called when the editor receives a `keydown` event.
//
//   handleKeyPress:: ?(view: EditorView, event: dom.KeyboardEvent) → bool
//   Handler for `keypress` events.
//
//   handleTextInput:: ?(view: EditorView, from: number, to: number, text: string) → bool
//   Whenever the user directly input text, this handler is called
//   before the input is applied. If it returns `true`, the default
//   behavior of actually inserting the text is suppressed.
//
//   handleClickOn:: ?(view: EditorView, pos: number, node: Node, nodePos: number, event: dom.MouseEvent, direct: bool) → bool
//   Called for each node around a click, from the inside out. The
//   `direct` flag will be true for the inner node.
//
//   handleClick:: ?(view: EditorView, pos: number, event: dom.MouseEvent) → bool
//   Called when the editor is clicked, after `handleClickOn` handlers
//   have been called.
//
//   handleDoubleClickOn:: ?(view: EditorView, pos: number, node: Node, nodePos: number, event: dom.MouseEvent, direct: bool) → bool
//   Called for each node around a double click.
//
//   handleDoubleClick:: ?(view: EditorView, pos: number, event: dom.MouseEvent) → bool
//   Called when the editor is double-clicked, after `handleDoubleClickOn`.
//
//   handleTripleClickOn:: ?(view: EditorView, pos: number, node: Node, nodePos: number, event: dom.MouseEvent, direct: bool) → bool
//   Called for each node around a triple click.
//
//   handleTripleClick:: ?(view: EditorView, pos: number, event: dom.MouseEvent) → bool
//   Called when the editor is triple-clicked, after `handleTripleClickOn`.
//
//   handlePaste:: ?(view: EditorView, event: dom.ClipboardEvent, slice: Slice) → bool
//   Can be used to override the behavior of pasting. `slice` is the
//   pasted content parsed by the editor, but you can directly access
//   the event to get at the raw content.
//
//   handleDrop:: ?(view: EditorView, event: dom.Event, slice: Slice, moved: bool) → bool
//   Called when something is dropped on the editor. `moved` will be
//   true if this drop moves from the current selection (which should
//   thus be deleted).
//
//   handleScrollToSelection:: ?(view: EditorView) → bool
//   Called when the view, after updating its state, tries to scroll
//   the selection into view. A handler function may return false to
//   indicate that it did not handle the scrolling and further
//   handlers or the default behavior should be tried.
//
//   createSelectionBetween:: ?(view: EditorView, anchor: ResolvedPos, head: ResolvedPos) → ?Selection
//   Can be used to override the way a selection is created when
//   reading a DOM selection between the given anchor and head.
//
//   domParser:: ?DOMParser
//   The [parser](#model.DOMParser) to use when reading editor changes
//   from the DOM. Defaults to calling
//   [`DOMParser.fromSchema`](#model.DOMParser^fromSchema) on the
//   editor's schema.
//
//   transformPastedHTML:: ?(html: string) → string
//   Can be used to transform pasted HTML text, _before_ it is parsed,
//   for example to clean it up.
//
//   clipboardParser:: ?DOMParser
//   The [parser](#model.DOMParser) to use when reading content from
//   the clipboard. When not given, the value of the
//   [`domParser`](#view.EditorProps.domParser) prop is used.
//
//   transformPastedText:: ?(text: string, plain: bool) → string
//   Transform pasted plain text. The `plain` flag will be true when
//   the text is pasted as plain text.
//
//   clipboardTextParser:: ?(text: string, $context: ResolvedPos, plain: bool) → Slice
//   A function to parse text from the clipboard into a document
//   slice. Called after
//   [`transformPastedText`](#view.EditorProps.transformPastedText).
//   The default behavior is to split the text into lines, wrap them
//   in `<p>` tags, and call
//   [`clipboardParser`](#view.EditorProps.clipboardParser) on it.
//   The `plain` flag will be true when the text is pasted as plain text.
//
//   transformPasted:: ?(Slice) → Slice
//   Can be used to transform pasted content before it is applied to
//   the document.
//
//   nodeViews:: ?Object<(node: Node, view: EditorView, getPos: () → number, decorations: [Decoration], innerDecorations: DecorationSource) → NodeView>
//   Allows you to pass custom rendering and behavior logic for nodes
//   and marks. Should map node and mark names to constructor
//   functions that produce a [`NodeView`](#view.NodeView) object
//   implementing the node's display behavior. For nodes, the third
//   argument `getPos` is a function that can be called to get the
//   node's current position, which can be useful when creating
//   transactions to update it. For marks, the third argument is a
//   boolean that indicates whether the mark's content is inline.
//
//   `decorations` is an array of node or inline decorations that are
//   active around the node. They are automatically drawn in the
//   normal way, and you will usually just want to ignore this, but
//   they can also be used as a way to provide context information to
//   the node view without adding it to the document itself.
//
//   `innerDecorations` holds the decorations for the node's content.
//   You can safely ignore this if your view has no content or a
//   `contentDOM` property, since the editor will draw the decorations
//   on the content. But if you, for example, want to create a nested
//   editor with the content, it may make sense to provide it with the
//   inner decorations.
//
//   clipboardSerializer:: ?DOMSerializer
//   The DOM serializer to use when putting content onto the
//   clipboard. If not given, the result of
//   [`DOMSerializer.fromSchema`](#model.DOMSerializer^fromSchema)
//   will be used.
//
//   clipboardTextSerializer:: ?(Slice) → string
//   A function that will be called to get the text for the current
//   selection when copying text to the clipboard. By default, the
//   editor will use [`textBetween`](#model.Node.textBetween) on the
//   selected range.
//
//   decorations:: ?(state: EditorState) → ?DecorationSource
//   A set of [document decorations](#view.Decoration) to show in the
//   view.
//
//   editable:: ?(state: EditorState) → bool
//   When this returns false, the content of the view is not directly
//   editable.
//
//   attributes:: ?union<Object<string>, (EditorState) → ?Object<string>>
//   Control the DOM attributes of the editable element. May be either
//   an object or a function going from an editor state to an object.
//   By default, the element will get a class `"ProseMirror"`, and
//   will have its `contentEditable` attribute determined by the
//   [`editable` prop](#view.EditorProps.editable). Additional classes
//   provided here will be added to the class. For other attributes,
//   the value provided first (as in
//   [`someProp`](#view.EditorView.someProp)) will be used.
//
//   scrollThreshold:: ?union<number, {top: number, right: number, bottom: number, left: number}>
//   Determines the distance (in pixels) between the cursor and the
//   end of the visible viewport at which point, when scrolling the
//   cursor into view, scrolling takes place. Defaults to 0.
//
//   scrollMargin:: ?union<number, {top: number, right: number, bottom: number, left: number}>
//   Determines the extra space (in pixels) that is left above or
//   below the cursor when it is scrolled into view. Defaults to 5.

// DirectEditorProps:: interface extends EditorProps
//
// The props object given directly to the editor view supports two
// fields that can't be used in plugins:
//
//   state:: EditorState
//   The current state of the editor.
//
//   plugins:: [Plugin]
//   A set of plugins to use in the view, applying their [plugin
//   view](#state.PluginSpec.view) and
//   [props](#state.PluginSpec.props). Passing plugins with a state
//   component (a [state field](#state.PluginSpec.state) field or a
//   [transaction)[#state.PluginSpec.filterTransaction] filter or
//   appender) will result in an error, since such plugins must be
//   present in the state to work.
//
//   dispatchTransaction:: ?(tr: Transaction)
//   The callback over which to send transactions (state updates)
//   produced by the view. If you specify this, you probably want to
//   make sure this ends up calling the view's
//   [`updateState`](#view.EditorView.updateState) method with a new
//   state that has the transaction
//   [applied](#state.EditorState.apply). The callback will be bound to have
//   the view instance as its `this` binding.


//# sourceMappingURL=index.es.js.map


/***/ }),

/***/ "./node_modules/rope-sequence/dist/index.es.js":
/*!*****************************************************!*\
  !*** ./node_modules/rope-sequence/dist/index.es.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var GOOD_LEAF_SIZE = 200;

// :: class<T> A rope sequence is a persistent sequence data structure
// that supports appending, prepending, and slicing without doing a
// full copy. It is represented as a mostly-balanced tree.
var RopeSequence = function RopeSequence () {};

RopeSequence.prototype.append = function append (other) {
  if (!other.length) { return this }
  other = RopeSequence.from(other);

  return (!this.length && other) ||
    (other.length < GOOD_LEAF_SIZE && this.leafAppend(other)) ||
    (this.length < GOOD_LEAF_SIZE && other.leafPrepend(this)) ||
    this.appendInner(other)
};

// :: (union<[T], RopeSequence<T>>) → RopeSequence<T>
// Prepend an array or other rope to this one, returning a new rope.
RopeSequence.prototype.prepend = function prepend (other) {
  if (!other.length) { return this }
  return RopeSequence.from(other).append(this)
};

RopeSequence.prototype.appendInner = function appendInner (other) {
  return new Append(this, other)
};

// :: (?number, ?number) → RopeSequence<T>
// Create a rope repesenting a sub-sequence of this rope.
RopeSequence.prototype.slice = function slice (from, to) {
    if ( from === void 0 ) from = 0;
    if ( to === void 0 ) to = this.length;

  if (from >= to) { return RopeSequence.empty }
  return this.sliceInner(Math.max(0, from), Math.min(this.length, to))
};

// :: (number) → T
// Retrieve the element at the given position from this rope.
RopeSequence.prototype.get = function get (i) {
  if (i < 0 || i >= this.length) { return undefined }
  return this.getInner(i)
};

// :: ((element: T, index: number) → ?bool, ?number, ?number)
// Call the given function for each element between the given
// indices. This tends to be more efficient than looping over the
// indices and calling `get`, because it doesn't have to descend the
// tree for every element.
RopeSequence.prototype.forEach = function forEach (f, from, to) {
    if ( from === void 0 ) from = 0;
    if ( to === void 0 ) to = this.length;

  if (from <= to)
    { this.forEachInner(f, from, to, 0); }
  else
    { this.forEachInvertedInner(f, from, to, 0); }
};

// :: ((element: T, index: number) → U, ?number, ?number) → [U]
// Map the given functions over the elements of the rope, producing
// a flat array.
RopeSequence.prototype.map = function map (f, from, to) {
    if ( from === void 0 ) from = 0;
    if ( to === void 0 ) to = this.length;

  var result = [];
  this.forEach(function (elt, i) { return result.push(f(elt, i)); }, from, to);
  return result
};

// :: (?union<[T], RopeSequence<T>>) → RopeSequence<T>
// Create a rope representing the given array, or return the rope
// itself if a rope was given.
RopeSequence.from = function from (values) {
  if (values instanceof RopeSequence) { return values }
  return values && values.length ? new Leaf(values) : RopeSequence.empty
};

var Leaf = /*@__PURE__*/(function (RopeSequence) {
  function Leaf(values) {
    RopeSequence.call(this);
    this.values = values;
  }

  if ( RopeSequence ) Leaf.__proto__ = RopeSequence;
  Leaf.prototype = Object.create( RopeSequence && RopeSequence.prototype );
  Leaf.prototype.constructor = Leaf;

  var prototypeAccessors = { length: { configurable: true },depth: { configurable: true } };

  Leaf.prototype.flatten = function flatten () {
    return this.values
  };

  Leaf.prototype.sliceInner = function sliceInner (from, to) {
    if (from == 0 && to == this.length) { return this }
    return new Leaf(this.values.slice(from, to))
  };

  Leaf.prototype.getInner = function getInner (i) {
    return this.values[i]
  };

  Leaf.prototype.forEachInner = function forEachInner (f, from, to, start) {
    for (var i = from; i < to; i++)
      { if (f(this.values[i], start + i) === false) { return false } }
  };

  Leaf.prototype.forEachInvertedInner = function forEachInvertedInner (f, from, to, start) {
    for (var i = from - 1; i >= to; i--)
      { if (f(this.values[i], start + i) === false) { return false } }
  };

  Leaf.prototype.leafAppend = function leafAppend (other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE)
      { return new Leaf(this.values.concat(other.flatten())) }
  };

  Leaf.prototype.leafPrepend = function leafPrepend (other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE)
      { return new Leaf(other.flatten().concat(this.values)) }
  };

  prototypeAccessors.length.get = function () { return this.values.length };

  prototypeAccessors.depth.get = function () { return 0 };

  Object.defineProperties( Leaf.prototype, prototypeAccessors );

  return Leaf;
}(RopeSequence));

// :: RopeSequence
// The empty rope sequence.
RopeSequence.empty = new Leaf([]);

var Append = /*@__PURE__*/(function (RopeSequence) {
  function Append(left, right) {
    RopeSequence.call(this);
    this.left = left;
    this.right = right;
    this.length = left.length + right.length;
    this.depth = Math.max(left.depth, right.depth) + 1;
  }

  if ( RopeSequence ) Append.__proto__ = RopeSequence;
  Append.prototype = Object.create( RopeSequence && RopeSequence.prototype );
  Append.prototype.constructor = Append;

  Append.prototype.flatten = function flatten () {
    return this.left.flatten().concat(this.right.flatten())
  };

  Append.prototype.getInner = function getInner (i) {
    return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length)
  };

  Append.prototype.forEachInner = function forEachInner (f, from, to, start) {
    var leftLen = this.left.length;
    if (from < leftLen &&
        this.left.forEachInner(f, from, Math.min(to, leftLen), start) === false)
      { return false }
    if (to > leftLen &&
        this.right.forEachInner(f, Math.max(from - leftLen, 0), Math.min(this.length, to) - leftLen, start + leftLen) === false)
      { return false }
  };

  Append.prototype.forEachInvertedInner = function forEachInvertedInner (f, from, to, start) {
    var leftLen = this.left.length;
    if (from > leftLen &&
        this.right.forEachInvertedInner(f, from - leftLen, Math.max(to, leftLen) - leftLen, start + leftLen) === false)
      { return false }
    if (to < leftLen &&
        this.left.forEachInvertedInner(f, Math.min(from, leftLen), to, start) === false)
      { return false }
  };

  Append.prototype.sliceInner = function sliceInner (from, to) {
    if (from == 0 && to == this.length) { return this }
    var leftLen = this.left.length;
    if (to <= leftLen) { return this.left.slice(from, to) }
    if (from >= leftLen) { return this.right.slice(from - leftLen, to - leftLen) }
    return this.left.slice(from, leftLen).append(this.right.slice(0, to - leftLen))
  };

  Append.prototype.leafAppend = function leafAppend (other) {
    var inner = this.right.leafAppend(other);
    if (inner) { return new Append(this.left, inner) }
  };

  Append.prototype.leafPrepend = function leafPrepend (other) {
    var inner = this.left.leafPrepend(other);
    if (inner) { return new Append(inner, this.right) }
  };

  Append.prototype.appendInner = function appendInner (other) {
    if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1)
      { return new Append(this.left, new Append(this.right, other)) }
    return new Append(this, other)
  };

  return Append;
}(RopeSequence));

var ropeSequence = RopeSequence;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ropeSequence);


/***/ }),

/***/ "./demo/index.ts":
/*!***********************!*\
  !*** ./demo/index.ts ***!
  \***********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* eslint-disable import/no-extraneous-dependencies */
const prosemirror_state_1 = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.es.js");
const prosemirror_view_1 = __webpack_require__(/*! prosemirror-view */ "./node_modules/prosemirror-view/dist/index.es.js");
const prosemirror_model_1 = __webpack_require__(/*! prosemirror-model */ "./node_modules/prosemirror-model/dist/index.es.js");
const prosemirror_schema_basic_1 = __webpack_require__(/*! prosemirror-schema-basic */ "./node_modules/prosemirror-schema-basic/dist/index.es.js");
const prosemirror_example_setup_1 = __webpack_require__(/*! prosemirror-example-setup */ "./node_modules/prosemirror-example-setup/dist/index.es.js");
const src_1 = __importDefault(__webpack_require__(/*! ../src */ "./src/index.ts"));
const reducer_1 = __webpack_require__(/*! ./reducer */ "./demo/reducer.ts");
const editor = document.querySelector('#editor');
const content = document.querySelector('#content');
const options = {
    reducer: reducer_1.reducer,
    triggers: [
        // For demo purposes, make the `#` and `@` easier to create
        { name: 'hashtag', trigger: /(#)$/ },
        { name: 'mention', trigger: /(@)$/ },
        { name: 'emoji', trigger: ':' },
        { name: 'link', trigger: '[[', cancelOnFirstSpace: false },
        { name: 'jinja', trigger: '{{', cancelOnFirstSpace: false },
        { name: 'command', trigger: '/', decorationAttrs: { class: 'command' } },
        { name: 'variable', trigger: /((?:^[a-zA-Z0-9_]+)\s?=)$/, cancelOnFirstSpace: false },
        { name: 'code', trigger: /((?:[a-zA-Z0-9_]+)\.)$/ },
    ],
};
window.view = new prosemirror_view_1.EditorView(editor, {
    state: prosemirror_state_1.EditorState.create({
        doc: prosemirror_model_1.DOMParser.fromSchema(prosemirror_schema_basic_1.schema).parse(content),
        plugins: [...(0, src_1.default)(options), ...(0, prosemirror_example_setup_1.exampleSetup)({ schema: prosemirror_schema_basic_1.schema, menuBar: false })],
    }),
});


/***/ }),

/***/ "./demo/reducer.ts":
/*!*************************!*\
  !*** ./demo/reducer.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.reducer = void 0;
const src_1 = __webpack_require__(/*! ../src */ "./src/index.ts");
const actions_1 = __webpack_require__(/*! ../src/actions */ "./src/actions.ts");
const suggestion = document.querySelector('#suggestion');
const info = document.querySelector('#info');
const picker = {
    view: null,
    open: false,
    current: 0,
    range: null,
};
const NUM_SUGGESTIONS = suggestion.children.length;
function setInfo(action) {
    var _a;
    info.innerText = `Action: ${action.kind}, Range: ${action.range.from}-${action.range.to}, Filter: ${action.filter}, Trigger: ${action.trigger}, Type: ${(_a = action.type) === null || _a === void 0 ? void 0 : _a.name}`;
}
function placeSuggestion() {
    var _a;
    suggestion.style.display = picker.open ? 'block' : 'none';
    const rect = (_a = document.getElementById(src_1.DEFAULT_ID)) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect();
    if (!rect)
        return;
    suggestion.style.top = `${rect.top + rect.height}px`;
    suggestion.style.left = `${rect.left}px`;
    [].forEach.call(suggestion.children, (item, i) => {
        item.classList[i === picker.current ? 'add' : 'remove']('selected');
    });
}
function reducer(action) {
    var _a;
    picker.view = action.view;
    setInfo(action);
    switch (action.kind) {
        case src_1.ActionKind.open:
            picker.current = 0;
            picker.open = true;
            picker.range = action.range;
            placeSuggestion();
            return true;
        case src_1.ActionKind.close:
            picker.open = false;
            placeSuggestion();
            return true;
        case src_1.ActionKind.up:
            picker.current -= 1;
            picker.current += NUM_SUGGESTIONS; // negative modulus doesn't work
            picker.current %= NUM_SUGGESTIONS;
            placeSuggestion();
            return true;
        case src_1.ActionKind.down:
            picker.current += 1;
            picker.current %= NUM_SUGGESTIONS;
            placeSuggestion();
            return true;
        case src_1.ActionKind.enter: {
            const tr = action.view.state.tr
                .deleteRange(action.range.from, action.range.to)
                .insertText(`You can define this ${action.type ? `${(_a = action.type) === null || _a === void 0 ? void 0 : _a.name} ` : ''}action!`);
            action.view.dispatch(tr);
            return true;
        }
        default:
            return false;
    }
}
exports.reducer = reducer;
[].forEach.call(suggestion.children, (item, i) => {
    item.addEventListener('click', () => {
        if (!picker.view)
            return;
        (0, actions_1.closeAutocomplete)(picker.view);
        picker.open = false;
        placeSuggestion();
        if (!picker.range)
            return;
        const tr = picker.view.state.tr
            .deleteRange(picker.range.from, picker.range.to)
            .insertText(`Clicked on ${i + 1}`);
        picker.view.dispatch(tr);
        picker.view.focus();
    });
});


/***/ }),

/***/ "./src/actions.ts":
/*!************************!*\
  !*** ./src/actions.ts ***!
  \************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.closeAutocomplete = exports.openAutocomplete = void 0;
const utils_1 = __webpack_require__(/*! ./utils */ "./src/utils.ts");
function openAutocomplete(view, trigger, filter) {
    // TODO: Can activate a type?
    const plugin = utils_1.pluginKey.get(view.state);
    const meta = { action: 'add', trigger, filter, type: null };
    const tr = view.state.tr
        .insertText(`${trigger}${filter !== null && filter !== void 0 ? filter : ''}`)
        .scrollIntoView()
        .setMeta(plugin, meta);
    view.dispatch(tr);
}
exports.openAutocomplete = openAutocomplete;
function closeAutocomplete(view) {
    const plugin = utils_1.pluginKey.get(view.state);
    const meta = { action: 'remove' };
    const tr = view.state.tr.setMeta(plugin, meta);
    view.dispatch(tr);
    return true;
}
exports.closeAutocomplete = closeAutocomplete;


/***/ }),

/***/ "./src/decoration.ts":
/*!***************************!*\
  !*** ./src/decoration.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getDecorationPlugin = void 0;
const prosemirror_inputrules_1 = __webpack_require__(/*! prosemirror-inputrules */ "./node_modules/prosemirror-inputrules/dist/index.es.js");
const prosemirror_state_1 = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.es.js");
const prosemirror_view_1 = __webpack_require__(/*! prosemirror-view */ "./node_modules/prosemirror-view/dist/index.es.js");
const actions_1 = __webpack_require__(/*! ./actions */ "./src/actions.ts");
const types_1 = __webpack_require__(/*! ./types */ "./src/types.ts");
const utils_1 = __webpack_require__(/*! ./utils */ "./src/utils.ts");
const inactiveSuggestionState = {
    active: false,
    decorations: prosemirror_view_1.DecorationSet.empty,
};
function actionFromEvent(event) {
    switch (event.key) {
        case 'ArrowUp':
        case 'ArrowDown':
        case 'ArrowLeft':
        case 'ArrowRight':
            return event.key;
        case 'Tab':
        case 'Enter':
            return types_1.ActionKind.enter;
        case 'Escape':
            return types_1.ActionKind.close;
        default:
            return null;
    }
}
function cancelIfInsideAndPass(view) {
    const plugin = utils_1.pluginKey.get(view.state);
    const { decorations } = plugin.getState(view.state);
    if ((0, utils_1.inSuggestion)(view.state.selection, decorations)) {
        (0, actions_1.closeAutocomplete)(view);
    }
    return false;
}
function getDecorationPlugin(reducer) {
    const plugin = new prosemirror_state_1.Plugin({
        key: utils_1.pluginKey,
        view() {
            return {
                update: (view, prevState) => {
                    var _a, _b, _c, _d;
                    const prev = plugin.getState(prevState);
                    const next = plugin.getState(view.state);
                    const started = !prev.active && next.active;
                    const stopped = prev.active && !next.active;
                    const changed = next.active && !started && !stopped && prev.filter !== next.filter;
                    const action = {
                        view,
                        trigger: (_a = next.trigger) !== null && _a !== void 0 ? _a : prev.trigger,
                        filter: (_b = next.filter) !== null && _b !== void 0 ? _b : prev.filter,
                        range: (_c = next.range) !== null && _c !== void 0 ? _c : prev.range,
                        type: (_d = next.type) !== null && _d !== void 0 ? _d : prev.type,
                    };
                    if (started)
                        reducer(Object.assign(Object.assign({}, action), { kind: types_1.ActionKind.open }));
                    if (changed)
                        reducer(Object.assign(Object.assign({}, action), { kind: types_1.ActionKind.filter }));
                    if (stopped)
                        reducer(Object.assign(Object.assign({}, action), { kind: types_1.ActionKind.close }));
                },
            };
        },
        state: {
            init: () => (Object.assign({}, inactiveSuggestionState)),
            apply(tr, state) {
                var _a;
                const meta = tr.getMeta(plugin);
                if ((meta === null || meta === void 0 ? void 0 : meta.action) === 'add') {
                    const { trigger, filter, type } = meta;
                    const from = tr.selection.from - trigger.length - ((_a = filter === null || filter === void 0 ? void 0 : filter.length) !== null && _a !== void 0 ? _a : 0);
                    const to = tr.selection.from;
                    const attrs = Object.assign(Object.assign({}, utils_1.DEFAULT_DECO_ATTRS), type === null || type === void 0 ? void 0 : type.decorationAttrs);
                    const deco = prosemirror_view_1.Decoration.inline(from, to, attrs, {
                        inclusiveStart: false,
                        inclusiveEnd: true,
                    });
                    return {
                        active: true,
                        trigger: meta.trigger,
                        decorations: prosemirror_view_1.DecorationSet.create(tr.doc, [deco]),
                        filter: filter !== null && filter !== void 0 ? filter : '',
                        range: { from, to },
                        type,
                    };
                }
                const { decorations } = state;
                const nextDecorations = decorations.map(tr.mapping, tr.doc);
                const hasDecoration = nextDecorations.find().length > 0;
                // If no decoration, explicitly remove, or click somewhere else in the editor
                if ((meta === null || meta === void 0 ? void 0 : meta.action) === 'remove' ||
                    !(0, utils_1.inSuggestion)(tr.selection, nextDecorations) ||
                    !hasDecoration)
                    return inactiveSuggestionState;
                const { active, trigger, type } = state;
                // Ensure that the trigger is in the decoration
                const { from, to } = nextDecorations.find()[0];
                const text = tr.doc.textBetween(from, to);
                if (!text.startsWith(trigger))
                    return inactiveSuggestionState;
                return {
                    active,
                    trigger,
                    decorations: nextDecorations,
                    filter: text.slice(trigger.length),
                    range: { from, to },
                    type,
                };
            },
        },
        props: {
            decorations: (state) => plugin.getState(state).decorations,
            handlePaste: (view) => cancelIfInsideAndPass(view),
            handleDrop: (view) => cancelIfInsideAndPass(view),
            handleKeyDown(view, event) {
                var _a, _b;
                const { trigger, active, decorations, type } = plugin.getState(view.state);
                if (!active || !(0, utils_1.inSuggestion)(view.state.selection, decorations))
                    return false;
                const { from, to } = decorations.find()[0];
                const text = view.state.doc.textBetween(from, to);
                // Be defensive, just in case the trigger doesn't exist
                const filter = text.slice((_a = trigger === null || trigger === void 0 ? void 0 : trigger.length) !== null && _a !== void 0 ? _a : 1);
                const checkCancelOnSpace = (_b = type === null || type === void 0 ? void 0 : type.cancelOnFirstSpace) !== null && _b !== void 0 ? _b : true;
                if (checkCancelOnSpace &&
                    filter.length === 0 &&
                    (event.key === ' ' || event.key === 'Spacebar')) {
                    (0, actions_1.closeAutocomplete)(view);
                    // Take over the space creation so no other input rules are fired
                    view.dispatch(view.state.tr.insertText(' ').scrollIntoView());
                    return true;
                }
                if (filter.length === 0 && event.key === 'Backspace') {
                    (0, prosemirror_inputrules_1.undoInputRule)(view.state, view.dispatch);
                    (0, actions_1.closeAutocomplete)(view);
                    return true;
                }
                const kind = actionFromEvent(event);
                const action = {
                    view,
                    trigger,
                    filter,
                    range: { from, to },
                    type,
                };
                switch (kind) {
                    case types_1.ActionKind.close:
                        // The user action will be handled in the view code above
                        // Allows clicking off to be handled in the same way
                        return (0, actions_1.closeAutocomplete)(view);
                    case types_1.ActionKind.enter: {
                        // Only trigger the cancel if it is not expliticly handled in the select
                        const result = reducer(Object.assign(Object.assign({}, action), { kind: types_1.ActionKind.enter }));
                        if (result === types_1.KEEP_OPEN)
                            return true;
                        return result || (0, actions_1.closeAutocomplete)(view);
                    }
                    case types_1.ActionKind.up:
                    case types_1.ActionKind.down:
                        return Boolean(reducer(Object.assign(Object.assign({}, action), { kind })));
                    case types_1.ActionKind.left:
                    case types_1.ActionKind.right:
                        if (!(type === null || type === void 0 ? void 0 : type.allArrowKeys))
                            return false;
                        return Boolean(reducer(Object.assign(Object.assign({}, action), { kind })));
                    default:
                        break;
                }
                return false;
            },
        },
    });
    return plugin;
}
exports.getDecorationPlugin = getDecorationPlugin;


/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const plugin_1 = __webpack_require__(/*! ./plugin */ "./src/plugin.ts");
__exportStar(__webpack_require__(/*! ./types */ "./src/types.ts"), exports);
__exportStar(__webpack_require__(/*! ./utils */ "./src/utils.ts"), exports);
__exportStar(__webpack_require__(/*! ./plugin */ "./src/plugin.ts"), exports);
__exportStar(__webpack_require__(/*! ./actions */ "./src/actions.ts"), exports);
exports["default"] = plugin_1.autocomplete;


/***/ }),

/***/ "./src/inputRules.ts":
/*!***************************!*\
  !*** ./src/inputRules.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createInputRule = void 0;
const prosemirror_inputrules_1 = __webpack_require__(/*! prosemirror-inputrules */ "./node_modules/prosemirror-inputrules/dist/index.es.js");
const utils_1 = __webpack_require__(/*! ./utils */ "./src/utils.ts");
function createInputRule(plugin, type) {
    const trigger = typeof type.trigger === 'string'
        ? RegExp(`(?:^|\\s|\\n|[^\\d\\w])(${type.trigger.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})$`)
        : type.trigger;
    return new prosemirror_inputrules_1.InputRule(trigger, (state, match) => {
        const { decorations } = plugin.getState(state);
        // If we are currently suggesting, don't activate
        if ((0, utils_1.inSuggestion)(state.selection, decorations))
            return null;
        // We are taking over the text input here
        const tr = state.tr.insertText(match[1][match[1].length - 1]).scrollIntoView();
        const meta = { action: 'add', trigger: match[1], type };
        tr.setMeta(plugin, meta);
        return tr;
    });
}
exports.createInputRule = createInputRule;


/***/ }),

/***/ "./src/plugin.ts":
/*!***********************!*\
  !*** ./src/plugin.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.autocomplete = exports.defaultReducer = void 0;
const prosemirror_inputrules_1 = __webpack_require__(/*! prosemirror-inputrules */ "./node_modules/prosemirror-inputrules/dist/index.es.js");
const types_1 = __webpack_require__(/*! ./types */ "./src/types.ts");
const decoration_1 = __webpack_require__(/*! ./decoration */ "./src/decoration.ts");
const inputRules_1 = __webpack_require__(/*! ./inputRules */ "./src/inputRules.ts");
function defaultReducer(options) {
    return (action) => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        switch (action.kind) {
            case types_1.ActionKind.open:
                return (_b = (_a = options.onOpen) === null || _a === void 0 ? void 0 : _a.call(options, action)) !== null && _b !== void 0 ? _b : false;
            case types_1.ActionKind.close:
                return (_d = (_c = options.onClose) === null || _c === void 0 ? void 0 : _c.call(options, action)) !== null && _d !== void 0 ? _d : false;
            case types_1.ActionKind.up:
            case types_1.ActionKind.down:
            case types_1.ActionKind.left:
            case types_1.ActionKind.right:
                return (_f = (_e = options.onArrow) === null || _e === void 0 ? void 0 : _e.call(options, action)) !== null && _f !== void 0 ? _f : false;
            case types_1.ActionKind.filter:
                return (_h = (_g = options.onFilter) === null || _g === void 0 ? void 0 : _g.call(options, action)) !== null && _h !== void 0 ? _h : false;
            case types_1.ActionKind.enter:
                return (_k = (_j = options.onEnter) === null || _j === void 0 ? void 0 : _j.call(options, action)) !== null && _k !== void 0 ? _k : false;
            default:
                return false;
        }
    };
}
exports.defaultReducer = defaultReducer;
function autocomplete(opts = {}) {
    const options = Object.assign({ triggers: [], reducer: defaultReducer(opts) }, opts);
    const { reducer, triggers } = options;
    const plugin = (0, decoration_1.getDecorationPlugin)(reducer);
    const rules = [
        plugin,
        (0, prosemirror_inputrules_1.inputRules)({
            // Create an input rule for each trigger
            rules: triggers.map((type) => (0, inputRules_1.createInputRule)(plugin, type)),
        }),
    ];
    return rules;
}
exports.autocomplete = autocomplete;


/***/ }),

/***/ "./src/types.ts":
/*!**********************!*\
  !*** ./src/types.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActionKind = exports.KEEP_OPEN = void 0;
exports.KEEP_OPEN = 'KEEP_OPEN';
var ActionKind;
(function (ActionKind) {
    ActionKind["open"] = "open";
    ActionKind["close"] = "close";
    ActionKind["filter"] = "filter";
    ActionKind["up"] = "ArrowUp";
    ActionKind["down"] = "ArrowDown";
    ActionKind["left"] = "ArrowLeft";
    ActionKind["right"] = "ArrowRight";
    ActionKind["enter"] = "enter";
})(ActionKind = exports.ActionKind || (exports.ActionKind = {}));


/***/ }),

/***/ "./src/utils.ts":
/*!**********************!*\
  !*** ./src/utils.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.inSuggestion = exports.pluginKey = exports.DEFAULT_DECO_ATTRS = exports.DEFAULT_ID = void 0;
const prosemirror_state_1 = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.es.js");
exports.DEFAULT_ID = 'autocomplete';
exports.DEFAULT_DECO_ATTRS = { id: exports.DEFAULT_ID, class: exports.DEFAULT_ID };
exports.pluginKey = new prosemirror_state_1.PluginKey(exports.DEFAULT_ID);
function inSuggestion(selection, decorations) {
    return decorations.find(selection.from, selection.to).length > 0;
}
exports.inSuggestion = inSuggestion;


/***/ }),

/***/ "./node_modules/crelt/index.es.js":
/*!****************************************!*\
  !*** ./node_modules/crelt/index.es.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ crelt)
/* harmony export */ });
function crelt() {
  var elt = arguments[0]
  if (typeof elt == "string") elt = document.createElement(elt)
  var i = 1, next = arguments[1]
  if (next && typeof next == "object" && next.nodeType == null && !Array.isArray(next)) {
    for (var name in next) if (Object.prototype.hasOwnProperty.call(next, name)) {
      var value = next[name]
      if (typeof value == "string") elt.setAttribute(name, value)
      else if (value != null) elt[name] = value
    }
    i++
  }
  for (; i < arguments.length; i++) add(elt, arguments[i])
  return elt
}

function add(elt, child) {
  if (typeof child == "string") {
    elt.appendChild(document.createTextNode(child))
  } else if (child == null) {
  } else if (child.nodeType != null) {
    elt.appendChild(child)
  } else if (Array.isArray(child)) {
    for (var i = 0; i < child.length; i++) add(elt, child[i])
  } else {
    throw new RangeError("Unsupported child node: " + child)
  }
}


/***/ }),

/***/ "./node_modules/w3c-keyname/index.es.js":
/*!**********************************************!*\
  !*** ./node_modules/w3c-keyname/index.es.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "base": () => (/* binding */ base),
/* harmony export */   "keyName": () => (/* binding */ keyName)
/* harmony export */ });
/* unused harmony export shift */
var base = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'",
  229: "q"
}

var shift = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: "\"",
  229: "Q"
}

var chrome = typeof navigator != "undefined" && /Chrome\/(\d+)/.exec(navigator.userAgent)
var safari = typeof navigator != "undefined" && /Apple Computer/.test(navigator.vendor)
var gecko = typeof navigator != "undefined" && /Gecko\/\d+/.test(navigator.userAgent)
var mac = typeof navigator != "undefined" && /Mac/.test(navigator.platform)
var ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent)
var brokenModifierNames = chrome && (mac || +chrome[1] < 57) || gecko && mac

// Fill in the digit keys
for (var i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i)

// The function keys
for (var i = 1; i <= 24; i++) base[i + 111] = "F" + i

// And the alphabetic keys
for (var i = 65; i <= 90; i++) {
  base[i] = String.fromCharCode(i + 32)
  shift[i] = String.fromCharCode(i)
}

// For each code that doesn't have a shift-equivalent, copy the base name
for (var code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code]

function keyName(event) {
  // Don't trust event.key in Chrome when there are modifiers until
  // they fix https://bugs.chromium.org/p/chromium/issues/detail?id=633838
  var ignoreKey = brokenModifierNames && (event.ctrlKey || event.altKey || event.metaKey) ||
    (safari || ie) && event.shiftKey && event.key && event.key.length == 1
  var name = (!ignoreKey && event.key) ||
    (event.shiftKey ? shift : base)[event.keyCode] ||
    event.key || "Unidentified"
  // Edge sometimes produces wrong names (Issue #3)
  if (name == "Esc") name = "Escape"
  if (name == "Del") name = "Delete"
  // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/
  if (name == "Left") name = "ArrowLeft"
  if (name == "Up") name = "ArrowUp"
  if (name == "Right") name = "ArrowRight"
  if (name == "Down") name = "ArrowDown"
  return name
}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./demo/index.ts");
/******/ 	
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQixPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQyxNQUFNLDJCQUEyQjtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaURBQWlEOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3REFBd0Q7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkIsUUFBUSxvQkFBb0IsV0FBVzs7QUFFcEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx5REFBeUQ7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MseURBQXlEO0FBQzdGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW1MO0FBQ25MOzs7Ozs7Ozs7Ozs7OztBQzV6S0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUI7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQyxnQ0FBZ0M7QUFDbkU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDZCQUE2QixVQUFVLG9CQUFvQixVQUFVOztBQUVyRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQixRQUFRLDhDQUE4QztBQUN0RDs7QUFFQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDLFFBQVEsOENBQThDO0FBQ3REOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQSxnREFBZ0Q7O0FBRWhELCtDQUErQzs7QUFFL0M7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBLHlCQUF5QjtBQUN6QiwyQkFBMkI7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxpRUFBZSxZQUFZLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoTjVCLHNEQUFzRDtBQUN0RCw4SEFBZ0Q7QUFDaEQsMkhBQThDO0FBQzlDLDhIQUE4QztBQUM5QyxtSkFBa0Q7QUFDbEQsc0pBQXlEO0FBQ3pELG1GQUErQztBQUMvQyw0RUFBb0M7QUFFcEMsTUFBTSxNQUFNLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxTQUFTLENBQW1CLENBQUM7QUFDbkUsTUFBTSxPQUFPLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxVQUFVLENBQW1CLENBQUM7QUFFckUsTUFBTSxPQUFPLEdBQVk7SUFDdkIsT0FBTyxFQUFQLGlCQUFPO0lBQ1AsUUFBUSxFQUFFO1FBQ1IsMkRBQTJEO1FBQzNELEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxPQUFPLEVBQUUsTUFBTSxFQUFFO1FBQ3BDLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxPQUFPLEVBQUUsTUFBTSxFQUFFO1FBQ3BDLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUUsR0FBRyxFQUFFO1FBQy9CLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLGtCQUFrQixFQUFFLEtBQUssRUFBRTtRQUMxRCxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxrQkFBa0IsRUFBRSxLQUFLLEVBQUU7UUFDM0QsRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLE9BQU8sRUFBRSxHQUFHLEVBQUUsZUFBZSxFQUFFLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRSxFQUFFO1FBQ3hFLEVBQUUsSUFBSSxFQUFFLFVBQVUsRUFBRSxPQUFPLEVBQUUsMkJBQTJCLEVBQUUsa0JBQWtCLEVBQUUsS0FBSyxFQUFFO1FBQ3JGLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxPQUFPLEVBQUUsd0JBQXdCLEVBQUU7S0FDcEQ7Q0FDRixDQUFDO0FBRUQsTUFBYyxDQUFDLElBQUksR0FBRyxJQUFJLDZCQUFVLENBQUMsTUFBTSxFQUFFO0lBQzVDLEtBQUssRUFBRSwrQkFBVyxDQUFDLE1BQU0sQ0FBQztRQUN4QixHQUFHLEVBQUUsNkJBQVMsQ0FBQyxVQUFVLENBQUMsaUNBQU0sQ0FBQyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUM7UUFDaEQsT0FBTyxFQUFFLENBQUMsR0FBRyxpQkFBWSxFQUFDLE9BQU8sQ0FBQyxFQUFFLEdBQUcsNENBQVksRUFBQyxFQUFFLE1BQU0sRUFBTixpQ0FBTSxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsQ0FBQyxDQUFDO0tBQ2pGLENBQUM7Q0FDSCxDQUFDLENBQUM7Ozs7Ozs7Ozs7Ozs7O0FDL0JILGtFQUE0RTtBQUM1RSxnRkFBbUQ7QUFFbkQsTUFBTSxVQUFVLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxhQUFhLENBQW1CLENBQUM7QUFDM0UsTUFBTSxJQUFJLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQW1CLENBQUM7QUFFL0QsTUFBTSxNQUFNLEdBQUc7SUFDYixJQUFJLEVBQUUsSUFBeUI7SUFDL0IsSUFBSSxFQUFFLEtBQUs7SUFDWCxPQUFPLEVBQUUsQ0FBQztJQUNWLEtBQUssRUFBRSxJQUFxQjtDQUM3QixDQUFDO0FBRUYsTUFBTSxlQUFlLEdBQUcsVUFBVSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUM7QUFFbkQsU0FBUyxPQUFPLENBQUMsTUFBMEI7O0lBQ3pDLElBQUksQ0FBQyxTQUFTLEdBQUcsV0FBVyxNQUFNLENBQUMsSUFBSSxZQUFZLE1BQU0sQ0FBQyxLQUFLLENBQUMsSUFBSSxJQUFJLE1BQU0sQ0FBQyxLQUFLLENBQUMsRUFBRSxhQUFhLE1BQU0sQ0FBQyxNQUFNLGNBQWMsTUFBTSxDQUFDLE9BQU8sV0FBVyxZQUFNLENBQUMsSUFBSSwwQ0FBRSxJQUFJLEVBQUUsQ0FBQztBQUM5SyxDQUFDO0FBRUQsU0FBUyxlQUFlOztJQUN0QixVQUFVLENBQUMsS0FBSyxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQztJQUMxRCxNQUFNLElBQUksR0FBRyxjQUFRLENBQUMsY0FBYyxDQUFDLGdCQUFVLENBQUMsMENBQUUscUJBQXFCLEVBQUUsQ0FBQztJQUMxRSxJQUFJLENBQUMsSUFBSTtRQUFFLE9BQU87SUFDbEIsVUFBVSxDQUFDLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLElBQUksQ0FBQztJQUNyRCxVQUFVLENBQUMsS0FBSyxDQUFDLElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxJQUFJLElBQUksQ0FBQztJQUN6QyxFQUFFLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsUUFBUSxFQUFFLENBQUMsSUFBb0IsRUFBRSxDQUFDLEVBQUUsRUFBRTtRQUMvRCxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsS0FBSyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQ3RFLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQztBQUVELFNBQWdCLE9BQU8sQ0FBQyxNQUEwQjs7SUFDaEQsTUFBTSxDQUFDLElBQUksR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDO0lBQzFCLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNoQixRQUFRLE1BQU0sQ0FBQyxJQUFJLEVBQUU7UUFDbkIsS0FBSyxnQkFBVSxDQUFDLElBQUk7WUFDbEIsTUFBTSxDQUFDLE9BQU8sR0FBRyxDQUFDLENBQUM7WUFDbkIsTUFBTSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7WUFDbkIsTUFBTSxDQUFDLEtBQUssR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDO1lBQzVCLGVBQWUsRUFBRSxDQUFDO1lBQ2xCLE9BQU8sSUFBSSxDQUFDO1FBQ2QsS0FBSyxnQkFBVSxDQUFDLEtBQUs7WUFDbkIsTUFBTSxDQUFDLElBQUksR0FBRyxLQUFLLENBQUM7WUFDcEIsZUFBZSxFQUFFLENBQUM7WUFDbEIsT0FBTyxJQUFJLENBQUM7UUFDZCxLQUFLLGdCQUFVLENBQUMsRUFBRTtZQUNoQixNQUFNLENBQUMsT0FBTyxJQUFJLENBQUMsQ0FBQztZQUNwQixNQUFNLENBQUMsT0FBTyxJQUFJLGVBQWUsQ0FBQyxDQUFDLGdDQUFnQztZQUNuRSxNQUFNLENBQUMsT0FBTyxJQUFJLGVBQWUsQ0FBQztZQUNsQyxlQUFlLEVBQUUsQ0FBQztZQUNsQixPQUFPLElBQUksQ0FBQztRQUNkLEtBQUssZ0JBQVUsQ0FBQyxJQUFJO1lBQ2xCLE1BQU0sQ0FBQyxPQUFPLElBQUksQ0FBQyxDQUFDO1lBQ3BCLE1BQU0sQ0FBQyxPQUFPLElBQUksZUFBZSxDQUFDO1lBQ2xDLGVBQWUsRUFBRSxDQUFDO1lBQ2xCLE9BQU8sSUFBSSxDQUFDO1FBQ2QsS0FBSyxnQkFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ3JCLE1BQU0sRUFBRSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUU7aUJBQzVCLFdBQVcsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQztpQkFDL0MsVUFBVSxDQUFDLHVCQUF1QixNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLFlBQU0sQ0FBQyxJQUFJLDBDQUFFLElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxDQUFDO1lBQzFGLE1BQU0sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBQ3pCLE9BQU8sSUFBSSxDQUFDO1NBQ2I7UUFDRDtZQUNFLE9BQU8sS0FBSyxDQUFDO0tBQ2hCO0FBQ0gsQ0FBQztBQW5DRCwwQkFtQ0M7QUFFRCxFQUFFLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsUUFBUSxFQUFFLENBQUMsSUFBb0IsRUFBRSxDQUFDLEVBQUUsRUFBRTtJQUMvRCxJQUFJLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLEdBQUcsRUFBRTtRQUNsQyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUk7WUFBRSxPQUFPO1FBQ3pCLCtCQUFpQixFQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUMvQixNQUFNLENBQUMsSUFBSSxHQUFHLEtBQUssQ0FBQztRQUNwQixlQUFlLEVBQUUsQ0FBQztRQUNsQixJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUs7WUFBRSxPQUFPO1FBQzFCLE1BQU0sRUFBRSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUU7YUFDNUIsV0FBVyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDO2FBQy9DLFVBQVUsQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ3JDLE1BQU0sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ3pCLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUM7SUFDdEIsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7QUM5RUgscUVBQW9DO0FBRXBDLFNBQWdCLGdCQUFnQixDQUFDLElBQWdCLEVBQUUsT0FBZSxFQUFFLE1BQWU7SUFDakYsNkJBQTZCO0lBQzdCLE1BQU0sTUFBTSxHQUFHLGlCQUFTLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQVcsQ0FBQztJQUNuRCxNQUFNLElBQUksR0FBdUIsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxDQUFDO0lBQ2hGLE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRTtTQUNyQixVQUFVLENBQUMsR0FBRyxPQUFPLEdBQUcsTUFBTSxhQUFOLE1BQU0sY0FBTixNQUFNLEdBQUksRUFBRSxFQUFFLENBQUM7U0FDdkMsY0FBYyxFQUFFO1NBQ2hCLE9BQU8sQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDekIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUNwQixDQUFDO0FBVEQsNENBU0M7QUFFRCxTQUFnQixpQkFBaUIsQ0FBQyxJQUFnQjtJQUNoRCxNQUFNLE1BQU0sR0FBRyxpQkFBUyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFXLENBQUM7SUFDbkQsTUFBTSxJQUFJLEdBQXVCLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBRSxDQUFDO0lBQ3RELE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDL0MsSUFBSSxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUNsQixPQUFPLElBQUksQ0FBQztBQUNkLENBQUM7QUFORCw4Q0FNQzs7Ozs7Ozs7Ozs7Ozs7QUN0QkQsNklBQXVEO0FBQ3ZELDhIQUEyQztBQUMzQywySEFBeUU7QUFDekUsMkVBQThDO0FBQzlDLHFFQVNpQjtBQUNqQixxRUFBc0U7QUFFdEUsTUFBTSx1QkFBdUIsR0FBc0I7SUFDakQsTUFBTSxFQUFFLEtBQUs7SUFDYixXQUFXLEVBQUUsZ0NBQWEsQ0FBQyxLQUFLO0NBQ2pDLENBQUM7QUFFRixTQUFTLGVBQWUsQ0FBQyxLQUFvQjtJQUMzQyxRQUFRLEtBQUssQ0FBQyxHQUFHLEVBQUU7UUFDakIsS0FBSyxTQUFTLENBQUM7UUFDZixLQUFLLFdBQVcsQ0FBQztRQUNqQixLQUFLLFdBQVcsQ0FBQztRQUNqQixLQUFLLFlBQVk7WUFDZixPQUFPLEtBQUssQ0FBQyxHQUFpQixDQUFDO1FBQ2pDLEtBQUssS0FBSyxDQUFDO1FBQ1gsS0FBSyxPQUFPO1lBQ1YsT0FBTyxrQkFBVSxDQUFDLEtBQUssQ0FBQztRQUMxQixLQUFLLFFBQVE7WUFDWCxPQUFPLGtCQUFVLENBQUMsS0FBSyxDQUFDO1FBQzFCO1lBQ0UsT0FBTyxJQUFJLENBQUM7S0FDZjtBQUNILENBQUM7QUFFRCxTQUFTLHFCQUFxQixDQUFDLElBQWdCO0lBQzdDLE1BQU0sTUFBTSxHQUFHLGlCQUFTLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQVcsQ0FBQztJQUNuRCxNQUFNLEVBQUUsV0FBVyxFQUFFLEdBQUcsTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDcEQsSUFBSSx3QkFBWSxFQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxFQUFFLFdBQVcsQ0FBQyxFQUFFO1FBQ25ELCtCQUFpQixFQUFDLElBQUksQ0FBQyxDQUFDO0tBQ3pCO0lBQ0QsT0FBTyxLQUFLLENBQUM7QUFDZixDQUFDO0FBRUQsU0FBZ0IsbUJBQW1CLENBQUMsT0FBcUM7SUFDdkUsTUFBTSxNQUFNLEdBQThCLElBQUksMEJBQU0sQ0FBQztRQUNuRCxHQUFHLEVBQUUsaUJBQVM7UUFDZCxJQUFJO1lBQ0YsT0FBTztnQkFDTCxNQUFNLEVBQUUsQ0FBQyxJQUFJLEVBQUUsU0FBUyxFQUFFLEVBQUU7O29CQUMxQixNQUFNLElBQUksR0FBRyxNQUFNLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBNEIsQ0FBQztvQkFDbkUsTUFBTSxJQUFJLEdBQUcsTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUE0QixDQUFDO29CQUVwRSxNQUFNLE9BQU8sR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQztvQkFDNUMsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLE1BQU0sSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUM7b0JBQzVDLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxNQUFNLElBQUksQ0FBQyxPQUFPLElBQUksQ0FBQyxPQUFPLElBQUksSUFBSSxDQUFDLE1BQU0sS0FBSyxJQUFJLENBQUMsTUFBTSxDQUFDO29CQUVuRixNQUFNLE1BQU0sR0FBcUM7d0JBQy9DLElBQUk7d0JBQ0osT0FBTyxFQUFFLFVBQUksQ0FBQyxPQUFPLG1DQUFLLElBQUksQ0FBQyxPQUFrQjt3QkFDakQsTUFBTSxFQUFFLFVBQUksQ0FBQyxNQUFNLG1DQUFJLElBQUksQ0FBQyxNQUFNO3dCQUNsQyxLQUFLLEVBQUUsVUFBSSxDQUFDLEtBQUssbUNBQUssSUFBSSxDQUFDLEtBQWdCO3dCQUMzQyxJQUFJLEVBQUUsVUFBSSxDQUFDLElBQUksbUNBQUksSUFBSSxDQUFDLElBQUk7cUJBQzdCLENBQUM7b0JBQ0YsSUFBSSxPQUFPO3dCQUFFLE9BQU8saUNBQU0sTUFBTSxLQUFFLElBQUksRUFBRSxrQkFBVSxDQUFDLElBQUksSUFBRyxDQUFDO29CQUMzRCxJQUFJLE9BQU87d0JBQUUsT0FBTyxpQ0FBTSxNQUFNLEtBQUUsSUFBSSxFQUFFLGtCQUFVLENBQUMsTUFBTSxJQUFHLENBQUM7b0JBQzdELElBQUksT0FBTzt3QkFBRSxPQUFPLGlDQUFNLE1BQU0sS0FBRSxJQUFJLEVBQUUsa0JBQVUsQ0FBQyxLQUFLLElBQUcsQ0FBQztnQkFDOUQsQ0FBQzthQUNGLENBQUM7UUFDSixDQUFDO1FBQ0QsS0FBSyxFQUFFO1lBQ0wsSUFBSSxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUMsa0JBQUssdUJBQXVCLENBQXdCO1lBQ2pFLEtBQUssQ0FBQyxFQUFFLEVBQUUsS0FBSzs7Z0JBQ2IsTUFBTSxJQUFJLEdBQUcsRUFBRSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQXVCLENBQUM7Z0JBQ3RELElBQUksS0FBSSxhQUFKLElBQUksdUJBQUosSUFBSSxDQUFFLE1BQU0sTUFBSyxLQUFLLEVBQUU7b0JBQzFCLE1BQU0sRUFBRSxPQUFPLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxHQUFHLElBQUksQ0FBQztvQkFDdkMsTUFBTSxJQUFJLEdBQUcsRUFBRSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEdBQUcsT0FBTyxDQUFDLE1BQU0sR0FBRyxDQUFDLFlBQU0sYUFBTixNQUFNLHVCQUFOLE1BQU0sQ0FBRSxNQUFNLG1DQUFJLENBQUMsQ0FBQyxDQUFDO29CQUN4RSxNQUFNLEVBQUUsR0FBRyxFQUFFLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQztvQkFDN0IsTUFBTSxLQUFLLG1DQUFRLDBCQUFrQixHQUFLLElBQUksYUFBSixJQUFJLHVCQUFKLElBQUksQ0FBRSxlQUFlLENBQUUsQ0FBQztvQkFDbEUsTUFBTSxJQUFJLEdBQUcsNkJBQVUsQ0FBQyxNQUFNLENBQUMsSUFBSSxFQUFFLEVBQUUsRUFBRSxLQUFLLEVBQUU7d0JBQzlDLGNBQWMsRUFBRSxLQUFLO3dCQUNyQixZQUFZLEVBQUUsSUFBSTtxQkFDbkIsQ0FBQyxDQUFDO29CQUNILE9BQU87d0JBQ0wsTUFBTSxFQUFFLElBQUk7d0JBQ1osT0FBTyxFQUFFLElBQUksQ0FBQyxPQUFPO3dCQUNyQixXQUFXLEVBQUUsZ0NBQWEsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDO3dCQUNqRCxNQUFNLEVBQUUsTUFBTSxhQUFOLE1BQU0sY0FBTixNQUFNLEdBQUksRUFBRTt3QkFDcEIsS0FBSyxFQUFFLEVBQUUsSUFBSSxFQUFFLEVBQUUsRUFBRTt3QkFDbkIsSUFBSTtxQkFDTCxDQUFDO2lCQUNIO2dCQUNELE1BQU0sRUFBRSxXQUFXLEVBQUUsR0FBRyxLQUEwQixDQUFDO2dCQUNuRCxNQUFNLGVBQWUsR0FBRyxXQUFXLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDO2dCQUM1RCxNQUFNLGFBQWEsR0FBRyxlQUFlLENBQUMsSUFBSSxFQUFFLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQztnQkFDeEQsNkVBQTZFO2dCQUM3RSxJQUNFLEtBQUksYUFBSixJQUFJLHVCQUFKLElBQUksQ0FBRSxNQUFNLE1BQUssUUFBUTtvQkFDekIsQ0FBQyx3QkFBWSxFQUFDLEVBQUUsQ0FBQyxTQUFTLEVBQUUsZUFBZSxDQUFDO29CQUM1QyxDQUFDLGFBQWE7b0JBRWQsT0FBTyx1QkFBdUIsQ0FBQztnQkFFakMsTUFBTSxFQUFFLE1BQU0sRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLEdBQUcsS0FBZ0MsQ0FBQztnQkFDbkUsK0NBQStDO2dCQUMvQyxNQUFNLEVBQUUsSUFBSSxFQUFFLEVBQUUsRUFBRSxHQUFHLGVBQWUsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDL0MsTUFBTSxJQUFJLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxDQUFDO2dCQUMxQyxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUM7b0JBQUUsT0FBTyx1QkFBdUIsQ0FBQztnQkFFOUQsT0FBTztvQkFDTCxNQUFNO29CQUNOLE9BQU87b0JBQ1AsV0FBVyxFQUFFLGVBQWU7b0JBQzVCLE1BQU0sRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUM7b0JBQ2xDLEtBQUssRUFBRSxFQUFFLElBQUksRUFBRSxFQUFFLEVBQUU7b0JBQ25CLElBQUk7aUJBQ0wsQ0FBQztZQUNKLENBQUM7U0FDRjtRQUNELEtBQUssRUFBRTtZQUNMLFdBQVcsRUFBRSxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxXQUFXO1lBQzFELFdBQVcsRUFBRSxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMscUJBQXFCLENBQUMsSUFBSSxDQUFDO1lBQ2xELFVBQVUsRUFBRSxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMscUJBQXFCLENBQUMsSUFBSSxDQUFDO1lBQ2pELGFBQWEsQ0FBQyxJQUFJLEVBQUUsS0FBSzs7Z0JBQ3ZCLE1BQU0sRUFBRSxPQUFPLEVBQUUsTUFBTSxFQUFFLFdBQVcsRUFBRSxJQUFJLEVBQUUsR0FBRyxNQUFNLENBQUMsUUFBUSxDQUM1RCxJQUFJLENBQUMsS0FBSyxDQUNnQixDQUFDO2dCQUU3QixJQUFJLENBQUMsTUFBTSxJQUFJLENBQUMsd0JBQVksRUFBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsRUFBRSxXQUFXLENBQUM7b0JBQUUsT0FBTyxLQUFLLENBQUM7Z0JBRTlFLE1BQU0sRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFFLEdBQUcsV0FBVyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUMzQyxNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxDQUFDO2dCQUVsRCx1REFBdUQ7Z0JBQ3ZELE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsYUFBTyxhQUFQLE9BQU8sdUJBQVAsT0FBTyxDQUFFLE1BQU0sbUNBQUksQ0FBQyxDQUFDLENBQUM7Z0JBRWhELE1BQU0sa0JBQWtCLEdBQUcsVUFBSSxhQUFKLElBQUksdUJBQUosSUFBSSxDQUFFLGtCQUFrQixtQ0FBSSxJQUFJLENBQUM7Z0JBQzVELElBQ0Usa0JBQWtCO29CQUNsQixNQUFNLENBQUMsTUFBTSxLQUFLLENBQUM7b0JBQ25CLENBQUMsS0FBSyxDQUFDLEdBQUcsS0FBSyxHQUFHLElBQUksS0FBSyxDQUFDLEdBQUcsS0FBSyxVQUFVLENBQUMsRUFDL0M7b0JBQ0EsK0JBQWlCLEVBQUMsSUFBSSxDQUFDLENBQUM7b0JBQ3hCLGlFQUFpRTtvQkFDakUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUMsY0FBYyxFQUFFLENBQUMsQ0FBQztvQkFDOUQsT0FBTyxJQUFJLENBQUM7aUJBQ2I7Z0JBQ0QsSUFBSSxNQUFNLENBQUMsTUFBTSxLQUFLLENBQUMsSUFBSSxLQUFLLENBQUMsR0FBRyxLQUFLLFdBQVcsRUFBRTtvQkFDcEQsMENBQWEsRUFBQyxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztvQkFDekMsK0JBQWlCLEVBQUMsSUFBSSxDQUFDLENBQUM7b0JBQ3hCLE9BQU8sSUFBSSxDQUFDO2lCQUNiO2dCQUVELE1BQU0sSUFBSSxHQUFHLGVBQWUsQ0FBQyxLQUFLLENBQUMsQ0FBQztnQkFDcEMsTUFBTSxNQUFNLEdBQXFDO29CQUMvQyxJQUFJO29CQUNKLE9BQU87b0JBQ1AsTUFBTTtvQkFDTixLQUFLLEVBQUUsRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFFO29CQUNuQixJQUFJO2lCQUNMLENBQUM7Z0JBQ0YsUUFBUSxJQUFJLEVBQUU7b0JBQ1osS0FBSyxrQkFBVSxDQUFDLEtBQUs7d0JBQ25CLHlEQUF5RDt3QkFDekQsb0RBQW9EO3dCQUNwRCxPQUFPLCtCQUFpQixFQUFDLElBQUksQ0FBQyxDQUFDO29CQUNqQyxLQUFLLGtCQUFVLENBQUMsS0FBSyxDQUFDLENBQUM7d0JBQ3JCLHdFQUF3RTt3QkFDeEUsTUFBTSxNQUFNLEdBQUcsT0FBTyxpQ0FBTSxNQUFNLEtBQUUsSUFBSSxFQUFFLGtCQUFVLENBQUMsS0FBSyxJQUFHLENBQUM7d0JBQzlELElBQUksTUFBTSxLQUFLLGlCQUFTOzRCQUFFLE9BQU8sSUFBSSxDQUFDO3dCQUN0QyxPQUFPLE1BQU0sSUFBSSwrQkFBaUIsRUFBQyxJQUFJLENBQUMsQ0FBQztxQkFDMUM7b0JBQ0QsS0FBSyxrQkFBVSxDQUFDLEVBQUUsQ0FBQztvQkFDbkIsS0FBSyxrQkFBVSxDQUFDLElBQUk7d0JBQ2xCLE9BQU8sT0FBTyxDQUFDLE9BQU8saUNBQU0sTUFBTSxLQUFFLElBQUksSUFBRyxDQUFDLENBQUM7b0JBQy9DLEtBQUssa0JBQVUsQ0FBQyxJQUFJLENBQUM7b0JBQ3JCLEtBQUssa0JBQVUsQ0FBQyxLQUFLO3dCQUNuQixJQUFJLENBQUMsS0FBSSxhQUFKLElBQUksdUJBQUosSUFBSSxDQUFFLFlBQVk7NEJBQUUsT0FBTyxLQUFLLENBQUM7d0JBQ3RDLE9BQU8sT0FBTyxDQUFDLE9BQU8saUNBQU0sTUFBTSxLQUFFLElBQUksSUFBRyxDQUFDLENBQUM7b0JBQy9DO3dCQUNFLE1BQU07aUJBQ1Q7Z0JBQ0QsT0FBTyxLQUFLLENBQUM7WUFDZixDQUFDO1NBQ0Y7S0FDRixDQUFDLENBQUM7SUFDSCxPQUFPLE1BQU0sQ0FBQztBQUNoQixDQUFDO0FBL0lELGtEQStJQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM5TEQsd0VBQXdDO0FBRXhDLDRFQUF3QjtBQUN4Qiw0RUFBd0I7QUFDeEIsOEVBQXlCO0FBQ3pCLGdGQUEwQjtBQUUxQixxQkFBZSxxQkFBWSxDQUFDOzs7Ozs7Ozs7Ozs7OztBQ1A1Qiw2SUFBbUQ7QUFHbkQscUVBQXVDO0FBRXZDLFNBQWdCLGVBQWUsQ0FBQyxNQUFjLEVBQUUsSUFBYTtJQUMzRCxNQUFNLE9BQU8sR0FDWCxPQUFPLElBQUksQ0FBQyxPQUFPLEtBQUssUUFBUTtRQUM5QixDQUFDLENBQUMsTUFBTSxDQUFDLDJCQUEyQixJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxxQkFBcUIsRUFBRSxNQUFNLENBQUMsSUFBSSxDQUFDO1FBQzVGLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDO0lBRW5CLE9BQU8sSUFBSSxrQ0FBUyxDQUFDLE9BQU8sRUFBRSxDQUFDLEtBQUssRUFBRSxLQUFLLEVBQUUsRUFBRTtRQUM3QyxNQUFNLEVBQUUsV0FBVyxFQUFFLEdBQUcsTUFBTSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUMvQyxpREFBaUQ7UUFDakQsSUFBSSx3QkFBWSxFQUFDLEtBQUssQ0FBQyxTQUFTLEVBQUUsV0FBVyxDQUFDO1lBQUUsT0FBTyxJQUFJLENBQUM7UUFDNUQseUNBQXlDO1FBQ3pDLE1BQU0sRUFBRSxHQUFHLEtBQUssQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsY0FBYyxFQUFFLENBQUM7UUFDL0UsTUFBTSxJQUFJLEdBQXFCLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksRUFBRSxDQUFDO1FBQzFFLEVBQUUsQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQ3pCLE9BQU8sRUFBRSxDQUFDO0lBQ1osQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDO0FBaEJELDBDQWdCQzs7Ozs7Ozs7Ozs7Ozs7QUNwQkQsNklBQW9EO0FBQ3BELHFFQUFrRTtBQUNsRSxvRkFBbUQ7QUFDbkQsb0ZBQStDO0FBRS9DLFNBQWdCLGNBQWMsQ0FBQyxPQUF5QjtJQUN0RCxPQUFPLENBQUMsTUFBMEIsRUFBVyxFQUFFOztRQUM3QyxRQUFRLE1BQU0sQ0FBQyxJQUFJLEVBQUU7WUFDbkIsS0FBSyxrQkFBVSxDQUFDLElBQUk7Z0JBQ2xCLE9BQU8sbUJBQU8sQ0FBQyxNQUFNLCtDQUFkLE9BQU8sRUFBVSxNQUFNLENBQUMsbUNBQUksS0FBSyxDQUFDO1lBQzNDLEtBQUssa0JBQVUsQ0FBQyxLQUFLO2dCQUNuQixPQUFPLG1CQUFPLENBQUMsT0FBTywrQ0FBZixPQUFPLEVBQVcsTUFBTSxDQUFDLG1DQUFJLEtBQUssQ0FBQztZQUM1QyxLQUFLLGtCQUFVLENBQUMsRUFBRSxDQUFDO1lBQ25CLEtBQUssa0JBQVUsQ0FBQyxJQUFJLENBQUM7WUFDckIsS0FBSyxrQkFBVSxDQUFDLElBQUksQ0FBQztZQUNyQixLQUFLLGtCQUFVLENBQUMsS0FBSztnQkFDbkIsT0FBTyxtQkFBTyxDQUFDLE9BQU8sK0NBQWYsT0FBTyxFQUFXLE1BQU0sQ0FBQyxtQ0FBSSxLQUFLLENBQUM7WUFDNUMsS0FBSyxrQkFBVSxDQUFDLE1BQU07Z0JBQ3BCLE9BQU8sbUJBQU8sQ0FBQyxRQUFRLCtDQUFoQixPQUFPLEVBQVksTUFBTSxDQUFDLG1DQUFJLEtBQUssQ0FBQztZQUM3QyxLQUFLLGtCQUFVLENBQUMsS0FBSztnQkFDbkIsT0FBTyxtQkFBTyxDQUFDLE9BQU8sK0NBQWYsT0FBTyxFQUFXLE1BQU0sQ0FBQyxtQ0FBSSxLQUFLLENBQUM7WUFDNUM7Z0JBQ0UsT0FBTyxLQUFLLENBQUM7U0FDaEI7SUFDSCxDQUFDLENBQUM7QUFDSixDQUFDO0FBcEJELHdDQW9CQztBQUVELFNBQWdCLFlBQVksQ0FBQyxPQUF5QixFQUFFO0lBQ3RELE1BQU0sT0FBTyxtQkFDWCxRQUFRLEVBQUUsRUFBRSxFQUNaLE9BQU8sRUFBRSxjQUFjLENBQUMsSUFBSSxDQUFDLElBQzFCLElBQUksQ0FDUixDQUFDO0lBQ0YsTUFBTSxFQUFFLE9BQU8sRUFBRSxRQUFRLEVBQUUsR0FBRyxPQUFPLENBQUM7SUFFdEMsTUFBTSxNQUFNLEdBQUcsb0NBQW1CLEVBQUMsT0FBTyxDQUFDLENBQUM7SUFFNUMsTUFBTSxLQUFLLEdBQWE7UUFDdEIsTUFBTTtRQUNOLHVDQUFVLEVBQUM7WUFDVCx3Q0FBd0M7WUFDeEMsS0FBSyxFQUFFLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLGdDQUFlLEVBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFDO1NBQzdELENBQUM7S0FDSCxDQUFDO0lBQ0YsT0FBTyxLQUFLLENBQUM7QUFDZixDQUFDO0FBbEJELG9DQWtCQzs7Ozs7Ozs7Ozs7Ozs7QUM1Q1ksaUJBQVMsR0FBRyxXQUFXLENBQUM7QUF1QnJDLElBQVksVUFTWDtBQVRELFdBQVksVUFBVTtJQUNwQiwyQkFBZTtJQUNmLDZCQUFpQjtJQUNqQiwrQkFBbUI7SUFDbkIsNEJBQWdCO0lBQ2hCLGdDQUFvQjtJQUNwQixnQ0FBb0I7SUFDcEIsa0NBQXNCO0lBQ3RCLDZCQUFpQjtBQUNuQixDQUFDLEVBVFcsVUFBVSxHQUFWLGtCQUFVLEtBQVYsa0JBQVUsUUFTckI7Ozs7Ozs7Ozs7Ozs7O0FDbENELDhIQUF5RDtBQUc1QyxrQkFBVSxHQUFHLGNBQWMsQ0FBQztBQUM1QiwwQkFBa0IsR0FBRyxFQUFFLEVBQUUsRUFBRSxrQkFBVSxFQUFFLEtBQUssRUFBRSxrQkFBVSxFQUFFLENBQUM7QUFFM0QsaUJBQVMsR0FBRyxJQUFJLDZCQUFTLENBQUMsa0JBQVUsQ0FBQyxDQUFDO0FBRW5ELFNBQWdCLFlBQVksQ0FBQyxTQUFvQixFQUFFLFdBQTBCO0lBQzNFLE9BQU8sV0FBVyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO0FBQ25FLENBQUM7QUFGRCxvQ0FFQzs7Ozs7Ozs7Ozs7Ozs7QUNWYztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHNCQUFzQjtBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0osb0JBQW9CLGtCQUFrQjtBQUN0QyxJQUFJO0FBQ0o7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDM0JPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLEdBQUc7QUFDN0U7O0FBRUE7QUFDQSxnQkFBZ0IsUUFBUTs7QUFFeEI7QUFDQSxnQkFBZ0IsU0FBUzs7QUFFekI7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7VUMzSEE7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTs7VUFFQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTs7Ozs7V0N0QkE7V0FDQTtXQUNBO1dBQ0E7V0FDQSx5Q0FBeUMsd0NBQXdDO1dBQ2pGO1dBQ0E7V0FDQTs7Ozs7V0NQQTs7Ozs7V0NBQTtXQUNBO1dBQ0E7V0FDQSx1REFBdUQsaUJBQWlCO1dBQ3hFO1dBQ0EsZ0RBQWdELGFBQWE7V0FDN0Q7Ozs7O1VFTkE7VUFDQTtVQUNBO1VBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9zZW1pcnJvci1hdXRvY29tcGxldGUvLi9ub2RlX21vZHVsZXMvb3JkZXJlZG1hcC9pbmRleC5lcy5qcyIsIndlYnBhY2s6Ly9wcm9zZW1pcnJvci1hdXRvY29tcGxldGUvLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItY29tbWFuZHMvZGlzdC9pbmRleC5lcy5qcyIsIndlYnBhY2s6Ly9wcm9zZW1pcnJvci1hdXRvY29tcGxldGUvLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItZHJvcGN1cnNvci9kaXN0L2luZGV4LmVzLmpzIiwid2VicGFjazovL3Byb3NlbWlycm9yLWF1dG9jb21wbGV0ZS8uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1leGFtcGxlLXNldHVwL2Rpc3QvaW5kZXguZXMuanMiLCJ3ZWJwYWNrOi8vcHJvc2VtaXJyb3ItYXV0b2NvbXBsZXRlLy4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLWdhcGN1cnNvci9kaXN0L2luZGV4LmVzLmpzIiwid2VicGFjazovL3Byb3NlbWlycm9yLWF1dG9jb21wbGV0ZS8uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1oaXN0b3J5L2Rpc3QvaW5kZXguZXMuanMiLCJ3ZWJwYWNrOi8vcHJvc2VtaXJyb3ItYXV0b2NvbXBsZXRlLy4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLWlucHV0cnVsZXMvZGlzdC9pbmRleC5lcy5qcyIsIndlYnBhY2s6Ly9wcm9zZW1pcnJvci1hdXRvY29tcGxldGUvLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3Ita2V5bWFwL2Rpc3QvaW5kZXguZXMuanMiLCJ3ZWJwYWNrOi8vcHJvc2VtaXJyb3ItYXV0b2NvbXBsZXRlLy4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLW1lbnUvZGlzdC9pbmRleC5lcy5qcyIsIndlYnBhY2s6Ly9wcm9zZW1pcnJvci1hdXRvY29tcGxldGUvLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItbW9kZWwvZGlzdC9pbmRleC5lcy5qcyIsIndlYnBhY2s6Ly9wcm9zZW1pcnJvci1hdXRvY29tcGxldGUvLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3Itc2NoZW1hLWJhc2ljL2Rpc3QvaW5kZXguZXMuanMiLCJ3ZWJwYWNrOi8vcHJvc2VtaXJyb3ItYXV0b2NvbXBsZXRlLy4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLXNjaGVtYS1saXN0L2Rpc3QvaW5kZXguZXMuanMiLCJ3ZWJwYWNrOi8vcHJvc2VtaXJyb3ItYXV0b2NvbXBsZXRlLy4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLXN0YXRlL2Rpc3QvaW5kZXguZXMuanMiLCJ3ZWJwYWNrOi8vcHJvc2VtaXJyb3ItYXV0b2NvbXBsZXRlLy4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLXRyYW5zZm9ybS9kaXN0L2luZGV4LmVzLmpzIiwid2VicGFjazovL3Byb3NlbWlycm9yLWF1dG9jb21wbGV0ZS8uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci12aWV3L2Rpc3QvaW5kZXguZXMuanMiLCJ3ZWJwYWNrOi8vcHJvc2VtaXJyb3ItYXV0b2NvbXBsZXRlLy4vbm9kZV9tb2R1bGVzL3JvcGUtc2VxdWVuY2UvZGlzdC9pbmRleC5lcy5qcyIsIndlYnBhY2s6Ly9wcm9zZW1pcnJvci1hdXRvY29tcGxldGUvLi9kZW1vL2luZGV4LnRzIiwid2VicGFjazovL3Byb3NlbWlycm9yLWF1dG9jb21wbGV0ZS8uL2RlbW8vcmVkdWNlci50cyIsIndlYnBhY2s6Ly9wcm9zZW1pcnJvci1hdXRvY29tcGxldGUvLi9zcmMvYWN0aW9ucy50cyIsIndlYnBhY2s6Ly9wcm9zZW1pcnJvci1hdXRvY29tcGxldGUvLi9zcmMvZGVjb3JhdGlvbi50cyIsIndlYnBhY2s6Ly9wcm9zZW1pcnJvci1hdXRvY29tcGxldGUvLi9zcmMvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vcHJvc2VtaXJyb3ItYXV0b2NvbXBsZXRlLy4vc3JjL2lucHV0UnVsZXMudHMiLCJ3ZWJwYWNrOi8vcHJvc2VtaXJyb3ItYXV0b2NvbXBsZXRlLy4vc3JjL3BsdWdpbi50cyIsIndlYnBhY2s6Ly9wcm9zZW1pcnJvci1hdXRvY29tcGxldGUvLi9zcmMvdHlwZXMudHMiLCJ3ZWJwYWNrOi8vcHJvc2VtaXJyb3ItYXV0b2NvbXBsZXRlLy4vc3JjL3V0aWxzLnRzIiwid2VicGFjazovL3Byb3NlbWlycm9yLWF1dG9jb21wbGV0ZS8uL25vZGVfbW9kdWxlcy9jcmVsdC9pbmRleC5lcy5qcyIsIndlYnBhY2s6Ly9wcm9zZW1pcnJvci1hdXRvY29tcGxldGUvLi9ub2RlX21vZHVsZXMvdzNjLWtleW5hbWUvaW5kZXguZXMuanMiLCJ3ZWJwYWNrOi8vcHJvc2VtaXJyb3ItYXV0b2NvbXBsZXRlL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL3Byb3NlbWlycm9yLWF1dG9jb21wbGV0ZS93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vcHJvc2VtaXJyb3ItYXV0b2NvbXBsZXRlL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vcHJvc2VtaXJyb3ItYXV0b2NvbXBsZXRlL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vcHJvc2VtaXJyb3ItYXV0b2NvbXBsZXRlL3dlYnBhY2svYmVmb3JlLXN0YXJ0dXAiLCJ3ZWJwYWNrOi8vcHJvc2VtaXJyb3ItYXV0b2NvbXBsZXRlL3dlYnBhY2svc3RhcnR1cCIsIndlYnBhY2s6Ly9wcm9zZW1pcnJvci1hdXRvY29tcGxldGUvd2VicGFjay9hZnRlci1zdGFydHVwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIDo6LSBQZXJzaXN0ZW50IGRhdGEgc3RydWN0dXJlIHJlcHJlc2VudGluZyBhbiBvcmRlcmVkIG1hcHBpbmcgZnJvbVxuLy8gc3RyaW5ncyB0byB2YWx1ZXMsIHdpdGggc29tZSBjb252ZW5pZW50IHVwZGF0ZSBtZXRob2RzLlxuZnVuY3Rpb24gT3JkZXJlZE1hcChjb250ZW50KSB7XG4gIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG59XG5cbk9yZGVyZWRNYXAucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogT3JkZXJlZE1hcCxcblxuICBmaW5kOiBmdW5jdGlvbihrZXkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29udGVudC5sZW5ndGg7IGkgKz0gMilcbiAgICAgIGlmICh0aGlzLmNvbnRlbnRbaV0gPT09IGtleSkgcmV0dXJuIGlcbiAgICByZXR1cm4gLTFcbiAgfSxcblxuICAvLyA6OiAoc3RyaW5nKSDihpIgP2FueVxuICAvLyBSZXRyaWV2ZSB0aGUgdmFsdWUgc3RvcmVkIHVuZGVyIGBrZXlgLCBvciByZXR1cm4gdW5kZWZpbmVkIHdoZW5cbiAgLy8gbm8gc3VjaCBrZXkgZXhpc3RzLlxuICBnZXQ6IGZ1bmN0aW9uKGtleSkge1xuICAgIHZhciBmb3VuZCA9IHRoaXMuZmluZChrZXkpO1xuICAgIHJldHVybiBmb3VuZCA9PSAtMSA/IHVuZGVmaW5lZCA6IHRoaXMuY29udGVudFtmb3VuZCArIDFdXG4gIH0sXG5cbiAgLy8gOjogKHN0cmluZywgYW55LCA/c3RyaW5nKSDihpIgT3JkZXJlZE1hcFxuICAvLyBDcmVhdGUgYSBuZXcgbWFwIGJ5IHJlcGxhY2luZyB0aGUgdmFsdWUgb2YgYGtleWAgd2l0aCBhIG5ld1xuICAvLyB2YWx1ZSwgb3IgYWRkaW5nIGEgYmluZGluZyB0byB0aGUgZW5kIG9mIHRoZSBtYXAuIElmIGBuZXdLZXlgIGlzXG4gIC8vIGdpdmVuLCB0aGUga2V5IG9mIHRoZSBiaW5kaW5nIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCB0aGF0IGtleS5cbiAgdXBkYXRlOiBmdW5jdGlvbihrZXksIHZhbHVlLCBuZXdLZXkpIHtcbiAgICB2YXIgc2VsZiA9IG5ld0tleSAmJiBuZXdLZXkgIT0ga2V5ID8gdGhpcy5yZW1vdmUobmV3S2V5KSA6IHRoaXM7XG4gICAgdmFyIGZvdW5kID0gc2VsZi5maW5kKGtleSksIGNvbnRlbnQgPSBzZWxmLmNvbnRlbnQuc2xpY2UoKTtcbiAgICBpZiAoZm91bmQgPT0gLTEpIHtcbiAgICAgIGNvbnRlbnQucHVzaChuZXdLZXkgfHwga2V5LCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRlbnRbZm91bmQgKyAxXSA9IHZhbHVlO1xuICAgICAgaWYgKG5ld0tleSkgY29udGVudFtmb3VuZF0gPSBuZXdLZXk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgT3JkZXJlZE1hcChjb250ZW50KVxuICB9LFxuXG4gIC8vIDo6IChzdHJpbmcpIOKGkiBPcmRlcmVkTWFwXG4gIC8vIFJldHVybiBhIG1hcCB3aXRoIHRoZSBnaXZlbiBrZXkgcmVtb3ZlZCwgaWYgaXQgZXhpc3RlZC5cbiAgcmVtb3ZlOiBmdW5jdGlvbihrZXkpIHtcbiAgICB2YXIgZm91bmQgPSB0aGlzLmZpbmQoa2V5KTtcbiAgICBpZiAoZm91bmQgPT0gLTEpIHJldHVybiB0aGlzXG4gICAgdmFyIGNvbnRlbnQgPSB0aGlzLmNvbnRlbnQuc2xpY2UoKTtcbiAgICBjb250ZW50LnNwbGljZShmb3VuZCwgMik7XG4gICAgcmV0dXJuIG5ldyBPcmRlcmVkTWFwKGNvbnRlbnQpXG4gIH0sXG5cbiAgLy8gOjogKHN0cmluZywgYW55KSDihpIgT3JkZXJlZE1hcFxuICAvLyBBZGQgYSBuZXcga2V5IHRvIHRoZSBzdGFydCBvZiB0aGUgbWFwLlxuICBhZGRUb1N0YXJ0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBPcmRlcmVkTWFwKFtrZXksIHZhbHVlXS5jb25jYXQodGhpcy5yZW1vdmUoa2V5KS5jb250ZW50KSlcbiAgfSxcblxuICAvLyA6OiAoc3RyaW5nLCBhbnkpIOKGkiBPcmRlcmVkTWFwXG4gIC8vIEFkZCBhIG5ldyBrZXkgdG8gdGhlIGVuZCBvZiB0aGUgbWFwLlxuICBhZGRUb0VuZDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgIHZhciBjb250ZW50ID0gdGhpcy5yZW1vdmUoa2V5KS5jb250ZW50LnNsaWNlKCk7XG4gICAgY29udGVudC5wdXNoKGtleSwgdmFsdWUpO1xuICAgIHJldHVybiBuZXcgT3JkZXJlZE1hcChjb250ZW50KVxuICB9LFxuXG4gIC8vIDo6IChzdHJpbmcsIHN0cmluZywgYW55KSDihpIgT3JkZXJlZE1hcFxuICAvLyBBZGQgYSBrZXkgYWZ0ZXIgdGhlIGdpdmVuIGtleS4gSWYgYHBsYWNlYCBpcyBub3QgZm91bmQsIHRoZSBuZXdcbiAgLy8ga2V5IGlzIGFkZGVkIHRvIHRoZSBlbmQuXG4gIGFkZEJlZm9yZTogZnVuY3Rpb24ocGxhY2UsIGtleSwgdmFsdWUpIHtcbiAgICB2YXIgd2l0aG91dCA9IHRoaXMucmVtb3ZlKGtleSksIGNvbnRlbnQgPSB3aXRob3V0LmNvbnRlbnQuc2xpY2UoKTtcbiAgICB2YXIgZm91bmQgPSB3aXRob3V0LmZpbmQocGxhY2UpO1xuICAgIGNvbnRlbnQuc3BsaWNlKGZvdW5kID09IC0xID8gY29udGVudC5sZW5ndGggOiBmb3VuZCwgMCwga2V5LCB2YWx1ZSk7XG4gICAgcmV0dXJuIG5ldyBPcmRlcmVkTWFwKGNvbnRlbnQpXG4gIH0sXG5cbiAgLy8gOjogKChrZXk6IHN0cmluZywgdmFsdWU6IGFueSkpXG4gIC8vIENhbGwgdGhlIGdpdmVuIGZ1bmN0aW9uIGZvciBlYWNoIGtleS92YWx1ZSBwYWlyIGluIHRoZSBtYXAsIGluXG4gIC8vIG9yZGVyLlxuICBmb3JFYWNoOiBmdW5jdGlvbihmKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbnRlbnQubGVuZ3RoOyBpICs9IDIpXG4gICAgICBmKHRoaXMuY29udGVudFtpXSwgdGhpcy5jb250ZW50W2kgKyAxXSk7XG4gIH0sXG5cbiAgLy8gOjogKHVuaW9uPE9iamVjdCwgT3JkZXJlZE1hcD4pIOKGkiBPcmRlcmVkTWFwXG4gIC8vIENyZWF0ZSBhIG5ldyBtYXAgYnkgcHJlcGVuZGluZyB0aGUga2V5cyBpbiB0aGlzIG1hcCB0aGF0IGRvbid0XG4gIC8vIGFwcGVhciBpbiBgbWFwYCBiZWZvcmUgdGhlIGtleXMgaW4gYG1hcGAuXG4gIHByZXBlbmQ6IGZ1bmN0aW9uKG1hcCkge1xuICAgIG1hcCA9IE9yZGVyZWRNYXAuZnJvbShtYXApO1xuICAgIGlmICghbWFwLnNpemUpIHJldHVybiB0aGlzXG4gICAgcmV0dXJuIG5ldyBPcmRlcmVkTWFwKG1hcC5jb250ZW50LmNvbmNhdCh0aGlzLnN1YnRyYWN0KG1hcCkuY29udGVudCkpXG4gIH0sXG5cbiAgLy8gOjogKHVuaW9uPE9iamVjdCwgT3JkZXJlZE1hcD4pIOKGkiBPcmRlcmVkTWFwXG4gIC8vIENyZWF0ZSBhIG5ldyBtYXAgYnkgYXBwZW5kaW5nIHRoZSBrZXlzIGluIHRoaXMgbWFwIHRoYXQgZG9uJ3RcbiAgLy8gYXBwZWFyIGluIGBtYXBgIGFmdGVyIHRoZSBrZXlzIGluIGBtYXBgLlxuICBhcHBlbmQ6IGZ1bmN0aW9uKG1hcCkge1xuICAgIG1hcCA9IE9yZGVyZWRNYXAuZnJvbShtYXApO1xuICAgIGlmICghbWFwLnNpemUpIHJldHVybiB0aGlzXG4gICAgcmV0dXJuIG5ldyBPcmRlcmVkTWFwKHRoaXMuc3VidHJhY3QobWFwKS5jb250ZW50LmNvbmNhdChtYXAuY29udGVudCkpXG4gIH0sXG5cbiAgLy8gOjogKHVuaW9uPE9iamVjdCwgT3JkZXJlZE1hcD4pIOKGkiBPcmRlcmVkTWFwXG4gIC8vIENyZWF0ZSBhIG1hcCBjb250YWluaW5nIGFsbCB0aGUga2V5cyBpbiB0aGlzIG1hcCB0aGF0IGRvbid0XG4gIC8vIGFwcGVhciBpbiBgbWFwYC5cbiAgc3VidHJhY3Q6IGZ1bmN0aW9uKG1hcCkge1xuICAgIHZhciByZXN1bHQgPSB0aGlzO1xuICAgIG1hcCA9IE9yZGVyZWRNYXAuZnJvbShtYXApO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFwLmNvbnRlbnQubGVuZ3RoOyBpICs9IDIpXG4gICAgICByZXN1bHQgPSByZXN1bHQucmVtb3ZlKG1hcC5jb250ZW50W2ldKTtcbiAgICByZXR1cm4gcmVzdWx0XG4gIH0sXG5cbiAgLy8gOjogbnVtYmVyXG4gIC8vIFRoZSBhbW91bnQgb2Yga2V5cyBpbiB0aGlzIG1hcC5cbiAgZ2V0IHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudC5sZW5ndGggPj4gMVxuICB9XG59O1xuXG4vLyA6OiAoP3VuaW9uPE9iamVjdCwgT3JkZXJlZE1hcD4pIOKGkiBPcmRlcmVkTWFwXG4vLyBSZXR1cm4gYSBtYXAgd2l0aCB0aGUgZ2l2ZW4gY29udGVudC4gSWYgbnVsbCwgY3JlYXRlIGFuIGVtcHR5XG4vLyBtYXAuIElmIGdpdmVuIGFuIG9yZGVyZWQgbWFwLCByZXR1cm4gdGhhdCBtYXAgaXRzZWxmLiBJZiBnaXZlbiBhblxuLy8gb2JqZWN0LCBjcmVhdGUgYSBtYXAgZnJvbSB0aGUgb2JqZWN0J3MgcHJvcGVydGllcy5cbk9yZGVyZWRNYXAuZnJvbSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE9yZGVyZWRNYXApIHJldHVybiB2YWx1ZVxuICB2YXIgY29udGVudCA9IFtdO1xuICBpZiAodmFsdWUpIGZvciAodmFyIHByb3AgaW4gdmFsdWUpIGNvbnRlbnQucHVzaChwcm9wLCB2YWx1ZVtwcm9wXSk7XG4gIHJldHVybiBuZXcgT3JkZXJlZE1hcChjb250ZW50KVxufTtcblxudmFyIG9yZGVyZWRtYXAgPSBPcmRlcmVkTWFwO1xuXG5leHBvcnQgZGVmYXVsdCBvcmRlcmVkbWFwO1xuIiwiaW1wb3J0IHsgbGlmdFRhcmdldCwgY2FuSm9pbiwgam9pblBvaW50LCBjYW5TcGxpdCwgUmVwbGFjZUFyb3VuZFN0ZXAsIGZpbmRXcmFwcGluZyB9IGZyb20gJ3Byb3NlbWlycm9yLXRyYW5zZm9ybSc7XG5pbXBvcnQgeyBGcmFnbWVudCwgU2xpY2UgfSBmcm9tICdwcm9zZW1pcnJvci1tb2RlbCc7XG5pbXBvcnQgeyBOb2RlU2VsZWN0aW9uLCBTZWxlY3Rpb24sIEFsbFNlbGVjdGlvbiwgVGV4dFNlbGVjdGlvbiB9IGZyb20gJ3Byb3NlbWlycm9yLXN0YXRlJztcblxuLy8gOjogKEVkaXRvclN0YXRlLCA/KHRyOiBUcmFuc2FjdGlvbikpIOKGkiBib29sXG4vLyBEZWxldGUgdGhlIHNlbGVjdGlvbiwgaWYgdGhlcmUgaXMgb25lLlxuZnVuY3Rpb24gZGVsZXRlU2VsZWN0aW9uKHN0YXRlLCBkaXNwYXRjaCkge1xuICBpZiAoc3RhdGUuc2VsZWN0aW9uLmVtcHR5KSB7IHJldHVybiBmYWxzZSB9XG4gIGlmIChkaXNwYXRjaCkgeyBkaXNwYXRjaChzdGF0ZS50ci5kZWxldGVTZWxlY3Rpb24oKS5zY3JvbGxJbnRvVmlldygpKTsgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG4vLyA6OiAoRWRpdG9yU3RhdGUsID8odHI6IFRyYW5zYWN0aW9uKSwgP0VkaXRvclZpZXcpIOKGkiBib29sXG4vLyBJZiB0aGUgc2VsZWN0aW9uIGlzIGVtcHR5IGFuZCBhdCB0aGUgc3RhcnQgb2YgYSB0ZXh0YmxvY2ssIHRyeSB0b1xuLy8gcmVkdWNlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoYXQgYmxvY2sgYW5kIHRoZSBvbmUgYmVmb3JlIGl04oCUaWZcbi8vIHRoZXJlJ3MgYSBibG9jayBkaXJlY3RseSBiZWZvcmUgaXQgdGhhdCBjYW4gYmUgam9pbmVkLCBqb2luIHRoZW0uXG4vLyBJZiBub3QsIHRyeSB0byBtb3ZlIHRoZSBzZWxlY3RlZCBibG9jayBjbG9zZXIgdG8gdGhlIG5leHQgb25lIGluXG4vLyB0aGUgZG9jdW1lbnQgc3RydWN0dXJlIGJ5IGxpZnRpbmcgaXQgb3V0IG9mIGl0cyBwYXJlbnQgb3IgbW92aW5nIGl0XG4vLyBpbnRvIGEgcGFyZW50IG9mIHRoZSBwcmV2aW91cyBibG9jay4gV2lsbCB1c2UgdGhlIHZpZXcgZm9yIGFjY3VyYXRlXG4vLyAoYmlkaS1hd2FyZSkgc3RhcnQtb2YtdGV4dGJsb2NrIGRldGVjdGlvbiBpZiBnaXZlbi5cbmZ1bmN0aW9uIGpvaW5CYWNrd2FyZChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpIHtcbiAgdmFyIHJlZiA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgdmFyICRjdXJzb3IgPSByZWYuJGN1cnNvcjtcbiAgaWYgKCEkY3Vyc29yIHx8ICh2aWV3ID8gIXZpZXcuZW5kT2ZUZXh0YmxvY2soXCJiYWNrd2FyZFwiLCBzdGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogJGN1cnNvci5wYXJlbnRPZmZzZXQgPiAwKSlcbiAgICB7IHJldHVybiBmYWxzZSB9XG5cbiAgdmFyICRjdXQgPSBmaW5kQ3V0QmVmb3JlKCRjdXJzb3IpO1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vIG5vZGUgYmVmb3JlIHRoaXMsIHRyeSB0byBsaWZ0XG4gIGlmICghJGN1dCkge1xuICAgIHZhciByYW5nZSA9ICRjdXJzb3IuYmxvY2tSYW5nZSgpLCB0YXJnZXQgPSByYW5nZSAmJiBsaWZ0VGFyZ2V0KHJhbmdlKTtcbiAgICBpZiAodGFyZ2V0ID09IG51bGwpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBpZiAoZGlzcGF0Y2gpIHsgZGlzcGF0Y2goc3RhdGUudHIubGlmdChyYW5nZSwgdGFyZ2V0KS5zY3JvbGxJbnRvVmlldygpKTsgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICB2YXIgYmVmb3JlID0gJGN1dC5ub2RlQmVmb3JlO1xuICAvLyBBcHBseSB0aGUgam9pbmluZyBhbGdvcml0aG1cbiAgaWYgKCFiZWZvcmUudHlwZS5zcGVjLmlzb2xhdGluZyAmJiBkZWxldGVCYXJyaWVyKHN0YXRlLCAkY3V0LCBkaXNwYXRjaCkpXG4gICAgeyByZXR1cm4gdHJ1ZSB9XG5cbiAgLy8gSWYgdGhlIG5vZGUgYmVsb3cgaGFzIG5vIGNvbnRlbnQgYW5kIHRoZSBub2RlIGFib3ZlIGlzXG4gIC8vIHNlbGVjdGFibGUsIGRlbGV0ZSB0aGUgbm9kZSBiZWxvdyBhbmQgc2VsZWN0IHRoZSBvbmUgYWJvdmUuXG4gIGlmICgkY3Vyc29yLnBhcmVudC5jb250ZW50LnNpemUgPT0gMCAmJlxuICAgICAgKHRleHRibG9ja0F0KGJlZm9yZSwgXCJlbmRcIikgfHwgTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUoYmVmb3JlKSkpIHtcbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgIHZhciB0ciA9IHN0YXRlLnRyLmRlbGV0ZVJhbmdlKCRjdXJzb3IuYmVmb3JlKCksICRjdXJzb3IuYWZ0ZXIoKSk7XG4gICAgICB0ci5zZXRTZWxlY3Rpb24odGV4dGJsb2NrQXQoYmVmb3JlLCBcImVuZFwiKSA/IFNlbGVjdGlvbi5maW5kRnJvbSh0ci5kb2MucmVzb2x2ZSh0ci5tYXBwaW5nLm1hcCgkY3V0LnBvcywgLTEpKSwgLTEpXG4gICAgICAgICAgICAgICAgICAgICAgOiBOb2RlU2VsZWN0aW9uLmNyZWF0ZSh0ci5kb2MsICRjdXQucG9zIC0gYmVmb3JlLm5vZGVTaXplKSk7XG4gICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8vIElmIHRoZSBub2RlIGJlZm9yZSBpcyBhbiBhdG9tLCBkZWxldGUgaXRcbiAgaWYgKGJlZm9yZS5pc0F0b20gJiYgJGN1dC5kZXB0aCA9PSAkY3Vyc29yLmRlcHRoIC0gMSkge1xuICAgIGlmIChkaXNwYXRjaCkgeyBkaXNwYXRjaChzdGF0ZS50ci5kZWxldGUoJGN1dC5wb3MgLSBiZWZvcmUubm9kZVNpemUsICRjdXQucG9zKS5zY3JvbGxJbnRvVmlldygpKTsgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gdGV4dGJsb2NrQXQobm9kZSwgc2lkZSwgb25seSkge1xuICBmb3IgKDsgbm9kZTsgbm9kZSA9IChzaWRlID09IFwic3RhcnRcIiA/IG5vZGUuZmlyc3RDaGlsZCA6IG5vZGUubGFzdENoaWxkKSkge1xuICAgIGlmIChub2RlLmlzVGV4dGJsb2NrKSB7IHJldHVybiB0cnVlIH1cbiAgICBpZiAob25seSAmJiBub2RlLmNoaWxkQ291bnQgIT0gMSkgeyByZXR1cm4gZmFsc2UgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vLyA6OiAoRWRpdG9yU3RhdGUsID8odHI6IFRyYW5zYWN0aW9uKSwgP0VkaXRvclZpZXcpIOKGkiBib29sXG4vLyBXaGVuIHRoZSBzZWxlY3Rpb24gaXMgZW1wdHkgYW5kIGF0IHRoZSBzdGFydCBvZiBhIHRleHRibG9jaywgc2VsZWN0XG4vLyB0aGUgbm9kZSBiZWZvcmUgdGhhdCB0ZXh0YmxvY2ssIGlmIHBvc3NpYmxlLiBUaGlzIGlzIGludGVuZGVkIHRvIGJlXG4vLyBib3VuZCB0byBrZXlzIGxpa2UgYmFja3NwYWNlLCBhZnRlclxuLy8gW2Bqb2luQmFja3dhcmRgXSgjY29tbWFuZHMuam9pbkJhY2t3YXJkKSBvciBvdGhlciBkZWxldGluZ1xuLy8gY29tbWFuZHMsIGFzIGEgZmFsbC1iYWNrIGJlaGF2aW9yIHdoZW4gdGhlIHNjaGVtYSBkb2Vzbid0IGFsbG93XG4vLyBkZWxldGlvbiBhdCB0aGUgc2VsZWN0ZWQgcG9pbnQuXG5mdW5jdGlvbiBzZWxlY3ROb2RlQmFja3dhcmQoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSB7XG4gIHZhciByZWYgPSBzdGF0ZS5zZWxlY3Rpb247XG4gIHZhciAkaGVhZCA9IHJlZi4kaGVhZDtcbiAgdmFyIGVtcHR5ID0gcmVmLmVtcHR5O1xuICB2YXIgJGN1dCA9ICRoZWFkO1xuICBpZiAoIWVtcHR5KSB7IHJldHVybiBmYWxzZSB9XG5cbiAgaWYgKCRoZWFkLnBhcmVudC5pc1RleHRibG9jaykge1xuICAgIGlmICh2aWV3ID8gIXZpZXcuZW5kT2ZUZXh0YmxvY2soXCJiYWNrd2FyZFwiLCBzdGF0ZSkgOiAkaGVhZC5wYXJlbnRPZmZzZXQgPiAwKSB7IHJldHVybiBmYWxzZSB9XG4gICAgJGN1dCA9IGZpbmRDdXRCZWZvcmUoJGhlYWQpO1xuICB9XG4gIHZhciBub2RlID0gJGN1dCAmJiAkY3V0Lm5vZGVCZWZvcmU7XG4gIGlmICghbm9kZSB8fCAhTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUobm9kZSkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgaWYgKGRpc3BhdGNoKVxuICAgIHsgZGlzcGF0Y2goc3RhdGUudHIuc2V0U2VsZWN0aW9uKE5vZGVTZWxlY3Rpb24uY3JlYXRlKHN0YXRlLmRvYywgJGN1dC5wb3MgLSBub2RlLm5vZGVTaXplKSkuc2Nyb2xsSW50b1ZpZXcoKSk7IH1cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gZmluZEN1dEJlZm9yZSgkcG9zKSB7XG4gIGlmICghJHBvcy5wYXJlbnQudHlwZS5zcGVjLmlzb2xhdGluZykgeyBmb3IgKHZhciBpID0gJHBvcy5kZXB0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKCRwb3MuaW5kZXgoaSkgPiAwKSB7IHJldHVybiAkcG9zLmRvYy5yZXNvbHZlKCRwb3MuYmVmb3JlKGkgKyAxKSkgfVxuICAgIGlmICgkcG9zLm5vZGUoaSkudHlwZS5zcGVjLmlzb2xhdGluZykgeyBicmVhayB9XG4gIH0gfVxuICByZXR1cm4gbnVsbFxufVxuXG4vLyA6OiAoRWRpdG9yU3RhdGUsID8odHI6IFRyYW5zYWN0aW9uKSwgP0VkaXRvclZpZXcpIOKGkiBib29sXG4vLyBJZiB0aGUgc2VsZWN0aW9uIGlzIGVtcHR5IGFuZCB0aGUgY3Vyc29yIGlzIGF0IHRoZSBlbmQgb2YgYVxuLy8gdGV4dGJsb2NrLCB0cnkgdG8gcmVkdWNlIG9yIHJlbW92ZSB0aGUgYm91bmRhcnkgYmV0d2VlbiB0aGF0IGJsb2NrXG4vLyBhbmQgdGhlIG9uZSBhZnRlciBpdCwgZWl0aGVyIGJ5IGpvaW5pbmcgdGhlbSBvciBieSBtb3ZpbmcgdGhlIG90aGVyXG4vLyBibG9jayBjbG9zZXIgdG8gdGhpcyBvbmUgaW4gdGhlIHRyZWUgc3RydWN0dXJlLiBXaWxsIHVzZSB0aGUgdmlld1xuLy8gZm9yIGFjY3VyYXRlIHN0YXJ0LW9mLXRleHRibG9jayBkZXRlY3Rpb24gaWYgZ2l2ZW4uXG5mdW5jdGlvbiBqb2luRm9yd2FyZChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpIHtcbiAgdmFyIHJlZiA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgdmFyICRjdXJzb3IgPSByZWYuJGN1cnNvcjtcbiAgaWYgKCEkY3Vyc29yIHx8ICh2aWV3ID8gIXZpZXcuZW5kT2ZUZXh0YmxvY2soXCJmb3J3YXJkXCIsIHN0YXRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiAkY3Vyc29yLnBhcmVudE9mZnNldCA8ICRjdXJzb3IucGFyZW50LmNvbnRlbnQuc2l6ZSkpXG4gICAgeyByZXR1cm4gZmFsc2UgfVxuXG4gIHZhciAkY3V0ID0gZmluZEN1dEFmdGVyKCRjdXJzb3IpO1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vIG5vZGUgYWZ0ZXIgdGhpcywgdGhlcmUncyBub3RoaW5nIHRvIGRvXG4gIGlmICghJGN1dCkgeyByZXR1cm4gZmFsc2UgfVxuXG4gIHZhciBhZnRlciA9ICRjdXQubm9kZUFmdGVyO1xuICAvLyBUcnkgdGhlIGpvaW5pbmcgYWxnb3JpdGhtXG4gIGlmIChkZWxldGVCYXJyaWVyKHN0YXRlLCAkY3V0LCBkaXNwYXRjaCkpIHsgcmV0dXJuIHRydWUgfVxuXG4gIC8vIElmIHRoZSBub2RlIGFib3ZlIGhhcyBubyBjb250ZW50IGFuZCB0aGUgbm9kZSBiZWxvdyBpc1xuICAvLyBzZWxlY3RhYmxlLCBkZWxldGUgdGhlIG5vZGUgYWJvdmUgYW5kIHNlbGVjdCB0aGUgb25lIGJlbG93LlxuICBpZiAoJGN1cnNvci5wYXJlbnQuY29udGVudC5zaXplID09IDAgJiZcbiAgICAgICh0ZXh0YmxvY2tBdChhZnRlciwgXCJzdGFydFwiKSB8fCBOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShhZnRlcikpKSB7XG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICB2YXIgdHIgPSBzdGF0ZS50ci5kZWxldGVSYW5nZSgkY3Vyc29yLmJlZm9yZSgpLCAkY3Vyc29yLmFmdGVyKCkpO1xuICAgICAgdHIuc2V0U2VsZWN0aW9uKHRleHRibG9ja0F0KGFmdGVyLCBcInN0YXJ0XCIpID8gU2VsZWN0aW9uLmZpbmRGcm9tKHRyLmRvYy5yZXNvbHZlKHRyLm1hcHBpbmcubWFwKCRjdXQucG9zKSksIDEpXG4gICAgICAgICAgICAgICAgICAgICAgOiBOb2RlU2VsZWN0aW9uLmNyZWF0ZSh0ci5kb2MsIHRyLm1hcHBpbmcubWFwKCRjdXQucG9zKSkpO1xuICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvLyBJZiB0aGUgbmV4dCBub2RlIGlzIGFuIGF0b20sIGRlbGV0ZSBpdFxuICBpZiAoYWZ0ZXIuaXNBdG9tICYmICRjdXQuZGVwdGggPT0gJGN1cnNvci5kZXB0aCAtIDEpIHtcbiAgICBpZiAoZGlzcGF0Y2gpIHsgZGlzcGF0Y2goc3RhdGUudHIuZGVsZXRlKCRjdXQucG9zLCAkY3V0LnBvcyArIGFmdGVyLm5vZGVTaXplKS5zY3JvbGxJbnRvVmlldygpKTsgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn1cblxuLy8gOjogKEVkaXRvclN0YXRlLCA/KHRyOiBUcmFuc2FjdGlvbiksID9FZGl0b3JWaWV3KSDihpIgYm9vbFxuLy8gV2hlbiB0aGUgc2VsZWN0aW9uIGlzIGVtcHR5IGFuZCBhdCB0aGUgZW5kIG9mIGEgdGV4dGJsb2NrLCBzZWxlY3Rcbi8vIHRoZSBub2RlIGNvbWluZyBhZnRlciB0aGF0IHRleHRibG9jaywgaWYgcG9zc2libGUuIFRoaXMgaXMgaW50ZW5kZWRcbi8vIHRvIGJlIGJvdW5kIHRvIGtleXMgbGlrZSBkZWxldGUsIGFmdGVyXG4vLyBbYGpvaW5Gb3J3YXJkYF0oI2NvbW1hbmRzLmpvaW5Gb3J3YXJkKSBhbmQgc2ltaWxhciBkZWxldGluZ1xuLy8gY29tbWFuZHMsIHRvIHByb3ZpZGUgYSBmYWxsLWJhY2sgYmVoYXZpb3Igd2hlbiB0aGUgc2NoZW1hIGRvZXNuJ3Rcbi8vIGFsbG93IGRlbGV0aW9uIGF0IHRoZSBzZWxlY3RlZCBwb2ludC5cbmZ1bmN0aW9uIHNlbGVjdE5vZGVGb3J3YXJkKHN0YXRlLCBkaXNwYXRjaCwgdmlldykge1xuICB2YXIgcmVmID0gc3RhdGUuc2VsZWN0aW9uO1xuICB2YXIgJGhlYWQgPSByZWYuJGhlYWQ7XG4gIHZhciBlbXB0eSA9IHJlZi5lbXB0eTtcbiAgdmFyICRjdXQgPSAkaGVhZDtcbiAgaWYgKCFlbXB0eSkgeyByZXR1cm4gZmFsc2UgfVxuICBpZiAoJGhlYWQucGFyZW50LmlzVGV4dGJsb2NrKSB7XG4gICAgaWYgKHZpZXcgPyAhdmlldy5lbmRPZlRleHRibG9jayhcImZvcndhcmRcIiwgc3RhdGUpIDogJGhlYWQucGFyZW50T2Zmc2V0IDwgJGhlYWQucGFyZW50LmNvbnRlbnQuc2l6ZSlcbiAgICAgIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAkY3V0ID0gZmluZEN1dEFmdGVyKCRoZWFkKTtcbiAgfVxuICB2YXIgbm9kZSA9ICRjdXQgJiYgJGN1dC5ub2RlQWZ0ZXI7XG4gIGlmICghbm9kZSB8fCAhTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUobm9kZSkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgaWYgKGRpc3BhdGNoKVxuICAgIHsgZGlzcGF0Y2goc3RhdGUudHIuc2V0U2VsZWN0aW9uKE5vZGVTZWxlY3Rpb24uY3JlYXRlKHN0YXRlLmRvYywgJGN1dC5wb3MpKS5zY3JvbGxJbnRvVmlldygpKTsgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBmaW5kQ3V0QWZ0ZXIoJHBvcykge1xuICBpZiAoISRwb3MucGFyZW50LnR5cGUuc3BlYy5pc29sYXRpbmcpIHsgZm9yICh2YXIgaSA9ICRwb3MuZGVwdGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBwYXJlbnQgPSAkcG9zLm5vZGUoaSk7XG4gICAgaWYgKCRwb3MuaW5kZXgoaSkgKyAxIDwgcGFyZW50LmNoaWxkQ291bnQpIHsgcmV0dXJuICRwb3MuZG9jLnJlc29sdmUoJHBvcy5hZnRlcihpICsgMSkpIH1cbiAgICBpZiAocGFyZW50LnR5cGUuc3BlYy5pc29sYXRpbmcpIHsgYnJlYWsgfVxuICB9IH1cbiAgcmV0dXJuIG51bGxcbn1cblxuLy8gOjogKEVkaXRvclN0YXRlLCA/KHRyOiBUcmFuc2FjdGlvbikpIOKGkiBib29sXG4vLyBKb2luIHRoZSBzZWxlY3RlZCBibG9jayBvciwgaWYgdGhlcmUgaXMgYSB0ZXh0IHNlbGVjdGlvbiwgdGhlXG4vLyBjbG9zZXN0IGFuY2VzdG9yIGJsb2NrIG9mIHRoZSBzZWxlY3Rpb24gdGhhdCBjYW4gYmUgam9pbmVkLCB3aXRoXG4vLyB0aGUgc2libGluZyBhYm92ZSBpdC5cbmZ1bmN0aW9uIGpvaW5VcChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgdmFyIHNlbCA9IHN0YXRlLnNlbGVjdGlvbiwgbm9kZVNlbCA9IHNlbCBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24sIHBvaW50O1xuICBpZiAobm9kZVNlbCkge1xuICAgIGlmIChzZWwubm9kZS5pc1RleHRibG9jayB8fCAhY2FuSm9pbihzdGF0ZS5kb2MsIHNlbC5mcm9tKSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIHBvaW50ID0gc2VsLmZyb207XG4gIH0gZWxzZSB7XG4gICAgcG9pbnQgPSBqb2luUG9pbnQoc3RhdGUuZG9jLCBzZWwuZnJvbSwgLTEpO1xuICAgIGlmIChwb2ludCA9PSBudWxsKSB7IHJldHVybiBmYWxzZSB9XG4gIH1cbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgdmFyIHRyID0gc3RhdGUudHIuam9pbihwb2ludCk7XG4gICAgaWYgKG5vZGVTZWwpIHsgdHIuc2V0U2VsZWN0aW9uKE5vZGVTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgcG9pbnQgLSBzdGF0ZS5kb2MucmVzb2x2ZShwb2ludCkubm9kZUJlZm9yZS5ub2RlU2l6ZSkpOyB9XG4gICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuLy8gOjogKEVkaXRvclN0YXRlLCA/KHRyOiBUcmFuc2FjdGlvbikpIOKGkiBib29sXG4vLyBKb2luIHRoZSBzZWxlY3RlZCBibG9jaywgb3IgdGhlIGNsb3Nlc3QgYW5jZXN0b3Igb2YgdGhlIHNlbGVjdGlvblxuLy8gdGhhdCBjYW4gYmUgam9pbmVkLCB3aXRoIHRoZSBzaWJsaW5nIGFmdGVyIGl0LlxuZnVuY3Rpb24gam9pbkRvd24oc3RhdGUsIGRpc3BhdGNoKSB7XG4gIHZhciBzZWwgPSBzdGF0ZS5zZWxlY3Rpb24sIHBvaW50O1xuICBpZiAoc2VsIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbikge1xuICAgIGlmIChzZWwubm9kZS5pc1RleHRibG9jayB8fCAhY2FuSm9pbihzdGF0ZS5kb2MsIHNlbC50bykpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBwb2ludCA9IHNlbC50bztcbiAgfSBlbHNlIHtcbiAgICBwb2ludCA9IGpvaW5Qb2ludChzdGF0ZS5kb2MsIHNlbC50bywgMSk7XG4gICAgaWYgKHBvaW50ID09IG51bGwpIHsgcmV0dXJuIGZhbHNlIH1cbiAgfVxuICBpZiAoZGlzcGF0Y2gpXG4gICAgeyBkaXNwYXRjaChzdGF0ZS50ci5qb2luKHBvaW50KS5zY3JvbGxJbnRvVmlldygpKTsgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG4vLyA6OiAoRWRpdG9yU3RhdGUsID8odHI6IFRyYW5zYWN0aW9uKSkg4oaSIGJvb2xcbi8vIExpZnQgdGhlIHNlbGVjdGVkIGJsb2NrLCBvciB0aGUgY2xvc2VzdCBhbmNlc3RvciBibG9jayBvZiB0aGVcbi8vIHNlbGVjdGlvbiB0aGF0IGNhbiBiZSBsaWZ0ZWQsIG91dCBvZiBpdHMgcGFyZW50IG5vZGUuXG5mdW5jdGlvbiBsaWZ0KHN0YXRlLCBkaXNwYXRjaCkge1xuICB2YXIgcmVmID0gc3RhdGUuc2VsZWN0aW9uO1xuICB2YXIgJGZyb20gPSByZWYuJGZyb207XG4gIHZhciAkdG8gPSByZWYuJHRvO1xuICB2YXIgcmFuZ2UgPSAkZnJvbS5ibG9ja1JhbmdlKCR0byksIHRhcmdldCA9IHJhbmdlICYmIGxpZnRUYXJnZXQocmFuZ2UpO1xuICBpZiAodGFyZ2V0ID09IG51bGwpIHsgcmV0dXJuIGZhbHNlIH1cbiAgaWYgKGRpc3BhdGNoKSB7IGRpc3BhdGNoKHN0YXRlLnRyLmxpZnQocmFuZ2UsIHRhcmdldCkuc2Nyb2xsSW50b1ZpZXcoKSk7IH1cbiAgcmV0dXJuIHRydWVcbn1cblxuLy8gOjogKEVkaXRvclN0YXRlLCA/KHRyOiBUcmFuc2FjdGlvbikpIOKGkiBib29sXG4vLyBJZiB0aGUgc2VsZWN0aW9uIGlzIGluIGEgbm9kZSB3aG9zZSB0eXBlIGhhcyBhIHRydXRoeVxuLy8gW2Bjb2RlYF0oI21vZGVsLk5vZGVTcGVjLmNvZGUpIHByb3BlcnR5IGluIGl0cyBzcGVjLCByZXBsYWNlIHRoZVxuLy8gc2VsZWN0aW9uIHdpdGggYSBuZXdsaW5lIGNoYXJhY3Rlci5cbmZ1bmN0aW9uIG5ld2xpbmVJbkNvZGUoc3RhdGUsIGRpc3BhdGNoKSB7XG4gIHZhciByZWYgPSBzdGF0ZS5zZWxlY3Rpb247XG4gIHZhciAkaGVhZCA9IHJlZi4kaGVhZDtcbiAgdmFyICRhbmNob3IgPSByZWYuJGFuY2hvcjtcbiAgaWYgKCEkaGVhZC5wYXJlbnQudHlwZS5zcGVjLmNvZGUgfHwgISRoZWFkLnNhbWVQYXJlbnQoJGFuY2hvcikpIHsgcmV0dXJuIGZhbHNlIH1cbiAgaWYgKGRpc3BhdGNoKSB7IGRpc3BhdGNoKHN0YXRlLnRyLmluc2VydFRleHQoXCJcXG5cIikuc2Nyb2xsSW50b1ZpZXcoKSk7IH1cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gZGVmYXVsdEJsb2NrQXQobWF0Y2gpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXRjaC5lZGdlQ291bnQ7IGkrKykge1xuICAgIHZhciByZWYgPSBtYXRjaC5lZGdlKGkpO1xuICAgIHZhciB0eXBlID0gcmVmLnR5cGU7XG4gICAgaWYgKHR5cGUuaXNUZXh0YmxvY2sgJiYgIXR5cGUuaGFzUmVxdWlyZWRBdHRycygpKSB7IHJldHVybiB0eXBlIH1cbiAgfVxuICByZXR1cm4gbnVsbFxufVxuXG4vLyA6OiAoRWRpdG9yU3RhdGUsID8odHI6IFRyYW5zYWN0aW9uKSkg4oaSIGJvb2xcbi8vIFdoZW4gdGhlIHNlbGVjdGlvbiBpcyBpbiBhIG5vZGUgd2l0aCBhIHRydXRoeVxuLy8gW2Bjb2RlYF0oI21vZGVsLk5vZGVTcGVjLmNvZGUpIHByb3BlcnR5IGluIGl0cyBzcGVjLCBjcmVhdGUgYVxuLy8gZGVmYXVsdCBibG9jayBhZnRlciB0aGUgY29kZSBibG9jaywgYW5kIG1vdmUgdGhlIGN1cnNvciB0aGVyZS5cbmZ1bmN0aW9uIGV4aXRDb2RlKHN0YXRlLCBkaXNwYXRjaCkge1xuICB2YXIgcmVmID0gc3RhdGUuc2VsZWN0aW9uO1xuICB2YXIgJGhlYWQgPSByZWYuJGhlYWQ7XG4gIHZhciAkYW5jaG9yID0gcmVmLiRhbmNob3I7XG4gIGlmICghJGhlYWQucGFyZW50LnR5cGUuc3BlYy5jb2RlIHx8ICEkaGVhZC5zYW1lUGFyZW50KCRhbmNob3IpKSB7IHJldHVybiBmYWxzZSB9XG4gIHZhciBhYm92ZSA9ICRoZWFkLm5vZGUoLTEpLCBhZnRlciA9ICRoZWFkLmluZGV4QWZ0ZXIoLTEpLCB0eXBlID0gZGVmYXVsdEJsb2NrQXQoYWJvdmUuY29udGVudE1hdGNoQXQoYWZ0ZXIpKTtcbiAgaWYgKCFhYm92ZS5jYW5SZXBsYWNlV2l0aChhZnRlciwgYWZ0ZXIsIHR5cGUpKSB7IHJldHVybiBmYWxzZSB9XG4gIGlmIChkaXNwYXRjaCkge1xuICAgIHZhciBwb3MgPSAkaGVhZC5hZnRlcigpLCB0ciA9IHN0YXRlLnRyLnJlcGxhY2VXaXRoKHBvcywgcG9zLCB0eXBlLmNyZWF0ZUFuZEZpbGwoKSk7XG4gICAgdHIuc2V0U2VsZWN0aW9uKFNlbGVjdGlvbi5uZWFyKHRyLmRvYy5yZXNvbHZlKHBvcyksIDEpKTtcbiAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG4vLyA6OiAoRWRpdG9yU3RhdGUsID8odHI6IFRyYW5zYWN0aW9uKSkg4oaSIGJvb2xcbi8vIElmIGEgYmxvY2sgbm9kZSBpcyBzZWxlY3RlZCwgY3JlYXRlIGFuIGVtcHR5IHBhcmFncmFwaCBiZWZvcmUgKGlmXG4vLyBpdCBpcyBpdHMgcGFyZW50J3MgZmlyc3QgY2hpbGQpIG9yIGFmdGVyIGl0LlxuZnVuY3Rpb24gY3JlYXRlUGFyYWdyYXBoTmVhcihzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgdmFyIHNlbCA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgdmFyICRmcm9tID0gc2VsLiRmcm9tO1xuICB2YXIgJHRvID0gc2VsLiR0bztcbiAgaWYgKHNlbCBpbnN0YW5jZW9mIEFsbFNlbGVjdGlvbiB8fCAkZnJvbS5wYXJlbnQuaW5saW5lQ29udGVudCB8fCAkdG8ucGFyZW50LmlubGluZUNvbnRlbnQpIHsgcmV0dXJuIGZhbHNlIH1cbiAgdmFyIHR5cGUgPSBkZWZhdWx0QmxvY2tBdCgkdG8ucGFyZW50LmNvbnRlbnRNYXRjaEF0KCR0by5pbmRleEFmdGVyKCkpKTtcbiAgaWYgKCF0eXBlIHx8ICF0eXBlLmlzVGV4dGJsb2NrKSB7IHJldHVybiBmYWxzZSB9XG4gIGlmIChkaXNwYXRjaCkge1xuICAgIHZhciBzaWRlID0gKCEkZnJvbS5wYXJlbnRPZmZzZXQgJiYgJHRvLmluZGV4KCkgPCAkdG8ucGFyZW50LmNoaWxkQ291bnQgPyAkZnJvbSA6ICR0bykucG9zO1xuICAgIHZhciB0ciA9IHN0YXRlLnRyLmluc2VydChzaWRlLCB0eXBlLmNyZWF0ZUFuZEZpbGwoKSk7XG4gICAgdHIuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgc2lkZSArIDEpKTtcbiAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG4vLyA6OiAoRWRpdG9yU3RhdGUsID8odHI6IFRyYW5zYWN0aW9uKSkg4oaSIGJvb2xcbi8vIElmIHRoZSBjdXJzb3IgaXMgaW4gYW4gZW1wdHkgdGV4dGJsb2NrIHRoYXQgY2FuIGJlIGxpZnRlZCwgbGlmdCB0aGVcbi8vIGJsb2NrLlxuZnVuY3Rpb24gbGlmdEVtcHR5QmxvY2soc3RhdGUsIGRpc3BhdGNoKSB7XG4gIHZhciByZWYgPSBzdGF0ZS5zZWxlY3Rpb247XG4gIHZhciAkY3Vyc29yID0gcmVmLiRjdXJzb3I7XG4gIGlmICghJGN1cnNvciB8fCAkY3Vyc29yLnBhcmVudC5jb250ZW50LnNpemUpIHsgcmV0dXJuIGZhbHNlIH1cbiAgaWYgKCRjdXJzb3IuZGVwdGggPiAxICYmICRjdXJzb3IuYWZ0ZXIoKSAhPSAkY3Vyc29yLmVuZCgtMSkpIHtcbiAgICB2YXIgYmVmb3JlID0gJGN1cnNvci5iZWZvcmUoKTtcbiAgICBpZiAoY2FuU3BsaXQoc3RhdGUuZG9jLCBiZWZvcmUpKSB7XG4gICAgICBpZiAoZGlzcGF0Y2gpIHsgZGlzcGF0Y2goc3RhdGUudHIuc3BsaXQoYmVmb3JlKS5zY3JvbGxJbnRvVmlldygpKTsgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgdmFyIHJhbmdlID0gJGN1cnNvci5ibG9ja1JhbmdlKCksIHRhcmdldCA9IHJhbmdlICYmIGxpZnRUYXJnZXQocmFuZ2UpO1xuICBpZiAodGFyZ2V0ID09IG51bGwpIHsgcmV0dXJuIGZhbHNlIH1cbiAgaWYgKGRpc3BhdGNoKSB7IGRpc3BhdGNoKHN0YXRlLnRyLmxpZnQocmFuZ2UsIHRhcmdldCkuc2Nyb2xsSW50b1ZpZXcoKSk7IH1cbiAgcmV0dXJuIHRydWVcbn1cblxuLy8gOjogKEVkaXRvclN0YXRlLCA/KHRyOiBUcmFuc2FjdGlvbikpIOKGkiBib29sXG4vLyBTcGxpdCB0aGUgcGFyZW50IGJsb2NrIG9mIHRoZSBzZWxlY3Rpb24uIElmIHRoZSBzZWxlY3Rpb24gaXMgYSB0ZXh0XG4vLyBzZWxlY3Rpb24sIGFsc28gZGVsZXRlIGl0cyBjb250ZW50LlxuZnVuY3Rpb24gc3BsaXRCbG9jayhzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgdmFyIHJlZiA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgdmFyICRmcm9tID0gcmVmLiRmcm9tO1xuICB2YXIgJHRvID0gcmVmLiR0bztcbiAgaWYgKHN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24gJiYgc3RhdGUuc2VsZWN0aW9uLm5vZGUuaXNCbG9jaykge1xuICAgIGlmICghJGZyb20ucGFyZW50T2Zmc2V0IHx8ICFjYW5TcGxpdChzdGF0ZS5kb2MsICRmcm9tLnBvcykpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBpZiAoZGlzcGF0Y2gpIHsgZGlzcGF0Y2goc3RhdGUudHIuc3BsaXQoJGZyb20ucG9zKS5zY3JvbGxJbnRvVmlldygpKTsgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBpZiAoISRmcm9tLnBhcmVudC5pc0Jsb2NrKSB7IHJldHVybiBmYWxzZSB9XG5cbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgdmFyIGF0RW5kID0gJHRvLnBhcmVudE9mZnNldCA9PSAkdG8ucGFyZW50LmNvbnRlbnQuc2l6ZTtcbiAgICB2YXIgdHIgPSBzdGF0ZS50cjtcbiAgICBpZiAoc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbiB8fCBzdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBBbGxTZWxlY3Rpb24pIHsgdHIuZGVsZXRlU2VsZWN0aW9uKCk7IH1cbiAgICB2YXIgZGVmbHQgPSAkZnJvbS5kZXB0aCA9PSAwID8gbnVsbCA6IGRlZmF1bHRCbG9ja0F0KCRmcm9tLm5vZGUoLTEpLmNvbnRlbnRNYXRjaEF0KCRmcm9tLmluZGV4QWZ0ZXIoLTEpKSk7XG4gICAgdmFyIHR5cGVzID0gYXRFbmQgJiYgZGVmbHQgPyBbe3R5cGU6IGRlZmx0fV0gOiBudWxsO1xuICAgIHZhciBjYW4gPSBjYW5TcGxpdCh0ci5kb2MsIHRyLm1hcHBpbmcubWFwKCRmcm9tLnBvcyksIDEsIHR5cGVzKTtcbiAgICBpZiAoIXR5cGVzICYmICFjYW4gJiYgY2FuU3BsaXQodHIuZG9jLCB0ci5tYXBwaW5nLm1hcCgkZnJvbS5wb3MpLCAxLCBkZWZsdCAmJiBbe3R5cGU6IGRlZmx0fV0pKSB7XG4gICAgICB0eXBlcyA9IFt7dHlwZTogZGVmbHR9XTtcbiAgICAgIGNhbiA9IHRydWU7XG4gICAgfVxuICAgIGlmIChjYW4pIHtcbiAgICAgIHRyLnNwbGl0KHRyLm1hcHBpbmcubWFwKCRmcm9tLnBvcyksIDEsIHR5cGVzKTtcbiAgICAgIGlmICghYXRFbmQgJiYgISRmcm9tLnBhcmVudE9mZnNldCAmJiAkZnJvbS5wYXJlbnQudHlwZSAhPSBkZWZsdCkge1xuICAgICAgICB2YXIgZmlyc3QgPSB0ci5tYXBwaW5nLm1hcCgkZnJvbS5iZWZvcmUoKSksICRmaXJzdCA9IHRyLmRvYy5yZXNvbHZlKGZpcnN0KTtcbiAgICAgICAgaWYgKCRmcm9tLm5vZGUoLTEpLmNhblJlcGxhY2VXaXRoKCRmaXJzdC5pbmRleCgpLCAkZmlyc3QuaW5kZXgoKSArIDEsIGRlZmx0KSlcbiAgICAgICAgICB7IHRyLnNldE5vZGVNYXJrdXAodHIubWFwcGluZy5tYXAoJGZyb20uYmVmb3JlKCkpLCBkZWZsdCk7IH1cbiAgICAgIH1cbiAgICB9XG4gICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuLy8gOjogKEVkaXRvclN0YXRlLCA/KHRyOiBUcmFuc2FjdGlvbikpIOKGkiBib29sXG4vLyBBY3RzIGxpa2UgW2BzcGxpdEJsb2NrYF0oI2NvbW1hbmRzLnNwbGl0QmxvY2spLCBidXQgd2l0aG91dFxuLy8gcmVzZXR0aW5nIHRoZSBzZXQgb2YgYWN0aXZlIG1hcmtzIGF0IHRoZSBjdXJzb3IuXG5mdW5jdGlvbiBzcGxpdEJsb2NrS2VlcE1hcmtzKHN0YXRlLCBkaXNwYXRjaCkge1xuICByZXR1cm4gc3BsaXRCbG9jayhzdGF0ZSwgZGlzcGF0Y2ggJiYgKGZ1bmN0aW9uICh0cikge1xuICAgIHZhciBtYXJrcyA9IHN0YXRlLnN0b3JlZE1hcmtzIHx8IChzdGF0ZS5zZWxlY3Rpb24uJHRvLnBhcmVudE9mZnNldCAmJiBzdGF0ZS5zZWxlY3Rpb24uJGZyb20ubWFya3MoKSk7XG4gICAgaWYgKG1hcmtzKSB7IHRyLmVuc3VyZU1hcmtzKG1hcmtzKTsgfVxuICAgIGRpc3BhdGNoKHRyKTtcbiAgfSkpXG59XG5cbi8vIDo6IChFZGl0b3JTdGF0ZSwgPyh0cjogVHJhbnNhY3Rpb24pKSDihpIgYm9vbFxuLy8gTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBub2RlIHdyYXBwaW5nIHRoZSBjdXJyZW50IHNlbGVjdGlvbiwgaWZcbi8vIGFueS4gKFdpbGwgbm90IHNlbGVjdCB0aGUgZG9jdW1lbnQgbm9kZS4pXG5mdW5jdGlvbiBzZWxlY3RQYXJlbnROb2RlKHN0YXRlLCBkaXNwYXRjaCkge1xuICB2YXIgcmVmID0gc3RhdGUuc2VsZWN0aW9uO1xuICB2YXIgJGZyb20gPSByZWYuJGZyb207XG4gIHZhciB0byA9IHJlZi50bztcbiAgdmFyIHBvcztcbiAgdmFyIHNhbWUgPSAkZnJvbS5zaGFyZWREZXB0aCh0byk7XG4gIGlmIChzYW1lID09IDApIHsgcmV0dXJuIGZhbHNlIH1cbiAgcG9zID0gJGZyb20uYmVmb3JlKHNhbWUpO1xuICBpZiAoZGlzcGF0Y2gpIHsgZGlzcGF0Y2goc3RhdGUudHIuc2V0U2VsZWN0aW9uKE5vZGVTZWxlY3Rpb24uY3JlYXRlKHN0YXRlLmRvYywgcG9zKSkpOyB9XG4gIHJldHVybiB0cnVlXG59XG5cbi8vIDo6IChFZGl0b3JTdGF0ZSwgPyh0cjogVHJhbnNhY3Rpb24pKSDihpIgYm9vbFxuLy8gU2VsZWN0IHRoZSB3aG9sZSBkb2N1bWVudC5cbmZ1bmN0aW9uIHNlbGVjdEFsbChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgaWYgKGRpc3BhdGNoKSB7IGRpc3BhdGNoKHN0YXRlLnRyLnNldFNlbGVjdGlvbihuZXcgQWxsU2VsZWN0aW9uKHN0YXRlLmRvYykpKTsgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBqb2luTWF5YmVDbGVhcihzdGF0ZSwgJHBvcywgZGlzcGF0Y2gpIHtcbiAgdmFyIGJlZm9yZSA9ICRwb3Mubm9kZUJlZm9yZSwgYWZ0ZXIgPSAkcG9zLm5vZGVBZnRlciwgaW5kZXggPSAkcG9zLmluZGV4KCk7XG4gIGlmICghYmVmb3JlIHx8ICFhZnRlciB8fCAhYmVmb3JlLnR5cGUuY29tcGF0aWJsZUNvbnRlbnQoYWZ0ZXIudHlwZSkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgaWYgKCFiZWZvcmUuY29udGVudC5zaXplICYmICRwb3MucGFyZW50LmNhblJlcGxhY2UoaW5kZXggLSAxLCBpbmRleCkpIHtcbiAgICBpZiAoZGlzcGF0Y2gpIHsgZGlzcGF0Y2goc3RhdGUudHIuZGVsZXRlKCRwb3MucG9zIC0gYmVmb3JlLm5vZGVTaXplLCAkcG9zLnBvcykuc2Nyb2xsSW50b1ZpZXcoKSk7IH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGlmICghJHBvcy5wYXJlbnQuY2FuUmVwbGFjZShpbmRleCwgaW5kZXggKyAxKSB8fCAhKGFmdGVyLmlzVGV4dGJsb2NrIHx8IGNhbkpvaW4oc3RhdGUuZG9jLCAkcG9zLnBvcykpKVxuICAgIHsgcmV0dXJuIGZhbHNlIH1cbiAgaWYgKGRpc3BhdGNoKVxuICAgIHsgZGlzcGF0Y2goc3RhdGUudHJcbiAgICAgICAgICAgICAuY2xlYXJJbmNvbXBhdGlibGUoJHBvcy5wb3MsIGJlZm9yZS50eXBlLCBiZWZvcmUuY29udGVudE1hdGNoQXQoYmVmb3JlLmNoaWxkQ291bnQpKVxuICAgICAgICAgICAgIC5qb2luKCRwb3MucG9zKVxuICAgICAgICAgICAgIC5zY3JvbGxJbnRvVmlldygpKTsgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBkZWxldGVCYXJyaWVyKHN0YXRlLCAkY3V0LCBkaXNwYXRjaCkge1xuICB2YXIgYmVmb3JlID0gJGN1dC5ub2RlQmVmb3JlLCBhZnRlciA9ICRjdXQubm9kZUFmdGVyLCBjb25uLCBtYXRjaDtcbiAgaWYgKGJlZm9yZS50eXBlLnNwZWMuaXNvbGF0aW5nIHx8IGFmdGVyLnR5cGUuc3BlYy5pc29sYXRpbmcpIHsgcmV0dXJuIGZhbHNlIH1cbiAgaWYgKGpvaW5NYXliZUNsZWFyKHN0YXRlLCAkY3V0LCBkaXNwYXRjaCkpIHsgcmV0dXJuIHRydWUgfVxuXG4gIHZhciBjYW5EZWxBZnRlciA9ICRjdXQucGFyZW50LmNhblJlcGxhY2UoJGN1dC5pbmRleCgpLCAkY3V0LmluZGV4KCkgKyAxKTtcbiAgaWYgKGNhbkRlbEFmdGVyICYmXG4gICAgICAoY29ubiA9IChtYXRjaCA9IGJlZm9yZS5jb250ZW50TWF0Y2hBdChiZWZvcmUuY2hpbGRDb3VudCkpLmZpbmRXcmFwcGluZyhhZnRlci50eXBlKSkgJiZcbiAgICAgIG1hdGNoLm1hdGNoVHlwZShjb25uWzBdIHx8IGFmdGVyLnR5cGUpLnZhbGlkRW5kKSB7XG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICB2YXIgZW5kID0gJGN1dC5wb3MgKyBhZnRlci5ub2RlU2l6ZSwgd3JhcCA9IEZyYWdtZW50LmVtcHR5O1xuICAgICAgZm9yICh2YXIgaSA9IGNvbm4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIHsgd3JhcCA9IEZyYWdtZW50LmZyb20oY29ubltpXS5jcmVhdGUobnVsbCwgd3JhcCkpOyB9XG4gICAgICB3cmFwID0gRnJhZ21lbnQuZnJvbShiZWZvcmUuY29weSh3cmFwKSk7XG4gICAgICB2YXIgdHIgPSBzdGF0ZS50ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcCgkY3V0LnBvcyAtIDEsIGVuZCwgJGN1dC5wb3MsIGVuZCwgbmV3IFNsaWNlKHdyYXAsIDEsIDApLCBjb25uLmxlbmd0aCwgdHJ1ZSkpO1xuICAgICAgdmFyIGpvaW5BdCA9IGVuZCArIDIgKiBjb25uLmxlbmd0aDtcbiAgICAgIGlmIChjYW5Kb2luKHRyLmRvYywgam9pbkF0KSkgeyB0ci5qb2luKGpvaW5BdCk7IH1cbiAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgdmFyIHNlbEFmdGVyID0gU2VsZWN0aW9uLmZpbmRGcm9tKCRjdXQsIDEpO1xuICB2YXIgcmFuZ2UgPSBzZWxBZnRlciAmJiBzZWxBZnRlci4kZnJvbS5ibG9ja1JhbmdlKHNlbEFmdGVyLiR0byksIHRhcmdldCA9IHJhbmdlICYmIGxpZnRUYXJnZXQocmFuZ2UpO1xuICBpZiAodGFyZ2V0ICE9IG51bGwgJiYgdGFyZ2V0ID49ICRjdXQuZGVwdGgpIHtcbiAgICBpZiAoZGlzcGF0Y2gpIHsgZGlzcGF0Y2goc3RhdGUudHIubGlmdChyYW5nZSwgdGFyZ2V0KS5zY3JvbGxJbnRvVmlldygpKTsgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBpZiAoY2FuRGVsQWZ0ZXIgJiYgdGV4dGJsb2NrQXQoYWZ0ZXIsIFwic3RhcnRcIiwgdHJ1ZSkgJiYgdGV4dGJsb2NrQXQoYmVmb3JlLCBcImVuZFwiKSkge1xuICAgIHZhciBhdCA9IGJlZm9yZSwgd3JhcCQxID0gW107XG4gICAgZm9yICg7Oykge1xuICAgICAgd3JhcCQxLnB1c2goYXQpO1xuICAgICAgaWYgKGF0LmlzVGV4dGJsb2NrKSB7IGJyZWFrIH1cbiAgICAgIGF0ID0gYXQubGFzdENoaWxkO1xuICAgIH1cbiAgICB2YXIgYWZ0ZXJUZXh0ID0gYWZ0ZXIsIGFmdGVyRGVwdGggPSAxO1xuICAgIGZvciAoOyAhYWZ0ZXJUZXh0LmlzVGV4dGJsb2NrOyBhZnRlclRleHQgPSBhZnRlclRleHQuZmlyc3RDaGlsZCkgeyBhZnRlckRlcHRoKys7IH1cbiAgICBpZiAoYXQuY2FuUmVwbGFjZShhdC5jaGlsZENvdW50LCBhdC5jaGlsZENvdW50LCBhZnRlclRleHQuY29udGVudCkpIHtcbiAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICB2YXIgZW5kJDEgPSBGcmFnbWVudC5lbXB0eTtcbiAgICAgICAgZm9yICh2YXIgaSQxID0gd3JhcCQxLmxlbmd0aCAtIDE7IGkkMSA+PSAwOyBpJDEtLSkgeyBlbmQkMSA9IEZyYWdtZW50LmZyb20od3JhcCQxW2kkMV0uY29weShlbmQkMSkpOyB9XG4gICAgICAgIHZhciB0ciQxID0gc3RhdGUudHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoJGN1dC5wb3MgLSB3cmFwJDEubGVuZ3RoLCAkY3V0LnBvcyArIGFmdGVyLm5vZGVTaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkY3V0LnBvcyArIGFmdGVyRGVwdGgsICRjdXQucG9zICsgYWZ0ZXIubm9kZVNpemUgLSBhZnRlckRlcHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgU2xpY2UoZW5kJDEsIHdyYXAkMS5sZW5ndGgsIDApLCAwLCB0cnVlKSk7XG4gICAgICAgIGRpc3BhdGNoKHRyJDEuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufVxuXG4vLyBQYXJhbWV0ZXJpemVkIGNvbW1hbmRzXG5cbi8vIDo6IChOb2RlVHlwZSwgP09iamVjdCkg4oaSIChzdGF0ZTogRWRpdG9yU3RhdGUsIGRpc3BhdGNoOiA/KHRyOiBUcmFuc2FjdGlvbikpIOKGkiBib29sXG4vLyBXcmFwIHRoZSBzZWxlY3Rpb24gaW4gYSBub2RlIG9mIHRoZSBnaXZlbiB0eXBlIHdpdGggdGhlIGdpdmVuXG4vLyBhdHRyaWJ1dGVzLlxuZnVuY3Rpb24gd3JhcEluKG5vZGVUeXBlLCBhdHRycykge1xuICByZXR1cm4gZnVuY3Rpb24oc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgdmFyIHJlZiA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICB2YXIgJGZyb20gPSByZWYuJGZyb207XG4gICAgdmFyICR0byA9IHJlZi4kdG87XG4gICAgdmFyIHJhbmdlID0gJGZyb20uYmxvY2tSYW5nZSgkdG8pLCB3cmFwcGluZyA9IHJhbmdlICYmIGZpbmRXcmFwcGluZyhyYW5nZSwgbm9kZVR5cGUsIGF0dHJzKTtcbiAgICBpZiAoIXdyYXBwaW5nKSB7IHJldHVybiBmYWxzZSB9XG4gICAgaWYgKGRpc3BhdGNoKSB7IGRpc3BhdGNoKHN0YXRlLnRyLndyYXAocmFuZ2UsIHdyYXBwaW5nKS5zY3JvbGxJbnRvVmlldygpKTsgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cbn1cblxuLy8gOjogKE5vZGVUeXBlLCA/T2JqZWN0KSDihpIgKHN0YXRlOiBFZGl0b3JTdGF0ZSwgZGlzcGF0Y2g6ID8odHI6IFRyYW5zYWN0aW9uKSkg4oaSIGJvb2xcbi8vIFJldHVybnMgYSBjb21tYW5kIHRoYXQgdHJpZXMgdG8gc2V0IHRoZSBzZWxlY3RlZCB0ZXh0YmxvY2tzIHRvIHRoZVxuLy8gZ2l2ZW4gbm9kZSB0eXBlIHdpdGggdGhlIGdpdmVuIGF0dHJpYnV0ZXMuXG5mdW5jdGlvbiBzZXRCbG9ja1R5cGUobm9kZVR5cGUsIGF0dHJzKSB7XG4gIHJldHVybiBmdW5jdGlvbihzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICB2YXIgcmVmID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIHZhciBmcm9tID0gcmVmLmZyb207XG4gICAgdmFyIHRvID0gcmVmLnRvO1xuICAgIHZhciBhcHBsaWNhYmxlID0gZmFsc2U7XG4gICAgc3RhdGUuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgZnVuY3Rpb24gKG5vZGUsIHBvcykge1xuICAgICAgaWYgKGFwcGxpY2FibGUpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAgIGlmICghbm9kZS5pc1RleHRibG9jayB8fCBub2RlLmhhc01hcmt1cChub2RlVHlwZSwgYXR0cnMpKSB7IHJldHVybiB9XG4gICAgICBpZiAobm9kZS50eXBlID09IG5vZGVUeXBlKSB7XG4gICAgICAgIGFwcGxpY2FibGUgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyICRwb3MgPSBzdGF0ZS5kb2MucmVzb2x2ZShwb3MpLCBpbmRleCA9ICRwb3MuaW5kZXgoKTtcbiAgICAgICAgYXBwbGljYWJsZSA9ICRwb3MucGFyZW50LmNhblJlcGxhY2VXaXRoKGluZGV4LCBpbmRleCArIDEsIG5vZGVUeXBlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIWFwcGxpY2FibGUpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBpZiAoZGlzcGF0Y2gpIHsgZGlzcGF0Y2goc3RhdGUudHIuc2V0QmxvY2tUeXBlKGZyb20sIHRvLCBub2RlVHlwZSwgYXR0cnMpLnNjcm9sbEludG9WaWV3KCkpOyB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrQXBwbGllcyhkb2MsIHJhbmdlcywgdHlwZSkge1xuICB2YXIgbG9vcCA9IGZ1bmN0aW9uICggaSApIHtcbiAgICB2YXIgcmVmID0gcmFuZ2VzW2ldO1xuICAgIHZhciAkZnJvbSA9IHJlZi4kZnJvbTtcbiAgICB2YXIgJHRvID0gcmVmLiR0bztcbiAgICB2YXIgY2FuID0gJGZyb20uZGVwdGggPT0gMCA/IGRvYy50eXBlLmFsbG93c01hcmtUeXBlKHR5cGUpIDogZmFsc2U7XG4gICAgZG9jLm5vZGVzQmV0d2VlbigkZnJvbS5wb3MsICR0by5wb3MsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICBpZiAoY2FuKSB7IHJldHVybiBmYWxzZSB9XG4gICAgICBjYW4gPSBub2RlLmlubGluZUNvbnRlbnQgJiYgbm9kZS50eXBlLmFsbG93c01hcmtUeXBlKHR5cGUpO1xuICAgIH0pO1xuICAgIGlmIChjYW4pIHsgcmV0dXJuIHsgdjogdHJ1ZSB9IH1cbiAgfTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciByZXR1cm5lZCA9IGxvb3AoIGkgKTtcblxuICAgIGlmICggcmV0dXJuZWQgKSByZXR1cm4gcmV0dXJuZWQudjtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLy8gOjogKE1hcmtUeXBlLCA/T2JqZWN0KSDihpIgKHN0YXRlOiBFZGl0b3JTdGF0ZSwgZGlzcGF0Y2g6ID8odHI6IFRyYW5zYWN0aW9uKSkg4oaSIGJvb2xcbi8vIENyZWF0ZSBhIGNvbW1hbmQgZnVuY3Rpb24gdGhhdCB0b2dnbGVzIHRoZSBnaXZlbiBtYXJrIHdpdGggdGhlXG4vLyBnaXZlbiBhdHRyaWJ1dGVzLiBXaWxsIHJldHVybiBgZmFsc2VgIHdoZW4gdGhlIGN1cnJlbnQgc2VsZWN0aW9uXG4vLyBkb2Vzbid0IHN1cHBvcnQgdGhhdCBtYXJrLiBUaGlzIHdpbGwgcmVtb3ZlIHRoZSBtYXJrIGlmIGFueSBtYXJrc1xuLy8gb2YgdGhhdCB0eXBlIGV4aXN0IGluIHRoZSBzZWxlY3Rpb24sIG9yIGFkZCBpdCBvdGhlcndpc2UuIElmIHRoZVxuLy8gc2VsZWN0aW9uIGlzIGVtcHR5LCB0aGlzIGFwcGxpZXMgdG8gdGhlIFtzdG9yZWRcbi8vIG1hcmtzXSgjc3RhdGUuRWRpdG9yU3RhdGUuc3RvcmVkTWFya3MpIGluc3RlYWQgb2YgYSByYW5nZSBvZiB0aGVcbi8vIGRvY3VtZW50LlxuZnVuY3Rpb24gdG9nZ2xlTWFyayhtYXJrVHlwZSwgYXR0cnMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgIHZhciByZWYgPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgdmFyIGVtcHR5ID0gcmVmLmVtcHR5O1xuICAgIHZhciAkY3Vyc29yID0gcmVmLiRjdXJzb3I7XG4gICAgdmFyIHJhbmdlcyA9IHJlZi5yYW5nZXM7XG4gICAgaWYgKChlbXB0eSAmJiAhJGN1cnNvcikgfHwgIW1hcmtBcHBsaWVzKHN0YXRlLmRvYywgcmFuZ2VzLCBtYXJrVHlwZSkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgIGlmICgkY3Vyc29yKSB7XG4gICAgICAgIGlmIChtYXJrVHlwZS5pc0luU2V0KHN0YXRlLnN0b3JlZE1hcmtzIHx8ICRjdXJzb3IubWFya3MoKSkpXG4gICAgICAgICAgeyBkaXNwYXRjaChzdGF0ZS50ci5yZW1vdmVTdG9yZWRNYXJrKG1hcmtUeXBlKSk7IH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgIHsgZGlzcGF0Y2goc3RhdGUudHIuYWRkU3RvcmVkTWFyayhtYXJrVHlwZS5jcmVhdGUoYXR0cnMpKSk7IH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBoYXMgPSBmYWxzZSwgdHIgPSBzdGF0ZS50cjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7ICFoYXMgJiYgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciByZWYkMSA9IHJhbmdlc1tpXTtcbiAgICAgICAgICB2YXIgJGZyb20gPSByZWYkMS4kZnJvbTtcbiAgICAgICAgICB2YXIgJHRvID0gcmVmJDEuJHRvO1xuICAgICAgICAgIGhhcyA9IHN0YXRlLmRvYy5yYW5nZUhhc01hcmsoJGZyb20ucG9zLCAkdG8ucG9zLCBtYXJrVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgcmFuZ2VzLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgICB2YXIgcmVmJDIgPSByYW5nZXNbaSQxXTtcbiAgICAgICAgICB2YXIgJGZyb20kMSA9IHJlZiQyLiRmcm9tO1xuICAgICAgICAgIHZhciAkdG8kMSA9IHJlZiQyLiR0bztcbiAgICAgICAgICBpZiAoaGFzKSB7XG4gICAgICAgICAgICB0ci5yZW1vdmVNYXJrKCRmcm9tJDEucG9zLCAkdG8kMS5wb3MsIG1hcmtUeXBlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGZyb20gPSAkZnJvbSQxLnBvcywgdG8gPSAkdG8kMS5wb3MsIHN0YXJ0ID0gJGZyb20kMS5ub2RlQWZ0ZXIsIGVuZCA9ICR0byQxLm5vZGVCZWZvcmU7XG4gICAgICAgICAgICB2YXIgc3BhY2VTdGFydCA9IHN0YXJ0ICYmIHN0YXJ0LmlzVGV4dCA/IC9eXFxzKi8uZXhlYyhzdGFydC50ZXh0KVswXS5sZW5ndGggOiAwO1xuICAgICAgICAgICAgdmFyIHNwYWNlRW5kID0gZW5kICYmIGVuZC5pc1RleHQgPyAvXFxzKiQvLmV4ZWMoZW5kLnRleHQpWzBdLmxlbmd0aCA6IDA7XG4gICAgICAgICAgICBpZiAoZnJvbSArIHNwYWNlU3RhcnQgPCB0bykgeyBmcm9tICs9IHNwYWNlU3RhcnQ7IHRvIC09IHNwYWNlRW5kOyB9XG4gICAgICAgICAgICB0ci5hZGRNYXJrKGZyb20sIHRvLCBtYXJrVHlwZS5jcmVhdGUoYXR0cnMpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cbn1cblxuZnVuY3Rpb24gd3JhcERpc3BhdGNoRm9ySm9pbihkaXNwYXRjaCwgaXNKb2luYWJsZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKHRyKSB7XG4gICAgaWYgKCF0ci5pc0dlbmVyaWMpIHsgcmV0dXJuIGRpc3BhdGNoKHRyKSB9XG5cbiAgICB2YXIgcmFuZ2VzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ci5tYXBwaW5nLm1hcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBtYXAgPSB0ci5tYXBwaW5nLm1hcHNbaV07XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJhbmdlcy5sZW5ndGg7IGorKylcbiAgICAgICAgeyByYW5nZXNbal0gPSBtYXAubWFwKHJhbmdlc1tqXSk7IH1cbiAgICAgIG1hcC5mb3JFYWNoKGZ1bmN0aW9uIChfcywgX2UsIGZyb20sIHRvKSB7IHJldHVybiByYW5nZXMucHVzaChmcm9tLCB0byk7IH0pO1xuICAgIH1cblxuICAgIC8vIEZpZ3VyZSBvdXQgd2hpY2ggam9pbmFibGUgcG9pbnRzIGV4aXN0IGluc2lkZSB0aG9zZSByYW5nZXMsXG4gICAgLy8gYnkgY2hlY2tpbmcgYWxsIG5vZGUgYm91bmRhcmllcyBpbiB0aGVpciBwYXJlbnQgbm9kZXMuXG4gICAgdmFyIGpvaW5hYmxlID0gW107XG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgcmFuZ2VzLmxlbmd0aDsgaSQxICs9IDIpIHtcbiAgICAgIHZhciBmcm9tID0gcmFuZ2VzW2kkMV0sIHRvID0gcmFuZ2VzW2kkMSArIDFdO1xuICAgICAgdmFyICRmcm9tID0gdHIuZG9jLnJlc29sdmUoZnJvbSksIGRlcHRoID0gJGZyb20uc2hhcmVkRGVwdGgodG8pLCBwYXJlbnQgPSAkZnJvbS5ub2RlKGRlcHRoKTtcbiAgICAgIGZvciAodmFyIGluZGV4ID0gJGZyb20uaW5kZXhBZnRlcihkZXB0aCksIHBvcyA9ICRmcm9tLmFmdGVyKGRlcHRoICsgMSk7IHBvcyA8PSB0bzsgKytpbmRleCkge1xuICAgICAgICB2YXIgYWZ0ZXIgPSBwYXJlbnQubWF5YmVDaGlsZChpbmRleCk7XG4gICAgICAgIGlmICghYWZ0ZXIpIHsgYnJlYWsgfVxuICAgICAgICBpZiAoaW5kZXggJiYgam9pbmFibGUuaW5kZXhPZihwb3MpID09IC0xKSB7XG4gICAgICAgICAgdmFyIGJlZm9yZSA9IHBhcmVudC5jaGlsZChpbmRleCAtIDEpO1xuICAgICAgICAgIGlmIChiZWZvcmUudHlwZSA9PSBhZnRlci50eXBlICYmIGlzSm9pbmFibGUoYmVmb3JlLCBhZnRlcikpXG4gICAgICAgICAgICB7IGpvaW5hYmxlLnB1c2gocG9zKTsgfVxuICAgICAgICB9XG4gICAgICAgIHBvcyArPSBhZnRlci5ub2RlU2l6ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gSm9pbiB0aGUgam9pbmFibGUgcG9pbnRzXG4gICAgam9pbmFibGUuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSAtIGI7IH0pO1xuICAgIGZvciAodmFyIGkkMiA9IGpvaW5hYmxlLmxlbmd0aCAtIDE7IGkkMiA+PSAwOyBpJDItLSkge1xuICAgICAgaWYgKGNhbkpvaW4odHIuZG9jLCBqb2luYWJsZVtpJDJdKSkgeyB0ci5qb2luKGpvaW5hYmxlW2kkMl0pOyB9XG4gICAgfVxuICAgIGRpc3BhdGNoKHRyKTtcbiAgfVxufVxuXG4vLyA6OiAoKHN0YXRlOiBFZGl0b3JTdGF0ZSwgPyh0cjogVHJhbnNhY3Rpb24pKSDihpIgYm9vbCwgdW5pb248KGJlZm9yZTogTm9kZSwgYWZ0ZXI6IE5vZGUpIOKGkiBib29sLCBbc3RyaW5nXT4pIOKGkiAoc3RhdGU6IEVkaXRvclN0YXRlLCA/KHRyOiBUcmFuc2FjdGlvbikpIOKGkiBib29sXG4vLyBXcmFwIGEgY29tbWFuZCBzbyB0aGF0LCB3aGVuIGl0IHByb2R1Y2VzIGEgdHJhbnNmb3JtIHRoYXQgY2F1c2VzXG4vLyB0d28gam9pbmFibGUgbm9kZXMgdG8gZW5kIHVwIG5leHQgdG8gZWFjaCBvdGhlciwgdGhvc2UgYXJlIGpvaW5lZC5cbi8vIE5vZGVzIGFyZSBjb25zaWRlcmVkIGpvaW5hYmxlIHdoZW4gdGhleSBhcmUgb2YgdGhlIHNhbWUgdHlwZSBhbmRcbi8vIHdoZW4gdGhlIGBpc0pvaW5hYmxlYCBwcmVkaWNhdGUgcmV0dXJucyB0cnVlIGZvciB0aGVtIG9yLCBpZiBhblxuLy8gYXJyYXkgb2Ygc3RyaW5ncyB3YXMgcGFzc2VkLCBpZiB0aGVpciBub2RlIHR5cGUgbmFtZSBpcyBpbiB0aGF0XG4vLyBhcnJheS5cbmZ1bmN0aW9uIGF1dG9Kb2luKGNvbW1hbmQsIGlzSm9pbmFibGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoaXNKb2luYWJsZSkpIHtcbiAgICB2YXIgdHlwZXMgPSBpc0pvaW5hYmxlO1xuICAgIGlzSm9pbmFibGUgPSBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gdHlwZXMuaW5kZXhPZihub2RlLnR5cGUubmFtZSkgPiAtMTsgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCwgdmlldykgeyByZXR1cm4gY29tbWFuZChzdGF0ZSwgZGlzcGF0Y2ggJiYgd3JhcERpc3BhdGNoRm9ySm9pbihkaXNwYXRjaCwgaXNKb2luYWJsZSksIHZpZXcpOyB9XG59XG5cbi8vIDo6ICguLi5bKEVkaXRvclN0YXRlLCA/KHRyOiBUcmFuc2FjdGlvbiksID9FZGl0b3JWaWV3KSDihpIgYm9vbF0pIOKGkiAoRWRpdG9yU3RhdGUsID8odHI6IFRyYW5zYWN0aW9uKSwgP0VkaXRvclZpZXcpIOKGkiBib29sXG4vLyBDb21iaW5lIGEgbnVtYmVyIG9mIGNvbW1hbmQgZnVuY3Rpb25zIGludG8gYSBzaW5nbGUgZnVuY3Rpb24gKHdoaWNoXG4vLyBjYWxscyB0aGVtIG9uZSBieSBvbmUgdW50aWwgb25lIHJldHVybnMgdHJ1ZSkuXG5mdW5jdGlvbiBjaGFpbkNvbW1hbmRzKCkge1xuICB2YXIgY29tbWFuZHMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgd2hpbGUgKCBsZW4tLSApIGNvbW1hbmRzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHN0YXRlLCBkaXNwYXRjaCwgdmlldykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tbWFuZHMubGVuZ3RoOyBpKyspXG4gICAgICB7IGlmIChjb21tYW5kc1tpXShzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpKSB7IHJldHVybiB0cnVlIH0gfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbnZhciBiYWNrc3BhY2UgPSBjaGFpbkNvbW1hbmRzKGRlbGV0ZVNlbGVjdGlvbiwgam9pbkJhY2t3YXJkLCBzZWxlY3ROb2RlQmFja3dhcmQpO1xudmFyIGRlbCA9IGNoYWluQ29tbWFuZHMoZGVsZXRlU2VsZWN0aW9uLCBqb2luRm9yd2FyZCwgc2VsZWN0Tm9kZUZvcndhcmQpO1xuXG4vLyA6OiBPYmplY3Rcbi8vIEEgYmFzaWMga2V5bWFwIGNvbnRhaW5pbmcgYmluZGluZ3Mgbm90IHNwZWNpZmljIHRvIGFueSBzY2hlbWEuXG4vLyBCaW5kcyB0aGUgZm9sbG93aW5nIGtleXMgKHdoZW4gbXVsdGlwbGUgY29tbWFuZHMgYXJlIGxpc3RlZCwgdGhleVxuLy8gYXJlIGNoYWluZWQgd2l0aCBbYGNoYWluQ29tbWFuZHNgXSgjY29tbWFuZHMuY2hhaW5Db21tYW5kcykpOlxuLy9cbi8vICogKipFbnRlcioqIHRvIGBuZXdsaW5lSW5Db2RlYCwgYGNyZWF0ZVBhcmFncmFwaE5lYXJgLCBgbGlmdEVtcHR5QmxvY2tgLCBgc3BsaXRCbG9ja2Bcbi8vICogKipNb2QtRW50ZXIqKiB0byBgZXhpdENvZGVgXG4vLyAqICoqQmFja3NwYWNlKiogYW5kICoqTW9kLUJhY2tzcGFjZSoqIHRvIGBkZWxldGVTZWxlY3Rpb25gLCBgam9pbkJhY2t3YXJkYCwgYHNlbGVjdE5vZGVCYWNrd2FyZGBcbi8vICogKipEZWxldGUqKiBhbmQgKipNb2QtRGVsZXRlKiogdG8gYGRlbGV0ZVNlbGVjdGlvbmAsIGBqb2luRm9yd2FyZGAsIGBzZWxlY3ROb2RlRm9yd2FyZGBcbi8vICogKipNb2QtRGVsZXRlKiogdG8gYGRlbGV0ZVNlbGVjdGlvbmAsIGBqb2luRm9yd2FyZGAsIGBzZWxlY3ROb2RlRm9yd2FyZGBcbi8vICogKipNb2QtYSoqIHRvIGBzZWxlY3RBbGxgXG52YXIgcGNCYXNlS2V5bWFwID0ge1xuICBcIkVudGVyXCI6IGNoYWluQ29tbWFuZHMobmV3bGluZUluQ29kZSwgY3JlYXRlUGFyYWdyYXBoTmVhciwgbGlmdEVtcHR5QmxvY2ssIHNwbGl0QmxvY2spLFxuICBcIk1vZC1FbnRlclwiOiBleGl0Q29kZSxcbiAgXCJCYWNrc3BhY2VcIjogYmFja3NwYWNlLFxuICBcIk1vZC1CYWNrc3BhY2VcIjogYmFja3NwYWNlLFxuICBcIlNoaWZ0LUJhY2tzcGFjZVwiOiBiYWNrc3BhY2UsXG4gIFwiRGVsZXRlXCI6IGRlbCxcbiAgXCJNb2QtRGVsZXRlXCI6IGRlbCxcbiAgXCJNb2QtYVwiOiBzZWxlY3RBbGxcbn07XG5cbi8vIDo6IE9iamVjdFxuLy8gQSBjb3B5IG9mIGBwY0Jhc2VLZXltYXBgIHRoYXQgYWxzbyBiaW5kcyAqKkN0cmwtaCoqIGxpa2UgQmFja3NwYWNlLFxuLy8gKipDdHJsLWQqKiBsaWtlIERlbGV0ZSwgKipBbHQtQmFja3NwYWNlKiogbGlrZSBDdHJsLUJhY2tzcGFjZSwgYW5kXG4vLyAqKkN0cmwtQWx0LUJhY2tzcGFjZSoqLCAqKkFsdC1EZWxldGUqKiwgYW5kICoqQWx0LWQqKiBsaWtlXG4vLyBDdHJsLURlbGV0ZS5cbnZhciBtYWNCYXNlS2V5bWFwID0ge1xuICBcIkN0cmwtaFwiOiBwY0Jhc2VLZXltYXBbXCJCYWNrc3BhY2VcIl0sXG4gIFwiQWx0LUJhY2tzcGFjZVwiOiBwY0Jhc2VLZXltYXBbXCJNb2QtQmFja3NwYWNlXCJdLFxuICBcIkN0cmwtZFwiOiBwY0Jhc2VLZXltYXBbXCJEZWxldGVcIl0sXG4gIFwiQ3RybC1BbHQtQmFja3NwYWNlXCI6IHBjQmFzZUtleW1hcFtcIk1vZC1EZWxldGVcIl0sXG4gIFwiQWx0LURlbGV0ZVwiOiBwY0Jhc2VLZXltYXBbXCJNb2QtRGVsZXRlXCJdLFxuICBcIkFsdC1kXCI6IHBjQmFzZUtleW1hcFtcIk1vZC1EZWxldGVcIl1cbn07XG5mb3IgKHZhciBrZXkgaW4gcGNCYXNlS2V5bWFwKSB7IG1hY0Jhc2VLZXltYXBba2V5XSA9IHBjQmFzZUtleW1hcFtrZXldOyB9XG5cbi8vIGRlY2xhcmUgZ2xvYmFsOiBvcywgbmF2aWdhdG9yXG52YXIgbWFjID0gdHlwZW9mIG5hdmlnYXRvciAhPSBcInVuZGVmaW5lZFwiID8gL01hYy8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pXG4gICAgICAgICAgOiB0eXBlb2Ygb3MgIT0gXCJ1bmRlZmluZWRcIiA/IG9zLnBsYXRmb3JtKCkgPT0gXCJkYXJ3aW5cIiA6IGZhbHNlO1xuXG4vLyA6OiBPYmplY3Rcbi8vIERlcGVuZGluZyBvbiB0aGUgZGV0ZWN0ZWQgcGxhdGZvcm0sIHRoaXMgd2lsbCBob2xkXG4vLyBbYHBjQmFzZWtleW1hcGBdKCNjb21tYW5kcy5wY0Jhc2VLZXltYXApIG9yXG4vLyBbYG1hY0Jhc2VLZXltYXBgXSgjY29tbWFuZHMubWFjQmFzZUtleW1hcCkuXG52YXIgYmFzZUtleW1hcCA9IG1hYyA/IG1hY0Jhc2VLZXltYXAgOiBwY0Jhc2VLZXltYXA7XG5cbmV4cG9ydCB7IGF1dG9Kb2luLCBiYXNlS2V5bWFwLCBjaGFpbkNvbW1hbmRzLCBjcmVhdGVQYXJhZ3JhcGhOZWFyLCBkZWxldGVTZWxlY3Rpb24sIGV4aXRDb2RlLCBqb2luQmFja3dhcmQsIGpvaW5Eb3duLCBqb2luRm9yd2FyZCwgam9pblVwLCBsaWZ0LCBsaWZ0RW1wdHlCbG9jaywgbWFjQmFzZUtleW1hcCwgbmV3bGluZUluQ29kZSwgcGNCYXNlS2V5bWFwLCBzZWxlY3RBbGwsIHNlbGVjdE5vZGVCYWNrd2FyZCwgc2VsZWN0Tm9kZUZvcndhcmQsIHNlbGVjdFBhcmVudE5vZGUsIHNldEJsb2NrVHlwZSwgc3BsaXRCbG9jaywgc3BsaXRCbG9ja0tlZXBNYXJrcywgdG9nZ2xlTWFyaywgd3JhcEluIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lcy5qcy5tYXBcbiIsImltcG9ydCB7IFBsdWdpbiB9IGZyb20gJ3Byb3NlbWlycm9yLXN0YXRlJztcbmltcG9ydCB7IGRyb3BQb2ludCB9IGZyb20gJ3Byb3NlbWlycm9yLXRyYW5zZm9ybSc7XG5cbi8vIDo6IChvcHRpb25zOiA/T2JqZWN0KSDihpIgUGx1Z2luXG4vLyBDcmVhdGUgYSBwbHVnaW4gdGhhdCwgd2hlbiBhZGRlZCB0byBhIFByb3NlTWlycm9yIGluc3RhbmNlLFxuLy8gY2F1c2VzIGEgZGVjb3JhdGlvbiB0byBzaG93IHVwIGF0IHRoZSBkcm9wIHBvc2l0aW9uIHdoZW4gc29tZXRoaW5nXG4vLyBpcyBkcmFnZ2VkIG92ZXIgdGhlIGVkaXRvci5cbi8vXG4vLyAgIG9wdGlvbnM6Oi0gVGhlc2Ugb3B0aW9ucyBhcmUgc3VwcG9ydGVkOlxuLy9cbi8vICAgICBjb2xvcjo6ID9zdHJpbmdcbi8vICAgICBUaGUgY29sb3Igb2YgdGhlIGN1cnNvci4gRGVmYXVsdHMgdG8gYGJsYWNrYC5cbi8vXG4vLyAgICAgd2lkdGg6OiA/bnVtYmVyXG4vLyAgICAgVGhlIHByZWNpc2Ugd2lkdGggb2YgdGhlIGN1cnNvciBpbiBwaXhlbHMuIERlZmF1bHRzIHRvIDEuXG4vL1xuLy8gICAgIGNsYXNzOjogP3N0cmluZ1xuLy8gICAgIEEgQ1NTIGNsYXNzIG5hbWUgdG8gYWRkIHRvIHRoZSBjdXJzb3IgZWxlbWVudC5cbmZ1bmN0aW9uIGRyb3BDdXJzb3Iob3B0aW9ucykge1xuICBpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxuICByZXR1cm4gbmV3IFBsdWdpbih7XG4gICAgdmlldzogZnVuY3Rpb24gdmlldyhlZGl0b3JWaWV3KSB7IHJldHVybiBuZXcgRHJvcEN1cnNvclZpZXcoZWRpdG9yVmlldywgb3B0aW9ucykgfVxuICB9KVxufVxuXG52YXIgRHJvcEN1cnNvclZpZXcgPSBmdW5jdGlvbiBEcm9wQ3Vyc29yVmlldyhlZGl0b3JWaWV3LCBvcHRpb25zKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHRoaXMuZWRpdG9yVmlldyA9IGVkaXRvclZpZXc7XG4gIHRoaXMud2lkdGggPSBvcHRpb25zLndpZHRoIHx8IDE7XG4gIHRoaXMuY29sb3IgPSBvcHRpb25zLmNvbG9yIHx8IFwiYmxhY2tcIjtcbiAgdGhpcy5jbGFzcyA9IG9wdGlvbnMuY2xhc3M7XG4gIHRoaXMuY3Vyc29yUG9zID0gbnVsbDtcbiAgdGhpcy5lbGVtZW50ID0gbnVsbDtcbiAgdGhpcy50aW1lb3V0ID0gbnVsbDtcblxuICB0aGlzLmhhbmRsZXJzID0gW1wiZHJhZ292ZXJcIiwgXCJkcmFnZW5kXCIsIFwiZHJvcFwiLCBcImRyYWdsZWF2ZVwiXS5tYXAoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7IHJldHVybiB0aGlzJDFbbmFtZV0oZSk7IH07XG4gICAgZWRpdG9yVmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBoYW5kbGVyKTtcbiAgICByZXR1cm4ge25hbWU6IG5hbWUsIGhhbmRsZXI6IGhhbmRsZXJ9XG4gIH0pO1xufTtcblxuRHJvcEN1cnNvclZpZXcucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95ICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB0aGlzLmhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24gKHJlZikge1xuICAgICAgdmFyIG5hbWUgPSByZWYubmFtZTtcbiAgICAgIHZhciBoYW5kbGVyID0gcmVmLmhhbmRsZXI7XG5cbiAgICAgIHJldHVybiB0aGlzJDEuZWRpdG9yVmlldy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBoYW5kbGVyKTtcbiAgICB9KTtcbn07XG5cbkRyb3BDdXJzb3JWaWV3LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKGVkaXRvclZpZXcsIHByZXZTdGF0ZSkge1xuICBpZiAodGhpcy5jdXJzb3JQb3MgIT0gbnVsbCAmJiBwcmV2U3RhdGUuZG9jICE9IGVkaXRvclZpZXcuc3RhdGUuZG9jKSB7XG4gICAgaWYgKHRoaXMuY3Vyc29yUG9zID4gZWRpdG9yVmlldy5zdGF0ZS5kb2MuY29udGVudC5zaXplKSB7IHRoaXMuc2V0Q3Vyc29yKG51bGwpOyB9XG4gICAgZWxzZSB7IHRoaXMudXBkYXRlT3ZlcmxheSgpOyB9XG4gIH1cbn07XG5cbkRyb3BDdXJzb3JWaWV3LnByb3RvdHlwZS5zZXRDdXJzb3IgPSBmdW5jdGlvbiBzZXRDdXJzb3IgKHBvcykge1xuICBpZiAocG9zID09IHRoaXMuY3Vyc29yUG9zKSB7IHJldHVybiB9XG4gIHRoaXMuY3Vyc29yUG9zID0gcG9zO1xuICBpZiAocG9zID09IG51bGwpIHtcbiAgICB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmVsZW1lbnQpO1xuICAgIHRoaXMuZWxlbWVudCA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy51cGRhdGVPdmVybGF5KCk7XG4gIH1cbn07XG5cbkRyb3BDdXJzb3JWaWV3LnByb3RvdHlwZS51cGRhdGVPdmVybGF5ID0gZnVuY3Rpb24gdXBkYXRlT3ZlcmxheSAoKSB7XG4gIHZhciAkcG9zID0gdGhpcy5lZGl0b3JWaWV3LnN0YXRlLmRvYy5yZXNvbHZlKHRoaXMuY3Vyc29yUG9zKSwgcmVjdDtcbiAgaWYgKCEkcG9zLnBhcmVudC5pbmxpbmVDb250ZW50KSB7XG4gICAgdmFyIGJlZm9yZSA9ICRwb3Mubm9kZUJlZm9yZSwgYWZ0ZXIgPSAkcG9zLm5vZGVBZnRlcjtcbiAgICBpZiAoYmVmb3JlIHx8IGFmdGVyKSB7XG4gICAgICB2YXIgbm9kZVJlY3QgPSB0aGlzLmVkaXRvclZpZXcubm9kZURPTSh0aGlzLmN1cnNvclBvcyAtIChiZWZvcmUgP2JlZm9yZS5ub2RlU2l6ZSA6IDApKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciB0b3AgPSBiZWZvcmUgPyBub2RlUmVjdC5ib3R0b20gOiBub2RlUmVjdC50b3A7XG4gICAgICBpZiAoYmVmb3JlICYmIGFmdGVyKVxuICAgICAgICB7IHRvcCA9ICh0b3AgKyB0aGlzLmVkaXRvclZpZXcubm9kZURPTSh0aGlzLmN1cnNvclBvcykuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wKSAvIDI7IH1cbiAgICAgIHJlY3QgPSB7bGVmdDogbm9kZVJlY3QubGVmdCwgcmlnaHQ6IG5vZGVSZWN0LnJpZ2h0LCB0b3A6IHRvcCAtIHRoaXMud2lkdGggLyAyLCBib3R0b206IHRvcCArIHRoaXMud2lkdGggLyAyfTtcbiAgICB9XG4gIH1cbiAgaWYgKCFyZWN0KSB7XG4gICAgdmFyIGNvb3JkcyA9IHRoaXMuZWRpdG9yVmlldy5jb29yZHNBdFBvcyh0aGlzLmN1cnNvclBvcyk7XG4gICAgcmVjdCA9IHtsZWZ0OiBjb29yZHMubGVmdCAtIHRoaXMud2lkdGggLyAyLCByaWdodDogY29vcmRzLmxlZnQgKyB0aGlzLndpZHRoIC8gMiwgdG9wOiBjb29yZHMudG9wLCBib3R0b206IGNvb3Jkcy5ib3R0b219O1xuICB9XG5cbiAgdmFyIHBhcmVudCA9IHRoaXMuZWRpdG9yVmlldy5kb20ub2Zmc2V0UGFyZW50O1xuICBpZiAoIXRoaXMuZWxlbWVudCkge1xuICAgIHRoaXMuZWxlbWVudCA9IHBhcmVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcbiAgICBpZiAodGhpcy5jbGFzcykgeyB0aGlzLmVsZW1lbnQuY2xhc3NOYW1lID0gdGhpcy5jbGFzczsgfVxuICAgIHRoaXMuZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjogYWJzb2x1dGU7IHotaW5kZXg6IDUwOyBwb2ludGVyLWV2ZW50czogbm9uZTsgYmFja2dyb3VuZC1jb2xvcjogXCIgKyB0aGlzLmNvbG9yO1xuICB9XG4gIHZhciBwYXJlbnRMZWZ0LCBwYXJlbnRUb3A7XG4gIGlmICghcGFyZW50IHx8IHBhcmVudCA9PSBkb2N1bWVudC5ib2R5ICYmIGdldENvbXB1dGVkU3R5bGUocGFyZW50KS5wb3NpdGlvbiA9PSBcInN0YXRpY1wiKSB7XG4gICAgcGFyZW50TGVmdCA9IC1wYWdlWE9mZnNldDtcbiAgICBwYXJlbnRUb3AgPSAtcGFnZVlPZmZzZXQ7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHJlY3QkMSA9IHBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBwYXJlbnRMZWZ0ID0gcmVjdCQxLmxlZnQgLSBwYXJlbnQuc2Nyb2xsTGVmdDtcbiAgICBwYXJlbnRUb3AgPSByZWN0JDEudG9wIC0gcGFyZW50LnNjcm9sbFRvcDtcbiAgfVxuICB0aGlzLmVsZW1lbnQuc3R5bGUubGVmdCA9IChyZWN0LmxlZnQgLSBwYXJlbnRMZWZ0KSArIFwicHhcIjtcbiAgdGhpcy5lbGVtZW50LnN0eWxlLnRvcCA9IChyZWN0LnRvcCAtIHBhcmVudFRvcCkgKyBcInB4XCI7XG4gIHRoaXMuZWxlbWVudC5zdHlsZS53aWR0aCA9IChyZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0KSArIFwicHhcIjtcbiAgdGhpcy5lbGVtZW50LnN0eWxlLmhlaWdodCA9IChyZWN0LmJvdHRvbSAtIHJlY3QudG9wKSArIFwicHhcIjtcbn07XG5cbkRyb3BDdXJzb3JWaWV3LnByb3RvdHlwZS5zY2hlZHVsZVJlbW92YWwgPSBmdW5jdGlvbiBzY2hlZHVsZVJlbW92YWwgKHRpbWVvdXQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KTtcbiAgdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzJDEuc2V0Q3Vyc29yKG51bGwpOyB9LCB0aW1lb3V0KTtcbn07XG5cbkRyb3BDdXJzb3JWaWV3LnByb3RvdHlwZS5kcmFnb3ZlciA9IGZ1bmN0aW9uIGRyYWdvdmVyIChldmVudCkge1xuICBpZiAoIXRoaXMuZWRpdG9yVmlldy5lZGl0YWJsZSkgeyByZXR1cm4gfVxuICB2YXIgcG9zID0gdGhpcy5lZGl0b3JWaWV3LnBvc0F0Q29vcmRzKHtsZWZ0OiBldmVudC5jbGllbnRYLCB0b3A6IGV2ZW50LmNsaWVudFl9KTtcbiAgaWYgKHBvcykge1xuICAgIHZhciB0YXJnZXQgPSBwb3MucG9zO1xuICAgIGlmICh0aGlzLmVkaXRvclZpZXcuZHJhZ2dpbmcgJiYgdGhpcy5lZGl0b3JWaWV3LmRyYWdnaW5nLnNsaWNlKSB7XG4gICAgICB0YXJnZXQgPSBkcm9wUG9pbnQodGhpcy5lZGl0b3JWaWV3LnN0YXRlLmRvYywgdGFyZ2V0LCB0aGlzLmVkaXRvclZpZXcuZHJhZ2dpbmcuc2xpY2UpO1xuICAgICAgaWYgKHRhcmdldCA9PSBudWxsKSB7IHJldHVybiB0aGlzLnNldEN1cnNvcihudWxsKSB9XG4gICAgfVxuICAgIHRoaXMuc2V0Q3Vyc29yKHRhcmdldCk7XG4gICAgdGhpcy5zY2hlZHVsZVJlbW92YWwoNTAwMCk7XG4gIH1cbn07XG5cbkRyb3BDdXJzb3JWaWV3LnByb3RvdHlwZS5kcmFnZW5kID0gZnVuY3Rpb24gZHJhZ2VuZCAoKSB7XG4gIHRoaXMuc2NoZWR1bGVSZW1vdmFsKDIwKTtcbn07XG5cbkRyb3BDdXJzb3JWaWV3LnByb3RvdHlwZS5kcm9wID0gZnVuY3Rpb24gZHJvcCAoKSB7XG4gIHRoaXMuc2NoZWR1bGVSZW1vdmFsKDIwKTtcbn07XG5cbkRyb3BDdXJzb3JWaWV3LnByb3RvdHlwZS5kcmFnbGVhdmUgPSBmdW5jdGlvbiBkcmFnbGVhdmUgKGV2ZW50KSB7XG4gIGlmIChldmVudC50YXJnZXQgPT0gdGhpcy5lZGl0b3JWaWV3LmRvbSB8fCAhdGhpcy5lZGl0b3JWaWV3LmRvbS5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0KSlcbiAgICB7IHRoaXMuc2V0Q3Vyc29yKG51bGwpOyB9XG59O1xuXG5leHBvcnQgeyBkcm9wQ3Vyc29yIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lcy5qcy5tYXBcbiIsImltcG9ydCB7IGtleW1hcCB9IGZyb20gJ3Byb3NlbWlycm9yLWtleW1hcCc7XG5pbXBvcnQgeyB1bmRvLCByZWRvLCBoaXN0b3J5IH0gZnJvbSAncHJvc2VtaXJyb3ItaGlzdG9yeSc7XG5pbXBvcnQgeyB0b2dnbGVNYXJrLCB3cmFwSW4sIGNoYWluQ29tbWFuZHMsIGV4aXRDb2RlLCBzZXRCbG9ja1R5cGUsIGpvaW5VcCwgam9pbkRvd24sIGxpZnQsIHNlbGVjdFBhcmVudE5vZGUsIGJhc2VLZXltYXAgfSBmcm9tICdwcm9zZW1pcnJvci1jb21tYW5kcyc7XG5pbXBvcnQgeyBOb2RlU2VsZWN0aW9uLCBQbHVnaW4gfSBmcm9tICdwcm9zZW1pcnJvci1zdGF0ZSc7XG5pbXBvcnQgeyBkcm9wQ3Vyc29yIH0gZnJvbSAncHJvc2VtaXJyb3ItZHJvcGN1cnNvcic7XG5pbXBvcnQgeyBnYXBDdXJzb3IgfSBmcm9tICdwcm9zZW1pcnJvci1nYXBjdXJzb3InO1xuaW1wb3J0IHsgaWNvbnMsIE1lbnVJdGVtLCB3cmFwSXRlbSwgYmxvY2tUeXBlSXRlbSwgRHJvcGRvd24sIERyb3Bkb3duU3VibWVudSwgam9pblVwSXRlbSwgbGlmdEl0ZW0sIHNlbGVjdFBhcmVudE5vZGVJdGVtLCB1bmRvSXRlbSwgcmVkb0l0ZW0sIG1lbnVCYXIgfSBmcm9tICdwcm9zZW1pcnJvci1tZW51JztcbmltcG9ydCB7IHdyYXBJbkxpc3QsIHNwbGl0TGlzdEl0ZW0sIGxpZnRMaXN0SXRlbSwgc2lua0xpc3RJdGVtIH0gZnJvbSAncHJvc2VtaXJyb3Itc2NoZW1hLWxpc3QnO1xuaW1wb3J0IHsgdW5kb0lucHV0UnVsZSwgc21hcnRRdW90ZXMsIGVsbGlwc2lzLCBlbURhc2gsIHdyYXBwaW5nSW5wdXRSdWxlLCB0ZXh0YmxvY2tUeXBlSW5wdXRSdWxlLCBpbnB1dFJ1bGVzIH0gZnJvbSAncHJvc2VtaXJyb3ItaW5wdXRydWxlcyc7XG5cbnZhciBwcmVmaXggPSBcIlByb3NlTWlycm9yLXByb21wdFwiO1xuXG5mdW5jdGlvbiBvcGVuUHJvbXB0KG9wdGlvbnMpIHtcbiAgdmFyIHdyYXBwZXIgPSBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO1xuICB3cmFwcGVyLmNsYXNzTmFtZSA9IHByZWZpeDtcblxuICB2YXIgbW91c2VPdXRzaWRlID0gZnVuY3Rpb24gKGUpIHsgaWYgKCF3cmFwcGVyLmNvbnRhaW5zKGUudGFyZ2V0KSkgeyBjbG9zZSgpOyB9IH07XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgbW91c2VPdXRzaWRlKTsgfSwgNTApO1xuICB2YXIgY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgbW91c2VPdXRzaWRlKTtcbiAgICBpZiAod3JhcHBlci5wYXJlbnROb2RlKSB7IHdyYXBwZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh3cmFwcGVyKTsgfVxuICB9O1xuXG4gIHZhciBkb21GaWVsZHMgPSBbXTtcbiAgZm9yICh2YXIgbmFtZSBpbiBvcHRpb25zLmZpZWxkcykgeyBkb21GaWVsZHMucHVzaChvcHRpb25zLmZpZWxkc1tuYW1lXS5yZW5kZXIoKSk7IH1cblxuICB2YXIgc3VibWl0QnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgc3VibWl0QnV0dG9uLnR5cGUgPSBcInN1Ym1pdFwiO1xuICBzdWJtaXRCdXR0b24uY2xhc3NOYW1lID0gcHJlZml4ICsgXCItc3VibWl0XCI7XG4gIHN1Ym1pdEJ1dHRvbi50ZXh0Q29udGVudCA9IFwiT0tcIjtcbiAgdmFyIGNhbmNlbEJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gIGNhbmNlbEJ1dHRvbi50eXBlID0gXCJidXR0b25cIjtcbiAgY2FuY2VsQnV0dG9uLmNsYXNzTmFtZSA9IHByZWZpeCArIFwiLWNhbmNlbFwiO1xuICBjYW5jZWxCdXR0b24udGV4dENvbnRlbnQgPSBcIkNhbmNlbFwiO1xuICBjYW5jZWxCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGNsb3NlKTtcblxuICB2YXIgZm9ybSA9IHdyYXBwZXIuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZvcm1cIikpO1xuICBpZiAob3B0aW9ucy50aXRsZSkgeyBmb3JtLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJoNVwiKSkudGV4dENvbnRlbnQgPSBvcHRpb25zLnRpdGxlOyB9XG4gIGRvbUZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgIGZvcm0uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSkuYXBwZW5kQ2hpbGQoZmllbGQpO1xuICB9KTtcbiAgdmFyIGJ1dHRvbnMgPSBmb3JtLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO1xuICBidXR0b25zLmNsYXNzTmFtZSA9IHByZWZpeCArIFwiLWJ1dHRvbnNcIjtcbiAgYnV0dG9ucy5hcHBlbmRDaGlsZChzdWJtaXRCdXR0b24pO1xuICBidXR0b25zLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiIFwiKSk7XG4gIGJ1dHRvbnMuYXBwZW5kQ2hpbGQoY2FuY2VsQnV0dG9uKTtcblxuICB2YXIgYm94ID0gd3JhcHBlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgd3JhcHBlci5zdHlsZS50b3AgPSAoKHdpbmRvdy5pbm5lckhlaWdodCAtIGJveC5oZWlnaHQpIC8gMikgKyBcInB4XCI7XG4gIHdyYXBwZXIuc3R5bGUubGVmdCA9ICgod2luZG93LmlubmVyV2lkdGggLSBib3gud2lkdGgpIC8gMikgKyBcInB4XCI7XG5cbiAgdmFyIHN1Ym1pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGFyYW1zID0gZ2V0VmFsdWVzKG9wdGlvbnMuZmllbGRzLCBkb21GaWVsZHMpO1xuICAgIGlmIChwYXJhbXMpIHtcbiAgICAgIGNsb3NlKCk7XG4gICAgICBvcHRpb25zLmNhbGxiYWNrKHBhcmFtcyk7XG4gICAgfVxuICB9O1xuXG4gIGZvcm0uYWRkRXZlbnRMaXN0ZW5lcihcInN1Ym1pdFwiLCBmdW5jdGlvbiAoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBzdWJtaXQoKTtcbiAgfSk7XG5cbiAgZm9ybS5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLmtleUNvZGUgPT0gMjcpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGNsb3NlKCk7XG4gICAgfSBlbHNlIGlmIChlLmtleUNvZGUgPT0gMTMgJiYgIShlLmN0cmxLZXkgfHwgZS5tZXRhS2V5IHx8IGUuc2hpZnRLZXkpKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBzdWJtaXQoKTtcbiAgICB9IGVsc2UgaWYgKGUua2V5Q29kZSA9PSA5KSB7XG4gICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghd3JhcHBlci5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KSkgeyBjbG9zZSgpOyB9XG4gICAgICB9LCA1MDApO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIGlucHV0ID0gZm9ybS5lbGVtZW50c1swXTtcbiAgaWYgKGlucHV0KSB7IGlucHV0LmZvY3VzKCk7IH1cbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWVzKGZpZWxkcywgZG9tRmllbGRzKSB7XG4gIHZhciByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpLCBpID0gMDtcbiAgZm9yICh2YXIgbmFtZSBpbiBmaWVsZHMpIHtcbiAgICB2YXIgZmllbGQgPSBmaWVsZHNbbmFtZV0sIGRvbSA9IGRvbUZpZWxkc1tpKytdO1xuICAgIHZhciB2YWx1ZSA9IGZpZWxkLnJlYWQoZG9tKSwgYmFkID0gZmllbGQudmFsaWRhdGUodmFsdWUpO1xuICAgIGlmIChiYWQpIHtcbiAgICAgIHJlcG9ydEludmFsaWQoZG9tLCBiYWQpO1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgcmVzdWx0W25hbWVdID0gZmllbGQuY2xlYW4odmFsdWUpO1xuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gcmVwb3J0SW52YWxpZChkb20sIG1lc3NhZ2UpIHtcbiAgLy8gRklYTUUgdGhpcyBpcyBhd2Z1bCBhbmQgbmVlZHMgYSBsb3QgbW9yZSB3b3JrXG4gIHZhciBwYXJlbnQgPSBkb20ucGFyZW50Tm9kZTtcbiAgdmFyIG1zZyA9IHBhcmVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcbiAgbXNnLnN0eWxlLmxlZnQgPSAoZG9tLm9mZnNldExlZnQgKyBkb20ub2Zmc2V0V2lkdGggKyAyKSArIFwicHhcIjtcbiAgbXNnLnN0eWxlLnRvcCA9IChkb20ub2Zmc2V0VG9wIC0gNSkgKyBcInB4XCI7XG4gIG1zZy5jbGFzc05hbWUgPSBcIlByb3NlTWlycm9yLWludmFsaWRcIjtcbiAgbXNnLnRleHRDb250ZW50ID0gbWVzc2FnZTtcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBwYXJlbnQucmVtb3ZlQ2hpbGQobXNnKTsgfSwgMTUwMCk7XG59XG5cbi8vIDo6LSBUaGUgdHlwZSBvZiBmaWVsZCB0aGF0IGBGaWVsZFByb21wdGAgZXhwZWN0cyB0byBiZSBwYXNzZWQgdG8gaXQuXG52YXIgRmllbGQgPSBmdW5jdGlvbiBGaWVsZChvcHRpb25zKSB7IHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7IH07XG5cbi8vIHJlbmRlcjo6IChzdGF0ZTogRWRpdG9yU3RhdGUsIHByb3BzOiBPYmplY3QpIOKGkiBkb20uTm9kZVxuLy8gUmVuZGVyIHRoZSBmaWVsZCB0byB0aGUgRE9NLiBTaG91bGQgYmUgaW1wbGVtZW50ZWQgYnkgYWxsIHN1YmNsYXNzZXMuXG5cbi8vIDo6IChkb20uTm9kZSkg4oaSIGFueVxuLy8gUmVhZCB0aGUgZmllbGQncyB2YWx1ZSBmcm9tIGl0cyBET00gbm9kZS5cbkZpZWxkLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gcmVhZCAoZG9tKSB7IHJldHVybiBkb20udmFsdWUgfTtcblxuLy8gOjogKGFueSkg4oaSID9zdHJpbmdcbi8vIEEgZmllbGQtdHlwZS1zcGVjaWZpYyB2YWxpZGF0aW9uIGZ1bmN0aW9uLlxuRmllbGQucHJvdG90eXBlLnZhbGlkYXRlVHlwZSA9IGZ1bmN0aW9uIHZhbGlkYXRlVHlwZSAoX3ZhbHVlKSB7fTtcblxuRmllbGQucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gdmFsaWRhdGUgKHZhbHVlKSB7XG4gIGlmICghdmFsdWUgJiYgdGhpcy5vcHRpb25zLnJlcXVpcmVkKVxuICAgIHsgcmV0dXJuIFwiUmVxdWlyZWQgZmllbGRcIiB9XG4gIHJldHVybiB0aGlzLnZhbGlkYXRlVHlwZSh2YWx1ZSkgfHwgKHRoaXMub3B0aW9ucy52YWxpZGF0ZSAmJiB0aGlzLm9wdGlvbnMudmFsaWRhdGUodmFsdWUpKVxufTtcblxuRmllbGQucHJvdG90eXBlLmNsZWFuID0gZnVuY3Rpb24gY2xlYW4gKHZhbHVlKSB7XG4gIHJldHVybiB0aGlzLm9wdGlvbnMuY2xlYW4gPyB0aGlzLm9wdGlvbnMuY2xlYW4odmFsdWUpIDogdmFsdWVcbn07XG5cbi8vIDo6LSBBIGZpZWxkIGNsYXNzIGZvciBzaW5nbGUtbGluZSB0ZXh0IGZpZWxkcy5cbnZhciBUZXh0RmllbGQgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChGaWVsZCkge1xuICBmdW5jdGlvbiBUZXh0RmllbGQgKCkge1xuICAgIEZpZWxkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBpZiAoIEZpZWxkICkgVGV4dEZpZWxkLl9fcHJvdG9fXyA9IEZpZWxkO1xuICBUZXh0RmllbGQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggRmllbGQgJiYgRmllbGQucHJvdG90eXBlICk7XG4gIFRleHRGaWVsZC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUZXh0RmllbGQ7XG5cbiAgVGV4dEZpZWxkLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIgKCkge1xuICAgIHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICBpbnB1dC50eXBlID0gXCJ0ZXh0XCI7XG4gICAgaW5wdXQucGxhY2Vob2xkZXIgPSB0aGlzLm9wdGlvbnMubGFiZWw7XG4gICAgaW5wdXQudmFsdWUgPSB0aGlzLm9wdGlvbnMudmFsdWUgfHwgXCJcIjtcbiAgICBpbnB1dC5hdXRvY29tcGxldGUgPSBcIm9mZlwiO1xuICAgIHJldHVybiBpbnB1dFxuICB9O1xuXG4gIHJldHVybiBUZXh0RmllbGQ7XG59KEZpZWxkKSk7XG5cbi8vIEhlbHBlcnMgdG8gY3JlYXRlIHNwZWNpZmljIHR5cGVzIG9mIGl0ZW1zXG5cbmZ1bmN0aW9uIGNhbkluc2VydChzdGF0ZSwgbm9kZVR5cGUpIHtcbiAgdmFyICRmcm9tID0gc3RhdGUuc2VsZWN0aW9uLiRmcm9tO1xuICBmb3IgKHZhciBkID0gJGZyb20uZGVwdGg7IGQgPj0gMDsgZC0tKSB7XG4gICAgdmFyIGluZGV4ID0gJGZyb20uaW5kZXgoZCk7XG4gICAgaWYgKCRmcm9tLm5vZGUoZCkuY2FuUmVwbGFjZVdpdGgoaW5kZXgsIGluZGV4LCBub2RlVHlwZSkpIHsgcmV0dXJuIHRydWUgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBpbnNlcnRJbWFnZUl0ZW0obm9kZVR5cGUpIHtcbiAgcmV0dXJuIG5ldyBNZW51SXRlbSh7XG4gICAgdGl0bGU6IFwiSW5zZXJ0IGltYWdlXCIsXG4gICAgbGFiZWw6IFwiSW1hZ2VcIixcbiAgICBlbmFibGU6IGZ1bmN0aW9uIGVuYWJsZShzdGF0ZSkgeyByZXR1cm4gY2FuSW5zZXJ0KHN0YXRlLCBub2RlVHlwZSkgfSxcbiAgICBydW46IGZ1bmN0aW9uIHJ1bihzdGF0ZSwgXywgdmlldykge1xuICAgICAgdmFyIHJlZiA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgIHZhciBmcm9tID0gcmVmLmZyb207XG4gICAgICB2YXIgdG8gPSByZWYudG87XG4gICAgICB2YXIgYXR0cnMgPSBudWxsO1xuICAgICAgaWYgKHN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24gJiYgc3RhdGUuc2VsZWN0aW9uLm5vZGUudHlwZSA9PSBub2RlVHlwZSlcbiAgICAgICAgeyBhdHRycyA9IHN0YXRlLnNlbGVjdGlvbi5ub2RlLmF0dHJzOyB9XG4gICAgICBvcGVuUHJvbXB0KHtcbiAgICAgICAgdGl0bGU6IFwiSW5zZXJ0IGltYWdlXCIsXG4gICAgICAgIGZpZWxkczoge1xuICAgICAgICAgIHNyYzogbmV3IFRleHRGaWVsZCh7bGFiZWw6IFwiTG9jYXRpb25cIiwgcmVxdWlyZWQ6IHRydWUsIHZhbHVlOiBhdHRycyAmJiBhdHRycy5zcmN9KSxcbiAgICAgICAgICB0aXRsZTogbmV3IFRleHRGaWVsZCh7bGFiZWw6IFwiVGl0bGVcIiwgdmFsdWU6IGF0dHJzICYmIGF0dHJzLnRpdGxlfSksXG4gICAgICAgICAgYWx0OiBuZXcgVGV4dEZpZWxkKHtsYWJlbDogXCJEZXNjcmlwdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGF0dHJzID8gYXR0cnMuYWx0IDogc3RhdGUuZG9jLnRleHRCZXR3ZWVuKGZyb20sIHRvLCBcIiBcIil9KVxuICAgICAgICB9LFxuICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24gY2FsbGJhY2soYXR0cnMpIHtcbiAgICAgICAgICB2aWV3LmRpc3BhdGNoKHZpZXcuc3RhdGUudHIucmVwbGFjZVNlbGVjdGlvbldpdGgobm9kZVR5cGUuY3JlYXRlQW5kRmlsbChhdHRycykpKTtcbiAgICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSlcbn1cblxuZnVuY3Rpb24gY21kSXRlbShjbWQsIG9wdGlvbnMpIHtcbiAgdmFyIHBhc3NlZE9wdGlvbnMgPSB7XG4gICAgbGFiZWw6IG9wdGlvbnMudGl0bGUsXG4gICAgcnVuOiBjbWRcbiAgfTtcbiAgZm9yICh2YXIgcHJvcCBpbiBvcHRpb25zKSB7IHBhc3NlZE9wdGlvbnNbcHJvcF0gPSBvcHRpb25zW3Byb3BdOyB9XG4gIGlmICgoIW9wdGlvbnMuZW5hYmxlIHx8IG9wdGlvbnMuZW5hYmxlID09PSB0cnVlKSAmJiAhb3B0aW9ucy5zZWxlY3QpXG4gICAgeyBwYXNzZWRPcHRpb25zW29wdGlvbnMuZW5hYmxlID8gXCJlbmFibGVcIiA6IFwic2VsZWN0XCJdID0gZnVuY3Rpb24gKHN0YXRlKSB7IHJldHVybiBjbWQoc3RhdGUpOyB9OyB9XG5cbiAgcmV0dXJuIG5ldyBNZW51SXRlbShwYXNzZWRPcHRpb25zKVxufVxuXG5mdW5jdGlvbiBtYXJrQWN0aXZlKHN0YXRlLCB0eXBlKSB7XG4gIHZhciByZWYgPSBzdGF0ZS5zZWxlY3Rpb247XG4gIHZhciBmcm9tID0gcmVmLmZyb207XG4gIHZhciAkZnJvbSA9IHJlZi4kZnJvbTtcbiAgdmFyIHRvID0gcmVmLnRvO1xuICB2YXIgZW1wdHkgPSByZWYuZW1wdHk7XG4gIGlmIChlbXB0eSkgeyByZXR1cm4gdHlwZS5pc0luU2V0KHN0YXRlLnN0b3JlZE1hcmtzIHx8ICRmcm9tLm1hcmtzKCkpIH1cbiAgZWxzZSB7IHJldHVybiBzdGF0ZS5kb2MucmFuZ2VIYXNNYXJrKGZyb20sIHRvLCB0eXBlKSB9XG59XG5cbmZ1bmN0aW9uIG1hcmtJdGVtKG1hcmtUeXBlLCBvcHRpb25zKSB7XG4gIHZhciBwYXNzZWRPcHRpb25zID0ge1xuICAgIGFjdGl2ZTogZnVuY3Rpb24gYWN0aXZlKHN0YXRlKSB7IHJldHVybiBtYXJrQWN0aXZlKHN0YXRlLCBtYXJrVHlwZSkgfSxcbiAgICBlbmFibGU6IHRydWVcbiAgfTtcbiAgZm9yICh2YXIgcHJvcCBpbiBvcHRpb25zKSB7IHBhc3NlZE9wdGlvbnNbcHJvcF0gPSBvcHRpb25zW3Byb3BdOyB9XG4gIHJldHVybiBjbWRJdGVtKHRvZ2dsZU1hcmsobWFya1R5cGUpLCBwYXNzZWRPcHRpb25zKVxufVxuXG5mdW5jdGlvbiBsaW5rSXRlbShtYXJrVHlwZSkge1xuICByZXR1cm4gbmV3IE1lbnVJdGVtKHtcbiAgICB0aXRsZTogXCJBZGQgb3IgcmVtb3ZlIGxpbmtcIixcbiAgICBpY29uOiBpY29ucy5saW5rLFxuICAgIGFjdGl2ZTogZnVuY3Rpb24gYWN0aXZlKHN0YXRlKSB7IHJldHVybiBtYXJrQWN0aXZlKHN0YXRlLCBtYXJrVHlwZSkgfSxcbiAgICBlbmFibGU6IGZ1bmN0aW9uIGVuYWJsZShzdGF0ZSkgeyByZXR1cm4gIXN0YXRlLnNlbGVjdGlvbi5lbXB0eSB9LFxuICAgIHJ1bjogZnVuY3Rpb24gcnVuKHN0YXRlLCBkaXNwYXRjaCwgdmlldykge1xuICAgICAgaWYgKG1hcmtBY3RpdmUoc3RhdGUsIG1hcmtUeXBlKSkge1xuICAgICAgICB0b2dnbGVNYXJrKG1hcmtUeXBlKShzdGF0ZSwgZGlzcGF0Y2gpO1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgb3BlblByb21wdCh7XG4gICAgICAgIHRpdGxlOiBcIkNyZWF0ZSBhIGxpbmtcIixcbiAgICAgICAgZmllbGRzOiB7XG4gICAgICAgICAgaHJlZjogbmV3IFRleHRGaWVsZCh7XG4gICAgICAgICAgICBsYWJlbDogXCJMaW5rIHRhcmdldFwiLFxuICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICAgICAgICB9KSxcbiAgICAgICAgICB0aXRsZTogbmV3IFRleHRGaWVsZCh7bGFiZWw6IFwiVGl0bGVcIn0pXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbiBjYWxsYmFjayhhdHRycykge1xuICAgICAgICAgIHRvZ2dsZU1hcmsobWFya1R5cGUsIGF0dHJzKSh2aWV3LnN0YXRlLCB2aWV3LmRpc3BhdGNoKTtcbiAgICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSlcbn1cblxuZnVuY3Rpb24gd3JhcExpc3RJdGVtKG5vZGVUeXBlLCBvcHRpb25zKSB7XG4gIHJldHVybiBjbWRJdGVtKHdyYXBJbkxpc3Qobm9kZVR5cGUsIG9wdGlvbnMuYXR0cnMpLCBvcHRpb25zKVxufVxuXG4vLyA6OiAoU2NoZW1hKSDihpIgT2JqZWN0XG4vLyBHaXZlbiBhIHNjaGVtYSwgbG9vayBmb3IgZGVmYXVsdCBtYXJrIGFuZCBub2RlIHR5cGVzIGluIGl0IGFuZFxuLy8gcmV0dXJuIGFuIG9iamVjdCB3aXRoIHJlbGV2YW50IG1lbnUgaXRlbXMgcmVsYXRpbmcgdG8gdGhvc2UgbWFya3M6XG4vL1xuLy8gKipgdG9nZ2xlU3Ryb25nYCoqYDogTWVudUl0ZW1gXG4vLyAgIDogQSBtZW51IGl0ZW0gdG8gdG9nZ2xlIHRoZSBbc3Ryb25nIG1hcmtdKCNzY2hlbWEtYmFzaWMuU3Ryb25nTWFyaykuXG4vL1xuLy8gKipgdG9nZ2xlRW1gKipgOiBNZW51SXRlbWBcbi8vICAgOiBBIG1lbnUgaXRlbSB0byB0b2dnbGUgdGhlIFtlbXBoYXNpcyBtYXJrXSgjc2NoZW1hLWJhc2ljLkVtTWFyaykuXG4vL1xuLy8gKipgdG9nZ2xlQ29kZWAqKmA6IE1lbnVJdGVtYFxuLy8gICA6IEEgbWVudSBpdGVtIHRvIHRvZ2dsZSB0aGUgW2NvZGUgZm9udCBtYXJrXSgjc2NoZW1hLWJhc2ljLkNvZGVNYXJrKS5cbi8vXG4vLyAqKmB0b2dnbGVMaW5rYCoqYDogTWVudUl0ZW1gXG4vLyAgIDogQSBtZW51IGl0ZW0gdG8gdG9nZ2xlIHRoZSBbbGluayBtYXJrXSgjc2NoZW1hLWJhc2ljLkxpbmtNYXJrKS5cbi8vXG4vLyAqKmBpbnNlcnRJbWFnZWAqKmA6IE1lbnVJdGVtYFxuLy8gICA6IEEgbWVudSBpdGVtIHRvIGluc2VydCBhbiBbaW1hZ2VdKCNzY2hlbWEtYmFzaWMuSW1hZ2UpLlxuLy9cbi8vICoqYHdyYXBCdWxsZXRMaXN0YCoqYDogTWVudUl0ZW1gXG4vLyAgIDogQSBtZW51IGl0ZW0gdG8gd3JhcCB0aGUgc2VsZWN0aW9uIGluIGEgW2J1bGxldCBsaXN0XSgjc2NoZW1hLWxpc3QuQnVsbGV0TGlzdCkuXG4vL1xuLy8gKipgd3JhcE9yZGVyZWRMaXN0YCoqYDogTWVudUl0ZW1gXG4vLyAgIDogQSBtZW51IGl0ZW0gdG8gd3JhcCB0aGUgc2VsZWN0aW9uIGluIGFuIFtvcmRlcmVkIGxpc3RdKCNzY2hlbWEtbGlzdC5PcmRlcmVkTGlzdCkuXG4vL1xuLy8gKipgd3JhcEJsb2NrUXVvdGVgKipgOiBNZW51SXRlbWBcbi8vICAgOiBBIG1lbnUgaXRlbSB0byB3cmFwIHRoZSBzZWxlY3Rpb24gaW4gYSBbYmxvY2sgcXVvdGVdKCNzY2hlbWEtYmFzaWMuQmxvY2tRdW90ZSkuXG4vL1xuLy8gKipgbWFrZVBhcmFncmFwaGAqKmA6IE1lbnVJdGVtYFxuLy8gICA6IEEgbWVudSBpdGVtIHRvIHNldCB0aGUgY3VycmVudCB0ZXh0YmxvY2sgdG8gYmUgYSBub3JtYWxcbi8vICAgICBbcGFyYWdyYXBoXSgjc2NoZW1hLWJhc2ljLlBhcmFncmFwaCkuXG4vL1xuLy8gKipgbWFrZUNvZGVCbG9ja2AqKmA6IE1lbnVJdGVtYFxuLy8gICA6IEEgbWVudSBpdGVtIHRvIHNldCB0aGUgY3VycmVudCB0ZXh0YmxvY2sgdG8gYmUgYVxuLy8gICAgIFtjb2RlIGJsb2NrXSgjc2NoZW1hLWJhc2ljLkNvZGVCbG9jaykuXG4vL1xuLy8gKipgbWFrZUhlYWRbTl1gKipgOiBNZW51SXRlbWBcbi8vICAgOiBXaGVyZSBfTl8gaXMgMSB0byA2LiBNZW51IGl0ZW1zIHRvIHNldCB0aGUgY3VycmVudCB0ZXh0YmxvY2sgdG9cbi8vICAgICBiZSBhIFtoZWFkaW5nXSgjc2NoZW1hLWJhc2ljLkhlYWRpbmcpIG9mIGxldmVsIF9OXy5cbi8vXG4vLyAqKmBpbnNlcnRIb3Jpem9udGFsUnVsZWAqKmA6IE1lbnVJdGVtYFxuLy8gICA6IEEgbWVudSBpdGVtIHRvIGluc2VydCBhIGhvcml6b250YWwgcnVsZS5cbi8vXG4vLyBUaGUgcmV0dXJuIHZhbHVlIGFsc28gY29udGFpbnMgc29tZSBwcmVmYWJyaWNhdGVkIG1lbnUgZWxlbWVudHMgYW5kXG4vLyBtZW51cywgdGhhdCB5b3UgY2FuIHVzZSBpbnN0ZWFkIG9mIGNvbXBvc2luZyB5b3VyIG93biBtZW51IGZyb21cbi8vIHNjcmF0Y2g6XG4vL1xuLy8gKipgaW5zZXJ0TWVudWAqKmA6IERyb3Bkb3duYFxuLy8gICA6IEEgZHJvcGRvd24gY29udGFpbmluZyB0aGUgYGluc2VydEltYWdlYCBhbmRcbi8vICAgICBgaW5zZXJ0SG9yaXpvbnRhbFJ1bGVgIGl0ZW1zLlxuLy9cbi8vICoqYHR5cGVNZW51YCoqYDogRHJvcGRvd25gXG4vLyAgIDogQSBkcm9wZG93biBjb250YWluaW5nIHRoZSBpdGVtcyBmb3IgbWFraW5nIHRoZSBjdXJyZW50XG4vLyAgICAgdGV4dGJsb2NrIGEgcGFyYWdyYXBoLCBjb2RlIGJsb2NrLCBvciBoZWFkaW5nLlxuLy9cbi8vICoqYGZ1bGxNZW51YCoqYDogW1tNZW51RWxlbWVudF1dYFxuLy8gICA6IEFuIGFycmF5IG9mIGFycmF5cyBvZiBtZW51IGVsZW1lbnRzIGZvciB1c2UgYXMgdGhlIGZ1bGwgbWVudVxuLy8gICAgIGZvciwgZm9yIGV4YW1wbGUgdGhlIFttZW51IGJhcl0oaHR0cHM6Ly9naXRodWIuY29tL3Byb3NlbWlycm9yL3Byb3NlbWlycm9yLW1lbnUjdXNlci1jb250ZW50LW1lbnViYXIpLlxuZnVuY3Rpb24gYnVpbGRNZW51SXRlbXMoc2NoZW1hKSB7XG4gIHZhciByID0ge30sIHR5cGU7XG4gIGlmICh0eXBlID0gc2NoZW1hLm1hcmtzLnN0cm9uZylcbiAgICB7IHIudG9nZ2xlU3Ryb25nID0gbWFya0l0ZW0odHlwZSwge3RpdGxlOiBcIlRvZ2dsZSBzdHJvbmcgc3R5bGVcIiwgaWNvbjogaWNvbnMuc3Ryb25nfSk7IH1cbiAgaWYgKHR5cGUgPSBzY2hlbWEubWFya3MuZW0pXG4gICAgeyByLnRvZ2dsZUVtID0gbWFya0l0ZW0odHlwZSwge3RpdGxlOiBcIlRvZ2dsZSBlbXBoYXNpc1wiLCBpY29uOiBpY29ucy5lbX0pOyB9XG4gIGlmICh0eXBlID0gc2NoZW1hLm1hcmtzLmNvZGUpXG4gICAgeyByLnRvZ2dsZUNvZGUgPSBtYXJrSXRlbSh0eXBlLCB7dGl0bGU6IFwiVG9nZ2xlIGNvZGUgZm9udFwiLCBpY29uOiBpY29ucy5jb2RlfSk7IH1cbiAgaWYgKHR5cGUgPSBzY2hlbWEubWFya3MubGluaylcbiAgICB7IHIudG9nZ2xlTGluayA9IGxpbmtJdGVtKHR5cGUpOyB9XG5cbiAgaWYgKHR5cGUgPSBzY2hlbWEubm9kZXMuaW1hZ2UpXG4gICAgeyByLmluc2VydEltYWdlID0gaW5zZXJ0SW1hZ2VJdGVtKHR5cGUpOyB9XG4gIGlmICh0eXBlID0gc2NoZW1hLm5vZGVzLmJ1bGxldF9saXN0KVxuICAgIHsgci53cmFwQnVsbGV0TGlzdCA9IHdyYXBMaXN0SXRlbSh0eXBlLCB7XG4gICAgICB0aXRsZTogXCJXcmFwIGluIGJ1bGxldCBsaXN0XCIsXG4gICAgICBpY29uOiBpY29ucy5idWxsZXRMaXN0XG4gICAgfSk7IH1cbiAgaWYgKHR5cGUgPSBzY2hlbWEubm9kZXMub3JkZXJlZF9saXN0KVxuICAgIHsgci53cmFwT3JkZXJlZExpc3QgPSB3cmFwTGlzdEl0ZW0odHlwZSwge1xuICAgICAgdGl0bGU6IFwiV3JhcCBpbiBvcmRlcmVkIGxpc3RcIixcbiAgICAgIGljb246IGljb25zLm9yZGVyZWRMaXN0XG4gICAgfSk7IH1cbiAgaWYgKHR5cGUgPSBzY2hlbWEubm9kZXMuYmxvY2txdW90ZSlcbiAgICB7IHIud3JhcEJsb2NrUXVvdGUgPSB3cmFwSXRlbSh0eXBlLCB7XG4gICAgICB0aXRsZTogXCJXcmFwIGluIGJsb2NrIHF1b3RlXCIsXG4gICAgICBpY29uOiBpY29ucy5ibG9ja3F1b3RlXG4gICAgfSk7IH1cbiAgaWYgKHR5cGUgPSBzY2hlbWEubm9kZXMucGFyYWdyYXBoKVxuICAgIHsgci5tYWtlUGFyYWdyYXBoID0gYmxvY2tUeXBlSXRlbSh0eXBlLCB7XG4gICAgICB0aXRsZTogXCJDaGFuZ2UgdG8gcGFyYWdyYXBoXCIsXG4gICAgICBsYWJlbDogXCJQbGFpblwiXG4gICAgfSk7IH1cbiAgaWYgKHR5cGUgPSBzY2hlbWEubm9kZXMuY29kZV9ibG9jaylcbiAgICB7IHIubWFrZUNvZGVCbG9jayA9IGJsb2NrVHlwZUl0ZW0odHlwZSwge1xuICAgICAgdGl0bGU6IFwiQ2hhbmdlIHRvIGNvZGUgYmxvY2tcIixcbiAgICAgIGxhYmVsOiBcIkNvZGVcIlxuICAgIH0pOyB9XG4gIGlmICh0eXBlID0gc2NoZW1hLm5vZGVzLmhlYWRpbmcpXG4gICAgeyBmb3IgKHZhciBpID0gMTsgaSA8PSAxMDsgaSsrKVxuICAgICAgeyByW1wibWFrZUhlYWRcIiArIGldID0gYmxvY2tUeXBlSXRlbSh0eXBlLCB7XG4gICAgICAgIHRpdGxlOiBcIkNoYW5nZSB0byBoZWFkaW5nIFwiICsgaSxcbiAgICAgICAgbGFiZWw6IFwiTGV2ZWwgXCIgKyBpLFxuICAgICAgICBhdHRyczoge2xldmVsOiBpfVxuICAgICAgfSk7IH0gfVxuICBpZiAodHlwZSA9IHNjaGVtYS5ub2Rlcy5ob3Jpem9udGFsX3J1bGUpIHtcbiAgICB2YXIgaHIgPSB0eXBlO1xuICAgIHIuaW5zZXJ0SG9yaXpvbnRhbFJ1bGUgPSBuZXcgTWVudUl0ZW0oe1xuICAgICAgdGl0bGU6IFwiSW5zZXJ0IGhvcml6b250YWwgcnVsZVwiLFxuICAgICAgbGFiZWw6IFwiSG9yaXpvbnRhbCBydWxlXCIsXG4gICAgICBlbmFibGU6IGZ1bmN0aW9uIGVuYWJsZShzdGF0ZSkgeyByZXR1cm4gY2FuSW5zZXJ0KHN0YXRlLCBocikgfSxcbiAgICAgIHJ1bjogZnVuY3Rpb24gcnVuKHN0YXRlLCBkaXNwYXRjaCkgeyBkaXNwYXRjaChzdGF0ZS50ci5yZXBsYWNlU2VsZWN0aW9uV2l0aChoci5jcmVhdGUoKSkpOyB9XG4gICAgfSk7XG4gIH1cblxuICB2YXIgY3V0ID0gZnVuY3Rpb24gKGFycikgeyByZXR1cm4gYXJyLmZpbHRlcihmdW5jdGlvbiAoeCkgeyByZXR1cm4geDsgfSk7IH07XG4gIHIuaW5zZXJ0TWVudSA9IG5ldyBEcm9wZG93bihjdXQoW3IuaW5zZXJ0SW1hZ2UsIHIuaW5zZXJ0SG9yaXpvbnRhbFJ1bGVdKSwge2xhYmVsOiBcIkluc2VydFwifSk7XG4gIHIudHlwZU1lbnUgPSBuZXcgRHJvcGRvd24oY3V0KFtyLm1ha2VQYXJhZ3JhcGgsIHIubWFrZUNvZGVCbG9jaywgci5tYWtlSGVhZDEgJiYgbmV3IERyb3Bkb3duU3VibWVudShjdXQoW1xuICAgIHIubWFrZUhlYWQxLCByLm1ha2VIZWFkMiwgci5tYWtlSGVhZDMsIHIubWFrZUhlYWQ0LCByLm1ha2VIZWFkNSwgci5tYWtlSGVhZDZcbiAgXSksIHtsYWJlbDogXCJIZWFkaW5nXCJ9KV0pLCB7bGFiZWw6IFwiVHlwZS4uLlwifSk7XG5cbiAgci5pbmxpbmVNZW51ID0gW2N1dChbci50b2dnbGVTdHJvbmcsIHIudG9nZ2xlRW0sIHIudG9nZ2xlQ29kZSwgci50b2dnbGVMaW5rXSldO1xuICByLmJsb2NrTWVudSA9IFtjdXQoW3Iud3JhcEJ1bGxldExpc3QsIHIud3JhcE9yZGVyZWRMaXN0LCByLndyYXBCbG9ja1F1b3RlLCBqb2luVXBJdGVtLFxuICAgICAgICAgICAgICAgICAgICAgIGxpZnRJdGVtLCBzZWxlY3RQYXJlbnROb2RlSXRlbV0pXTtcbiAgci5mdWxsTWVudSA9IHIuaW5saW5lTWVudS5jb25jYXQoW1tyLmluc2VydE1lbnUsIHIudHlwZU1lbnVdXSwgW1t1bmRvSXRlbSwgcmVkb0l0ZW1dXSwgci5ibG9ja01lbnUpO1xuXG4gIHJldHVybiByXG59XG5cbnZhciBtYWMgPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgPyAvTWFjLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSkgOiBmYWxzZTtcblxuLy8gOjogKFNjaGVtYSwgP09iamVjdCkg4oaSIE9iamVjdFxuLy8gSW5zcGVjdCB0aGUgZ2l2ZW4gc2NoZW1hIGxvb2tpbmcgZm9yIG1hcmtzIGFuZCBub2RlcyBmcm9tIHRoZVxuLy8gYmFzaWMgc2NoZW1hLCBhbmQgaWYgZm91bmQsIGFkZCBrZXkgYmluZGluZ3MgcmVsYXRlZCB0byB0aGVtLlxuLy8gVGhpcyB3aWxsIGFkZDpcbi8vXG4vLyAqICoqTW9kLWIqKiBmb3IgdG9nZ2xpbmcgW3N0cm9uZ10oI3NjaGVtYS1iYXNpYy5TdHJvbmdNYXJrKVxuLy8gKiAqKk1vZC1pKiogZm9yIHRvZ2dsaW5nIFtlbXBoYXNpc10oI3NjaGVtYS1iYXNpYy5FbU1hcmspXG4vLyAqICoqTW9kLWAqKiBmb3IgdG9nZ2xpbmcgW2NvZGUgZm9udF0oI3NjaGVtYS1iYXNpYy5Db2RlTWFyaylcbi8vICogKipDdHJsLVNoaWZ0LTAqKiBmb3IgbWFraW5nIHRoZSBjdXJyZW50IHRleHRibG9jayBhIHBhcmFncmFwaFxuLy8gKiAqKkN0cmwtU2hpZnQtMSoqIHRvICoqQ3RybC1TaGlmdC1EaWdpdDYqKiBmb3IgbWFraW5nIHRoZSBjdXJyZW50XG4vLyAgIHRleHRibG9jayBhIGhlYWRpbmcgb2YgdGhlIGNvcnJlc3BvbmRpbmcgbGV2ZWxcbi8vICogKipDdHJsLVNoaWZ0LUJhY2tzbGFzaCoqIHRvIG1ha2UgdGhlIGN1cnJlbnQgdGV4dGJsb2NrIGEgY29kZSBibG9ja1xuLy8gKiAqKkN0cmwtU2hpZnQtOCoqIHRvIHdyYXAgdGhlIHNlbGVjdGlvbiBpbiBhbiBvcmRlcmVkIGxpc3Rcbi8vICogKipDdHJsLVNoaWZ0LTkqKiB0byB3cmFwIHRoZSBzZWxlY3Rpb24gaW4gYSBidWxsZXQgbGlzdFxuLy8gKiAqKkN0cmwtPioqIHRvIHdyYXAgdGhlIHNlbGVjdGlvbiBpbiBhIGJsb2NrIHF1b3RlXG4vLyAqICoqRW50ZXIqKiB0byBzcGxpdCBhIG5vbi1lbXB0eSB0ZXh0YmxvY2sgaW4gYSBsaXN0IGl0ZW0gd2hpbGUgYXRcbi8vICAgdGhlIHNhbWUgdGltZSBzcGxpdHRpbmcgdGhlIGxpc3QgaXRlbVxuLy8gKiAqKk1vZC1FbnRlcioqIHRvIGluc2VydCBhIGhhcmQgYnJlYWtcbi8vICogKipNb2QtXyoqIHRvIGluc2VydCBhIGhvcml6b250YWwgcnVsZVxuLy8gKiAqKkJhY2tzcGFjZSoqIHRvIHVuZG8gYW4gaW5wdXQgcnVsZVxuLy8gKiAqKkFsdC1BcnJvd1VwKiogdG8gYGpvaW5VcGBcbi8vICogKipBbHQtQXJyb3dEb3duKiogdG8gYGpvaW5Eb3duYFxuLy8gKiAqKk1vZC1CcmFja2V0TGVmdCoqIHRvIGBsaWZ0YFxuLy8gKiAqKkVzY2FwZSoqIHRvIGBzZWxlY3RQYXJlbnROb2RlYFxuLy9cbi8vIFlvdSBjYW4gc3VwcHJlc3Mgb3IgbWFwIHRoZXNlIGJpbmRpbmdzIGJ5IHBhc3NpbmcgYSBgbWFwS2V5c2Bcbi8vIGFyZ3VtZW50LCB3aGljaCBtYXBzIGtleSBuYW1lcyAoc2F5IGBcIk1vZC1CXCJgIHRvIGVpdGhlciBgZmFsc2VgLCB0b1xuLy8gcmVtb3ZlIHRoZSBiaW5kaW5nLCBvciBhIG5ldyBrZXkgbmFtZSBzdHJpbmcuXG5mdW5jdGlvbiBidWlsZEtleW1hcChzY2hlbWEsIG1hcEtleXMpIHtcbiAgdmFyIGtleXMgPSB7fSwgdHlwZTtcbiAgZnVuY3Rpb24gYmluZChrZXksIGNtZCkge1xuICAgIGlmIChtYXBLZXlzKSB7XG4gICAgICB2YXIgbWFwcGVkID0gbWFwS2V5c1trZXldO1xuICAgICAgaWYgKG1hcHBlZCA9PT0gZmFsc2UpIHsgcmV0dXJuIH1cbiAgICAgIGlmIChtYXBwZWQpIHsga2V5ID0gbWFwcGVkOyB9XG4gICAgfVxuICAgIGtleXNba2V5XSA9IGNtZDtcbiAgfVxuXG5cbiAgYmluZChcIk1vZC16XCIsIHVuZG8pO1xuICBiaW5kKFwiU2hpZnQtTW9kLXpcIiwgcmVkbyk7XG4gIGJpbmQoXCJCYWNrc3BhY2VcIiwgdW5kb0lucHV0UnVsZSk7XG4gIGlmICghbWFjKSB7IGJpbmQoXCJNb2QteVwiLCByZWRvKTsgfVxuXG4gIGJpbmQoXCJBbHQtQXJyb3dVcFwiLCBqb2luVXApO1xuICBiaW5kKFwiQWx0LUFycm93RG93blwiLCBqb2luRG93bik7XG4gIGJpbmQoXCJNb2QtQnJhY2tldExlZnRcIiwgbGlmdCk7XG4gIGJpbmQoXCJFc2NhcGVcIiwgc2VsZWN0UGFyZW50Tm9kZSk7XG5cbiAgaWYgKHR5cGUgPSBzY2hlbWEubWFya3Muc3Ryb25nKSB7XG4gICAgYmluZChcIk1vZC1iXCIsIHRvZ2dsZU1hcmsodHlwZSkpO1xuICAgIGJpbmQoXCJNb2QtQlwiLCB0b2dnbGVNYXJrKHR5cGUpKTtcbiAgfVxuICBpZiAodHlwZSA9IHNjaGVtYS5tYXJrcy5lbSkge1xuICAgIGJpbmQoXCJNb2QtaVwiLCB0b2dnbGVNYXJrKHR5cGUpKTtcbiAgICBiaW5kKFwiTW9kLUlcIiwgdG9nZ2xlTWFyayh0eXBlKSk7XG4gIH1cbiAgaWYgKHR5cGUgPSBzY2hlbWEubWFya3MuY29kZSlcbiAgICB7IGJpbmQoXCJNb2QtYFwiLCB0b2dnbGVNYXJrKHR5cGUpKTsgfVxuXG4gIGlmICh0eXBlID0gc2NoZW1hLm5vZGVzLmJ1bGxldF9saXN0KVxuICAgIHsgYmluZChcIlNoaWZ0LUN0cmwtOFwiLCB3cmFwSW5MaXN0KHR5cGUpKTsgfVxuICBpZiAodHlwZSA9IHNjaGVtYS5ub2Rlcy5vcmRlcmVkX2xpc3QpXG4gICAgeyBiaW5kKFwiU2hpZnQtQ3RybC05XCIsIHdyYXBJbkxpc3QodHlwZSkpOyB9XG4gIGlmICh0eXBlID0gc2NoZW1hLm5vZGVzLmJsb2NrcXVvdGUpXG4gICAgeyBiaW5kKFwiQ3RybC0+XCIsIHdyYXBJbih0eXBlKSk7IH1cbiAgaWYgKHR5cGUgPSBzY2hlbWEubm9kZXMuaGFyZF9icmVhaykge1xuICAgIHZhciBiciA9IHR5cGUsIGNtZCA9IGNoYWluQ29tbWFuZHMoZXhpdENvZGUsIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLnJlcGxhY2VTZWxlY3Rpb25XaXRoKGJyLmNyZWF0ZSgpKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSk7XG4gICAgYmluZChcIk1vZC1FbnRlclwiLCBjbWQpO1xuICAgIGJpbmQoXCJTaGlmdC1FbnRlclwiLCBjbWQpO1xuICAgIGlmIChtYWMpIHsgYmluZChcIkN0cmwtRW50ZXJcIiwgY21kKTsgfVxuICB9XG4gIGlmICh0eXBlID0gc2NoZW1hLm5vZGVzLmxpc3RfaXRlbSkge1xuICAgIGJpbmQoXCJFbnRlclwiLCBzcGxpdExpc3RJdGVtKHR5cGUpKTtcbiAgICBiaW5kKFwiTW9kLVtcIiwgbGlmdExpc3RJdGVtKHR5cGUpKTtcbiAgICBiaW5kKFwiTW9kLV1cIiwgc2lua0xpc3RJdGVtKHR5cGUpKTtcbiAgfVxuICBpZiAodHlwZSA9IHNjaGVtYS5ub2Rlcy5wYXJhZ3JhcGgpXG4gICAgeyBiaW5kKFwiU2hpZnQtQ3RybC0wXCIsIHNldEJsb2NrVHlwZSh0eXBlKSk7IH1cbiAgaWYgKHR5cGUgPSBzY2hlbWEubm9kZXMuY29kZV9ibG9jaylcbiAgICB7IGJpbmQoXCJTaGlmdC1DdHJsLVxcXFxcIiwgc2V0QmxvY2tUeXBlKHR5cGUpKTsgfVxuICBpZiAodHlwZSA9IHNjaGVtYS5ub2Rlcy5oZWFkaW5nKVxuICAgIHsgZm9yICh2YXIgaSA9IDE7IGkgPD0gNjsgaSsrKSB7IGJpbmQoXCJTaGlmdC1DdHJsLVwiICsgaSwgc2V0QmxvY2tUeXBlKHR5cGUsIHtsZXZlbDogaX0pKTsgfSB9XG4gIGlmICh0eXBlID0gc2NoZW1hLm5vZGVzLmhvcml6b250YWxfcnVsZSkge1xuICAgIHZhciBociA9IHR5cGU7XG4gICAgYmluZChcIk1vZC1fXCIsIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLnJlcGxhY2VTZWxlY3Rpb25XaXRoKGhyLmNyZWF0ZSgpKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4ga2V5c1xufVxuXG4vLyA6IChOb2RlVHlwZSkg4oaSIElucHV0UnVsZVxuLy8gR2l2ZW4gYSBibG9ja3F1b3RlIG5vZGUgdHlwZSwgcmV0dXJucyBhbiBpbnB1dCBydWxlIHRoYXQgdHVybnMgYFwiPiBcImBcbi8vIGF0IHRoZSBzdGFydCBvZiBhIHRleHRibG9jayBpbnRvIGEgYmxvY2txdW90ZS5cbmZ1bmN0aW9uIGJsb2NrUXVvdGVSdWxlKG5vZGVUeXBlKSB7XG4gIHJldHVybiB3cmFwcGluZ0lucHV0UnVsZSgvXlxccyo+XFxzJC8sIG5vZGVUeXBlKVxufVxuXG4vLyA6IChOb2RlVHlwZSkg4oaSIElucHV0UnVsZVxuLy8gR2l2ZW4gYSBsaXN0IG5vZGUgdHlwZSwgcmV0dXJucyBhbiBpbnB1dCBydWxlIHRoYXQgdHVybnMgYSBudW1iZXJcbi8vIGZvbGxvd2VkIGJ5IGEgZG90IGF0IHRoZSBzdGFydCBvZiBhIHRleHRibG9jayBpbnRvIGFuIG9yZGVyZWQgbGlzdC5cbmZ1bmN0aW9uIG9yZGVyZWRMaXN0UnVsZShub2RlVHlwZSkge1xuICByZXR1cm4gd3JhcHBpbmdJbnB1dFJ1bGUoL14oXFxkKylcXC5cXHMkLywgbm9kZVR5cGUsIGZ1bmN0aW9uIChtYXRjaCkgeyByZXR1cm4gKHtvcmRlcjogK21hdGNoWzFdfSk7IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAobWF0Y2gsIG5vZGUpIHsgcmV0dXJuIG5vZGUuY2hpbGRDb3VudCArIG5vZGUuYXR0cnMub3JkZXIgPT0gK21hdGNoWzFdOyB9KVxufVxuXG4vLyA6IChOb2RlVHlwZSkg4oaSIElucHV0UnVsZVxuLy8gR2l2ZW4gYSBsaXN0IG5vZGUgdHlwZSwgcmV0dXJucyBhbiBpbnB1dCBydWxlIHRoYXQgdHVybnMgYSBidWxsZXRcbi8vIChkYXNoLCBwbHVzaCwgb3IgYXN0ZXJpc2spIGF0IHRoZSBzdGFydCBvZiBhIHRleHRibG9jayBpbnRvIGFcbi8vIGJ1bGxldCBsaXN0LlxuZnVuY3Rpb24gYnVsbGV0TGlzdFJ1bGUobm9kZVR5cGUpIHtcbiAgcmV0dXJuIHdyYXBwaW5nSW5wdXRSdWxlKC9eXFxzKihbLSsqXSlcXHMkLywgbm9kZVR5cGUpXG59XG5cbi8vIDogKE5vZGVUeXBlKSDihpIgSW5wdXRSdWxlXG4vLyBHaXZlbiBhIGNvZGUgYmxvY2sgbm9kZSB0eXBlLCByZXR1cm5zIGFuIGlucHV0IHJ1bGUgdGhhdCB0dXJucyBhXG4vLyB0ZXh0YmxvY2sgc3RhcnRpbmcgd2l0aCB0aHJlZSBiYWNrdGlja3MgaW50byBhIGNvZGUgYmxvY2suXG5mdW5jdGlvbiBjb2RlQmxvY2tSdWxlKG5vZGVUeXBlKSB7XG4gIHJldHVybiB0ZXh0YmxvY2tUeXBlSW5wdXRSdWxlKC9eYGBgJC8sIG5vZGVUeXBlKVxufVxuXG4vLyA6IChOb2RlVHlwZSwgbnVtYmVyKSDihpIgSW5wdXRSdWxlXG4vLyBHaXZlbiBhIG5vZGUgdHlwZSBhbmQgYSBtYXhpbXVtIGxldmVsLCBjcmVhdGVzIGFuIGlucHV0IHJ1bGUgdGhhdFxuLy8gdHVybnMgdXAgdG8gdGhhdCBudW1iZXIgb2YgYCNgIGNoYXJhY3RlcnMgZm9sbG93ZWQgYnkgYSBzcGFjZSBhdFxuLy8gdGhlIHN0YXJ0IG9mIGEgdGV4dGJsb2NrIGludG8gYSBoZWFkaW5nIHdob3NlIGxldmVsIGNvcnJlc3BvbmRzIHRvXG4vLyB0aGUgbnVtYmVyIG9mIGAjYCBzaWducy5cbmZ1bmN0aW9uIGhlYWRpbmdSdWxlKG5vZGVUeXBlLCBtYXhMZXZlbCkge1xuICByZXR1cm4gdGV4dGJsb2NrVHlwZUlucHV0UnVsZShuZXcgUmVnRXhwKFwiXigjezEsXCIgKyBtYXhMZXZlbCArIFwifSlcXFxccyRcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVUeXBlLCBmdW5jdGlvbiAobWF0Y2gpIHsgcmV0dXJuICh7bGV2ZWw6IG1hdGNoWzFdLmxlbmd0aH0pOyB9KVxufVxuXG4vLyA6IChTY2hlbWEpIOKGkiBQbHVnaW5cbi8vIEEgc2V0IG9mIGlucHV0IHJ1bGVzIGZvciBjcmVhdGluZyB0aGUgYmFzaWMgYmxvY2sgcXVvdGVzLCBsaXN0cyxcbi8vIGNvZGUgYmxvY2tzLCBhbmQgaGVhZGluZy5cbmZ1bmN0aW9uIGJ1aWxkSW5wdXRSdWxlcyhzY2hlbWEpIHtcbiAgdmFyIHJ1bGVzID0gc21hcnRRdW90ZXMuY29uY2F0KGVsbGlwc2lzLCBlbURhc2gpLCB0eXBlO1xuICBpZiAodHlwZSA9IHNjaGVtYS5ub2Rlcy5ibG9ja3F1b3RlKSB7IHJ1bGVzLnB1c2goYmxvY2tRdW90ZVJ1bGUodHlwZSkpOyB9XG4gIGlmICh0eXBlID0gc2NoZW1hLm5vZGVzLm9yZGVyZWRfbGlzdCkgeyBydWxlcy5wdXNoKG9yZGVyZWRMaXN0UnVsZSh0eXBlKSk7IH1cbiAgaWYgKHR5cGUgPSBzY2hlbWEubm9kZXMuYnVsbGV0X2xpc3QpIHsgcnVsZXMucHVzaChidWxsZXRMaXN0UnVsZSh0eXBlKSk7IH1cbiAgaWYgKHR5cGUgPSBzY2hlbWEubm9kZXMuY29kZV9ibG9jaykgeyBydWxlcy5wdXNoKGNvZGVCbG9ja1J1bGUodHlwZSkpOyB9XG4gIGlmICh0eXBlID0gc2NoZW1hLm5vZGVzLmhlYWRpbmcpIHsgcnVsZXMucHVzaChoZWFkaW5nUnVsZSh0eXBlLCA2KSk7IH1cbiAgcmV0dXJuIGlucHV0UnVsZXMoe3J1bGVzOiBydWxlc30pXG59XG5cbi8vICEhIFRoaXMgbW9kdWxlIGV4cG9ydHMgaGVscGVyIGZ1bmN0aW9ucyBmb3IgZGVyaXZpbmcgYSBzZXQgb2YgYmFzaWNcbi8vIG1lbnUgaXRlbXMsIGlucHV0IHJ1bGVzLCBvciBrZXkgYmluZGluZ3MgZnJvbSBhIHNjaGVtYS4gVGhlc2Vcbi8vIHZhbHVlcyBuZWVkIHRvIGtub3cgYWJvdXQgdGhlIHNjaGVtYSBmb3IgdHdvIHJlYXNvbnPigJR0aGV5IG5lZWRcbi8vIGFjY2VzcyB0byBzcGVjaWZpYyBpbnN0YW5jZXMgb2Ygbm9kZSBhbmQgbWFyayB0eXBlcywgYW5kIHRoZXkgbmVlZFxuLy8gdG8ga25vdyB3aGljaCBvZiB0aGUgbm9kZSBhbmQgbWFyayB0eXBlcyB0aGF0IHRoZXkga25vdyBhYm91dCBhcmVcbi8vIGFjdHVhbGx5IHByZXNlbnQgaW4gdGhlIHNjaGVtYS5cbi8vXG4vLyBUaGUgYGV4YW1wbGVTZXR1cGAgcGx1Z2luIHRpZXMgdGhlc2UgdG9nZXRoZXIgaW50byBhIHBsdWdpbiB0aGF0XG4vLyB3aWxsIGF1dG9tYXRpY2FsbHkgZW5hYmxlIHRoaXMgYmFzaWMgZnVuY3Rpb25hbGl0eSBpbiBhbiBlZGl0b3IuXG5cbi8vIDo6IChPYmplY3QpIOKGkiBbUGx1Z2luXVxuLy8gQSBjb252ZW5pZW5jZSBwbHVnaW4gdGhhdCBidW5kbGVzIHRvZ2V0aGVyIGEgc2ltcGxlIG1lbnUgd2l0aCBiYXNpY1xuLy8ga2V5IGJpbmRpbmdzLCBpbnB1dCBydWxlcywgYW5kIHN0eWxpbmcgZm9yIHRoZSBleGFtcGxlIHNjaGVtYS5cbi8vIFByb2JhYmx5IG9ubHkgdXNlZnVsIGZvciBxdWlja2x5IHNldHRpbmcgdXAgYSBwYXNzYWJsZVxuLy8gZWRpdG9y4oCUeW91J2xsIG5lZWQgbW9yZSBjb250cm9sIG92ZXIgeW91ciBzZXR0aW5ncyBpbiBtb3N0XG4vLyByZWFsLXdvcmxkIHNpdHVhdGlvbnMuXG4vL1xuLy8gICBvcHRpb25zOjotIFRoZSBmb2xsb3dpbmcgb3B0aW9ucyBhcmUgcmVjb2duaXplZDpcbi8vXG4vLyAgICAgc2NoZW1hOjogU2NoZW1hXG4vLyAgICAgVGhlIHNjaGVtYSB0byBnZW5lcmF0ZSBrZXkgYmluZGluZ3MgYW5kIG1lbnUgaXRlbXMgZm9yLlxuLy9cbi8vICAgICBtYXBLZXlzOjogP09iamVjdFxuLy8gICAgIENhbiBiZSB1c2VkIHRvIFthZGp1c3RdKCNleGFtcGxlLXNldHVwLmJ1aWxkS2V5bWFwKSB0aGUga2V5IGJpbmRpbmdzIGNyZWF0ZWQuXG4vL1xuLy8gICAgIG1lbnVCYXI6OiA/Ym9vbFxuLy8gICAgIFNldCB0byBmYWxzZSB0byBkaXNhYmxlIHRoZSBtZW51IGJhci5cbi8vXG4vLyAgICAgaGlzdG9yeTo6ID9ib29sXG4vLyAgICAgU2V0IHRvIGZhbHNlIHRvIGRpc2FibGUgdGhlIGhpc3RvcnkgcGx1Z2luLlxuLy9cbi8vICAgICBmbG9hdGluZ01lbnU6OiA/Ym9vbFxuLy8gICAgIFNldCB0byBmYWxzZSB0byBtYWtlIHRoZSBtZW51IGJhciBub24tZmxvYXRpbmcuXG4vL1xuLy8gICAgIG1lbnVDb250ZW50OjogW1tNZW51SXRlbV1dXG4vLyAgICAgQ2FuIGJlIHVzZWQgdG8gb3ZlcnJpZGUgdGhlIG1lbnUgY29udGVudC5cbmZ1bmN0aW9uIGV4YW1wbGVTZXR1cChvcHRpb25zKSB7XG4gIHZhciBwbHVnaW5zID0gW1xuICAgIGJ1aWxkSW5wdXRSdWxlcyhvcHRpb25zLnNjaGVtYSksXG4gICAga2V5bWFwKGJ1aWxkS2V5bWFwKG9wdGlvbnMuc2NoZW1hLCBvcHRpb25zLm1hcEtleXMpKSxcbiAgICBrZXltYXAoYmFzZUtleW1hcCksXG4gICAgZHJvcEN1cnNvcigpLFxuICAgIGdhcEN1cnNvcigpXG4gIF07XG4gIGlmIChvcHRpb25zLm1lbnVCYXIgIT09IGZhbHNlKVxuICAgIHsgcGx1Z2lucy5wdXNoKG1lbnVCYXIoe2Zsb2F0aW5nOiBvcHRpb25zLmZsb2F0aW5nTWVudSAhPT0gZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IG9wdGlvbnMubWVudUNvbnRlbnQgfHwgYnVpbGRNZW51SXRlbXMob3B0aW9ucy5zY2hlbWEpLmZ1bGxNZW51fSkpOyB9XG4gIGlmIChvcHRpb25zLmhpc3RvcnkgIT09IGZhbHNlKVxuICAgIHsgcGx1Z2lucy5wdXNoKGhpc3RvcnkoKSk7IH1cblxuICByZXR1cm4gcGx1Z2lucy5jb25jYXQobmV3IFBsdWdpbih7XG4gICAgcHJvcHM6IHtcbiAgICAgIGF0dHJpYnV0ZXM6IHtjbGFzczogXCJQcm9zZU1pcnJvci1leGFtcGxlLXNldHVwLXN0eWxlXCJ9XG4gICAgfVxuICB9KSlcbn1cblxuZXhwb3J0IHsgYnVpbGRJbnB1dFJ1bGVzLCBidWlsZEtleW1hcCwgYnVpbGRNZW51SXRlbXMsIGV4YW1wbGVTZXR1cCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXMuanMubWFwXG4iLCJpbXBvcnQgeyBrZXlkb3duSGFuZGxlciB9IGZyb20gJ3Byb3NlbWlycm9yLWtleW1hcCc7XG5pbXBvcnQgeyBOb2RlU2VsZWN0aW9uLCBTZWxlY3Rpb24sIFBsdWdpbiwgVGV4dFNlbGVjdGlvbiB9IGZyb20gJ3Byb3NlbWlycm9yLXN0YXRlJztcbmltcG9ydCB7IERlY29yYXRpb25TZXQsIERlY29yYXRpb24gfSBmcm9tICdwcm9zZW1pcnJvci12aWV3JztcbmltcG9ydCB7IFNsaWNlIH0gZnJvbSAncHJvc2VtaXJyb3ItbW9kZWwnO1xuXG4vLyA6Oi0gR2FwIGN1cnNvciBzZWxlY3Rpb25zIGFyZSByZXByZXNlbnRlZCB1c2luZyB0aGlzIGNsYXNzLiBJdHNcbi8vIGAkYW5jaG9yYCBhbmQgYCRoZWFkYCBwcm9wZXJ0aWVzIGJvdGggcG9pbnQgYXQgdGhlIGN1cnNvciBwb3NpdGlvbi5cbnZhciBHYXBDdXJzb3IgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChTZWxlY3Rpb24pIHtcbiAgZnVuY3Rpb24gR2FwQ3Vyc29yKCRwb3MpIHtcbiAgICBTZWxlY3Rpb24uY2FsbCh0aGlzLCAkcG9zLCAkcG9zKTtcbiAgfVxuXG4gIGlmICggU2VsZWN0aW9uICkgR2FwQ3Vyc29yLl9fcHJvdG9fXyA9IFNlbGVjdGlvbjtcbiAgR2FwQ3Vyc29yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFNlbGVjdGlvbiAmJiBTZWxlY3Rpb24ucHJvdG90eXBlICk7XG4gIEdhcEN1cnNvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBHYXBDdXJzb3I7XG5cbiAgR2FwQ3Vyc29yLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiBtYXAgKGRvYywgbWFwcGluZykge1xuICAgIHZhciAkcG9zID0gZG9jLnJlc29sdmUobWFwcGluZy5tYXAodGhpcy5oZWFkKSk7XG4gICAgcmV0dXJuIEdhcEN1cnNvci52YWxpZCgkcG9zKSA/IG5ldyBHYXBDdXJzb3IoJHBvcykgOiBTZWxlY3Rpb24ubmVhcigkcG9zKVxuICB9O1xuXG4gIEdhcEN1cnNvci5wcm90b3R5cGUuY29udGVudCA9IGZ1bmN0aW9uIGNvbnRlbnQgKCkgeyByZXR1cm4gU2xpY2UuZW1wdHkgfTtcblxuICBHYXBDdXJzb3IucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gZXEgKG90aGVyKSB7XG4gICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgR2FwQ3Vyc29yICYmIG90aGVyLmhlYWQgPT0gdGhpcy5oZWFkXG4gIH07XG5cbiAgR2FwQ3Vyc29yLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICAgIHJldHVybiB7dHlwZTogXCJnYXBjdXJzb3JcIiwgcG9zOiB0aGlzLmhlYWR9XG4gIH07XG5cbiAgR2FwQ3Vyc29yLmZyb21KU09OID0gZnVuY3Rpb24gZnJvbUpTT04gKGRvYywganNvbikge1xuICAgIGlmICh0eXBlb2YganNvbi5wb3MgIT0gXCJudW1iZXJcIikgeyB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIEdhcEN1cnNvci5mcm9tSlNPTlwiKSB9XG4gICAgcmV0dXJuIG5ldyBHYXBDdXJzb3IoZG9jLnJlc29sdmUoanNvbi5wb3MpKVxuICB9O1xuXG4gIEdhcEN1cnNvci5wcm90b3R5cGUuZ2V0Qm9va21hcmsgPSBmdW5jdGlvbiBnZXRCb29rbWFyayAoKSB7IHJldHVybiBuZXcgR2FwQm9va21hcmsodGhpcy5hbmNob3IpIH07XG5cbiAgR2FwQ3Vyc29yLnZhbGlkID0gZnVuY3Rpb24gdmFsaWQgKCRwb3MpIHtcbiAgICB2YXIgcGFyZW50ID0gJHBvcy5wYXJlbnQ7XG4gICAgaWYgKHBhcmVudC5pc1RleHRibG9jayB8fCAhY2xvc2VkQmVmb3JlKCRwb3MpIHx8ICFjbG9zZWRBZnRlcigkcG9zKSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIHZhciBvdmVycmlkZSA9IHBhcmVudC50eXBlLnNwZWMuYWxsb3dHYXBDdXJzb3I7XG4gICAgaWYgKG92ZXJyaWRlICE9IG51bGwpIHsgcmV0dXJuIG92ZXJyaWRlIH1cbiAgICB2YXIgZGVmbHQgPSBwYXJlbnQuY29udGVudE1hdGNoQXQoJHBvcy5pbmRleCgpKS5kZWZhdWx0VHlwZTtcbiAgICByZXR1cm4gZGVmbHQgJiYgZGVmbHQuaXNUZXh0YmxvY2tcbiAgfTtcblxuICBHYXBDdXJzb3IuZmluZEZyb20gPSBmdW5jdGlvbiBmaW5kRnJvbSAoJHBvcywgZGlyLCBtdXN0TW92ZSkge1xuICAgIHNlYXJjaDogZm9yICg7Oykge1xuICAgICAgaWYgKCFtdXN0TW92ZSAmJiBHYXBDdXJzb3IudmFsaWQoJHBvcykpIHsgcmV0dXJuICRwb3MgfVxuICAgICAgdmFyIHBvcyA9ICRwb3MucG9zLCBuZXh0ID0gbnVsbDtcbiAgICAgIC8vIFNjYW4gdXAgZnJvbSB0aGlzIHBvc2l0aW9uXG4gICAgICBmb3IgKHZhciBkID0gJHBvcy5kZXB0aDs7IGQtLSkge1xuICAgICAgICB2YXIgcGFyZW50ID0gJHBvcy5ub2RlKGQpO1xuICAgICAgICBpZiAoZGlyID4gMCA/ICRwb3MuaW5kZXhBZnRlcihkKSA8IHBhcmVudC5jaGlsZENvdW50IDogJHBvcy5pbmRleChkKSA+IDApIHtcbiAgICAgICAgICBuZXh0ID0gcGFyZW50LmNoaWxkKGRpciA+IDAgPyAkcG9zLmluZGV4QWZ0ZXIoZCkgOiAkcG9zLmluZGV4KGQpIC0gMSk7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfSBlbHNlIGlmIChkID09IDApIHtcbiAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9XG4gICAgICAgIHBvcyArPSBkaXI7XG4gICAgICAgIHZhciAkY3VyID0gJHBvcy5kb2MucmVzb2x2ZShwb3MpO1xuICAgICAgICBpZiAoR2FwQ3Vyc29yLnZhbGlkKCRjdXIpKSB7IHJldHVybiAkY3VyIH1cbiAgICAgIH1cblxuICAgICAgLy8gQW5kIHRoZW4gZG93biBpbnRvIHRoZSBuZXh0IG5vZGVcbiAgICAgIGZvciAoOzspIHtcbiAgICAgICAgdmFyIGluc2lkZSA9IGRpciA+IDAgPyBuZXh0LmZpcnN0Q2hpbGQgOiBuZXh0Lmxhc3RDaGlsZDtcbiAgICAgICAgaWYgKCFpbnNpZGUpIHtcbiAgICAgICAgICBpZiAobmV4dC5pc0F0b20gJiYgIW5leHQuaXNUZXh0ICYmICFOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShuZXh0KSkge1xuICAgICAgICAgICAgJHBvcyA9ICRwb3MuZG9jLnJlc29sdmUocG9zICsgbmV4dC5ub2RlU2l6ZSAqIGRpcik7XG4gICAgICAgICAgICBtdXN0TW92ZSA9IGZhbHNlO1xuICAgICAgICAgICAgY29udGludWUgc2VhcmNoXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgbmV4dCA9IGluc2lkZTtcbiAgICAgICAgcG9zICs9IGRpcjtcbiAgICAgICAgdmFyICRjdXIkMSA9ICRwb3MuZG9jLnJlc29sdmUocG9zKTtcbiAgICAgICAgaWYgKEdhcEN1cnNvci52YWxpZCgkY3VyJDEpKSB7IHJldHVybiAkY3VyJDEgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gR2FwQ3Vyc29yO1xufShTZWxlY3Rpb24pKTtcblxuR2FwQ3Vyc29yLnByb3RvdHlwZS52aXNpYmxlID0gZmFsc2U7XG5cblNlbGVjdGlvbi5qc29uSUQoXCJnYXBjdXJzb3JcIiwgR2FwQ3Vyc29yKTtcblxudmFyIEdhcEJvb2ttYXJrID0gZnVuY3Rpb24gR2FwQm9va21hcmsocG9zKSB7XG4gIHRoaXMucG9zID0gcG9zO1xufTtcbkdhcEJvb2ttYXJrLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiBtYXAgKG1hcHBpbmcpIHtcbiAgcmV0dXJuIG5ldyBHYXBCb29rbWFyayhtYXBwaW5nLm1hcCh0aGlzLnBvcykpXG59O1xuR2FwQm9va21hcmsucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiByZXNvbHZlIChkb2MpIHtcbiAgdmFyICRwb3MgPSBkb2MucmVzb2x2ZSh0aGlzLnBvcyk7XG4gIHJldHVybiBHYXBDdXJzb3IudmFsaWQoJHBvcykgPyBuZXcgR2FwQ3Vyc29yKCRwb3MpIDogU2VsZWN0aW9uLm5lYXIoJHBvcylcbn07XG5cbmZ1bmN0aW9uIGNsb3NlZEJlZm9yZSgkcG9zKSB7XG4gIGZvciAodmFyIGQgPSAkcG9zLmRlcHRoOyBkID49IDA7IGQtLSkge1xuICAgIHZhciBpbmRleCA9ICRwb3MuaW5kZXgoZCk7XG4gICAgLy8gQXQgdGhlIHN0YXJ0IG9mIHRoaXMgcGFyZW50LCBsb29rIGF0IG5leHQgb25lXG4gICAgaWYgKGluZGV4ID09IDApIHsgY29udGludWUgfVxuICAgIC8vIFNlZSBpZiB0aGUgbm9kZSBiZWZvcmUgKG9yIGl0cyBmaXJzdCBhbmNlc3RvcikgaXMgY2xvc2VkXG4gICAgZm9yICh2YXIgYmVmb3JlID0gJHBvcy5ub2RlKGQpLmNoaWxkKGluZGV4IC0gMSk7OyBiZWZvcmUgPSBiZWZvcmUubGFzdENoaWxkKSB7XG4gICAgICBpZiAoKGJlZm9yZS5jaGlsZENvdW50ID09IDAgJiYgIWJlZm9yZS5pbmxpbmVDb250ZW50KSB8fCBiZWZvcmUuaXNBdG9tIHx8IGJlZm9yZS50eXBlLnNwZWMuaXNvbGF0aW5nKSB7IHJldHVybiB0cnVlIH1cbiAgICAgIGlmIChiZWZvcmUuaW5saW5lQ29udGVudCkgeyByZXR1cm4gZmFsc2UgfVxuICAgIH1cbiAgfVxuICAvLyBIaXQgc3RhcnQgb2YgZG9jdW1lbnRcbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gY2xvc2VkQWZ0ZXIoJHBvcykge1xuICBmb3IgKHZhciBkID0gJHBvcy5kZXB0aDsgZCA+PSAwOyBkLS0pIHtcbiAgICB2YXIgaW5kZXggPSAkcG9zLmluZGV4QWZ0ZXIoZCksIHBhcmVudCA9ICRwb3Mubm9kZShkKTtcbiAgICBpZiAoaW5kZXggPT0gcGFyZW50LmNoaWxkQ291bnQpIHsgY29udGludWUgfVxuICAgIGZvciAodmFyIGFmdGVyID0gcGFyZW50LmNoaWxkKGluZGV4KTs7IGFmdGVyID0gYWZ0ZXIuZmlyc3RDaGlsZCkge1xuICAgICAgaWYgKChhZnRlci5jaGlsZENvdW50ID09IDAgJiYgIWFmdGVyLmlubGluZUNvbnRlbnQpIHx8IGFmdGVyLmlzQXRvbSB8fCBhZnRlci50eXBlLnNwZWMuaXNvbGF0aW5nKSB7IHJldHVybiB0cnVlIH1cbiAgICAgIGlmIChhZnRlci5pbmxpbmVDb250ZW50KSB7IHJldHVybiBmYWxzZSB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbi8vIDo6ICgpIOKGkiBQbHVnaW5cbi8vIENyZWF0ZSBhIGdhcCBjdXJzb3IgcGx1Z2luLiBXaGVuIGVuYWJsZWQsIHRoaXMgd2lsbCBjYXB0dXJlIGNsaWNrc1xuLy8gbmVhciBhbmQgYXJyb3cta2V5LW1vdGlvbiBwYXN0IHBsYWNlcyB0aGF0IGRvbid0IGhhdmUgYSBub3JtYWxseVxuLy8gc2VsZWN0YWJsZSBwb3NpdGlvbiBuZWFyYnksIGFuZCBjcmVhdGUgYSBnYXAgY3Vyc29yIHNlbGVjdGlvbiBmb3Jcbi8vIHRoZW0uIFRoZSBjdXJzb3IgaXMgZHJhd24gYXMgYW4gZWxlbWVudCB3aXRoIGNsYXNzXG4vLyBgUHJvc2VNaXJyb3ItZ2FwY3Vyc29yYC4gWW91IGNhbiBlaXRoZXIgaW5jbHVkZVxuLy8gYHN0eWxlL2dhcGN1cnNvci5jc3NgIGZyb20gdGhlIHBhY2thZ2UncyBkaXJlY3Rvcnkgb3IgYWRkIHlvdXIgb3duXG4vLyBzdHlsZXMgdG8gbWFrZSBpdCB2aXNpYmxlLlxudmFyIGdhcEN1cnNvciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFBsdWdpbih7XG4gICAgcHJvcHM6IHtcbiAgICAgIGRlY29yYXRpb25zOiBkcmF3R2FwQ3Vyc29yLFxuXG4gICAgICBjcmVhdGVTZWxlY3Rpb25CZXR3ZWVuOiBmdW5jdGlvbiBjcmVhdGVTZWxlY3Rpb25CZXR3ZWVuKF92aWV3LCAkYW5jaG9yLCAkaGVhZCkge1xuICAgICAgICBpZiAoJGFuY2hvci5wb3MgPT0gJGhlYWQucG9zICYmIEdhcEN1cnNvci52YWxpZCgkaGVhZCkpIHsgcmV0dXJuIG5ldyBHYXBDdXJzb3IoJGhlYWQpIH1cbiAgICAgIH0sXG5cbiAgICAgIGhhbmRsZUNsaWNrOiBoYW5kbGVDbGljayxcbiAgICAgIGhhbmRsZUtleURvd246IGhhbmRsZUtleURvd25cbiAgICB9XG4gIH0pXG59O1xuXG52YXIgaGFuZGxlS2V5RG93biA9IGtleWRvd25IYW5kbGVyKHtcbiAgXCJBcnJvd0xlZnRcIjogYXJyb3coXCJob3JpelwiLCAtMSksXG4gIFwiQXJyb3dSaWdodFwiOiBhcnJvdyhcImhvcml6XCIsIDEpLFxuICBcIkFycm93VXBcIjogYXJyb3coXCJ2ZXJ0XCIsIC0xKSxcbiAgXCJBcnJvd0Rvd25cIjogYXJyb3coXCJ2ZXJ0XCIsIDEpXG59KTtcblxuZnVuY3Rpb24gYXJyb3coYXhpcywgZGlyKSB7XG4gIHZhciBkaXJTdHIgPSBheGlzID09IFwidmVydFwiID8gKGRpciA+IDAgPyBcImRvd25cIiA6IFwidXBcIikgOiAoZGlyID4gMCA/IFwicmlnaHRcIiA6IFwibGVmdFwiKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0YXRlLCBkaXNwYXRjaCwgdmlldykge1xuICAgIHZhciBzZWwgPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgdmFyICRzdGFydCA9IGRpciA+IDAgPyBzZWwuJHRvIDogc2VsLiRmcm9tLCBtdXN0TW92ZSA9IHNlbC5lbXB0eTtcbiAgICBpZiAoc2VsIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbikge1xuICAgICAgaWYgKCF2aWV3LmVuZE9mVGV4dGJsb2NrKGRpclN0cikgfHwgJHN0YXJ0LmRlcHRoID09IDApIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAgIG11c3RNb3ZlID0gZmFsc2U7XG4gICAgICAkc3RhcnQgPSBzdGF0ZS5kb2MucmVzb2x2ZShkaXIgPiAwID8gJHN0YXJ0LmFmdGVyKCkgOiAkc3RhcnQuYmVmb3JlKCkpO1xuICAgIH1cbiAgICB2YXIgJGZvdW5kID0gR2FwQ3Vyc29yLmZpbmRGcm9tKCRzdGFydCwgZGlyLCBtdXN0TW92ZSk7XG4gICAgaWYgKCEkZm91bmQpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBpZiAoZGlzcGF0Y2gpIHsgZGlzcGF0Y2goc3RhdGUudHIuc2V0U2VsZWN0aW9uKG5ldyBHYXBDdXJzb3IoJGZvdW5kKSkpOyB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVDbGljayh2aWV3LCBwb3MsIGV2ZW50KSB7XG4gIGlmICghdmlldy5lZGl0YWJsZSkgeyByZXR1cm4gZmFsc2UgfVxuICB2YXIgJHBvcyA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUocG9zKTtcbiAgaWYgKCFHYXBDdXJzb3IudmFsaWQoJHBvcykpIHsgcmV0dXJuIGZhbHNlIH1cbiAgdmFyIHJlZiA9IHZpZXcucG9zQXRDb29yZHMoe2xlZnQ6IGV2ZW50LmNsaWVudFgsIHRvcDogZXZlbnQuY2xpZW50WX0pO1xuICB2YXIgaW5zaWRlID0gcmVmLmluc2lkZTtcbiAgaWYgKGluc2lkZSA+IC0xICYmIE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKHZpZXcuc3RhdGUuZG9jLm5vZGVBdChpbnNpZGUpKSkgeyByZXR1cm4gZmFsc2UgfVxuICB2aWV3LmRpc3BhdGNoKHZpZXcuc3RhdGUudHIuc2V0U2VsZWN0aW9uKG5ldyBHYXBDdXJzb3IoJHBvcykpKTtcbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gZHJhd0dhcEN1cnNvcihzdGF0ZSkge1xuICBpZiAoIShzdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBHYXBDdXJzb3IpKSB7IHJldHVybiBudWxsIH1cbiAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICBub2RlLmNsYXNzTmFtZSA9IFwiUHJvc2VNaXJyb3ItZ2FwY3Vyc29yXCI7XG4gIHJldHVybiBEZWNvcmF0aW9uU2V0LmNyZWF0ZShzdGF0ZS5kb2MsIFtEZWNvcmF0aW9uLndpZGdldChzdGF0ZS5zZWxlY3Rpb24uaGVhZCwgbm9kZSwge2tleTogXCJnYXBjdXJzb3JcIn0pXSlcbn1cblxuZXhwb3J0IHsgR2FwQ3Vyc29yLCBnYXBDdXJzb3IgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzLmpzLm1hcFxuIiwiaW1wb3J0IFJvcGVTZXF1ZW5jZSBmcm9tICdyb3BlLXNlcXVlbmNlJztcbmltcG9ydCB7IE1hcHBpbmcgfSBmcm9tICdwcm9zZW1pcnJvci10cmFuc2Zvcm0nO1xuaW1wb3J0IHsgUGx1Z2luS2V5LCBQbHVnaW4gfSBmcm9tICdwcm9zZW1pcnJvci1zdGF0ZSc7XG5cbi8vIFByb3NlTWlycm9yJ3MgaGlzdG9yeSBpc24ndCBzaW1wbHkgYSB3YXkgdG8gcm9sbCBiYWNrIHRvIGEgcHJldmlvdXNcbi8vIHN0YXRlLCBiZWNhdXNlIFByb3NlTWlycm9yIHN1cHBvcnRzIGFwcGx5aW5nIGNoYW5nZXMgd2l0aG91dCBhZGRpbmdcbi8vIHRoZW0gdG8gdGhlIGhpc3RvcnkgKGZvciBleGFtcGxlIGR1cmluZyBjb2xsYWJvcmF0aW9uKS5cbi8vXG4vLyBUbyB0aGlzIGVuZCwgZWFjaCAnQnJhbmNoJyAob25lIGZvciB0aGUgdW5kbyBoaXN0b3J5IGFuZCBvbmUgZm9yXG4vLyB0aGUgcmVkbyBoaXN0b3J5KSBrZWVwcyBhbiBhcnJheSBvZiAnSXRlbXMnLCB3aGljaCBjYW4gb3B0aW9uYWxseVxuLy8gaG9sZCBhIHN0ZXAgKGFuIGFjdHVhbCB1bmRvYWJsZSBjaGFuZ2UpLCBhbmQgYWx3YXlzIGhvbGQgYSBwb3NpdGlvblxuLy8gbWFwICh3aGljaCBpcyBuZWVkZWQgdG8gbW92ZSBjaGFuZ2VzIGJlbG93IHRoZW0gdG8gYXBwbHkgdG8gdGhlXG4vLyBjdXJyZW50IGRvY3VtZW50KS5cbi8vXG4vLyBBbiBpdGVtIHRoYXQgaGFzIGJvdGggYSBzdGVwIGFuZCBhIHNlbGVjdGlvbiBib29rbWFyayBpcyB0aGUgc3RhcnRcbi8vIG9mIGFuICdldmVudCcg4oCUIGEgZ3JvdXAgb2YgY2hhbmdlcyB0aGF0IHdpbGwgYmUgdW5kb25lIG9yIHJlZG9uZSBhdFxuLy8gb25jZS4gKEl0IHN0b3JlcyBvbmx5IHRoZSBib29rbWFyaywgc2luY2UgdGhhdCB3YXkgd2UgZG9uJ3QgaGF2ZSB0b1xuLy8gcHJvdmlkZSBhIGRvY3VtZW50IHVudGlsIHRoZSBzZWxlY3Rpb24gaXMgYWN0dWFsbHkgYXBwbGllZCwgd2hpY2hcbi8vIGlzIHVzZWZ1bCB3aGVuIGNvbXByZXNzaW5nLilcblxuLy8gVXNlZCB0byBzY2hlZHVsZSBoaXN0b3J5IGNvbXByZXNzaW9uXG52YXIgbWF4X2VtcHR5X2l0ZW1zID0gNTAwO1xuXG52YXIgQnJhbmNoID0gZnVuY3Rpb24gQnJhbmNoKGl0ZW1zLCBldmVudENvdW50KSB7XG4gIHRoaXMuaXRlbXMgPSBpdGVtcztcbiAgdGhpcy5ldmVudENvdW50ID0gZXZlbnRDb3VudDtcbn07XG5cbi8vIDogKEVkaXRvclN0YXRlLCBib29sKSDihpIgP3t0cmFuc2Zvcm06IFRyYW5zZm9ybSwgc2VsZWN0aW9uOiA/U2VsZWN0aW9uQm9va21hcmssIHJlbWFpbmluZzogQnJhbmNofVxuLy8gUG9wIHRoZSBsYXRlc3QgZXZlbnQgb2ZmIHRoZSBicmFuY2gncyBoaXN0b3J5IGFuZCBhcHBseSBpdFxuLy8gdG8gYSBkb2N1bWVudCB0cmFuc2Zvcm0uXG5CcmFuY2gucHJvdG90eXBlLnBvcEV2ZW50ID0gZnVuY3Rpb24gcG9wRXZlbnQgKHN0YXRlLCBwcmVzZXJ2ZUl0ZW1zKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKHRoaXMuZXZlbnRDb3VudCA9PSAwKSB7IHJldHVybiBudWxsIH1cblxuICB2YXIgZW5kID0gdGhpcy5pdGVtcy5sZW5ndGg7XG4gIGZvciAoOzsgZW5kLS0pIHtcbiAgICB2YXIgbmV4dCA9IHRoaXMuaXRlbXMuZ2V0KGVuZCAtIDEpO1xuICAgIGlmIChuZXh0LnNlbGVjdGlvbikgeyAtLWVuZDsgYnJlYWsgfVxuICB9XG5cbiAgdmFyIHJlbWFwLCBtYXBGcm9tO1xuICBpZiAocHJlc2VydmVJdGVtcykge1xuICAgIHJlbWFwID0gdGhpcy5yZW1hcHBpbmcoZW5kLCB0aGlzLml0ZW1zLmxlbmd0aCk7XG4gICAgbWFwRnJvbSA9IHJlbWFwLm1hcHMubGVuZ3RoO1xuICB9XG4gIHZhciB0cmFuc2Zvcm0gPSBzdGF0ZS50cjtcbiAgdmFyIHNlbGVjdGlvbiwgcmVtYWluaW5nO1xuICB2YXIgYWRkQWZ0ZXIgPSBbXSwgYWRkQmVmb3JlID0gW107XG5cbiAgdGhpcy5pdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBpKSB7XG4gICAgaWYgKCFpdGVtLnN0ZXApIHtcbiAgICAgIGlmICghcmVtYXApIHtcbiAgICAgICAgcmVtYXAgPSB0aGlzJDEucmVtYXBwaW5nKGVuZCwgaSArIDEpO1xuICAgICAgICBtYXBGcm9tID0gcmVtYXAubWFwcy5sZW5ndGg7XG4gICAgICB9XG4gICAgICBtYXBGcm9tLS07XG4gICAgICBhZGRCZWZvcmUucHVzaChpdGVtKTtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChyZW1hcCkge1xuICAgICAgYWRkQmVmb3JlLnB1c2gobmV3IEl0ZW0oaXRlbS5tYXApKTtcbiAgICAgIHZhciBzdGVwID0gaXRlbS5zdGVwLm1hcChyZW1hcC5zbGljZShtYXBGcm9tKSksIG1hcDtcblxuICAgICAgaWYgKHN0ZXAgJiYgdHJhbnNmb3JtLm1heWJlU3RlcChzdGVwKS5kb2MpIHtcbiAgICAgICAgbWFwID0gdHJhbnNmb3JtLm1hcHBpbmcubWFwc1t0cmFuc2Zvcm0ubWFwcGluZy5tYXBzLmxlbmd0aCAtIDFdO1xuICAgICAgICBhZGRBZnRlci5wdXNoKG5ldyBJdGVtKG1hcCwgbnVsbCwgbnVsbCwgYWRkQWZ0ZXIubGVuZ3RoICsgYWRkQmVmb3JlLmxlbmd0aCkpO1xuICAgICAgfVxuICAgICAgbWFwRnJvbS0tO1xuICAgICAgaWYgKG1hcCkgeyByZW1hcC5hcHBlbmRNYXAobWFwLCBtYXBGcm9tKTsgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cmFuc2Zvcm0ubWF5YmVTdGVwKGl0ZW0uc3RlcCk7XG4gICAgfVxuXG4gICAgaWYgKGl0ZW0uc2VsZWN0aW9uKSB7XG4gICAgICBzZWxlY3Rpb24gPSByZW1hcCA/IGl0ZW0uc2VsZWN0aW9uLm1hcChyZW1hcC5zbGljZShtYXBGcm9tKSkgOiBpdGVtLnNlbGVjdGlvbjtcbiAgICAgIHJlbWFpbmluZyA9IG5ldyBCcmFuY2godGhpcyQxLml0ZW1zLnNsaWNlKDAsIGVuZCkuYXBwZW5kKGFkZEJlZm9yZS5yZXZlcnNlKCkuY29uY2F0KGFkZEFmdGVyKSksIHRoaXMkMS5ldmVudENvdW50IC0gMSk7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH0sIHRoaXMuaXRlbXMubGVuZ3RoLCAwKTtcblxuICByZXR1cm4ge3JlbWFpbmluZzogcmVtYWluaW5nLCB0cmFuc2Zvcm06IHRyYW5zZm9ybSwgc2VsZWN0aW9uOiBzZWxlY3Rpb259XG59O1xuXG4vLyA6IChUcmFuc2Zvcm0sID9TZWxlY3Rpb25Cb29rbWFyaywgT2JqZWN0KSDihpIgQnJhbmNoXG4vLyBDcmVhdGUgYSBuZXcgYnJhbmNoIHdpdGggdGhlIGdpdmVuIHRyYW5zZm9ybSBhZGRlZC5cbkJyYW5jaC5wcm90b3R5cGUuYWRkVHJhbnNmb3JtID0gZnVuY3Rpb24gYWRkVHJhbnNmb3JtICh0cmFuc2Zvcm0sIHNlbGVjdGlvbiwgaGlzdE9wdGlvbnMsIHByZXNlcnZlSXRlbXMpIHtcbiAgdmFyIG5ld0l0ZW1zID0gW10sIGV2ZW50Q291bnQgPSB0aGlzLmV2ZW50Q291bnQ7XG4gIHZhciBvbGRJdGVtcyA9IHRoaXMuaXRlbXMsIGxhc3RJdGVtID0gIXByZXNlcnZlSXRlbXMgJiYgb2xkSXRlbXMubGVuZ3RoID8gb2xkSXRlbXMuZ2V0KG9sZEl0ZW1zLmxlbmd0aCAtIDEpIDogbnVsbDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYW5zZm9ybS5zdGVwcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzdGVwID0gdHJhbnNmb3JtLnN0ZXBzW2ldLmludmVydCh0cmFuc2Zvcm0uZG9jc1tpXSk7XG4gICAgdmFyIGl0ZW0gPSBuZXcgSXRlbSh0cmFuc2Zvcm0ubWFwcGluZy5tYXBzW2ldLCBzdGVwLCBzZWxlY3Rpb24pLCBtZXJnZWQgPSAodm9pZCAwKTtcbiAgICBpZiAobWVyZ2VkID0gbGFzdEl0ZW0gJiYgbGFzdEl0ZW0ubWVyZ2UoaXRlbSkpIHtcbiAgICAgIGl0ZW0gPSBtZXJnZWQ7XG4gICAgICBpZiAoaSkgeyBuZXdJdGVtcy5wb3AoKTsgfVxuICAgICAgZWxzZSB7IG9sZEl0ZW1zID0gb2xkSXRlbXMuc2xpY2UoMCwgb2xkSXRlbXMubGVuZ3RoIC0gMSk7IH1cbiAgICB9XG4gICAgbmV3SXRlbXMucHVzaChpdGVtKTtcbiAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICBldmVudENvdW50Kys7XG4gICAgICBzZWxlY3Rpb24gPSBudWxsO1xuICAgIH1cbiAgICBpZiAoIXByZXNlcnZlSXRlbXMpIHsgbGFzdEl0ZW0gPSBpdGVtOyB9XG4gIH1cbiAgdmFyIG92ZXJmbG93ID0gZXZlbnRDb3VudCAtIGhpc3RPcHRpb25zLmRlcHRoO1xuICBpZiAob3ZlcmZsb3cgPiBERVBUSF9PVkVSRkxPVykge1xuICAgIG9sZEl0ZW1zID0gY3V0T2ZmRXZlbnRzKG9sZEl0ZW1zLCBvdmVyZmxvdyk7XG4gICAgZXZlbnRDb3VudCAtPSBvdmVyZmxvdztcbiAgfVxuICByZXR1cm4gbmV3IEJyYW5jaChvbGRJdGVtcy5hcHBlbmQobmV3SXRlbXMpLCBldmVudENvdW50KVxufTtcblxuQnJhbmNoLnByb3RvdHlwZS5yZW1hcHBpbmcgPSBmdW5jdGlvbiByZW1hcHBpbmcgKGZyb20sIHRvKSB7XG4gIHZhciBtYXBzID0gbmV3IE1hcHBpbmc7XG4gIHRoaXMuaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSwgaSkge1xuICAgIHZhciBtaXJyb3JQb3MgPSBpdGVtLm1pcnJvck9mZnNldCAhPSBudWxsICYmIGkgLSBpdGVtLm1pcnJvck9mZnNldCA+PSBmcm9tXG4gICAgICAgID8gbWFwcy5tYXBzLmxlbmd0aCAtIGl0ZW0ubWlycm9yT2Zmc2V0IDogbnVsbDtcbiAgICBtYXBzLmFwcGVuZE1hcChpdGVtLm1hcCwgbWlycm9yUG9zKTtcbiAgfSwgZnJvbSwgdG8pO1xuICByZXR1cm4gbWFwc1xufTtcblxuQnJhbmNoLnByb3RvdHlwZS5hZGRNYXBzID0gZnVuY3Rpb24gYWRkTWFwcyAoYXJyYXkpIHtcbiAgaWYgKHRoaXMuZXZlbnRDb3VudCA9PSAwKSB7IHJldHVybiB0aGlzIH1cbiAgcmV0dXJuIG5ldyBCcmFuY2godGhpcy5pdGVtcy5hcHBlbmQoYXJyYXkubWFwKGZ1bmN0aW9uIChtYXApIHsgcmV0dXJuIG5ldyBJdGVtKG1hcCk7IH0pKSwgdGhpcy5ldmVudENvdW50KVxufTtcblxuLy8gOiAoVHJhbnNmb3JtLCBudW1iZXIpXG4vLyBXaGVuIHRoZSBjb2xsYWIgbW9kdWxlIHJlY2VpdmVzIHJlbW90ZSBjaGFuZ2VzLCB0aGUgaGlzdG9yeSBoYXNcbi8vIHRvIGtub3cgYWJvdXQgdGhvc2UsIHNvIHRoYXQgaXQgY2FuIGFkanVzdCB0aGUgc3RlcHMgdGhhdCB3ZXJlXG4vLyByZWJhc2VkIG9uIHRvcCBvZiB0aGUgcmVtb3RlIGNoYW5nZXMsIGFuZCBpbmNsdWRlIHRoZSBwb3NpdGlvblxuLy8gbWFwcyBmb3IgdGhlIHJlbW90ZSBjaGFuZ2VzIGluIGl0cyBhcnJheSBvZiBpdGVtcy5cbkJyYW5jaC5wcm90b3R5cGUucmViYXNlZCA9IGZ1bmN0aW9uIHJlYmFzZWQgKHJlYmFzZWRUcmFuc2Zvcm0sIHJlYmFzZWRDb3VudCkge1xuICBpZiAoIXRoaXMuZXZlbnRDb3VudCkgeyByZXR1cm4gdGhpcyB9XG5cbiAgdmFyIHJlYmFzZWRJdGVtcyA9IFtdLCBzdGFydCA9IE1hdGgubWF4KDAsIHRoaXMuaXRlbXMubGVuZ3RoIC0gcmViYXNlZENvdW50KTtcblxuICB2YXIgbWFwcGluZyA9IHJlYmFzZWRUcmFuc2Zvcm0ubWFwcGluZztcbiAgdmFyIG5ld1VudGlsID0gcmViYXNlZFRyYW5zZm9ybS5zdGVwcy5sZW5ndGg7XG4gIHZhciBldmVudENvdW50ID0gdGhpcy5ldmVudENvdW50O1xuICB0aGlzLml0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHsgaWYgKGl0ZW0uc2VsZWN0aW9uKSB7IGV2ZW50Q291bnQtLTsgfSB9LCBzdGFydCk7XG5cbiAgdmFyIGlSZWJhc2VkID0gcmViYXNlZENvdW50O1xuICB0aGlzLml0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICB2YXIgcG9zID0gbWFwcGluZy5nZXRNaXJyb3IoLS1pUmViYXNlZCk7XG4gICAgaWYgKHBvcyA9PSBudWxsKSB7IHJldHVybiB9XG4gICAgbmV3VW50aWwgPSBNYXRoLm1pbihuZXdVbnRpbCwgcG9zKTtcbiAgICB2YXIgbWFwID0gbWFwcGluZy5tYXBzW3Bvc107XG4gICAgaWYgKGl0ZW0uc3RlcCkge1xuICAgICAgdmFyIHN0ZXAgPSByZWJhc2VkVHJhbnNmb3JtLnN0ZXBzW3Bvc10uaW52ZXJ0KHJlYmFzZWRUcmFuc2Zvcm0uZG9jc1twb3NdKTtcbiAgICAgIHZhciBzZWxlY3Rpb24gPSBpdGVtLnNlbGVjdGlvbiAmJiBpdGVtLnNlbGVjdGlvbi5tYXAobWFwcGluZy5zbGljZShpUmViYXNlZCArIDEsIHBvcykpO1xuICAgICAgaWYgKHNlbGVjdGlvbikgeyBldmVudENvdW50Kys7IH1cbiAgICAgIHJlYmFzZWRJdGVtcy5wdXNoKG5ldyBJdGVtKG1hcCwgc3RlcCwgc2VsZWN0aW9uKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlYmFzZWRJdGVtcy5wdXNoKG5ldyBJdGVtKG1hcCkpO1xuICAgIH1cbiAgfSwgc3RhcnQpO1xuXG4gIHZhciBuZXdNYXBzID0gW107XG4gIGZvciAodmFyIGkgPSByZWJhc2VkQ291bnQ7IGkgPCBuZXdVbnRpbDsgaSsrKVxuICAgIHsgbmV3TWFwcy5wdXNoKG5ldyBJdGVtKG1hcHBpbmcubWFwc1tpXSkpOyB9XG4gIHZhciBpdGVtcyA9IHRoaXMuaXRlbXMuc2xpY2UoMCwgc3RhcnQpLmFwcGVuZChuZXdNYXBzKS5hcHBlbmQocmViYXNlZEl0ZW1zKTtcbiAgdmFyIGJyYW5jaCA9IG5ldyBCcmFuY2goaXRlbXMsIGV2ZW50Q291bnQpO1xuXG4gIGlmIChicmFuY2guZW1wdHlJdGVtQ291bnQoKSA+IG1heF9lbXB0eV9pdGVtcylcbiAgICB7IGJyYW5jaCA9IGJyYW5jaC5jb21wcmVzcyh0aGlzLml0ZW1zLmxlbmd0aCAtIHJlYmFzZWRJdGVtcy5sZW5ndGgpOyB9XG4gIHJldHVybiBicmFuY2hcbn07XG5cbkJyYW5jaC5wcm90b3R5cGUuZW1wdHlJdGVtQ291bnQgPSBmdW5jdGlvbiBlbXB0eUl0ZW1Db3VudCAoKSB7XG4gIHZhciBjb3VudCA9IDA7XG4gIHRoaXMuaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkgeyBpZiAoIWl0ZW0uc3RlcCkgeyBjb3VudCsrOyB9IH0pO1xuICByZXR1cm4gY291bnRcbn07XG5cbi8vIENvbXByZXNzaW5nIGEgYnJhbmNoIG1lYW5zIHJld3JpdGluZyBpdCB0byBwdXNoIHRoZSBhaXIgKG1hcC1vbmx5XG4vLyBpdGVtcykgb3V0LiBEdXJpbmcgY29sbGFib3JhdGlvbiwgdGhlc2UgbmF0dXJhbGx5IGFjY3VtdWxhdGVcbi8vIGJlY2F1c2UgZWFjaCByZW1vdGUgY2hhbmdlIGFkZHMgb25lLiBUaGUgYHVwdG9gIGFyZ3VtZW50IGlzIHVzZWRcbi8vIHRvIGVuc3VyZSB0aGF0IG9ubHkgdGhlIGl0ZW1zIGJlbG93IGEgZ2l2ZW4gbGV2ZWwgYXJlIGNvbXByZXNzZWQsXG4vLyBiZWNhdXNlIGByZWJhc2VkYCByZWxpZXMgb24gYSBjbGVhbiwgdW50b3VjaGVkIHNldCBvZiBpdGVtcyBpblxuLy8gb3JkZXIgdG8gYXNzb2NpYXRlIG9sZCBpdGVtcyB3aXRoIHJlYmFzZWQgc3RlcHMuXG5CcmFuY2gucHJvdG90eXBlLmNvbXByZXNzID0gZnVuY3Rpb24gY29tcHJlc3MgKHVwdG8pIHtcbiAgICBpZiAoIHVwdG8gPT09IHZvaWQgMCApIHVwdG8gPSB0aGlzLml0ZW1zLmxlbmd0aDtcblxuICB2YXIgcmVtYXAgPSB0aGlzLnJlbWFwcGluZygwLCB1cHRvKSwgbWFwRnJvbSA9IHJlbWFwLm1hcHMubGVuZ3RoO1xuICB2YXIgaXRlbXMgPSBbXSwgZXZlbnRzID0gMDtcbiAgdGhpcy5pdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBpKSB7XG4gICAgaWYgKGkgPj0gdXB0bykge1xuICAgICAgaXRlbXMucHVzaChpdGVtKTtcbiAgICAgIGlmIChpdGVtLnNlbGVjdGlvbikgeyBldmVudHMrKzsgfVxuICAgIH0gZWxzZSBpZiAoaXRlbS5zdGVwKSB7XG4gICAgICB2YXIgc3RlcCA9IGl0ZW0uc3RlcC5tYXAocmVtYXAuc2xpY2UobWFwRnJvbSkpLCBtYXAgPSBzdGVwICYmIHN0ZXAuZ2V0TWFwKCk7XG4gICAgICBtYXBGcm9tLS07XG4gICAgICBpZiAobWFwKSB7IHJlbWFwLmFwcGVuZE1hcChtYXAsIG1hcEZyb20pOyB9XG4gICAgICBpZiAoc3RlcCkge1xuICAgICAgICB2YXIgc2VsZWN0aW9uID0gaXRlbS5zZWxlY3Rpb24gJiYgaXRlbS5zZWxlY3Rpb24ubWFwKHJlbWFwLnNsaWNlKG1hcEZyb20pKTtcbiAgICAgICAgaWYgKHNlbGVjdGlvbikgeyBldmVudHMrKzsgfVxuICAgICAgICB2YXIgbmV3SXRlbSA9IG5ldyBJdGVtKG1hcC5pbnZlcnQoKSwgc3RlcCwgc2VsZWN0aW9uKSwgbWVyZ2VkLCBsYXN0ID0gaXRlbXMubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKG1lcmdlZCA9IGl0ZW1zLmxlbmd0aCAmJiBpdGVtc1tsYXN0XS5tZXJnZShuZXdJdGVtKSlcbiAgICAgICAgICB7IGl0ZW1zW2xhc3RdID0gbWVyZ2VkOyB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB7IGl0ZW1zLnB1c2gobmV3SXRlbSk7IH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGl0ZW0ubWFwKSB7XG4gICAgICBtYXBGcm9tLS07XG4gICAgfVxuICB9LCB0aGlzLml0ZW1zLmxlbmd0aCwgMCk7XG4gIHJldHVybiBuZXcgQnJhbmNoKFJvcGVTZXF1ZW5jZS5mcm9tKGl0ZW1zLnJldmVyc2UoKSksIGV2ZW50cylcbn07XG5cbkJyYW5jaC5lbXB0eSA9IG5ldyBCcmFuY2goUm9wZVNlcXVlbmNlLmVtcHR5LCAwKTtcblxuZnVuY3Rpb24gY3V0T2ZmRXZlbnRzKGl0ZW1zLCBuKSB7XG4gIHZhciBjdXRQb2ludDtcbiAgaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSwgaSkge1xuICAgIGlmIChpdGVtLnNlbGVjdGlvbiAmJiAobi0tID09IDApKSB7XG4gICAgICBjdXRQb2ludCA9IGk7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gaXRlbXMuc2xpY2UoY3V0UG9pbnQpXG59XG5cbnZhciBJdGVtID0gZnVuY3Rpb24gSXRlbShtYXAsIHN0ZXAsIHNlbGVjdGlvbiwgbWlycm9yT2Zmc2V0KSB7XG4gIC8vIFRoZSAoZm9yd2FyZCkgc3RlcCBtYXAgZm9yIHRoaXMgaXRlbS5cbiAgdGhpcy5tYXAgPSBtYXA7XG4gIC8vIFRoZSBpbnZlcnRlZCBzdGVwXG4gIHRoaXMuc3RlcCA9IHN0ZXA7XG4gIC8vIElmIHRoaXMgaXMgbm9uLW51bGwsIHRoaXMgaXRlbSBpcyB0aGUgc3RhcnQgb2YgYSBncm91cCwgYW5kXG4gIC8vIHRoaXMgc2VsZWN0aW9uIGlzIHRoZSBzdGFydGluZyBzZWxlY3Rpb24gZm9yIHRoZSBncm91cCAodGhlIG9uZVxuICAvLyB0aGF0IHdhcyBhY3RpdmUgYmVmb3JlIHRoZSBmaXJzdCBzdGVwIHdhcyBhcHBsaWVkKVxuICB0aGlzLnNlbGVjdGlvbiA9IHNlbGVjdGlvbjtcbiAgLy8gSWYgdGhpcyBpdGVtIGlzIHRoZSBpbnZlcnNlIG9mIGEgcHJldmlvdXMgbWFwcGluZyBvbiB0aGUgc3RhY2ssXG4gIC8vIHRoaXMgcG9pbnRzIGF0IHRoZSBpbnZlcnNlJ3Mgb2Zmc2V0XG4gIHRoaXMubWlycm9yT2Zmc2V0ID0gbWlycm9yT2Zmc2V0O1xufTtcblxuSXRlbS5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbiBtZXJnZSAob3RoZXIpIHtcbiAgaWYgKHRoaXMuc3RlcCAmJiBvdGhlci5zdGVwICYmICFvdGhlci5zZWxlY3Rpb24pIHtcbiAgICB2YXIgc3RlcCA9IG90aGVyLnN0ZXAubWVyZ2UodGhpcy5zdGVwKTtcbiAgICBpZiAoc3RlcCkgeyByZXR1cm4gbmV3IEl0ZW0oc3RlcC5nZXRNYXAoKS5pbnZlcnQoKSwgc3RlcCwgdGhpcy5zZWxlY3Rpb24pIH1cbiAgfVxufTtcblxuLy8gVGhlIHZhbHVlIG9mIHRoZSBzdGF0ZSBmaWVsZCB0aGF0IHRyYWNrcyB1bmRvL3JlZG8gaGlzdG9yeSBmb3IgdGhhdFxuLy8gc3RhdGUuIFdpbGwgYmUgc3RvcmVkIGluIHRoZSBwbHVnaW4gc3RhdGUgd2hlbiB0aGUgaGlzdG9yeSBwbHVnaW5cbi8vIGlzIGFjdGl2ZS5cbnZhciBIaXN0b3J5U3RhdGUgPSBmdW5jdGlvbiBIaXN0b3J5U3RhdGUoZG9uZSwgdW5kb25lLCBwcmV2UmFuZ2VzLCBwcmV2VGltZSkge1xuICB0aGlzLmRvbmUgPSBkb25lO1xuICB0aGlzLnVuZG9uZSA9IHVuZG9uZTtcbiAgdGhpcy5wcmV2UmFuZ2VzID0gcHJldlJhbmdlcztcbiAgdGhpcy5wcmV2VGltZSA9IHByZXZUaW1lO1xufTtcblxudmFyIERFUFRIX09WRVJGTE9XID0gMjA7XG5cbi8vIDogKEhpc3RvcnlTdGF0ZSwgRWRpdG9yU3RhdGUsIFRyYW5zYWN0aW9uLCBPYmplY3QpXG4vLyBSZWNvcmQgYSB0cmFuc2Zvcm1hdGlvbiBpbiB1bmRvIGhpc3RvcnkuXG5mdW5jdGlvbiBhcHBseVRyYW5zYWN0aW9uKGhpc3RvcnksIHN0YXRlLCB0ciwgb3B0aW9ucykge1xuICB2YXIgaGlzdG9yeVRyID0gdHIuZ2V0TWV0YShoaXN0b3J5S2V5KSwgcmViYXNlZDtcbiAgaWYgKGhpc3RvcnlUcikgeyByZXR1cm4gaGlzdG9yeVRyLmhpc3RvcnlTdGF0ZSB9XG5cbiAgaWYgKHRyLmdldE1ldGEoY2xvc2VIaXN0b3J5S2V5KSkgeyBoaXN0b3J5ID0gbmV3IEhpc3RvcnlTdGF0ZShoaXN0b3J5LmRvbmUsIGhpc3RvcnkudW5kb25lLCBudWxsLCAwKTsgfVxuXG4gIHZhciBhcHBlbmRlZCA9IHRyLmdldE1ldGEoXCJhcHBlbmRlZFRyYW5zYWN0aW9uXCIpO1xuXG4gIGlmICh0ci5zdGVwcy5sZW5ndGggPT0gMCkge1xuICAgIHJldHVybiBoaXN0b3J5XG4gIH0gZWxzZSBpZiAoYXBwZW5kZWQgJiYgYXBwZW5kZWQuZ2V0TWV0YShoaXN0b3J5S2V5KSkge1xuICAgIGlmIChhcHBlbmRlZC5nZXRNZXRhKGhpc3RvcnlLZXkpLnJlZG8pXG4gICAgICB7IHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKGhpc3RvcnkuZG9uZS5hZGRUcmFuc2Zvcm0odHIsIG51bGwsIG9wdGlvbnMsIG11c3RQcmVzZXJ2ZUl0ZW1zKHN0YXRlKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaXN0b3J5LnVuZG9uZSwgcmFuZ2VzRm9yKHRyLm1hcHBpbmcubWFwc1t0ci5zdGVwcy5sZW5ndGggLSAxXSksIGhpc3RvcnkucHJldlRpbWUpIH1cbiAgICBlbHNlXG4gICAgICB7IHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKGhpc3RvcnkuZG9uZSwgaGlzdG9yeS51bmRvbmUuYWRkVHJhbnNmb3JtKHRyLCBudWxsLCBvcHRpb25zLCBtdXN0UHJlc2VydmVJdGVtcyhzdGF0ZSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCwgaGlzdG9yeS5wcmV2VGltZSkgfVxuICB9IGVsc2UgaWYgKHRyLmdldE1ldGEoXCJhZGRUb0hpc3RvcnlcIikgIT09IGZhbHNlICYmICEoYXBwZW5kZWQgJiYgYXBwZW5kZWQuZ2V0TWV0YShcImFkZFRvSGlzdG9yeVwiKSA9PT0gZmFsc2UpKSB7XG4gICAgLy8gR3JvdXAgdHJhbnNmb3JtcyB0aGF0IG9jY3VyIGluIHF1aWNrIHN1Y2Nlc3Npb24gaW50byBvbmUgZXZlbnQuXG4gICAgdmFyIG5ld0dyb3VwID0gaGlzdG9yeS5wcmV2VGltZSA9PSAwIHx8ICFhcHBlbmRlZCAmJiAoaGlzdG9yeS5wcmV2VGltZSA8ICh0ci50aW1lIHx8IDApIC0gb3B0aW9ucy5uZXdHcm91cERlbGF5IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIWlzQWRqYWNlbnRUbyh0ciwgaGlzdG9yeS5wcmV2UmFuZ2VzKSk7XG4gICAgdmFyIHByZXZSYW5nZXMgPSBhcHBlbmRlZCA/IG1hcFJhbmdlcyhoaXN0b3J5LnByZXZSYW5nZXMsIHRyLm1hcHBpbmcpIDogcmFuZ2VzRm9yKHRyLm1hcHBpbmcubWFwc1t0ci5zdGVwcy5sZW5ndGggLSAxXSk7XG4gICAgcmV0dXJuIG5ldyBIaXN0b3J5U3RhdGUoaGlzdG9yeS5kb25lLmFkZFRyYW5zZm9ybSh0ciwgbmV3R3JvdXAgPyBzdGF0ZS5zZWxlY3Rpb24uZ2V0Qm9va21hcmsoKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLCBtdXN0UHJlc2VydmVJdGVtcyhzdGF0ZSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEJyYW5jaC5lbXB0eSwgcHJldlJhbmdlcywgdHIudGltZSlcbiAgfSBlbHNlIGlmIChyZWJhc2VkID0gdHIuZ2V0TWV0YShcInJlYmFzZWRcIikpIHtcbiAgICAvLyBVc2VkIGJ5IHRoZSBjb2xsYWIgbW9kdWxlIHRvIHRlbGwgdGhlIGhpc3RvcnkgdGhhdCBzb21lIG9mIGl0c1xuICAgIC8vIGNvbnRlbnQgaGFzIGJlZW4gcmViYXNlZC5cbiAgICByZXR1cm4gbmV3IEhpc3RvcnlTdGF0ZShoaXN0b3J5LmRvbmUucmViYXNlZCh0ciwgcmViYXNlZCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlzdG9yeS51bmRvbmUucmViYXNlZCh0ciwgcmViYXNlZCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwUmFuZ2VzKGhpc3RvcnkucHJldlJhbmdlcywgdHIubWFwcGluZyksIGhpc3RvcnkucHJldlRpbWUpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBIaXN0b3J5U3RhdGUoaGlzdG9yeS5kb25lLmFkZE1hcHModHIubWFwcGluZy5tYXBzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaXN0b3J5LnVuZG9uZS5hZGRNYXBzKHRyLm1hcHBpbmcubWFwcyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwUmFuZ2VzKGhpc3RvcnkucHJldlJhbmdlcywgdHIubWFwcGluZyksIGhpc3RvcnkucHJldlRpbWUpXG4gIH1cbn1cblxuZnVuY3Rpb24gaXNBZGphY2VudFRvKHRyYW5zZm9ybSwgcHJldlJhbmdlcykge1xuICBpZiAoIXByZXZSYW5nZXMpIHsgcmV0dXJuIGZhbHNlIH1cbiAgaWYgKCF0cmFuc2Zvcm0uZG9jQ2hhbmdlZCkgeyByZXR1cm4gdHJ1ZSB9XG4gIHZhciBhZGphY2VudCA9IGZhbHNlO1xuICB0cmFuc2Zvcm0ubWFwcGluZy5tYXBzWzBdLmZvckVhY2goZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByZXZSYW5nZXMubGVuZ3RoOyBpICs9IDIpXG4gICAgICB7IGlmIChzdGFydCA8PSBwcmV2UmFuZ2VzW2kgKyAxXSAmJiBlbmQgPj0gcHJldlJhbmdlc1tpXSlcbiAgICAgICAgeyBhZGphY2VudCA9IHRydWU7IH0gfVxuICB9KTtcbiAgcmV0dXJuIGFkamFjZW50XG59XG5cbmZ1bmN0aW9uIHJhbmdlc0ZvcihtYXApIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBtYXAuZm9yRWFjaChmdW5jdGlvbiAoX2Zyb20sIF90bywgZnJvbSwgdG8pIHsgcmV0dXJuIHJlc3VsdC5wdXNoKGZyb20sIHRvKTsgfSk7XG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gbWFwUmFuZ2VzKHJhbmdlcywgbWFwcGluZykge1xuICBpZiAoIXJhbmdlcykgeyByZXR1cm4gbnVsbCB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB2YXIgZnJvbSA9IG1hcHBpbmcubWFwKHJhbmdlc1tpXSwgMSksIHRvID0gbWFwcGluZy5tYXAocmFuZ2VzW2kgKyAxXSwgLTEpO1xuICAgIGlmIChmcm9tIDw9IHRvKSB7IHJlc3VsdC5wdXNoKGZyb20sIHRvKTsgfVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxuLy8gOiAoSGlzdG9yeVN0YXRlLCBFZGl0b3JTdGF0ZSwgKHRyOiBUcmFuc2FjdGlvbiksIGJvb2wpXG4vLyBBcHBseSB0aGUgbGF0ZXN0IGV2ZW50IGZyb20gb25lIGJyYW5jaCB0byB0aGUgZG9jdW1lbnQgYW5kIHNoaWZ0IHRoZSBldmVudFxuLy8gb250byB0aGUgb3RoZXIgYnJhbmNoLlxuZnVuY3Rpb24gaGlzdFRyYW5zYWN0aW9uKGhpc3RvcnksIHN0YXRlLCBkaXNwYXRjaCwgcmVkbykge1xuICB2YXIgcHJlc2VydmVJdGVtcyA9IG11c3RQcmVzZXJ2ZUl0ZW1zKHN0YXRlKSwgaGlzdE9wdGlvbnMgPSBoaXN0b3J5S2V5LmdldChzdGF0ZSkuc3BlYy5jb25maWc7XG4gIHZhciBwb3AgPSAocmVkbyA/IGhpc3RvcnkudW5kb25lIDogaGlzdG9yeS5kb25lKS5wb3BFdmVudChzdGF0ZSwgcHJlc2VydmVJdGVtcyk7XG4gIGlmICghcG9wKSB7IHJldHVybiB9XG5cbiAgdmFyIHNlbGVjdGlvbiA9IHBvcC5zZWxlY3Rpb24ucmVzb2x2ZShwb3AudHJhbnNmb3JtLmRvYyk7XG4gIHZhciBhZGRlZCA9IChyZWRvID8gaGlzdG9yeS5kb25lIDogaGlzdG9yeS51bmRvbmUpLmFkZFRyYW5zZm9ybShwb3AudHJhbnNmb3JtLCBzdGF0ZS5zZWxlY3Rpb24uZ2V0Qm9va21hcmsoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpc3RPcHRpb25zLCBwcmVzZXJ2ZUl0ZW1zKTtcblxuICB2YXIgbmV3SGlzdCA9IG5ldyBIaXN0b3J5U3RhdGUocmVkbyA/IGFkZGVkIDogcG9wLnJlbWFpbmluZywgcmVkbyA/IHBvcC5yZW1haW5pbmcgOiBhZGRlZCwgbnVsbCwgMCk7XG4gIGRpc3BhdGNoKHBvcC50cmFuc2Zvcm0uc2V0U2VsZWN0aW9uKHNlbGVjdGlvbikuc2V0TWV0YShoaXN0b3J5S2V5LCB7cmVkbzogcmVkbywgaGlzdG9yeVN0YXRlOiBuZXdIaXN0fSkuc2Nyb2xsSW50b1ZpZXcoKSk7XG59XG5cbnZhciBjYWNoZWRQcmVzZXJ2ZUl0ZW1zID0gZmFsc2UsIGNhY2hlZFByZXNlcnZlSXRlbXNQbHVnaW5zID0gbnVsbDtcbi8vIENoZWNrIHdoZXRoZXIgYW55IHBsdWdpbiBpbiB0aGUgZ2l2ZW4gc3RhdGUgaGFzIGFcbi8vIGBoaXN0b3J5UHJlc2VydmVJdGVtc2AgcHJvcGVydHkgaW4gaXRzIHNwZWMsIGluIHdoaWNoIGNhc2Ugd2UgbXVzdFxuLy8gcHJlc2VydmUgc3RlcHMgZXhhY3RseSBhcyB0aGV5IGNhbWUgaW4sIHNvIHRoYXQgdGhleSBjYW4gYmVcbi8vIHJlYmFzZWQuXG5mdW5jdGlvbiBtdXN0UHJlc2VydmVJdGVtcyhzdGF0ZSkge1xuICB2YXIgcGx1Z2lucyA9IHN0YXRlLnBsdWdpbnM7XG4gIGlmIChjYWNoZWRQcmVzZXJ2ZUl0ZW1zUGx1Z2lucyAhPSBwbHVnaW5zKSB7XG4gICAgY2FjaGVkUHJlc2VydmVJdGVtcyA9IGZhbHNlO1xuICAgIGNhY2hlZFByZXNlcnZlSXRlbXNQbHVnaW5zID0gcGx1Z2lucztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBsdWdpbnMubGVuZ3RoOyBpKyspIHsgaWYgKHBsdWdpbnNbaV0uc3BlYy5oaXN0b3J5UHJlc2VydmVJdGVtcykge1xuICAgICAgY2FjaGVkUHJlc2VydmVJdGVtcyA9IHRydWU7XG4gICAgICBicmVha1xuICAgIH0gfVxuICB9XG4gIHJldHVybiBjYWNoZWRQcmVzZXJ2ZUl0ZW1zXG59XG5cbi8vIDo6IChUcmFuc2FjdGlvbikg4oaSIFRyYW5zYWN0aW9uXG4vLyBTZXQgYSBmbGFnIG9uIHRoZSBnaXZlbiB0cmFuc2FjdGlvbiB0aGF0IHdpbGwgcHJldmVudCBmdXJ0aGVyIHN0ZXBzXG4vLyBmcm9tIGJlaW5nIGFwcGVuZGVkIHRvIGFuIGV4aXN0aW5nIGhpc3RvcnkgZXZlbnQgKHNvIHRoYXQgdGhleVxuLy8gcmVxdWlyZSBhIHNlcGFyYXRlIHVuZG8gY29tbWFuZCB0byB1bmRvKS5cbmZ1bmN0aW9uIGNsb3NlSGlzdG9yeSh0cikge1xuICByZXR1cm4gdHIuc2V0TWV0YShjbG9zZUhpc3RvcnlLZXksIHRydWUpXG59XG5cbnZhciBoaXN0b3J5S2V5ID0gbmV3IFBsdWdpbktleShcImhpc3RvcnlcIik7XG52YXIgY2xvc2VIaXN0b3J5S2V5ID0gbmV3IFBsdWdpbktleShcImNsb3NlSGlzdG9yeVwiKTtcblxuLy8gOjogKD9PYmplY3QpIOKGkiBQbHVnaW5cbi8vIFJldHVybnMgYSBwbHVnaW4gdGhhdCBlbmFibGVzIHRoZSB1bmRvIGhpc3RvcnkgZm9yIGFuIGVkaXRvci4gVGhlXG4vLyBwbHVnaW4gd2lsbCB0cmFjayB1bmRvIGFuZCByZWRvIHN0YWNrcywgd2hpY2ggY2FuIGJlIHVzZWQgd2l0aCB0aGVcbi8vIFtgdW5kb2BdKCNoaXN0b3J5LnVuZG8pIGFuZCBbYHJlZG9gXSgjaGlzdG9yeS5yZWRvKSBjb21tYW5kcy5cbi8vXG4vLyBZb3UgY2FuIHNldCBhbiBgXCJhZGRUb0hpc3RvcnlcImAgW21ldGFkYXRhXG4vLyBwcm9wZXJ0eV0oI3N0YXRlLlRyYW5zYWN0aW9uLnNldE1ldGEpIG9mIGBmYWxzZWAgb24gYSB0cmFuc2FjdGlvblxuLy8gdG8gcHJldmVudCBpdCBmcm9tIGJlaW5nIHJvbGxlZCBiYWNrIGJ5IHVuZG8uXG4vL1xuLy8gICBjb25maWc6Oi1cbi8vICAgU3VwcG9ydHMgdGhlIGZvbGxvd2luZyBjb25maWd1cmF0aW9uIG9wdGlvbnM6XG4vL1xuLy8gICAgIGRlcHRoOjogP251bWJlclxuLy8gICAgIFRoZSBhbW91bnQgb2YgaGlzdG9yeSBldmVudHMgdGhhdCBhcmUgY29sbGVjdGVkIGJlZm9yZSB0aGVcbi8vICAgICBvbGRlc3QgZXZlbnRzIGFyZSBkaXNjYXJkZWQuIERlZmF1bHRzIHRvIDEwMC5cbi8vXG4vLyAgICAgbmV3R3JvdXBEZWxheTo6ID9udW1iZXJcbi8vICAgICBUaGUgZGVsYXkgYmV0d2VlbiBjaGFuZ2VzIGFmdGVyIHdoaWNoIGEgbmV3IGdyb3VwIHNob3VsZCBiZVxuLy8gICAgIHN0YXJ0ZWQuIERlZmF1bHRzIHRvIDUwMCAobWlsbGlzZWNvbmRzKS4gTm90ZSB0aGF0IHdoZW4gY2hhbmdlc1xuLy8gICAgIGFyZW4ndCBhZGphY2VudCwgYSBuZXcgZ3JvdXAgaXMgYWx3YXlzIHN0YXJ0ZWQuXG5mdW5jdGlvbiBoaXN0b3J5KGNvbmZpZykge1xuICBjb25maWcgPSB7ZGVwdGg6IGNvbmZpZyAmJiBjb25maWcuZGVwdGggfHwgMTAwLFxuICAgICAgICAgICAgbmV3R3JvdXBEZWxheTogY29uZmlnICYmIGNvbmZpZy5uZXdHcm91cERlbGF5IHx8IDUwMH07XG4gIHJldHVybiBuZXcgUGx1Z2luKHtcbiAgICBrZXk6IGhpc3RvcnlLZXksXG5cbiAgICBzdGF0ZToge1xuICAgICAgaW5pdDogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIaXN0b3J5U3RhdGUoQnJhbmNoLmVtcHR5LCBCcmFuY2guZW1wdHksIG51bGwsIDApXG4gICAgICB9LFxuICAgICAgYXBwbHk6IGZ1bmN0aW9uIGFwcGx5KHRyLCBoaXN0LCBzdGF0ZSkge1xuICAgICAgICByZXR1cm4gYXBwbHlUcmFuc2FjdGlvbihoaXN0LCBzdGF0ZSwgdHIsIGNvbmZpZylcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgY29uZmlnOiBjb25maWcsXG5cbiAgICBwcm9wczoge1xuICAgICAgaGFuZGxlRE9NRXZlbnRzOiB7XG4gICAgICAgIGJlZm9yZWlucHV0OiBmdW5jdGlvbiBiZWZvcmVpbnB1dCh2aWV3LCBlKSB7XG4gICAgICAgICAgdmFyIGhhbmRsZWQgPSBlLmlucHV0VHlwZSA9PSBcImhpc3RvcnlVbmRvXCIgPyB1bmRvKHZpZXcuc3RhdGUsIHZpZXcuZGlzcGF0Y2gpIDpcbiAgICAgICAgICAgICAgZS5pbnB1dFR5cGUgPT0gXCJoaXN0b3J5UmVkb1wiID8gcmVkbyh2aWV3LnN0YXRlLCB2aWV3LmRpc3BhdGNoKSA6IGZhbHNlO1xuICAgICAgICAgIGlmIChoYW5kbGVkKSB7IGUucHJldmVudERlZmF1bHQoKTsgfVxuICAgICAgICAgIHJldHVybiBoYW5kbGVkXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pXG59XG5cbi8vIDo6IChFZGl0b3JTdGF0ZSwgPyh0cjogVHJhbnNhY3Rpb24pKSDihpIgYm9vbFxuLy8gQSBjb21tYW5kIGZ1bmN0aW9uIHRoYXQgdW5kb2VzIHRoZSBsYXN0IGNoYW5nZSwgaWYgYW55LlxuZnVuY3Rpb24gdW5kbyhzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgdmFyIGhpc3QgPSBoaXN0b3J5S2V5LmdldFN0YXRlKHN0YXRlKTtcbiAgaWYgKCFoaXN0IHx8IGhpc3QuZG9uZS5ldmVudENvdW50ID09IDApIHsgcmV0dXJuIGZhbHNlIH1cbiAgaWYgKGRpc3BhdGNoKSB7IGhpc3RUcmFuc2FjdGlvbihoaXN0LCBzdGF0ZSwgZGlzcGF0Y2gsIGZhbHNlKTsgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG4vLyA6OiAoRWRpdG9yU3RhdGUsID8odHI6IFRyYW5zYWN0aW9uKSkg4oaSIGJvb2xcbi8vIEEgY29tbWFuZCBmdW5jdGlvbiB0aGF0IHJlZG9lcyB0aGUgbGFzdCB1bmRvbmUgY2hhbmdlLCBpZiBhbnkuXG5mdW5jdGlvbiByZWRvKHN0YXRlLCBkaXNwYXRjaCkge1xuICB2YXIgaGlzdCA9IGhpc3RvcnlLZXkuZ2V0U3RhdGUoc3RhdGUpO1xuICBpZiAoIWhpc3QgfHwgaGlzdC51bmRvbmUuZXZlbnRDb3VudCA9PSAwKSB7IHJldHVybiBmYWxzZSB9XG4gIGlmIChkaXNwYXRjaCkgeyBoaXN0VHJhbnNhY3Rpb24oaGlzdCwgc3RhdGUsIGRpc3BhdGNoLCB0cnVlKTsgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG4vLyA6OiAoRWRpdG9yU3RhdGUpIOKGkiBudW1iZXJcbi8vIFRoZSBhbW91bnQgb2YgdW5kb2FibGUgZXZlbnRzIGF2YWlsYWJsZSBpbiBhIGdpdmVuIHN0YXRlLlxuZnVuY3Rpb24gdW5kb0RlcHRoKHN0YXRlKSB7XG4gIHZhciBoaXN0ID0gaGlzdG9yeUtleS5nZXRTdGF0ZShzdGF0ZSk7XG4gIHJldHVybiBoaXN0ID8gaGlzdC5kb25lLmV2ZW50Q291bnQgOiAwXG59XG5cbi8vIDo6IChFZGl0b3JTdGF0ZSkg4oaSIG51bWJlclxuLy8gVGhlIGFtb3VudCBvZiByZWRvYWJsZSBldmVudHMgYXZhaWxhYmxlIGluIGEgZ2l2ZW4gZWRpdG9yIHN0YXRlLlxuZnVuY3Rpb24gcmVkb0RlcHRoKHN0YXRlKSB7XG4gIHZhciBoaXN0ID0gaGlzdG9yeUtleS5nZXRTdGF0ZShzdGF0ZSk7XG4gIHJldHVybiBoaXN0ID8gaGlzdC51bmRvbmUuZXZlbnRDb3VudCA6IDBcbn1cblxuZXhwb3J0IHsgSGlzdG9yeVN0YXRlLCBjbG9zZUhpc3RvcnksIGhpc3RvcnksIHJlZG8sIHJlZG9EZXB0aCwgdW5kbywgdW5kb0RlcHRoIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lcy5qcy5tYXBcbiIsImltcG9ydCB7IFBsdWdpbiB9IGZyb20gJ3Byb3NlbWlycm9yLXN0YXRlJztcbmltcG9ydCB7IGZpbmRXcmFwcGluZywgY2FuSm9pbiB9IGZyb20gJ3Byb3NlbWlycm9yLXRyYW5zZm9ybSc7XG5cbi8vIDo6LSBJbnB1dCBydWxlcyBhcmUgcmVndWxhciBleHByZXNzaW9ucyBkZXNjcmliaW5nIGEgcGllY2Ugb2YgdGV4dFxuLy8gdGhhdCwgd2hlbiB0eXBlZCwgY2F1c2VzIHNvbWV0aGluZyB0byBoYXBwZW4uIFRoaXMgbWlnaHQgYmVcbi8vIGNoYW5naW5nIHR3byBkYXNoZXMgaW50byBhbiBlbWRhc2gsIHdyYXBwaW5nIGEgcGFyYWdyYXBoIHN0YXJ0aW5nXG4vLyB3aXRoIGBcIj4gXCJgIGludG8gYSBibG9ja3F1b3RlLCBvciBzb21ldGhpbmcgZW50aXJlbHkgZGlmZmVyZW50LlxudmFyIElucHV0UnVsZSA9IGZ1bmN0aW9uIElucHV0UnVsZShtYXRjaCwgaGFuZGxlcikge1xuICB0aGlzLm1hdGNoID0gbWF0Y2g7XG4gIHRoaXMuaGFuZGxlciA9IHR5cGVvZiBoYW5kbGVyID09IFwic3RyaW5nXCIgPyBzdHJpbmdIYW5kbGVyKGhhbmRsZXIpIDogaGFuZGxlcjtcbn07XG5cbmZ1bmN0aW9uIHN0cmluZ0hhbmRsZXIoc3RyaW5nKSB7XG4gIHJldHVybiBmdW5jdGlvbihzdGF0ZSwgbWF0Y2gsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgaW5zZXJ0ID0gc3RyaW5nO1xuICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgdmFyIG9mZnNldCA9IG1hdGNoWzBdLmxhc3RJbmRleE9mKG1hdGNoWzFdKTtcbiAgICAgIGluc2VydCArPSBtYXRjaFswXS5zbGljZShvZmZzZXQgKyBtYXRjaFsxXS5sZW5ndGgpO1xuICAgICAgc3RhcnQgKz0gb2Zmc2V0O1xuICAgICAgdmFyIGN1dE9mZiA9IHN0YXJ0IC0gZW5kO1xuICAgICAgaWYgKGN1dE9mZiA+IDApIHtcbiAgICAgICAgaW5zZXJ0ID0gbWF0Y2hbMF0uc2xpY2Uob2Zmc2V0IC0gY3V0T2ZmLCBvZmZzZXQpICsgaW5zZXJ0O1xuICAgICAgICBzdGFydCA9IGVuZDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlLnRyLmluc2VydFRleHQoaW5zZXJ0LCBzdGFydCwgZW5kKVxuICB9XG59XG5cbnZhciBNQVhfTUFUQ0ggPSA1MDA7XG5cbi8vIDo6IChjb25maWc6IHtydWxlczogW0lucHV0UnVsZV19KSDihpIgUGx1Z2luXG4vLyBDcmVhdGUgYW4gaW5wdXQgcnVsZXMgcGx1Z2luLiBXaGVuIGVuYWJsZWQsIGl0IHdpbGwgY2F1c2UgdGV4dFxuLy8gaW5wdXQgdGhhdCBtYXRjaGVzIGFueSBvZiB0aGUgZ2l2ZW4gcnVsZXMgdG8gdHJpZ2dlciB0aGUgcnVsZSdzXG4vLyBhY3Rpb24uXG5mdW5jdGlvbiBpbnB1dFJ1bGVzKHJlZikge1xuICB2YXIgcnVsZXMgPSByZWYucnVsZXM7XG5cbiAgdmFyIHBsdWdpbiA9IG5ldyBQbHVnaW4oe1xuICAgIHN0YXRlOiB7XG4gICAgICBpbml0OiBmdW5jdGlvbiBpbml0KCkgeyByZXR1cm4gbnVsbCB9LFxuICAgICAgYXBwbHk6IGZ1bmN0aW9uIGFwcGx5KHRyLCBwcmV2KSB7XG4gICAgICAgIHZhciBzdG9yZWQgPSB0ci5nZXRNZXRhKHRoaXMpO1xuICAgICAgICBpZiAoc3RvcmVkKSB7IHJldHVybiBzdG9yZWQgfVxuICAgICAgICByZXR1cm4gdHIuc2VsZWN0aW9uU2V0IHx8IHRyLmRvY0NoYW5nZWQgPyBudWxsIDogcHJldlxuICAgICAgfVxuICAgIH0sXG5cbiAgICBwcm9wczoge1xuICAgICAgaGFuZGxlVGV4dElucHV0OiBmdW5jdGlvbiBoYW5kbGVUZXh0SW5wdXQodmlldywgZnJvbSwgdG8sIHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHJ1bih2aWV3LCBmcm9tLCB0bywgdGV4dCwgcnVsZXMsIHBsdWdpbilcbiAgICAgIH0sXG4gICAgICBoYW5kbGVET01FdmVudHM6IHtcbiAgICAgICAgY29tcG9zaXRpb25lbmQ6IGZ1bmN0aW9uICh2aWV3KSB7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVmID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgICAgICB2YXIgJGN1cnNvciA9IHJlZi4kY3Vyc29yO1xuICAgICAgICAgICAgaWYgKCRjdXJzb3IpIHsgcnVuKHZpZXcsICRjdXJzb3IucG9zLCAkY3Vyc29yLnBvcywgXCJcIiwgcnVsZXMsIHBsdWdpbik7IH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBpc0lucHV0UnVsZXM6IHRydWVcbiAgfSk7XG4gIHJldHVybiBwbHVnaW5cbn1cblxuZnVuY3Rpb24gcnVuKHZpZXcsIGZyb20sIHRvLCB0ZXh0LCBydWxlcywgcGx1Z2luKSB7XG4gIGlmICh2aWV3LmNvbXBvc2luZykgeyByZXR1cm4gZmFsc2UgfVxuICB2YXIgc3RhdGUgPSB2aWV3LnN0YXRlLCAkZnJvbSA9IHN0YXRlLmRvYy5yZXNvbHZlKGZyb20pO1xuICBpZiAoJGZyb20ucGFyZW50LnR5cGUuc3BlYy5jb2RlKSB7IHJldHVybiBmYWxzZSB9XG4gIHZhciB0ZXh0QmVmb3JlID0gJGZyb20ucGFyZW50LnRleHRCZXR3ZWVuKE1hdGgubWF4KDAsICRmcm9tLnBhcmVudE9mZnNldCAtIE1BWF9NQVRDSCksICRmcm9tLnBhcmVudE9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCwgXCJcXHVmZmZjXCIpICsgdGV4dDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBtYXRjaCA9IHJ1bGVzW2ldLm1hdGNoLmV4ZWModGV4dEJlZm9yZSk7XG4gICAgdmFyIHRyID0gbWF0Y2ggJiYgcnVsZXNbaV0uaGFuZGxlcihzdGF0ZSwgbWF0Y2gsIGZyb20gLSAobWF0Y2hbMF0ubGVuZ3RoIC0gdGV4dC5sZW5ndGgpLCB0byk7XG4gICAgaWYgKCF0cikgeyBjb250aW51ZSB9XG4gICAgdmlldy5kaXNwYXRjaCh0ci5zZXRNZXRhKHBsdWdpbiwge3RyYW5zZm9ybTogdHIsIGZyb206IGZyb20sIHRvOiB0bywgdGV4dDogdGV4dH0pKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vLyA6OiAoRWRpdG9yU3RhdGUsID8oVHJhbnNhY3Rpb24pKSDihpIgYm9vbFxuLy8gVGhpcyBpcyBhIGNvbW1hbmQgdGhhdCB3aWxsIHVuZG8gYW4gaW5wdXQgcnVsZSwgaWYgYXBwbHlpbmcgc3VjaCBhXG4vLyBydWxlIHdhcyB0aGUgbGFzdCB0aGluZyB0aGF0IHRoZSB1c2VyIGRpZC5cbmZ1bmN0aW9uIHVuZG9JbnB1dFJ1bGUoc3RhdGUsIGRpc3BhdGNoKSB7XG4gIHZhciBwbHVnaW5zID0gc3RhdGUucGx1Z2lucztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBsdWdpbiA9IHBsdWdpbnNbaV0sIHVuZG9hYmxlID0gKHZvaWQgMCk7XG4gICAgaWYgKHBsdWdpbi5zcGVjLmlzSW5wdXRSdWxlcyAmJiAodW5kb2FibGUgPSBwbHVnaW4uZ2V0U3RhdGUoc3RhdGUpKSkge1xuICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgIHZhciB0ciA9IHN0YXRlLnRyLCB0b1VuZG8gPSB1bmRvYWJsZS50cmFuc2Zvcm07XG4gICAgICAgIGZvciAodmFyIGogPSB0b1VuZG8uc3RlcHMubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pXG4gICAgICAgICAgeyB0ci5zdGVwKHRvVW5kby5zdGVwc1tqXS5pbnZlcnQodG9VbmRvLmRvY3Nbal0pKTsgfVxuICAgICAgICBpZiAodW5kb2FibGUudGV4dCkge1xuICAgICAgICAgIHZhciBtYXJrcyA9IHRyLmRvYy5yZXNvbHZlKHVuZG9hYmxlLmZyb20pLm1hcmtzKCk7XG4gICAgICAgICAgdHIucmVwbGFjZVdpdGgodW5kb2FibGUuZnJvbSwgdW5kb2FibGUudG8sIHN0YXRlLnNjaGVtYS50ZXh0KHVuZG9hYmxlLnRleHQsIG1hcmtzKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHIuZGVsZXRlKHVuZG9hYmxlLmZyb20sIHVuZG9hYmxlLnRvKTtcbiAgICAgICAgfVxuICAgICAgICBkaXNwYXRjaCh0cik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLy8gOjogSW5wdXRSdWxlIENvbnZlcnRzIGRvdWJsZSBkYXNoZXMgdG8gYW4gZW1kYXNoLlxudmFyIGVtRGFzaCA9IG5ldyBJbnB1dFJ1bGUoLy0tJC8sIFwi4oCUXCIpO1xuLy8gOjogSW5wdXRSdWxlIENvbnZlcnRzIHRocmVlIGRvdHMgdG8gYW4gZWxsaXBzaXMgY2hhcmFjdGVyLlxudmFyIGVsbGlwc2lzID0gbmV3IElucHV0UnVsZSgvXFwuXFwuXFwuJC8sIFwi4oCmXCIpO1xuLy8gOjogSW5wdXRSdWxlIOKAnFNtYXJ04oCdIG9wZW5pbmcgZG91YmxlIHF1b3Rlcy5cbnZhciBvcGVuRG91YmxlUXVvdGUgPSBuZXcgSW5wdXRSdWxlKC8oPzpefFtcXHNcXHtcXFtcXChcXDwnXCJcXHUyMDE4XFx1MjAxQ10pKFwiKSQvLCBcIuKAnFwiKTtcbi8vIDo6IElucHV0UnVsZSDigJxTbWFydOKAnSBjbG9zaW5nIGRvdWJsZSBxdW90ZXMuXG52YXIgY2xvc2VEb3VibGVRdW90ZSA9IG5ldyBJbnB1dFJ1bGUoL1wiJC8sIFwi4oCdXCIpO1xuLy8gOjogSW5wdXRSdWxlIOKAnFNtYXJ04oCdIG9wZW5pbmcgc2luZ2xlIHF1b3Rlcy5cbnZhciBvcGVuU2luZ2xlUXVvdGUgPSBuZXcgSW5wdXRSdWxlKC8oPzpefFtcXHNcXHtcXFtcXChcXDwnXCJcXHUyMDE4XFx1MjAxQ10pKCcpJC8sIFwi4oCYXCIpO1xuLy8gOjogSW5wdXRSdWxlIOKAnFNtYXJ04oCdIGNsb3Npbmcgc2luZ2xlIHF1b3Rlcy5cbnZhciBjbG9zZVNpbmdsZVF1b3RlID0gbmV3IElucHV0UnVsZSgvJyQvLCBcIuKAmVwiKTtcblxuLy8gOjogW0lucHV0UnVsZV0gU21hcnQtcXVvdGUgcmVsYXRlZCBpbnB1dCBydWxlcy5cbnZhciBzbWFydFF1b3RlcyA9IFtvcGVuRG91YmxlUXVvdGUsIGNsb3NlRG91YmxlUXVvdGUsIG9wZW5TaW5nbGVRdW90ZSwgY2xvc2VTaW5nbGVRdW90ZV07XG5cbi8vIDo6IChSZWdFeHAsIE5vZGVUeXBlLCA/dW5pb248T2JqZWN0LCAoW3N0cmluZ10pIOKGkiA/T2JqZWN0PiwgPyhbc3RyaW5nXSwgTm9kZSkg4oaSIGJvb2wpIOKGkiBJbnB1dFJ1bGVcbi8vIEJ1aWxkIGFuIGlucHV0IHJ1bGUgZm9yIGF1dG9tYXRpY2FsbHkgd3JhcHBpbmcgYSB0ZXh0YmxvY2sgd2hlbiBhXG4vLyBnaXZlbiBzdHJpbmcgaXMgdHlwZWQuIFRoZSBgcmVnZXhwYCBhcmd1bWVudCBpc1xuLy8gZGlyZWN0bHkgcGFzc2VkIHRocm91Z2ggdG8gdGhlIGBJbnB1dFJ1bGVgIGNvbnN0cnVjdG9yLiBZb3UnbGxcbi8vIHByb2JhYmx5IHdhbnQgdGhlIHJlZ2V4cCB0byBzdGFydCB3aXRoIGBeYCwgc28gdGhhdCB0aGUgcGF0dGVybiBjYW5cbi8vIG9ubHkgb2NjdXIgYXQgdGhlIHN0YXJ0IG9mIGEgdGV4dGJsb2NrLlxuLy9cbi8vIGBub2RlVHlwZWAgaXMgdGhlIHR5cGUgb2Ygbm9kZSB0byB3cmFwIGluLiBJZiBpdCBuZWVkcyBhdHRyaWJ1dGVzLFxuLy8geW91IGNhbiBlaXRoZXIgcGFzcyB0aGVtIGRpcmVjdGx5LCBvciBwYXNzIGEgZnVuY3Rpb24gdGhhdCB3aWxsXG4vLyBjb21wdXRlIHRoZW0gZnJvbSB0aGUgcmVndWxhciBleHByZXNzaW9uIG1hdGNoLlxuLy9cbi8vIEJ5IGRlZmF1bHQsIGlmIHRoZXJlJ3MgYSBub2RlIHdpdGggdGhlIHNhbWUgdHlwZSBhYm92ZSB0aGUgbmV3bHlcbi8vIHdyYXBwZWQgbm9kZSwgdGhlIHJ1bGUgd2lsbCB0cnkgdG8gW2pvaW5dKCN0cmFuc2Zvcm0uVHJhbnNmb3JtLmpvaW4pIHRob3NlXG4vLyB0d28gbm9kZXMuIFlvdSBjYW4gcGFzcyBhIGpvaW4gcHJlZGljYXRlLCB3aGljaCB0YWtlcyBhIHJlZ3VsYXJcbi8vIGV4cHJlc3Npb24gbWF0Y2ggYW5kIHRoZSBub2RlIGJlZm9yZSB0aGUgd3JhcHBlZCBub2RlLCBhbmQgY2FuXG4vLyByZXR1cm4gYSBib29sZWFuIHRvIGluZGljYXRlIHdoZXRoZXIgYSBqb2luIHNob3VsZCBoYXBwZW4uXG5mdW5jdGlvbiB3cmFwcGluZ0lucHV0UnVsZShyZWdleHAsIG5vZGVUeXBlLCBnZXRBdHRycywgam9pblByZWRpY2F0ZSkge1xuICByZXR1cm4gbmV3IElucHV0UnVsZShyZWdleHAsIGZ1bmN0aW9uIChzdGF0ZSwgbWF0Y2gsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgYXR0cnMgPSBnZXRBdHRycyBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gZ2V0QXR0cnMobWF0Y2gpIDogZ2V0QXR0cnM7XG4gICAgdmFyIHRyID0gc3RhdGUudHIuZGVsZXRlKHN0YXJ0LCBlbmQpO1xuICAgIHZhciAkc3RhcnQgPSB0ci5kb2MucmVzb2x2ZShzdGFydCksIHJhbmdlID0gJHN0YXJ0LmJsb2NrUmFuZ2UoKSwgd3JhcHBpbmcgPSByYW5nZSAmJiBmaW5kV3JhcHBpbmcocmFuZ2UsIG5vZGVUeXBlLCBhdHRycyk7XG4gICAgaWYgKCF3cmFwcGluZykgeyByZXR1cm4gbnVsbCB9XG4gICAgdHIud3JhcChyYW5nZSwgd3JhcHBpbmcpO1xuICAgIHZhciBiZWZvcmUgPSB0ci5kb2MucmVzb2x2ZShzdGFydCAtIDEpLm5vZGVCZWZvcmU7XG4gICAgaWYgKGJlZm9yZSAmJiBiZWZvcmUudHlwZSA9PSBub2RlVHlwZSAmJiBjYW5Kb2luKHRyLmRvYywgc3RhcnQgLSAxKSAmJlxuICAgICAgICAoIWpvaW5QcmVkaWNhdGUgfHwgam9pblByZWRpY2F0ZShtYXRjaCwgYmVmb3JlKSkpXG4gICAgICB7IHRyLmpvaW4oc3RhcnQgLSAxKTsgfVxuICAgIHJldHVybiB0clxuICB9KVxufVxuXG4vLyA6OiAoUmVnRXhwLCBOb2RlVHlwZSwgP3VuaW9uPE9iamVjdCwgKFtzdHJpbmddKSDihpIgP09iamVjdD4pIOKGkiBJbnB1dFJ1bGVcbi8vIEJ1aWxkIGFuIGlucHV0IHJ1bGUgdGhhdCBjaGFuZ2VzIHRoZSB0eXBlIG9mIGEgdGV4dGJsb2NrIHdoZW4gdGhlXG4vLyBtYXRjaGVkIHRleHQgaXMgdHlwZWQgaW50byBpdC4gWW91J2xsIHVzdWFsbHkgd2FudCB0byBzdGFydCB5b3VyXG4vLyByZWdleHAgd2l0aCBgXmAgdG8gdGhhdCBpdCBpcyBvbmx5IG1hdGNoZWQgYXQgdGhlIHN0YXJ0IG9mIGFcbi8vIHRleHRibG9jay4gVGhlIG9wdGlvbmFsIGBnZXRBdHRyc2AgcGFyYW1ldGVyIGNhbiBiZSB1c2VkIHRvIGNvbXB1dGVcbi8vIHRoZSBuZXcgbm9kZSdzIGF0dHJpYnV0ZXMsIGFuZCB3b3JrcyB0aGUgc2FtZSBhcyBpbiB0aGVcbi8vIGB3cmFwcGluZ0lucHV0UnVsZWAgZnVuY3Rpb24uXG5mdW5jdGlvbiB0ZXh0YmxvY2tUeXBlSW5wdXRSdWxlKHJlZ2V4cCwgbm9kZVR5cGUsIGdldEF0dHJzKSB7XG4gIHJldHVybiBuZXcgSW5wdXRSdWxlKHJlZ2V4cCwgZnVuY3Rpb24gKHN0YXRlLCBtYXRjaCwgc3RhcnQsIGVuZCkge1xuICAgIHZhciAkc3RhcnQgPSBzdGF0ZS5kb2MucmVzb2x2ZShzdGFydCk7XG4gICAgdmFyIGF0dHJzID0gZ2V0QXR0cnMgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IGdldEF0dHJzKG1hdGNoKSA6IGdldEF0dHJzO1xuICAgIGlmICghJHN0YXJ0Lm5vZGUoLTEpLmNhblJlcGxhY2VXaXRoKCRzdGFydC5pbmRleCgtMSksICRzdGFydC5pbmRleEFmdGVyKC0xKSwgbm9kZVR5cGUpKSB7IHJldHVybiBudWxsIH1cbiAgICByZXR1cm4gc3RhdGUudHJcbiAgICAgIC5kZWxldGUoc3RhcnQsIGVuZClcbiAgICAgIC5zZXRCbG9ja1R5cGUoc3RhcnQsIHN0YXJ0LCBub2RlVHlwZSwgYXR0cnMpXG4gIH0pXG59XG5cbmV4cG9ydCB7IElucHV0UnVsZSwgY2xvc2VEb3VibGVRdW90ZSwgY2xvc2VTaW5nbGVRdW90ZSwgZWxsaXBzaXMsIGVtRGFzaCwgaW5wdXRSdWxlcywgb3BlbkRvdWJsZVF1b3RlLCBvcGVuU2luZ2xlUXVvdGUsIHNtYXJ0UXVvdGVzLCB0ZXh0YmxvY2tUeXBlSW5wdXRSdWxlLCB1bmRvSW5wdXRSdWxlLCB3cmFwcGluZ0lucHV0UnVsZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXMuanMubWFwXG4iLCJpbXBvcnQgeyBrZXlOYW1lLCBiYXNlIH0gZnJvbSAndzNjLWtleW5hbWUnO1xuaW1wb3J0IHsgUGx1Z2luIH0gZnJvbSAncHJvc2VtaXJyb3Itc3RhdGUnO1xuXG4vLyBkZWNsYXJlIGdsb2JhbDogbmF2aWdhdG9yXG5cbnZhciBtYWMgPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgPyAvTWFjLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSkgOiBmYWxzZTtcblxuZnVuY3Rpb24gbm9ybWFsaXplS2V5TmFtZShuYW1lKSB7XG4gIHZhciBwYXJ0cyA9IG5hbWUuc3BsaXQoLy0oPyEkKS8pLCByZXN1bHQgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXTtcbiAgaWYgKHJlc3VsdCA9PSBcIlNwYWNlXCIpIHsgcmVzdWx0ID0gXCIgXCI7IH1cbiAgdmFyIGFsdCwgY3RybCwgc2hpZnQsIG1ldGE7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgdmFyIG1vZCA9IHBhcnRzW2ldO1xuICAgIGlmICgvXihjbWR8bWV0YXxtKSQvaS50ZXN0KG1vZCkpIHsgbWV0YSA9IHRydWU7IH1cbiAgICBlbHNlIGlmICgvXmEobHQpPyQvaS50ZXN0KG1vZCkpIHsgYWx0ID0gdHJ1ZTsgfVxuICAgIGVsc2UgaWYgKC9eKGN8Y3RybHxjb250cm9sKSQvaS50ZXN0KG1vZCkpIHsgY3RybCA9IHRydWU7IH1cbiAgICBlbHNlIGlmICgvXnMoaGlmdCk/JC9pLnRlc3QobW9kKSkgeyBzaGlmdCA9IHRydWU7IH1cbiAgICBlbHNlIGlmICgvXm1vZCQvaS50ZXN0KG1vZCkpIHsgaWYgKG1hYykgeyBtZXRhID0gdHJ1ZTsgfSBlbHNlIHsgY3RybCA9IHRydWU7IH0gfVxuICAgIGVsc2UgeyB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgbW9kaWZpZXIgbmFtZTogXCIgKyBtb2QpIH1cbiAgfVxuICBpZiAoYWx0KSB7IHJlc3VsdCA9IFwiQWx0LVwiICsgcmVzdWx0OyB9XG4gIGlmIChjdHJsKSB7IHJlc3VsdCA9IFwiQ3RybC1cIiArIHJlc3VsdDsgfVxuICBpZiAobWV0YSkgeyByZXN1bHQgPSBcIk1ldGEtXCIgKyByZXN1bHQ7IH1cbiAgaWYgKHNoaWZ0KSB7IHJlc3VsdCA9IFwiU2hpZnQtXCIgKyByZXN1bHQ7IH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiBub3JtYWxpemUobWFwKSB7XG4gIHZhciBjb3B5ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZm9yICh2YXIgcHJvcCBpbiBtYXApIHsgY29weVtub3JtYWxpemVLZXlOYW1lKHByb3ApXSA9IG1hcFtwcm9wXTsgfVxuICByZXR1cm4gY29weVxufVxuXG5mdW5jdGlvbiBtb2RpZmllcnMobmFtZSwgZXZlbnQsIHNoaWZ0KSB7XG4gIGlmIChldmVudC5hbHRLZXkpIHsgbmFtZSA9IFwiQWx0LVwiICsgbmFtZTsgfVxuICBpZiAoZXZlbnQuY3RybEtleSkgeyBuYW1lID0gXCJDdHJsLVwiICsgbmFtZTsgfVxuICBpZiAoZXZlbnQubWV0YUtleSkgeyBuYW1lID0gXCJNZXRhLVwiICsgbmFtZTsgfVxuICBpZiAoc2hpZnQgIT09IGZhbHNlICYmIGV2ZW50LnNoaWZ0S2V5KSB7IG5hbWUgPSBcIlNoaWZ0LVwiICsgbmFtZTsgfVxuICByZXR1cm4gbmFtZVxufVxuXG4vLyA6OiAoT2JqZWN0KSDihpIgUGx1Z2luXG4vLyBDcmVhdGUgYSBrZXltYXAgcGx1Z2luIGZvciB0aGUgZ2l2ZW4gc2V0IG9mIGJpbmRpbmdzLlxuLy9cbi8vIEJpbmRpbmdzIHNob3VsZCBtYXAga2V5IG5hbWVzIHRvIFtjb21tYW5kXSgjY29tbWFuZHMpLXN0eWxlXG4vLyBmdW5jdGlvbnMsIHdoaWNoIHdpbGwgYmUgY2FsbGVkIHdpdGggYChFZGl0b3JTdGF0ZSwgZGlzcGF0Y2gsXG4vLyBFZGl0b3JWaWV3KWAgYXJndW1lbnRzLCBhbmQgc2hvdWxkIHJldHVybiB0cnVlIHdoZW4gdGhleSd2ZSBoYW5kbGVkXG4vLyB0aGUga2V5LiBOb3RlIHRoYXQgdGhlIHZpZXcgYXJndW1lbnQgaXNuJ3QgcGFydCBvZiB0aGUgY29tbWFuZFxuLy8gcHJvdG9jb2wsIGJ1dCBjYW4gYmUgdXNlZCBhcyBhbiBlc2NhcGUgaGF0Y2ggaWYgYSBiaW5kaW5nIG5lZWRzIHRvXG4vLyBkaXJlY3RseSBpbnRlcmFjdCB3aXRoIHRoZSBVSS5cbi8vXG4vLyBLZXkgbmFtZXMgbWF5IGJlIHN0cmluZ3MgbGlrZSBgXCJTaGlmdC1DdHJsLUVudGVyXCJg4oCUYSBrZXlcbi8vIGlkZW50aWZpZXIgcHJlZml4ZWQgd2l0aCB6ZXJvIG9yIG1vcmUgbW9kaWZpZXJzLiBLZXkgaWRlbnRpZmllcnNcbi8vIGFyZSBiYXNlZCBvbiB0aGUgc3RyaW5ncyB0aGF0IGNhbiBhcHBlYXIgaW5cbi8vIFtgS2V5RXZlbnQua2V5YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQva2V5KS5cbi8vIFVzZSBsb3dlcmNhc2UgbGV0dGVycyB0byByZWZlciB0byBsZXR0ZXIga2V5cyAob3IgdXBwZXJjYXNlIGxldHRlcnNcbi8vIGlmIHlvdSB3YW50IHNoaWZ0IHRvIGJlIGhlbGQpLiBZb3UgbWF5IHVzZSBgXCJTcGFjZVwiYCBhcyBhbiBhbGlhc1xuLy8gZm9yIHRoZSBgXCIgXCJgIG5hbWUuXG4vL1xuLy8gTW9kaWZpZXJzIGNhbiBiZSBnaXZlbiBpbiBhbnkgb3JkZXIuIGBTaGlmdC1gIChvciBgcy1gKSwgYEFsdC1gIChvclxuLy8gYGEtYCksIGBDdHJsLWAgKG9yIGBjLWAgb3IgYENvbnRyb2wtYCkgYW5kIGBDbWQtYCAob3IgYG0tYCBvclxuLy8gYE1ldGEtYCkgYXJlIHJlY29nbml6ZWQuIEZvciBjaGFyYWN0ZXJzIHRoYXQgYXJlIGNyZWF0ZWQgYnkgaG9sZGluZ1xuLy8gc2hpZnQsIHRoZSBgU2hpZnQtYCBwcmVmaXggaXMgaW1wbGllZCwgYW5kIHNob3VsZCBub3QgYmUgYWRkZWRcbi8vIGV4cGxpY2l0bHkuXG4vL1xuLy8gWW91IGNhbiB1c2UgYE1vZC1gIGFzIGEgc2hvcnRoYW5kIGZvciBgQ21kLWAgb24gTWFjIGFuZCBgQ3RybC1gIG9uXG4vLyBvdGhlciBwbGF0Zm9ybXMuXG4vL1xuLy8gWW91IGNhbiBhZGQgbXVsdGlwbGUga2V5bWFwIHBsdWdpbnMgdG8gYW4gZWRpdG9yLiBUaGUgb3JkZXIgaW5cbi8vIHdoaWNoIHRoZXkgYXBwZWFyIGRldGVybWluZXMgdGhlaXIgcHJlY2VkZW5jZSAodGhlIG9uZXMgZWFybHkgaW5cbi8vIHRoZSBhcnJheSBnZXQgdG8gZGlzcGF0Y2ggZmlyc3QpLlxuZnVuY3Rpb24ga2V5bWFwKGJpbmRpbmdzKSB7XG4gIHJldHVybiBuZXcgUGx1Z2luKHtwcm9wczoge2hhbmRsZUtleURvd246IGtleWRvd25IYW5kbGVyKGJpbmRpbmdzKX19KVxufVxuXG4vLyA6OiAoT2JqZWN0KSDihpIgKHZpZXc6IEVkaXRvclZpZXcsIGV2ZW50OiBkb20uRXZlbnQpIOKGkiBib29sXG4vLyBHaXZlbiBhIHNldCBvZiBiaW5kaW5ncyAodXNpbmcgdGhlIHNhbWUgZm9ybWF0IGFzXG4vLyBbYGtleW1hcGBdKCNrZXltYXAua2V5bWFwKSwgcmV0dXJuIGEgW2tleWRvd25cbi8vIGhhbmRsZXJdKCN2aWV3LkVkaXRvclByb3BzLmhhbmRsZUtleURvd24pIHRoYXQgaGFuZGxlcyB0aGVtLlxuZnVuY3Rpb24ga2V5ZG93bkhhbmRsZXIoYmluZGluZ3MpIHtcbiAgdmFyIG1hcCA9IG5vcm1hbGl6ZShiaW5kaW5ncyk7XG4gIHJldHVybiBmdW5jdGlvbih2aWV3LCBldmVudCkge1xuICAgIHZhciBuYW1lID0ga2V5TmFtZShldmVudCksIGlzQ2hhciA9IG5hbWUubGVuZ3RoID09IDEgJiYgbmFtZSAhPSBcIiBcIiwgYmFzZU5hbWU7XG4gICAgdmFyIGRpcmVjdCA9IG1hcFttb2RpZmllcnMobmFtZSwgZXZlbnQsICFpc0NoYXIpXTtcbiAgICBpZiAoZGlyZWN0ICYmIGRpcmVjdCh2aWV3LnN0YXRlLCB2aWV3LmRpc3BhdGNoLCB2aWV3KSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgaWYgKGlzQ2hhciAmJiAoZXZlbnQuc2hpZnRLZXkgfHwgZXZlbnQuYWx0S2V5IHx8IGV2ZW50Lm1ldGFLZXkgfHwgbmFtZS5jaGFyQ29kZUF0KDApID4gMTI3KSAmJlxuICAgICAgICAoYmFzZU5hbWUgPSBiYXNlW2V2ZW50LmtleUNvZGVdKSAmJiBiYXNlTmFtZSAhPSBuYW1lKSB7XG4gICAgICAvLyBUcnkgZmFsbGluZyBiYWNrIHRvIHRoZSBrZXlDb2RlIHdoZW4gdGhlcmUncyBhIG1vZGlmaWVyXG4gICAgICAvLyBhY3RpdmUgb3IgdGhlIGNoYXJhY3RlciBwcm9kdWNlZCBpc24ndCBBU0NJSSwgYW5kIG91ciB0YWJsZVxuICAgICAgLy8gcHJvZHVjZXMgYSBkaWZmZXJlbnQgbmFtZSBmcm9tIHRoZSB0aGUga2V5Q29kZS4gU2VlICM2NjgsXG4gICAgICAvLyAjMTA2MFxuICAgICAgdmFyIGZyb21Db2RlID0gbWFwW21vZGlmaWVycyhiYXNlTmFtZSwgZXZlbnQsIHRydWUpXTtcbiAgICAgIGlmIChmcm9tQ29kZSAmJiBmcm9tQ29kZSh2aWV3LnN0YXRlLCB2aWV3LmRpc3BhdGNoLCB2aWV3KSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgfSBlbHNlIGlmIChpc0NoYXIgJiYgZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgIC8vIE90aGVyd2lzZSwgaWYgc2hpZnQgaXMgYWN0aXZlLCBhbHNvIHRyeSB0aGUgYmluZGluZyB3aXRoIHRoZVxuICAgICAgLy8gU2hpZnQtIHByZWZpeCBlbmFibGVkLiBTZWUgIzk5N1xuICAgICAgdmFyIHdpdGhTaGlmdCA9IG1hcFttb2RpZmllcnMobmFtZSwgZXZlbnQsIHRydWUpXTtcbiAgICAgIGlmICh3aXRoU2hpZnQgJiYgd2l0aFNoaWZ0KHZpZXcuc3RhdGUsIHZpZXcuZGlzcGF0Y2gsIHZpZXcpKSB7IHJldHVybiB0cnVlIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZXhwb3J0IHsga2V5ZG93bkhhbmRsZXIsIGtleW1hcCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXMuanMubWFwXG4iLCJpbXBvcnQgY3JlbCBmcm9tICdjcmVsdCc7XG5pbXBvcnQgeyBqb2luVXAsIGxpZnQsIHNlbGVjdFBhcmVudE5vZGUsIHNldEJsb2NrVHlwZSwgd3JhcEluIH0gZnJvbSAncHJvc2VtaXJyb3ItY29tbWFuZHMnO1xuaW1wb3J0IHsgdW5kbywgcmVkbyB9IGZyb20gJ3Byb3NlbWlycm9yLWhpc3RvcnknO1xuaW1wb3J0IHsgUGx1Z2luIH0gZnJvbSAncHJvc2VtaXJyb3Itc3RhdGUnO1xuXG52YXIgU1ZHID0gXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiO1xudmFyIFhMSU5LID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCI7XG5cbnZhciBwcmVmaXggPSBcIlByb3NlTWlycm9yLWljb25cIjtcblxuZnVuY3Rpb24gaGFzaFBhdGgocGF0aCkge1xuICB2YXIgaGFzaCA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKylcbiAgICB7IGhhc2ggPSAoKChoYXNoIDw8IDUpIC0gaGFzaCkgKyBwYXRoLmNoYXJDb2RlQXQoaSkpIHwgMDsgfVxuICByZXR1cm4gaGFzaFxufVxuXG5mdW5jdGlvbiBnZXRJY29uKGljb24pIHtcbiAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICBub2RlLmNsYXNzTmFtZSA9IHByZWZpeDtcbiAgaWYgKGljb24ucGF0aCkge1xuICAgIHZhciBuYW1lID0gXCJwbS1pY29uLVwiICsgaGFzaFBhdGgoaWNvbi5wYXRoKS50b1N0cmluZygxNik7XG4gICAgaWYgKCFkb2N1bWVudC5nZXRFbGVtZW50QnlJZChuYW1lKSkgeyBidWlsZFNWRyhuYW1lLCBpY29uKTsgfVxuICAgIHZhciBzdmcgPSBub2RlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkcsIFwic3ZnXCIpKTtcbiAgICBzdmcuc3R5bGUud2lkdGggPSAoaWNvbi53aWR0aCAvIGljb24uaGVpZ2h0KSArIFwiZW1cIjtcbiAgICB2YXIgdXNlID0gc3ZnLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkcsIFwidXNlXCIpKTtcbiAgICB1c2Uuc2V0QXR0cmlidXRlTlMoWExJTkssIFwiaHJlZlwiLCAvKFteI10qKS8uZXhlYyhkb2N1bWVudC5sb2NhdGlvbilbMV0gKyBcIiNcIiArIG5hbWUpO1xuICB9IGVsc2UgaWYgKGljb24uZG9tKSB7XG4gICAgbm9kZS5hcHBlbmRDaGlsZChpY29uLmRvbS5jbG9uZU5vZGUodHJ1ZSkpO1xuICB9IGVsc2Uge1xuICAgIG5vZGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIikpLnRleHRDb250ZW50ID0gaWNvbi50ZXh0IHx8ICcnO1xuICAgIGlmIChpY29uLmNzcykgeyBub2RlLmZpcnN0Q2hpbGQuc3R5bGUuY3NzVGV4dCA9IGljb24uY3NzOyB9XG4gIH1cbiAgcmV0dXJuIG5vZGVcbn1cblxuZnVuY3Rpb24gYnVpbGRTVkcobmFtZSwgZGF0YSkge1xuICB2YXIgY29sbGVjdGlvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHByZWZpeCArIFwiLWNvbGxlY3Rpb25cIik7XG4gIGlmICghY29sbGVjdGlvbikge1xuICAgIGNvbGxlY3Rpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHLCBcInN2Z1wiKTtcbiAgICBjb2xsZWN0aW9uLmlkID0gcHJlZml4ICsgXCItY29sbGVjdGlvblwiO1xuICAgIGNvbGxlY3Rpb24uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgIGRvY3VtZW50LmJvZHkuaW5zZXJ0QmVmb3JlKGNvbGxlY3Rpb24sIGRvY3VtZW50LmJvZHkuZmlyc3RDaGlsZCk7XG4gIH1cbiAgdmFyIHN5bSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkcsIFwic3ltYm9sXCIpO1xuICBzeW0uaWQgPSBuYW1lO1xuICBzeW0uc2V0QXR0cmlidXRlKFwidmlld0JveFwiLCBcIjAgMCBcIiArIGRhdGEud2lkdGggKyBcIiBcIiArIGRhdGEuaGVpZ2h0KTtcbiAgdmFyIHBhdGggPSBzeW0uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWRywgXCJwYXRoXCIpKTtcbiAgcGF0aC5zZXRBdHRyaWJ1dGUoXCJkXCIsIGRhdGEucGF0aCk7XG4gIGNvbGxlY3Rpb24uYXBwZW5kQ2hpbGQoc3ltKTtcbn1cblxudmFyIHByZWZpeCQxID0gXCJQcm9zZU1pcnJvci1tZW51XCI7XG5cbi8vIDo6LSBBbiBpY29uIG9yIGxhYmVsIHRoYXQsIHdoZW4gY2xpY2tlZCwgZXhlY3V0ZXMgYSBjb21tYW5kLlxudmFyIE1lbnVJdGVtID0gZnVuY3Rpb24gTWVudUl0ZW0oc3BlYykge1xuICAvLyA6OiBNZW51SXRlbVNwZWNcbiAgLy8gVGhlIHNwZWMgdXNlZCB0byBjcmVhdGUgdGhlIG1lbnUgaXRlbS5cbiAgdGhpcy5zcGVjID0gc3BlYztcbn07XG5cbi8vIDo6IChFZGl0b3JWaWV3KSDihpIge2RvbTogZG9tLk5vZGUsIHVwZGF0ZTogKEVkaXRvclN0YXRlKSDihpIgYm9vbH1cbi8vIFJlbmRlcnMgdGhlIGljb24gYWNjb3JkaW5nIHRvIGl0cyBbZGlzcGxheVxuLy8gc3BlY10oI21lbnUuTWVudUl0ZW1TcGVjLmRpc3BsYXkpLCBhbmQgYWRkcyBhbiBldmVudCBoYW5kbGVyIHdoaWNoXG4vLyBleGVjdXRlcyB0aGUgY29tbWFuZCB3aGVuIHRoZSByZXByZXNlbnRhdGlvbiBpcyBjbGlja2VkLlxuTWVudUl0ZW0ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlciAodmlldykge1xuICB2YXIgc3BlYyA9IHRoaXMuc3BlYztcbiAgdmFyIGRvbSA9IHNwZWMucmVuZGVyID8gc3BlYy5yZW5kZXIodmlldylcbiAgICAgIDogc3BlYy5pY29uID8gZ2V0SWNvbihzcGVjLmljb24pXG4gICAgICA6IHNwZWMubGFiZWwgPyBjcmVsKFwiZGl2XCIsIG51bGwsIHRyYW5zbGF0ZSh2aWV3LCBzcGVjLmxhYmVsKSlcbiAgICAgIDogbnVsbDtcbiAgaWYgKCFkb20pIHsgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJNZW51SXRlbSB3aXRob3V0IGljb24gb3IgbGFiZWwgcHJvcGVydHlcIikgfVxuICBpZiAoc3BlYy50aXRsZSkge1xuICAgIHZhciB0aXRsZSA9ICh0eXBlb2Ygc3BlYy50aXRsZSA9PT0gXCJmdW5jdGlvblwiID8gc3BlYy50aXRsZSh2aWV3LnN0YXRlKSA6IHNwZWMudGl0bGUpO1xuICAgIGRvbS5zZXRBdHRyaWJ1dGUoXCJ0aXRsZVwiLCB0cmFuc2xhdGUodmlldywgdGl0bGUpKTtcbiAgfVxuICBpZiAoc3BlYy5jbGFzcykgeyBkb20uY2xhc3NMaXN0LmFkZChzcGVjLmNsYXNzKTsgfVxuICBpZiAoc3BlYy5jc3MpIHsgZG9tLnN0eWxlLmNzc1RleHQgKz0gc3BlYy5jc3M7IH1cblxuICBkb20uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBmdW5jdGlvbiAoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBpZiAoIWRvbS5jbGFzc0xpc3QuY29udGFpbnMocHJlZml4JDEgKyBcIi1kaXNhYmxlZFwiKSlcbiAgICAgIHsgc3BlYy5ydW4odmlldy5zdGF0ZSwgdmlldy5kaXNwYXRjaCwgdmlldywgZSk7IH1cbiAgfSk7XG5cbiAgZnVuY3Rpb24gdXBkYXRlKHN0YXRlKSB7XG4gICAgaWYgKHNwZWMuc2VsZWN0KSB7XG4gICAgICB2YXIgc2VsZWN0ZWQgPSBzcGVjLnNlbGVjdChzdGF0ZSk7XG4gICAgICBkb20uc3R5bGUuZGlzcGxheSA9IHNlbGVjdGVkID8gXCJcIiA6IFwibm9uZVwiO1xuICAgICAgaWYgKCFzZWxlY3RlZCkgeyByZXR1cm4gZmFsc2UgfVxuICAgIH1cbiAgICB2YXIgZW5hYmxlZCA9IHRydWU7XG4gICAgaWYgKHNwZWMuZW5hYmxlKSB7XG4gICAgICBlbmFibGVkID0gc3BlYy5lbmFibGUoc3RhdGUpIHx8IGZhbHNlO1xuICAgICAgc2V0Q2xhc3MoZG9tLCBwcmVmaXgkMSArIFwiLWRpc2FibGVkXCIsICFlbmFibGVkKTtcbiAgICB9XG4gICAgaWYgKHNwZWMuYWN0aXZlKSB7XG4gICAgICB2YXIgYWN0aXZlID0gZW5hYmxlZCAmJiBzcGVjLmFjdGl2ZShzdGF0ZSkgfHwgZmFsc2U7XG4gICAgICBzZXRDbGFzcyhkb20sIHByZWZpeCQxICsgXCItYWN0aXZlXCIsIGFjdGl2ZSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICByZXR1cm4ge2RvbTogZG9tLCB1cGRhdGU6IHVwZGF0ZX1cbn07XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZSh2aWV3LCB0ZXh0KSB7XG4gIHJldHVybiB2aWV3Ll9wcm9wcy50cmFuc2xhdGUgPyB2aWV3Ll9wcm9wcy50cmFuc2xhdGUodGV4dCkgOiB0ZXh0XG59XG5cbi8vIE1lbnVJdGVtU3BlYzo6IGludGVyZmFjZVxuLy8gVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0IHBhc3NlZCB0byB0aGUgYE1lbnVJdGVtYCBjb25zdHJ1Y3Rvci5cbi8vXG4vLyAgIHJ1bjo6IChFZGl0b3JTdGF0ZSwgKFRyYW5zYWN0aW9uKSwgRWRpdG9yVmlldywgZG9tLkV2ZW50KVxuLy8gICBUaGUgZnVuY3Rpb24gdG8gZXhlY3V0ZSB3aGVuIHRoZSBtZW51IGl0ZW0gaXMgYWN0aXZhdGVkLlxuLy9cbi8vICAgc2VsZWN0OjogPyhFZGl0b3JTdGF0ZSkg4oaSIGJvb2xcbi8vICAgT3B0aW9uYWwgZnVuY3Rpb24gdGhhdCBpcyB1c2VkIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZSBpdGVtIGlzXG4vLyAgIGFwcHJvcHJpYXRlIGF0IHRoZSBtb21lbnQuIERlc2VsZWN0ZWQgaXRlbXMgd2lsbCBiZSBoaWRkZW4uXG4vL1xuLy8gICBlbmFibGU6OiA/KEVkaXRvclN0YXRlKSDihpIgYm9vbFxuLy8gICBGdW5jdGlvbiB0aGF0IGlzIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIHRoZSBpdGVtIGlzIGVuYWJsZWQuIElmXG4vLyAgIGdpdmVuIGFuZCByZXR1cm5pbmcgZmFsc2UsIHRoZSBpdGVtIHdpbGwgYmUgZ2l2ZW4gYSBkaXNhYmxlZFxuLy8gICBzdHlsaW5nLlxuLy9cbi8vICAgYWN0aXZlOjogPyhFZGl0b3JTdGF0ZSkg4oaSIGJvb2xcbi8vICAgQSBwcmVkaWNhdGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGl0ZW0gaXMgJ2FjdGl2ZScgKGZvclxuLy8gICBleGFtcGxlLCB0aGUgaXRlbSBmb3IgdG9nZ2xpbmcgdGhlIHN0cm9uZyBtYXJrIG1pZ2h0IGJlIGFjdGl2ZSB0aGVuXG4vLyAgIHRoZSBjdXJzb3IgaXMgaW4gc3Ryb25nIHRleHQpLlxuLy9cbi8vICAgcmVuZGVyOjogPyhFZGl0b3JWaWV3KSDihpIgZG9tLk5vZGVcbi8vICAgQSBmdW5jdGlvbiB0aGF0IHJlbmRlcnMgdGhlIGl0ZW0uIFlvdSBtdXN0IHByb3ZpZGUgZWl0aGVyIHRoaXMsXG4vLyAgIFtgaWNvbmBdKCNtZW51Lk1lbnVJdGVtU3BlYy5pY29uKSwgb3IgW2BsYWJlbGBdKCNNZW51SXRlbVNwZWMubGFiZWwpLlxuLy9cbi8vICAgaWNvbjo6ID9PYmplY3Rcbi8vICAgRGVzY3JpYmVzIGFuIGljb24gdG8gc2hvdyBmb3IgdGhpcyBpdGVtLiBUaGUgb2JqZWN0IG1heSBzcGVjaWZ5XG4vLyAgIGFuIFNWRyBpY29uLCBpbiB3aGljaCBjYXNlIGl0cyBgcGF0aGAgcHJvcGVydHkgc2hvdWxkIGJlIGFuIFtTVkdcbi8vICAgcGF0aFxuLy8gICBzcGVjXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL2QpLFxuLy8gICBhbmQgYHdpZHRoYCBhbmQgYGhlaWdodGAgc2hvdWxkIHByb3ZpZGUgdGhlIHZpZXdib3ggaW4gd2hpY2ggdGhhdFxuLy8gICBwYXRoIGV4aXN0cy4gQWx0ZXJuYXRpdmVseSwgaXQgbWF5IGhhdmUgYSBgdGV4dGAgcHJvcGVydHlcbi8vICAgc3BlY2lmeWluZyBhIHN0cmluZyBvZiB0ZXh0IHRoYXQgbWFrZXMgdXAgdGhlIGljb24sIHdpdGggYW5cbi8vICAgb3B0aW9uYWwgYGNzc2AgcHJvcGVydHkgZ2l2aW5nIGFkZGl0aW9uYWwgQ1NTIHN0eWxpbmcgZm9yIHRoZVxuLy8gICB0ZXh0LiBfT3JfIGl0IG1heSBjb250YWluIGBkb21gIHByb3BlcnR5IGNvbnRhaW5pbmcgYSBET00gbm9kZS5cbi8vXG4vLyAgIGxhYmVsOjogP3N0cmluZ1xuLy8gICBNYWtlcyB0aGUgaXRlbSBzaG93IHVwIGFzIGEgdGV4dCBsYWJlbC4gTW9zdGx5IHVzZWZ1bCBmb3IgaXRlbXNcbi8vICAgd3JhcHBlZCBpbiBhIFtkcm9wLWRvd25dKCNtZW51LkRyb3Bkb3duKSBvciBzaW1pbGFyIG1lbnUuIFRoZSBvYmplY3Rcbi8vICAgc2hvdWxkIGhhdmUgYSBgbGFiZWxgIHByb3BlcnR5IHByb3ZpZGluZyB0aGUgdGV4dCB0byBkaXNwbGF5LlxuLy9cbi8vICAgdGl0bGU6OiA/dW5pb248c3RyaW5nLCAoRWRpdG9yU3RhdGUpIOKGkiBzdHJpbmc+XG4vLyAgIERlZmluZXMgRE9NIHRpdGxlIChtb3VzZW92ZXIpIHRleHQgZm9yIHRoZSBpdGVtLlxuLy9cbi8vICAgY2xhc3M6OiA/c3RyaW5nXG4vLyAgIE9wdGlvbmFsbHkgYWRkcyBhIENTUyBjbGFzcyB0byB0aGUgaXRlbSdzIERPTSByZXByZXNlbnRhdGlvbi5cbi8vXG4vLyAgIGNzczo6ID9zdHJpbmdcbi8vICAgT3B0aW9uYWxseSBhZGRzIGEgc3RyaW5nIG9mIGlubGluZSBDU1MgdG8gdGhlIGl0ZW0ncyBET01cbi8vICAgcmVwcmVzZW50YXRpb24uXG5cbnZhciBsYXN0TWVudUV2ZW50ID0ge3RpbWU6IDAsIG5vZGU6IG51bGx9O1xuZnVuY3Rpb24gbWFya01lbnVFdmVudChlKSB7XG4gIGxhc3RNZW51RXZlbnQudGltZSA9IERhdGUubm93KCk7XG4gIGxhc3RNZW51RXZlbnQubm9kZSA9IGUudGFyZ2V0O1xufVxuZnVuY3Rpb24gaXNNZW51RXZlbnQod3JhcHBlcikge1xuICByZXR1cm4gRGF0ZS5ub3coKSAtIDEwMCA8IGxhc3RNZW51RXZlbnQudGltZSAmJlxuICAgIGxhc3RNZW51RXZlbnQubm9kZSAmJiB3cmFwcGVyLmNvbnRhaW5zKGxhc3RNZW51RXZlbnQubm9kZSlcbn1cblxuLy8gOjotIEEgZHJvcC1kb3duIG1lbnUsIGRpc3BsYXllZCBhcyBhIGxhYmVsIHdpdGggYSBkb3dud2FyZHMtcG9pbnRpbmdcbi8vIHRyaWFuZ2xlIHRvIHRoZSByaWdodCBvZiBpdC5cbnZhciBEcm9wZG93biA9IGZ1bmN0aW9uIERyb3Bkb3duKGNvbnRlbnQsIG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdGhpcy5jb250ZW50ID0gQXJyYXkuaXNBcnJheShjb250ZW50KSA/IGNvbnRlbnQgOiBbY29udGVudF07XG59O1xuXG4vLyA6OiAoRWRpdG9yVmlldykg4oaSIHtkb206IGRvbS5Ob2RlLCB1cGRhdGU6IChFZGl0b3JTdGF0ZSl9XG4vLyBSZW5kZXIgdGhlIGRyb3Bkb3duIG1lbnUgYW5kIHN1Yi1pdGVtcy5cbkRyb3Bkb3duLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIgKHZpZXcpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgY29udGVudCA9IHJlbmRlckRyb3Bkb3duSXRlbXModGhpcy5jb250ZW50LCB2aWV3KTtcblxuICB2YXIgbGFiZWwgPSBjcmVsKFwiZGl2XCIsIHtjbGFzczogcHJlZml4JDEgKyBcIi1kcm9wZG93biBcIiArICh0aGlzLm9wdGlvbnMuY2xhc3MgfHwgXCJcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogdGhpcy5vcHRpb25zLmNzc30sXG4gICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlKHZpZXcsIHRoaXMub3B0aW9ucy5sYWJlbCkpO1xuICBpZiAodGhpcy5vcHRpb25zLnRpdGxlKSB7IGxhYmVsLnNldEF0dHJpYnV0ZShcInRpdGxlXCIsIHRyYW5zbGF0ZSh2aWV3LCB0aGlzLm9wdGlvbnMudGl0bGUpKTsgfVxuICB2YXIgd3JhcCA9IGNyZWwoXCJkaXZcIiwge2NsYXNzOiBwcmVmaXgkMSArIFwiLWRyb3Bkb3duLXdyYXBcIn0sIGxhYmVsKTtcbiAgdmFyIG9wZW4gPSBudWxsLCBsaXN0ZW5pbmdPbkNsb3NlID0gbnVsbDtcbiAgdmFyIGNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChvcGVuICYmIG9wZW4uY2xvc2UoKSkge1xuICAgICAgb3BlbiA9IG51bGw7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBsaXN0ZW5pbmdPbkNsb3NlKTtcbiAgICB9XG4gIH07XG4gIGxhYmVsLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgZnVuY3Rpb24gKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgbWFya01lbnVFdmVudChlKTtcbiAgICBpZiAob3Blbikge1xuICAgICAgY2xvc2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3BlbiA9IHRoaXMkMS5leHBhbmQod3JhcCwgY29udGVudC5kb20pO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgbGlzdGVuaW5nT25DbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFpc01lbnVFdmVudCh3cmFwKSkgeyBjbG9zZSgpOyB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHVwZGF0ZShzdGF0ZSkge1xuICAgIHZhciBpbm5lciA9IGNvbnRlbnQudXBkYXRlKHN0YXRlKTtcbiAgICB3cmFwLnN0eWxlLmRpc3BsYXkgPSBpbm5lciA/IFwiXCIgOiBcIm5vbmVcIjtcbiAgICByZXR1cm4gaW5uZXJcbiAgfVxuXG4gIHJldHVybiB7ZG9tOiB3cmFwLCB1cGRhdGU6IHVwZGF0ZX1cbn07XG5cbkRyb3Bkb3duLnByb3RvdHlwZS5leHBhbmQgPSBmdW5jdGlvbiBleHBhbmQgKGRvbSwgaXRlbXMpIHtcbiAgdmFyIG1lbnVET00gPSBjcmVsKFwiZGl2XCIsIHtjbGFzczogcHJlZml4JDEgKyBcIi1kcm9wZG93bi1tZW51IFwiICsgKHRoaXMub3B0aW9ucy5jbGFzcyB8fCBcIlwiKX0sIGl0ZW1zKTtcblxuICB2YXIgZG9uZSA9IGZhbHNlO1xuICBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICBpZiAoZG9uZSkgeyByZXR1cm4gfVxuICAgIGRvbmUgPSB0cnVlO1xuICAgIGRvbS5yZW1vdmVDaGlsZChtZW51RE9NKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGRvbS5hcHBlbmRDaGlsZChtZW51RE9NKTtcbiAgcmV0dXJuIHtjbG9zZTogY2xvc2UsIG5vZGU6IG1lbnVET019XG59O1xuXG5mdW5jdGlvbiByZW5kZXJEcm9wZG93bkl0ZW1zKGl0ZW1zLCB2aWV3KSB7XG4gIHZhciByZW5kZXJlZCA9IFtdLCB1cGRhdGVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcmVmID0gaXRlbXNbaV0ucmVuZGVyKHZpZXcpO1xuICAgIHZhciBkb20gPSByZWYuZG9tO1xuICAgIHZhciB1cGRhdGUgPSByZWYudXBkYXRlO1xuICAgIHJlbmRlcmVkLnB1c2goY3JlbChcImRpdlwiLCB7Y2xhc3M6IHByZWZpeCQxICsgXCItZHJvcGRvd24taXRlbVwifSwgZG9tKSk7XG4gICAgdXBkYXRlcy5wdXNoKHVwZGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHtkb206IHJlbmRlcmVkLCB1cGRhdGU6IGNvbWJpbmVVcGRhdGVzKHVwZGF0ZXMsIHJlbmRlcmVkKX1cbn1cblxuZnVuY3Rpb24gY29tYmluZVVwZGF0ZXModXBkYXRlcywgbm9kZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgIHZhciBzb21ldGhpbmcgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVwZGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB1cCA9IHVwZGF0ZXNbaV0oc3RhdGUpO1xuICAgICAgbm9kZXNbaV0uc3R5bGUuZGlzcGxheSA9IHVwID8gXCJcIiA6IFwibm9uZVwiO1xuICAgICAgaWYgKHVwKSB7IHNvbWV0aGluZyA9IHRydWU7IH1cbiAgICB9XG4gICAgcmV0dXJuIHNvbWV0aGluZ1xuICB9XG59XG5cbi8vIDo6LSBSZXByZXNlbnRzIGEgc3VibWVudSB3cmFwcGluZyBhIGdyb3VwIG9mIGVsZW1lbnRzIHRoYXQgc3RhcnRcbi8vIGhpZGRlbiBhbmQgZXhwYW5kIHRvIHRoZSByaWdodCB3aGVuIGhvdmVyZWQgb3ZlciBvciB0YXBwZWQuXG52YXIgRHJvcGRvd25TdWJtZW51ID0gZnVuY3Rpb24gRHJvcGRvd25TdWJtZW51KGNvbnRlbnQsIG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdGhpcy5jb250ZW50ID0gQXJyYXkuaXNBcnJheShjb250ZW50KSA/IGNvbnRlbnQgOiBbY29udGVudF07XG59O1xuXG4vLyA6OiAoRWRpdG9yVmlldykg4oaSIHtkb206IGRvbS5Ob2RlLCB1cGRhdGU6IChFZGl0b3JTdGF0ZSkg4oaSIGJvb2x9XG4vLyBSZW5kZXJzIHRoZSBzdWJtZW51LlxuRHJvcGRvd25TdWJtZW51LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIgKHZpZXcpIHtcbiAgdmFyIGl0ZW1zID0gcmVuZGVyRHJvcGRvd25JdGVtcyh0aGlzLmNvbnRlbnQsIHZpZXcpO1xuXG4gIHZhciBsYWJlbCA9IGNyZWwoXCJkaXZcIiwge2NsYXNzOiBwcmVmaXgkMSArIFwiLXN1Ym1lbnUtbGFiZWxcIn0sIHRyYW5zbGF0ZSh2aWV3LCB0aGlzLm9wdGlvbnMubGFiZWwpKTtcbiAgdmFyIHdyYXAgPSBjcmVsKFwiZGl2XCIsIHtjbGFzczogcHJlZml4JDEgKyBcIi1zdWJtZW51LXdyYXBcIn0sIGxhYmVsLFxuICAgICAgICAgICAgICAgICBjcmVsKFwiZGl2XCIsIHtjbGFzczogcHJlZml4JDEgKyBcIi1zdWJtZW51XCJ9LCBpdGVtcy5kb20pKTtcbiAgdmFyIGxpc3RlbmluZ09uQ2xvc2UgPSBudWxsO1xuICBsYWJlbC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIG1hcmtNZW51RXZlbnQoZSk7XG4gICAgc2V0Q2xhc3Mod3JhcCwgcHJlZml4JDEgKyBcIi1zdWJtZW51LXdyYXAtYWN0aXZlXCIpO1xuICAgIGlmICghbGlzdGVuaW5nT25DbG9zZSlcbiAgICAgIHsgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgbGlzdGVuaW5nT25DbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFpc01lbnVFdmVudCh3cmFwKSkge1xuICAgICAgICAgIHdyYXAuY2xhc3NMaXN0LnJlbW92ZShwcmVmaXgkMSArIFwiLXN1Ym1lbnUtd3JhcC1hY3RpdmVcIik7XG4gICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgbGlzdGVuaW5nT25DbG9zZSk7XG4gICAgICAgICAgbGlzdGVuaW5nT25DbG9zZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0pOyB9XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHVwZGF0ZShzdGF0ZSkge1xuICAgIHZhciBpbm5lciA9IGl0ZW1zLnVwZGF0ZShzdGF0ZSk7XG4gICAgd3JhcC5zdHlsZS5kaXNwbGF5ID0gaW5uZXIgPyBcIlwiIDogXCJub25lXCI7XG4gICAgcmV0dXJuIGlubmVyXG4gIH1cbiAgcmV0dXJuIHtkb206IHdyYXAsIHVwZGF0ZTogdXBkYXRlfVxufTtcblxuLy8gOjogKEVkaXRvclZpZXcsIFt1bmlvbjxNZW51RWxlbWVudCwgW01lbnVFbGVtZW50XT5dKSDihpIge2RvbTogP2RvbS5Eb2N1bWVudEZyYWdtZW50LCB1cGRhdGU6IChFZGl0b3JTdGF0ZSkg4oaSIGJvb2x9XG4vLyBSZW5kZXIgdGhlIGdpdmVuLCBwb3NzaWJseSBuZXN0ZWQsIGFycmF5IG9mIG1lbnUgZWxlbWVudHMgaW50byBhXG4vLyBkb2N1bWVudCBmcmFnbWVudCwgcGxhY2luZyBzZXBhcmF0b3JzIGJldHdlZW4gdGhlbSAoYW5kIGVuc3VyaW5nIG5vXG4vLyBzdXBlcmZsdW91cyBzZXBhcmF0b3JzIGFwcGVhciB3aGVuIHNvbWUgb2YgdGhlIGdyb3VwcyB0dXJuIG91dCB0b1xuLy8gYmUgZW1wdHkpLlxuZnVuY3Rpb24gcmVuZGVyR3JvdXBlZCh2aWV3LCBjb250ZW50KSB7XG4gIHZhciByZXN1bHQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gIHZhciB1cGRhdGVzID0gW10sIHNlcGFyYXRvcnMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250ZW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW1zID0gY29udGVudFtpXSwgbG9jYWxVcGRhdGVzID0gW10sIGxvY2FsTm9kZXMgPSBbXTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGl0ZW1zLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgcmVmID0gaXRlbXNbal0ucmVuZGVyKHZpZXcpO1xuICAgICAgdmFyIGRvbSA9IHJlZi5kb207XG4gICAgICB2YXIgdXBkYXRlJDEgPSByZWYudXBkYXRlO1xuICAgICAgdmFyIHNwYW4gPSBjcmVsKFwic3BhblwiLCB7Y2xhc3M6IHByZWZpeCQxICsgXCJpdGVtXCJ9LCBkb20pO1xuICAgICAgcmVzdWx0LmFwcGVuZENoaWxkKHNwYW4pO1xuICAgICAgbG9jYWxOb2Rlcy5wdXNoKHNwYW4pO1xuICAgICAgbG9jYWxVcGRhdGVzLnB1c2godXBkYXRlJDEpO1xuICAgIH1cbiAgICBpZiAobG9jYWxVcGRhdGVzLmxlbmd0aCkge1xuICAgICAgdXBkYXRlcy5wdXNoKGNvbWJpbmVVcGRhdGVzKGxvY2FsVXBkYXRlcywgbG9jYWxOb2RlcykpO1xuICAgICAgaWYgKGkgPCBjb250ZW50Lmxlbmd0aCAtIDEpXG4gICAgICAgIHsgc2VwYXJhdG9ycy5wdXNoKHJlc3VsdC5hcHBlbmRDaGlsZChzZXBhcmF0b3IoKSkpOyB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlKHN0YXRlKSB7XG4gICAgdmFyIHNvbWV0aGluZyA9IGZhbHNlLCBuZWVkU2VwID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1cGRhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGFzQ29udGVudCA9IHVwZGF0ZXNbaV0oc3RhdGUpO1xuICAgICAgaWYgKGkpIHsgc2VwYXJhdG9yc1tpIC0gMV0uc3R5bGUuZGlzcGxheSA9IG5lZWRTZXAgJiYgaGFzQ29udGVudCA/IFwiXCIgOiBcIm5vbmVcIjsgfVxuICAgICAgbmVlZFNlcCA9IGhhc0NvbnRlbnQ7XG4gICAgICBpZiAoaGFzQ29udGVudCkgeyBzb21ldGhpbmcgPSB0cnVlOyB9XG4gICAgfVxuICAgIHJldHVybiBzb21ldGhpbmdcbiAgfVxuICByZXR1cm4ge2RvbTogcmVzdWx0LCB1cGRhdGU6IHVwZGF0ZX1cbn1cblxuZnVuY3Rpb24gc2VwYXJhdG9yKCkge1xuICByZXR1cm4gY3JlbChcInNwYW5cIiwge2NsYXNzOiBwcmVmaXgkMSArIFwic2VwYXJhdG9yXCJ9KVxufVxuXG4vLyA6OiBPYmplY3Rcbi8vIEEgc2V0IG9mIGJhc2ljIGVkaXRvci1yZWxhdGVkIGljb25zLiBDb250YWlucyB0aGUgcHJvcGVydGllc1xuLy8gYGpvaW5gLCBgbGlmdGAsIGBzZWxlY3RQYXJlbnROb2RlYCwgYHVuZG9gLCBgcmVkb2AsIGBzdHJvbmdgLCBgZW1gLFxuLy8gYGNvZGVgLCBgbGlua2AsIGBidWxsZXRMaXN0YCwgYG9yZGVyZWRMaXN0YCwgYW5kIGBibG9ja3F1b3RlYCwgZWFjaFxuLy8gaG9sZGluZyBhbiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCBhcyB0aGUgYGljb25gIG9wdGlvbiB0b1xuLy8gYE1lbnVJdGVtYC5cbnZhciBpY29ucyA9IHtcbiAgam9pbjoge1xuICAgIHdpZHRoOiA4MDAsIGhlaWdodDogOTAwLFxuICAgIHBhdGg6IFwiTTAgNzVoODAwdjEyNWgtODAweiBNMCA4MjVoODAwdi0xMjVoLTgwMHogTTI1MCA0MDBoMTAwdi0xMDBoMTAwdjEwMGgxMDB2MTAwaC0xMDB2MTAwaC0xMDB2LTEwMGgtMTAwelwiXG4gIH0sXG4gIGxpZnQ6IHtcbiAgICB3aWR0aDogMTAyNCwgaGVpZ2h0OiAxMDI0LFxuICAgIHBhdGg6IFwiTTIxOSAzMTB2MzI5cTAgNy01IDEydC0xMiA1cS04IDAtMTMtNWwtMTY0LTE2NHEtNS01LTUtMTN0NS0xM2wxNjQtMTY0cTUtNSAxMy01IDcgMCAxMiA1dDUgMTJ6TTEwMjQgNzQ5djEwOXEwIDctNSAxMnQtMTIgNWgtOTg3cS03IDAtMTItNXQtNS0xMnYtMTA5cTAtNyA1LTEydDEyLTVoOTg3cTcgMCAxMiA1dDUgMTJ6TTEwMjQgNTMwdjEwOXEwIDctNSAxMnQtMTIgNWgtNjIxcS03IDAtMTItNXQtNS0xMnYtMTA5cTAtNyA1LTEydDEyLTVoNjIxcTcgMCAxMiA1dDUgMTJ6TTEwMjQgMzEwdjEwOXEwIDctNSAxMnQtMTIgNWgtNjIxcS03IDAtMTItNXQtNS0xMnYtMTA5cTAtNyA1LTEydDEyLTVoNjIxcTcgMCAxMiA1dDUgMTJ6TTEwMjQgOTF2MTA5cTAgNy01IDEydC0xMiA1aC05ODdxLTcgMC0xMi01dC01LTEydi0xMDlxMC03IDUtMTJ0MTItNWg5ODdxNyAwIDEyIDV0NSAxMnpcIlxuICB9LFxuICBzZWxlY3RQYXJlbnROb2RlOiB7dGV4dDogXCJcXHUyYjFhXCIsIGNzczogXCJmb250LXdlaWdodDogYm9sZFwifSxcbiAgdW5kbzoge1xuICAgIHdpZHRoOiAxMDI0LCBoZWlnaHQ6IDEwMjQsXG4gICAgcGF0aDogXCJNNzYxIDEwMjRjMTEzLTIwNiAxMzItNTIwLTMxMy01MDl2MjUzbC0zODQtMzg0IDM4NC0zODR2MjQ4YzUzNC0xMyA1OTQgNDcyIDMxMyA3NzV6XCJcbiAgfSxcbiAgcmVkbzoge1xuICAgIHdpZHRoOiAxMDI0LCBoZWlnaHQ6IDEwMjQsXG4gICAgcGF0aDogXCJNNTc2IDI0OHYtMjQ4bDM4NCAzODQtMzg0IDM4NHYtMjUzYy00NDYtMTAtNDI3IDMwMy0zMTMgNTA5LTI4MC0zMDMtMjIxLTc4OSAzMTMtNzc1elwiXG4gIH0sXG4gIHN0cm9uZzoge1xuICAgIHdpZHRoOiA4MDUsIGhlaWdodDogMTAyNCxcbiAgICBwYXRoOiBcIk0zMTcgODY5cTQyIDE4IDgwIDE4IDIxNCAwIDIxNC0xOTEgMC02NS0yMy0xMDItMTUtMjUtMzUtNDJ0LTM4LTI2LTQ2LTE0LTQ4LTYtNTQtMXEtNDEgMC01NyA1IDAgMzAtMCA5MHQtMCA5MHEwIDQtMCAzOHQtMCA1NSAyIDQ3IDYgMzh6TTMwOSA0NDJxMjQgNCA2MiA0IDQ2IDAgODEtN3Q2Mi0yNSA0Mi01MSAxNC04MXEwLTQwLTE2LTcwdC00NS00Ni02MS0yNC03MC04cS0yOCAwLTc0IDcgMCAyOCAyIDg2dDIgODZxMCAxNS0wIDQ1dC0wIDQ1cTAgMjYgMCAzOXpNMCA5NTBsMS01M3E4LTIgNDgtOXQ2MC0xNXE0LTYgNy0xNXQ0LTE5IDMtMTggMS0yMSAwLTE5di0zN3EwLTU2MS0xMi01ODUtMi00LTEyLTh0LTI1LTYtMjgtNC0yNy0yLTE3LTFsLTItNDdxNTYtMSAxOTQtNnQyMTMtNXExMyAwIDM5IDB0MzggMHE0MCAwIDc4IDd0NzMgMjQgNjEgNDAgNDIgNTkgMTYgNzhxMCAyOS05IDU0dC0yMiA0MS0zNiAzMi00MSAyNS00OCAyMnE4OCAyMCAxNDYgNzZ0NTggMTQxcTAgNTctMjAgMTAydC01MyA3NC03OCA0OC05MyAyNy0xMDAgOHEtMjUgMC03NS0xdC03NS0xcS02MCAwLTE3NSA2dC0xMzIgNnpcIlxuICB9LFxuICBlbToge1xuICAgIHdpZHRoOiA1ODUsIGhlaWdodDogMTAyNCxcbiAgICBwYXRoOiBcIk0wIDk0OWw5LTQ4cTMtMSA0Ni0xMnQ2My0yMXExNi0yMCAyMy01NyAwLTQgMzUtMTY1dDY1LTMxMCAyOS0xNjl2LTE0cS0xMy03LTMxLTEwdC0zOS00LTMzLTNsMTAtNThxMTggMSA2OCAzdDg1IDQgNjggMXEyNyAwIDU2LTF0NjktNCA1Ni0zcS0yIDIyLTEwIDUwLTE3IDUtNTggMTZ0LTYyIDE5cS00IDEwLTggMjR0LTUgMjItNCAyNi0zIDI0cS0xNSA4NC01MCAyMzl0LTQ0IDIwM3EtMSA1LTcgMzN0LTExIDUxLTkgNDctMyAzMmwwIDEwcTkgMiAxMDUgMTctMSAyNS05IDU2LTYgMC0xOCAwdC0xOCAwcS0xNiAwLTQ5LTV0LTQ5LTVxLTc4LTEtMTE3LTEtMjkgMC04MSA1dC02OSA2elwiXG4gIH0sXG4gIGNvZGU6IHtcbiAgICB3aWR0aDogODk2LCBoZWlnaHQ6IDEwMjQsXG4gICAgcGF0aDogXCJNNjA4IDE5MmwtOTYgOTYgMjI0IDIyNC0yMjQgMjI0IDk2IDk2IDI4OC0zMjAtMjg4LTMyMHpNMjg4IDE5MmwtMjg4IDMyMCAyODggMzIwIDk2LTk2LTIyNC0yMjQgMjI0LTIyNC05Ni05NnpcIlxuICB9LFxuICBsaW5rOiB7XG4gICAgd2lkdGg6IDk1MSwgaGVpZ2h0OiAxMDI0LFxuICAgIHBhdGg6IFwiTTgzMiA2OTRxMC0yMi0xNi0zOGwtMTE4LTExOHEtMTYtMTYtMzgtMTYtMjQgMC00MSAxOCAxIDEgMTAgMTB0MTIgMTIgOCAxMCA3IDE0IDIgMTVxMCAyMi0xNiAzOHQtMzggMTZxLTggMC0xNS0ydC0xNC03LTEwLTgtMTItMTItMTAtMTBxLTE4IDE3LTE4IDQxIDAgMjIgMTYgMzhsMTE3IDExOHExNSAxNSAzOCAxNSAyMiAwIDM4LTE0bDg0LTgzcTE2LTE2IDE2LTM4ek00MzAgMjkycTAtMjItMTYtMzhsLTExNy0xMThxLTE2LTE2LTM4LTE2LTIyIDAtMzggMTVsLTg0IDgzcS0xNiAxNi0xNiAzOCAwIDIyIDE2IDM4bDExOCAxMThxMTUgMTUgMzggMTUgMjQgMCA0MS0xNy0xLTEtMTAtMTB0LTEyLTEyLTgtMTAtNy0xNC0yLTE1cTAtMjIgMTYtMzh0MzgtMTZxOCAwIDE1IDJ0MTQgNyAxMCA4IDEyIDEyIDEwIDEwcTE4LTE3IDE4LTQxek05NDEgNjk0cTAgNjgtNDggMTE2bC04NCA4M3EtNDcgNDctMTE2IDQ3LTY5IDAtMTE2LTQ4bC0xMTctMTE4cS00Ny00Ny00Ny0xMTYgMC03MCA1MC0xMTlsLTUwLTUwcS00OSA1MC0xMTggNTAtNjggMC0xMTYtNDhsLTExOC0xMThxLTQ4LTQ4LTQ4LTExNnQ0OC0xMTZsODQtODNxNDctNDcgMTE2LTQ3IDY5IDAgMTE2IDQ4bDExNyAxMThxNDcgNDcgNDcgMTE2IDAgNzAtNTAgMTE5bDUwIDUwcTQ5LTUwIDExOC01MCA2OCAwIDExNiA0OGwxMTggMTE4cTQ4IDQ4IDQ4IDExNnpcIlxuICB9LFxuICBidWxsZXRMaXN0OiB7XG4gICAgd2lkdGg6IDc2OCwgaGVpZ2h0OiA4OTYsXG4gICAgcGF0aDogXCJNMCA1MTJoMTI4di0xMjhoLTEyOHYxMjh6TTAgMjU2aDEyOHYtMTI4aC0xMjh2MTI4ek0wIDc2OGgxMjh2LTEyOGgtMTI4djEyOHpNMjU2IDUxMmg1MTJ2LTEyOGgtNTEydjEyOHpNMjU2IDI1Nmg1MTJ2LTEyOGgtNTEydjEyOHpNMjU2IDc2OGg1MTJ2LTEyOGgtNTEydjEyOHpcIlxuICB9LFxuICBvcmRlcmVkTGlzdDoge1xuICAgIHdpZHRoOiA3NjgsIGhlaWdodDogODk2LFxuICAgIHBhdGg6IFwiTTMyMCA1MTJoNDQ4di0xMjhoLTQ0OHYxMjh6TTMyMCA3NjhoNDQ4di0xMjhoLTQ0OHYxMjh6TTMyMCAxMjh2MTI4aDQ0OHYtMTI4aC00NDh6TTc5IDM4NGg3OHYtMjU2aC0zNmwtODUgMjN2NTBsNDMtMnYxODV6TTE4OSA1OTBjMC0zNi0xMi03OC05Ni03OC0zMyAwLTY0IDYtODMgMTZsMSA2NmMyMS0xMCA0Mi0xNSA2Ny0xNXMzMiAxMSAzMiAyOGMwIDI2LTMwIDU4LTExMCAxMTJ2NTBoMTkydi02N2wtOTEgMmM0OS0zMCA4Ny02NiA4Ny0xMTNsMS0xelwiXG4gIH0sXG4gIGJsb2NrcXVvdGU6IHtcbiAgICB3aWR0aDogNjQwLCBoZWlnaHQ6IDg5NixcbiAgICBwYXRoOiBcIk0wIDQ0OHYyNTZoMjU2di0yNTZoLTEyOGMwIDAgMC0xMjggMTI4LTEyOHYtMTI4YzAgMC0yNTYgMC0yNTYgMjU2ek02NDAgMzIwdi0xMjhjMCAwLTI1NiAwLTI1NiAyNTZ2MjU2aDI1NnYtMjU2aC0xMjhjMCAwIDAtMTI4IDEyOC0xMjh6XCJcbiAgfVxufTtcblxuLy8gOjogTWVudUl0ZW1cbi8vIE1lbnUgaXRlbSBmb3IgdGhlIGBqb2luVXBgIGNvbW1hbmQuXG52YXIgam9pblVwSXRlbSA9IG5ldyBNZW51SXRlbSh7XG4gIHRpdGxlOiBcIkpvaW4gd2l0aCBhYm92ZSBibG9ja1wiLFxuICBydW46IGpvaW5VcCxcbiAgc2VsZWN0OiBmdW5jdGlvbiAoc3RhdGUpIHsgcmV0dXJuIGpvaW5VcChzdGF0ZSk7IH0sXG4gIGljb246IGljb25zLmpvaW5cbn0pO1xuXG4vLyA6OiBNZW51SXRlbVxuLy8gTWVudSBpdGVtIGZvciB0aGUgYGxpZnRgIGNvbW1hbmQuXG52YXIgbGlmdEl0ZW0gPSBuZXcgTWVudUl0ZW0oe1xuICB0aXRsZTogXCJMaWZ0IG91dCBvZiBlbmNsb3NpbmcgYmxvY2tcIixcbiAgcnVuOiBsaWZ0LFxuICBzZWxlY3Q6IGZ1bmN0aW9uIChzdGF0ZSkgeyByZXR1cm4gbGlmdChzdGF0ZSk7IH0sXG4gIGljb246IGljb25zLmxpZnRcbn0pO1xuXG4vLyA6OiBNZW51SXRlbVxuLy8gTWVudSBpdGVtIGZvciB0aGUgYHNlbGVjdFBhcmVudE5vZGVgIGNvbW1hbmQuXG52YXIgc2VsZWN0UGFyZW50Tm9kZUl0ZW0gPSBuZXcgTWVudUl0ZW0oe1xuICB0aXRsZTogXCJTZWxlY3QgcGFyZW50IG5vZGVcIixcbiAgcnVuOiBzZWxlY3RQYXJlbnROb2RlLFxuICBzZWxlY3Q6IGZ1bmN0aW9uIChzdGF0ZSkgeyByZXR1cm4gc2VsZWN0UGFyZW50Tm9kZShzdGF0ZSk7IH0sXG4gIGljb246IGljb25zLnNlbGVjdFBhcmVudE5vZGVcbn0pO1xuXG4vLyA6OiBNZW51SXRlbVxuLy8gTWVudSBpdGVtIGZvciB0aGUgYHVuZG9gIGNvbW1hbmQuXG52YXIgdW5kb0l0ZW0gPSBuZXcgTWVudUl0ZW0oe1xuICB0aXRsZTogXCJVbmRvIGxhc3QgY2hhbmdlXCIsXG4gIHJ1bjogdW5kbyxcbiAgZW5hYmxlOiBmdW5jdGlvbiAoc3RhdGUpIHsgcmV0dXJuIHVuZG8oc3RhdGUpOyB9LFxuICBpY29uOiBpY29ucy51bmRvXG59KTtcblxuLy8gOjogTWVudUl0ZW1cbi8vIE1lbnUgaXRlbSBmb3IgdGhlIGByZWRvYCBjb21tYW5kLlxudmFyIHJlZG9JdGVtID0gbmV3IE1lbnVJdGVtKHtcbiAgdGl0bGU6IFwiUmVkbyBsYXN0IHVuZG9uZSBjaGFuZ2VcIixcbiAgcnVuOiByZWRvLFxuICBlbmFibGU6IGZ1bmN0aW9uIChzdGF0ZSkgeyByZXR1cm4gcmVkbyhzdGF0ZSk7IH0sXG4gIGljb246IGljb25zLnJlZG9cbn0pO1xuXG4vLyA6OiAoTm9kZVR5cGUsIE9iamVjdCkg4oaSIE1lbnVJdGVtXG4vLyBCdWlsZCBhIG1lbnUgaXRlbSBmb3Igd3JhcHBpbmcgdGhlIHNlbGVjdGlvbiBpbiBhIGdpdmVuIG5vZGUgdHlwZS5cbi8vIEFkZHMgYHJ1bmAgYW5kIGBzZWxlY3RgIHByb3BlcnRpZXMgdG8gdGhlIG9uZXMgcHJlc2VudCBpblxuLy8gYG9wdGlvbnNgLiBgb3B0aW9ucy5hdHRyc2AgbWF5IGJlIGFuIG9iamVjdCBvciBhIGZ1bmN0aW9uLlxuZnVuY3Rpb24gd3JhcEl0ZW0obm9kZVR5cGUsIG9wdGlvbnMpIHtcbiAgdmFyIHBhc3NlZE9wdGlvbnMgPSB7XG4gICAgcnVuOiBmdW5jdGlvbiBydW4oc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAvLyBGSVhNRSBpZiAob3B0aW9ucy5hdHRycyBpbnN0YW5jZW9mIEZ1bmN0aW9uKSBvcHRpb25zLmF0dHJzKHN0YXRlLCBhdHRycyA9PiB3cmFwSW4obm9kZVR5cGUsIGF0dHJzKShzdGF0ZSkpXG4gICAgICByZXR1cm4gd3JhcEluKG5vZGVUeXBlLCBvcHRpb25zLmF0dHJzKShzdGF0ZSwgZGlzcGF0Y2gpXG4gICAgfSxcbiAgICBzZWxlY3Q6IGZ1bmN0aW9uIHNlbGVjdChzdGF0ZSkge1xuICAgICAgcmV0dXJuIHdyYXBJbihub2RlVHlwZSwgb3B0aW9ucy5hdHRycyBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gbnVsbCA6IG9wdGlvbnMuYXR0cnMpKHN0YXRlKVxuICAgIH1cbiAgfTtcbiAgZm9yICh2YXIgcHJvcCBpbiBvcHRpb25zKSB7IHBhc3NlZE9wdGlvbnNbcHJvcF0gPSBvcHRpb25zW3Byb3BdOyB9XG4gIHJldHVybiBuZXcgTWVudUl0ZW0ocGFzc2VkT3B0aW9ucylcbn1cblxuLy8gOjogKE5vZGVUeXBlLCBPYmplY3QpIOKGkiBNZW51SXRlbVxuLy8gQnVpbGQgYSBtZW51IGl0ZW0gZm9yIGNoYW5naW5nIHRoZSB0eXBlIG9mIHRoZSB0ZXh0YmxvY2sgYXJvdW5kIHRoZVxuLy8gc2VsZWN0aW9uIHRvIHRoZSBnaXZlbiB0eXBlLiBQcm92aWRlcyBgcnVuYCwgYGFjdGl2ZWAsIGFuZCBgc2VsZWN0YFxuLy8gcHJvcGVydGllcy4gT3RoZXJzIG11c3QgYmUgZ2l2ZW4gaW4gYG9wdGlvbnNgLiBgb3B0aW9ucy5hdHRyc2AgbWF5XG4vLyBiZSBhbiBvYmplY3QgdG8gcHJvdmlkZSB0aGUgYXR0cmlidXRlcyBmb3IgdGhlIHRleHRibG9jayBub2RlLlxuZnVuY3Rpb24gYmxvY2tUeXBlSXRlbShub2RlVHlwZSwgb3B0aW9ucykge1xuICB2YXIgY29tbWFuZCA9IHNldEJsb2NrVHlwZShub2RlVHlwZSwgb3B0aW9ucy5hdHRycyk7XG4gIHZhciBwYXNzZWRPcHRpb25zID0ge1xuICAgIHJ1bjogY29tbWFuZCxcbiAgICBlbmFibGU6IGZ1bmN0aW9uIGVuYWJsZShzdGF0ZSkgeyByZXR1cm4gY29tbWFuZChzdGF0ZSkgfSxcbiAgICBhY3RpdmU6IGZ1bmN0aW9uIGFjdGl2ZShzdGF0ZSkge1xuICAgICAgdmFyIHJlZiA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgIHZhciAkZnJvbSA9IHJlZi4kZnJvbTtcbiAgICAgIHZhciB0byA9IHJlZi50bztcbiAgICAgIHZhciBub2RlID0gcmVmLm5vZGU7XG4gICAgICBpZiAobm9kZSkgeyByZXR1cm4gbm9kZS5oYXNNYXJrdXAobm9kZVR5cGUsIG9wdGlvbnMuYXR0cnMpIH1cbiAgICAgIHJldHVybiB0byA8PSAkZnJvbS5lbmQoKSAmJiAkZnJvbS5wYXJlbnQuaGFzTWFya3VwKG5vZGVUeXBlLCBvcHRpb25zLmF0dHJzKVxuICAgIH1cbiAgfTtcbiAgZm9yICh2YXIgcHJvcCBpbiBvcHRpb25zKSB7IHBhc3NlZE9wdGlvbnNbcHJvcF0gPSBvcHRpb25zW3Byb3BdOyB9XG4gIHJldHVybiBuZXcgTWVudUl0ZW0ocGFzc2VkT3B0aW9ucylcbn1cblxuLy8gV29yayBhcm91bmQgY2xhc3NMaXN0LnRvZ2dsZSBiZWluZyBicm9rZW4gaW4gSUUxMVxuZnVuY3Rpb24gc2V0Q2xhc3MoZG9tLCBjbHMsIG9uKSB7XG4gIGlmIChvbikgeyBkb20uY2xhc3NMaXN0LmFkZChjbHMpOyB9XG4gIGVsc2UgeyBkb20uY2xhc3NMaXN0LnJlbW92ZShjbHMpOyB9XG59XG5cbnZhciBwcmVmaXgkMiA9IFwiUHJvc2VNaXJyb3ItbWVudWJhclwiO1xuXG5mdW5jdGlvbiBpc0lPUygpIHtcbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT0gXCJ1bmRlZmluZWRcIikgeyByZXR1cm4gZmFsc2UgfVxuICB2YXIgYWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuICByZXR1cm4gIS9FZGdlXFwvXFxkLy50ZXN0KGFnZW50KSAmJiAvQXBwbGVXZWJLaXQvLnRlc3QoYWdlbnQpICYmIC9Nb2JpbGVcXC9cXHcrLy50ZXN0KGFnZW50KVxufVxuXG4vLyA6OiAoT2JqZWN0KSDihpIgUGx1Z2luXG4vLyBBIHBsdWdpbiB0aGF0IHdpbGwgcGxhY2UgYSBtZW51IGJhciBhYm92ZSB0aGUgZWRpdG9yLiBOb3RlIHRoYXRcbi8vIHRoaXMgaW52b2x2ZXMgd3JhcHBpbmcgdGhlIGVkaXRvciBpbiBhbiBhZGRpdGlvbmFsIGA8ZGl2PmAuXG4vL1xuLy8gICBvcHRpb25zOjotXG4vLyAgIFN1cHBvcnRzIHRoZSBmb2xsb3dpbmcgb3B0aW9uczpcbi8vXG4vLyAgICAgY29udGVudDo6IFtbTWVudUVsZW1lbnRdXVxuLy8gICAgIFByb3ZpZGVzIHRoZSBjb250ZW50IG9mIHRoZSBtZW51LCBhcyBhIG5lc3RlZCBhcnJheSB0byBiZVxuLy8gICAgIHBhc3NlZCB0byBgcmVuZGVyR3JvdXBlZGAuXG4vL1xuLy8gICAgIGZsb2F0aW5nOjogP2Jvb2xcbi8vICAgICBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG1lbnUgZmxvYXRzLCBpLmUuIHdoZXRoZXIgaXQgc3RpY2tzIHRvXG4vLyAgICAgdGhlIHRvcCBvZiB0aGUgdmlld3BvcnQgd2hlbiB0aGUgZWRpdG9yIGlzIHBhcnRpYWxseSBzY3JvbGxlZFxuLy8gICAgIG91dCBvZiB2aWV3LlxuZnVuY3Rpb24gbWVudUJhcihvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgUGx1Z2luKHtcbiAgICB2aWV3OiBmdW5jdGlvbiB2aWV3KGVkaXRvclZpZXcpIHsgcmV0dXJuIG5ldyBNZW51QmFyVmlldyhlZGl0b3JWaWV3LCBvcHRpb25zKSB9XG4gIH0pXG59XG5cbnZhciBNZW51QmFyVmlldyA9IGZ1bmN0aW9uIE1lbnVCYXJWaWV3KGVkaXRvclZpZXcsIG9wdGlvbnMpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdGhpcy5lZGl0b3JWaWV3ID0gZWRpdG9yVmlldztcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcblxuICB0aGlzLndyYXBwZXIgPSBjcmVsKFwiZGl2XCIsIHtjbGFzczogcHJlZml4JDIgKyBcIi13cmFwcGVyXCJ9KTtcbiAgdGhpcy5tZW51ID0gdGhpcy53cmFwcGVyLmFwcGVuZENoaWxkKGNyZWwoXCJkaXZcIiwge2NsYXNzOiBwcmVmaXgkMn0pKTtcbiAgdGhpcy5tZW51LmNsYXNzTmFtZSA9IHByZWZpeCQyO1xuICB0aGlzLnNwYWNlciA9IG51bGw7XG5cbiAgZWRpdG9yVmlldy5kb20ucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQodGhpcy53cmFwcGVyLCBlZGl0b3JWaWV3LmRvbSk7XG4gIHRoaXMud3JhcHBlci5hcHBlbmRDaGlsZChlZGl0b3JWaWV3LmRvbSk7XG5cbiAgdGhpcy5tYXhIZWlnaHQgPSAwO1xuICB0aGlzLndpZHRoRm9yTWF4SGVpZ2h0ID0gMDtcbiAgdGhpcy5mbG9hdGluZyA9IGZhbHNlO1xuXG4gIHZhciByZWYgPSByZW5kZXJHcm91cGVkKHRoaXMuZWRpdG9yVmlldywgdGhpcy5vcHRpb25zLmNvbnRlbnQpO1xuICB2YXIgZG9tID0gcmVmLmRvbTtcbiAgdmFyIHVwZGF0ZSA9IHJlZi51cGRhdGU7XG4gIHRoaXMuY29udGVudFVwZGF0ZSA9IHVwZGF0ZTtcbiAgdGhpcy5tZW51LmFwcGVuZENoaWxkKGRvbSk7XG4gIHRoaXMudXBkYXRlKCk7XG5cbiAgaWYgKG9wdGlvbnMuZmxvYXRpbmcgJiYgIWlzSU9TKCkpIHtcbiAgICB0aGlzLnVwZGF0ZUZsb2F0KCk7XG4gICAgdmFyIHBvdGVudGlhbFNjcm9sbGVycyA9IGdldEFsbFdyYXBwaW5nKHRoaXMud3JhcHBlcik7XG4gICAgdGhpcy5zY3JvbGxGdW5jID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciByb290ID0gdGhpcyQxLmVkaXRvclZpZXcucm9vdDtcbiAgICAgIGlmICghKHJvb3QuYm9keSB8fCByb290KS5jb250YWlucyh0aGlzJDEud3JhcHBlcikpIHtcbiAgICAgICAgICBwb3RlbnRpYWxTY3JvbGxlcnMuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcyQxLnNjcm9sbEZ1bmMpOyB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcyQxLnVwZGF0ZUZsb2F0KGUudGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCAmJiBlLnRhcmdldCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBwb3RlbnRpYWxTY3JvbGxlcnMuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMkMS5zY3JvbGxGdW5jKTsgfSk7XG4gIH1cbn07XG5cbk1lbnVCYXJWaWV3LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKCkge1xuICB0aGlzLmNvbnRlbnRVcGRhdGUodGhpcy5lZGl0b3JWaWV3LnN0YXRlKTtcblxuICBpZiAodGhpcy5mbG9hdGluZykge1xuICAgIHRoaXMudXBkYXRlU2Nyb2xsQ3Vyc29yKCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRoaXMubWVudS5vZmZzZXRXaWR0aCAhPSB0aGlzLndpZHRoRm9yTWF4SGVpZ2h0KSB7XG4gICAgICB0aGlzLndpZHRoRm9yTWF4SGVpZ2h0ID0gdGhpcy5tZW51Lm9mZnNldFdpZHRoO1xuICAgICAgdGhpcy5tYXhIZWlnaHQgPSAwO1xuICAgIH1cbiAgICBpZiAodGhpcy5tZW51Lm9mZnNldEhlaWdodCA+IHRoaXMubWF4SGVpZ2h0KSB7XG4gICAgICB0aGlzLm1heEhlaWdodCA9IHRoaXMubWVudS5vZmZzZXRIZWlnaHQ7XG4gICAgICB0aGlzLm1lbnUuc3R5bGUubWluSGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQgKyBcInB4XCI7XG4gICAgfVxuICB9XG59O1xuXG5NZW51QmFyVmlldy5wcm90b3R5cGUudXBkYXRlU2Nyb2xsQ3Vyc29yID0gZnVuY3Rpb24gdXBkYXRlU2Nyb2xsQ3Vyc29yICgpIHtcbiAgdmFyIHNlbGVjdGlvbiA9IHRoaXMuZWRpdG9yVmlldy5yb290LmdldFNlbGVjdGlvbigpO1xuICBpZiAoIXNlbGVjdGlvbi5mb2N1c05vZGUpIHsgcmV0dXJuIH1cbiAgdmFyIHJlY3RzID0gc2VsZWN0aW9uLmdldFJhbmdlQXQoMCkuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgdmFyIHNlbFJlY3QgPSByZWN0c1tzZWxlY3Rpb25Jc0ludmVydGVkKHNlbGVjdGlvbikgPyAwIDogcmVjdHMubGVuZ3RoIC0gMV07XG4gIGlmICghc2VsUmVjdCkgeyByZXR1cm4gfVxuICB2YXIgbWVudVJlY3QgPSB0aGlzLm1lbnUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGlmIChzZWxSZWN0LnRvcCA8IG1lbnVSZWN0LmJvdHRvbSAmJiBzZWxSZWN0LmJvdHRvbSA+IG1lbnVSZWN0LnRvcCkge1xuICAgIHZhciBzY3JvbGxhYmxlID0gZmluZFdyYXBwaW5nU2Nyb2xsYWJsZSh0aGlzLndyYXBwZXIpO1xuICAgIGlmIChzY3JvbGxhYmxlKSB7IHNjcm9sbGFibGUuc2Nyb2xsVG9wIC09IChtZW51UmVjdC5ib3R0b20gLSBzZWxSZWN0LnRvcCk7IH1cbiAgfVxufTtcblxuTWVudUJhclZpZXcucHJvdG90eXBlLnVwZGF0ZUZsb2F0ID0gZnVuY3Rpb24gdXBkYXRlRmxvYXQgKHNjcm9sbEFuY2VzdG9yKSB7XG4gIHZhciBwYXJlbnQgPSB0aGlzLndyYXBwZXIsIGVkaXRvclJlY3QgPSBwYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICB0b3AgPSBzY3JvbGxBbmNlc3RvciA/IE1hdGgubWF4KDAsIHNjcm9sbEFuY2VzdG9yLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCkgOiAwO1xuXG4gIGlmICh0aGlzLmZsb2F0aW5nKSB7XG4gICAgaWYgKGVkaXRvclJlY3QudG9wID49IHRvcCB8fCBlZGl0b3JSZWN0LmJvdHRvbSA8IHRoaXMubWVudS5vZmZzZXRIZWlnaHQgKyAxMCkge1xuICAgICAgdGhpcy5mbG9hdGluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5tZW51LnN0eWxlLnBvc2l0aW9uID0gdGhpcy5tZW51LnN0eWxlLmxlZnQgPSB0aGlzLm1lbnUuc3R5bGUudG9wID0gdGhpcy5tZW51LnN0eWxlLndpZHRoID0gXCJcIjtcbiAgICAgIHRoaXMubWVudS5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcbiAgICAgIHRoaXMuc3BhY2VyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zcGFjZXIpO1xuICAgICAgdGhpcy5zcGFjZXIgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYm9yZGVyID0gKHBhcmVudC5vZmZzZXRXaWR0aCAtIHBhcmVudC5jbGllbnRXaWR0aCkgLyAyO1xuICAgICAgdGhpcy5tZW51LnN0eWxlLmxlZnQgPSAoZWRpdG9yUmVjdC5sZWZ0ICsgYm9yZGVyKSArIFwicHhcIjtcbiAgICAgIHRoaXMubWVudS5zdHlsZS5kaXNwbGF5ID0gKGVkaXRvclJlY3QudG9wID4gd2luZG93LmlubmVySGVpZ2h0ID8gXCJub25lXCIgOiBcIlwiKTtcbiAgICAgIGlmIChzY3JvbGxBbmNlc3RvcikgeyB0aGlzLm1lbnUuc3R5bGUudG9wID0gdG9wICsgXCJweFwiOyB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChlZGl0b3JSZWN0LnRvcCA8IHRvcCAmJiBlZGl0b3JSZWN0LmJvdHRvbSA+PSB0aGlzLm1lbnUub2Zmc2V0SGVpZ2h0ICsgMTApIHtcbiAgICAgIHRoaXMuZmxvYXRpbmcgPSB0cnVlO1xuICAgICAgdmFyIG1lbnVSZWN0ID0gdGhpcy5tZW51LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdGhpcy5tZW51LnN0eWxlLmxlZnQgPSBtZW51UmVjdC5sZWZ0ICsgXCJweFwiO1xuICAgICAgdGhpcy5tZW51LnN0eWxlLndpZHRoID0gbWVudVJlY3Qud2lkdGggKyBcInB4XCI7XG4gICAgICBpZiAoc2Nyb2xsQW5jZXN0b3IpIHsgdGhpcy5tZW51LnN0eWxlLnRvcCA9IHRvcCArIFwicHhcIjsgfVxuICAgICAgdGhpcy5tZW51LnN0eWxlLnBvc2l0aW9uID0gXCJmaXhlZFwiO1xuICAgICAgdGhpcy5zcGFjZXIgPSBjcmVsKFwiZGl2XCIsIHtjbGFzczogcHJlZml4JDIgKyBcIi1zcGFjZXJcIiwgc3R5bGU6IChcImhlaWdodDogXCIgKyAobWVudVJlY3QuaGVpZ2h0KSArIFwicHhcIil9KTtcbiAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUodGhpcy5zcGFjZXIsIHRoaXMubWVudSk7XG4gICAgfVxuICB9XG59O1xuXG5NZW51QmFyVmlldy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3kgKCkge1xuICBpZiAodGhpcy53cmFwcGVyLnBhcmVudE5vZGUpXG4gICAgeyB0aGlzLndyYXBwZXIucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQodGhpcy5lZGl0b3JWaWV3LmRvbSwgdGhpcy53cmFwcGVyKTsgfVxufTtcblxuLy8gTm90IHByZWNpc2UsIGJ1dCBjbG9zZSBlbm91Z2hcbmZ1bmN0aW9uIHNlbGVjdGlvbklzSW52ZXJ0ZWQoc2VsZWN0aW9uKSB7XG4gIGlmIChzZWxlY3Rpb24uYW5jaG9yTm9kZSA9PSBzZWxlY3Rpb24uZm9jdXNOb2RlKSB7IHJldHVybiBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0ID4gc2VsZWN0aW9uLmZvY3VzT2Zmc2V0IH1cbiAgcmV0dXJuIHNlbGVjdGlvbi5hbmNob3JOb2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKHNlbGVjdGlvbi5mb2N1c05vZGUpID09IE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fRk9MTE9XSU5HXG59XG5cbmZ1bmN0aW9uIGZpbmRXcmFwcGluZ1Njcm9sbGFibGUobm9kZSkge1xuICBmb3IgKHZhciBjdXIgPSBub2RlLnBhcmVudE5vZGU7IGN1cjsgY3VyID0gY3VyLnBhcmVudE5vZGUpXG4gICAgeyBpZiAoY3VyLnNjcm9sbEhlaWdodCA+IGN1ci5jbGllbnRIZWlnaHQpIHsgcmV0dXJuIGN1ciB9IH1cbn1cblxuZnVuY3Rpb24gZ2V0QWxsV3JhcHBpbmcobm9kZSkge1xuICAgIHZhciByZXMgPSBbd2luZG93XTtcbiAgICBmb3IgKHZhciBjdXIgPSBub2RlLnBhcmVudE5vZGU7IGN1cjsgY3VyID0gY3VyLnBhcmVudE5vZGUpXG4gICAgICAgIHsgcmVzLnB1c2goY3VyKTsgfVxuICAgIHJldHVybiByZXNcbn1cblxuZXhwb3J0IHsgRHJvcGRvd24sIERyb3Bkb3duU3VibWVudSwgTWVudUl0ZW0sIGJsb2NrVHlwZUl0ZW0sIGljb25zLCBqb2luVXBJdGVtLCBsaWZ0SXRlbSwgbWVudUJhciwgcmVkb0l0ZW0sIHJlbmRlckdyb3VwZWQsIHNlbGVjdFBhcmVudE5vZGVJdGVtLCB1bmRvSXRlbSwgd3JhcEl0ZW0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzLmpzLm1hcFxuIiwiaW1wb3J0IE9yZGVyZWRNYXAgZnJvbSAnb3JkZXJlZG1hcCc7XG5cbmZ1bmN0aW9uIGZpbmREaWZmU3RhcnQoYSwgYiwgcG9zKSB7XG4gIGZvciAodmFyIGkgPSAwOzsgaSsrKSB7XG4gICAgaWYgKGkgPT0gYS5jaGlsZENvdW50IHx8IGkgPT0gYi5jaGlsZENvdW50KVxuICAgICAgeyByZXR1cm4gYS5jaGlsZENvdW50ID09IGIuY2hpbGRDb3VudCA/IG51bGwgOiBwb3MgfVxuXG4gICAgdmFyIGNoaWxkQSA9IGEuY2hpbGQoaSksIGNoaWxkQiA9IGIuY2hpbGQoaSk7XG4gICAgaWYgKGNoaWxkQSA9PSBjaGlsZEIpIHsgcG9zICs9IGNoaWxkQS5ub2RlU2l6ZTsgY29udGludWUgfVxuXG4gICAgaWYgKCFjaGlsZEEuc2FtZU1hcmt1cChjaGlsZEIpKSB7IHJldHVybiBwb3MgfVxuXG4gICAgaWYgKGNoaWxkQS5pc1RleHQgJiYgY2hpbGRBLnRleHQgIT0gY2hpbGRCLnRleHQpIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBjaGlsZEEudGV4dFtqXSA9PSBjaGlsZEIudGV4dFtqXTsgaisrKVxuICAgICAgICB7IHBvcysrOyB9XG4gICAgICByZXR1cm4gcG9zXG4gICAgfVxuICAgIGlmIChjaGlsZEEuY29udGVudC5zaXplIHx8IGNoaWxkQi5jb250ZW50LnNpemUpIHtcbiAgICAgIHZhciBpbm5lciA9IGZpbmREaWZmU3RhcnQoY2hpbGRBLmNvbnRlbnQsIGNoaWxkQi5jb250ZW50LCBwb3MgKyAxKTtcbiAgICAgIGlmIChpbm5lciAhPSBudWxsKSB7IHJldHVybiBpbm5lciB9XG4gICAgfVxuICAgIHBvcyArPSBjaGlsZEEubm9kZVNpemU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZERpZmZFbmQoYSwgYiwgcG9zQSwgcG9zQikge1xuICBmb3IgKHZhciBpQSA9IGEuY2hpbGRDb3VudCwgaUIgPSBiLmNoaWxkQ291bnQ7Oykge1xuICAgIGlmIChpQSA9PSAwIHx8IGlCID09IDApXG4gICAgICB7IHJldHVybiBpQSA9PSBpQiA/IG51bGwgOiB7YTogcG9zQSwgYjogcG9zQn0gfVxuXG4gICAgdmFyIGNoaWxkQSA9IGEuY2hpbGQoLS1pQSksIGNoaWxkQiA9IGIuY2hpbGQoLS1pQiksIHNpemUgPSBjaGlsZEEubm9kZVNpemU7XG4gICAgaWYgKGNoaWxkQSA9PSBjaGlsZEIpIHtcbiAgICAgIHBvc0EgLT0gc2l6ZTsgcG9zQiAtPSBzaXplO1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBpZiAoIWNoaWxkQS5zYW1lTWFya3VwKGNoaWxkQikpIHsgcmV0dXJuIHthOiBwb3NBLCBiOiBwb3NCfSB9XG5cbiAgICBpZiAoY2hpbGRBLmlzVGV4dCAmJiBjaGlsZEEudGV4dCAhPSBjaGlsZEIudGV4dCkge1xuICAgICAgdmFyIHNhbWUgPSAwLCBtaW5TaXplID0gTWF0aC5taW4oY2hpbGRBLnRleHQubGVuZ3RoLCBjaGlsZEIudGV4dC5sZW5ndGgpO1xuICAgICAgd2hpbGUgKHNhbWUgPCBtaW5TaXplICYmIGNoaWxkQS50ZXh0W2NoaWxkQS50ZXh0Lmxlbmd0aCAtIHNhbWUgLSAxXSA9PSBjaGlsZEIudGV4dFtjaGlsZEIudGV4dC5sZW5ndGggLSBzYW1lIC0gMV0pIHtcbiAgICAgICAgc2FtZSsrOyBwb3NBLS07IHBvc0ItLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7YTogcG9zQSwgYjogcG9zQn1cbiAgICB9XG4gICAgaWYgKGNoaWxkQS5jb250ZW50LnNpemUgfHwgY2hpbGRCLmNvbnRlbnQuc2l6ZSkge1xuICAgICAgdmFyIGlubmVyID0gZmluZERpZmZFbmQoY2hpbGRBLmNvbnRlbnQsIGNoaWxkQi5jb250ZW50LCBwb3NBIC0gMSwgcG9zQiAtIDEpO1xuICAgICAgaWYgKGlubmVyKSB7IHJldHVybiBpbm5lciB9XG4gICAgfVxuICAgIHBvc0EgLT0gc2l6ZTsgcG9zQiAtPSBzaXplO1xuICB9XG59XG5cbi8vIDo6LSBBIGZyYWdtZW50IHJlcHJlc2VudHMgYSBub2RlJ3MgY29sbGVjdGlvbiBvZiBjaGlsZCBub2Rlcy5cbi8vXG4vLyBMaWtlIG5vZGVzLCBmcmFnbWVudHMgYXJlIHBlcnNpc3RlbnQgZGF0YSBzdHJ1Y3R1cmVzLCBhbmQgeW91XG4vLyBzaG91bGQgbm90IG11dGF0ZSB0aGVtIG9yIHRoZWlyIGNvbnRlbnQuIFJhdGhlciwgeW91IGNyZWF0ZSBuZXdcbi8vIGluc3RhbmNlcyB3aGVuZXZlciBuZWVkZWQuIFRoZSBBUEkgdHJpZXMgdG8gbWFrZSB0aGlzIGVhc3kuXG52YXIgRnJhZ21lbnQgPSBmdW5jdGlvbiBGcmFnbWVudChjb250ZW50LCBzaXplKSB7XG4gIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gIC8vIDo6IG51bWJlclxuICAvLyBUaGUgc2l6ZSBvZiB0aGUgZnJhZ21lbnQsIHdoaWNoIGlzIHRoZSB0b3RhbCBvZiB0aGUgc2l6ZSBvZiBpdHNcbiAgLy8gY29udGVudCBub2Rlcy5cbiAgdGhpcy5zaXplID0gc2l6ZSB8fCAwO1xuICBpZiAoc2l6ZSA9PSBudWxsKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgY29udGVudC5sZW5ndGg7IGkrKylcbiAgICB7IHRoaXMuc2l6ZSArPSBjb250ZW50W2ldLm5vZGVTaXplOyB9IH1cbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMgPSB7IGZpcnN0Q2hpbGQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sbGFzdENoaWxkOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGNoaWxkQ291bnQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxuLy8gOjogKG51bWJlciwgbnVtYmVyLCAobm9kZTogTm9kZSwgc3RhcnQ6IG51bWJlciwgcGFyZW50OiBOb2RlLCBpbmRleDogbnVtYmVyKSDihpIgP2Jvb2wsID9udW1iZXIpXG4vLyBJbnZva2UgYSBjYWxsYmFjayBmb3IgYWxsIGRlc2NlbmRhbnQgbm9kZXMgYmV0d2VlbiB0aGUgZ2l2ZW4gdHdvXG4vLyBwb3NpdGlvbnMgKHJlbGF0aXZlIHRvIHN0YXJ0IG9mIHRoaXMgZnJhZ21lbnQpLiBEb2Vzbid0IGRlc2NlbmRcbi8vIGludG8gYSBub2RlIHdoZW4gdGhlIGNhbGxiYWNrIHJldHVybnMgYGZhbHNlYC5cbkZyYWdtZW50LnByb3RvdHlwZS5ub2Rlc0JldHdlZW4gPSBmdW5jdGlvbiBub2Rlc0JldHdlZW4gKGZyb20sIHRvLCBmLCBub2RlU3RhcnQsIHBhcmVudCkge1xuICAgIGlmICggbm9kZVN0YXJ0ID09PSB2b2lkIDAgKSBub2RlU3RhcnQgPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwLCBwb3MgPSAwOyBwb3MgPCB0bzsgaSsrKSB7XG4gICAgdmFyIGNoaWxkID0gdGhpcy5jb250ZW50W2ldLCBlbmQgPSBwb3MgKyBjaGlsZC5ub2RlU2l6ZTtcbiAgICBpZiAoZW5kID4gZnJvbSAmJiBmKGNoaWxkLCBub2RlU3RhcnQgKyBwb3MsIHBhcmVudCwgaSkgIT09IGZhbHNlICYmIGNoaWxkLmNvbnRlbnQuc2l6ZSkge1xuICAgICAgdmFyIHN0YXJ0ID0gcG9zICsgMTtcbiAgICAgIGNoaWxkLm5vZGVzQmV0d2VlbihNYXRoLm1heCgwLCBmcm9tIC0gc3RhcnQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWluKGNoaWxkLmNvbnRlbnQuc2l6ZSwgdG8gLSBzdGFydCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgZiwgbm9kZVN0YXJ0ICsgc3RhcnQpO1xuICAgIH1cbiAgICBwb3MgPSBlbmQ7XG4gIH1cbn07XG5cbi8vIDo6ICgobm9kZTogTm9kZSwgcG9zOiBudW1iZXIsIHBhcmVudDogTm9kZSkg4oaSID9ib29sKVxuLy8gQ2FsbCB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGV2ZXJ5IGRlc2NlbmRhbnQgbm9kZS4gVGhlIGNhbGxiYWNrXG4vLyBtYXkgcmV0dXJuIGBmYWxzZWAgdG8gcHJldmVudCB0cmF2ZXJzYWwgb2YgYSBnaXZlbiBub2RlJ3MgY2hpbGRyZW4uXG5GcmFnbWVudC5wcm90b3R5cGUuZGVzY2VuZGFudHMgPSBmdW5jdGlvbiBkZXNjZW5kYW50cyAoZikge1xuICB0aGlzLm5vZGVzQmV0d2VlbigwLCB0aGlzLnNpemUsIGYpO1xufTtcblxuLy8gOjogKG51bWJlciwgbnVtYmVyLCA/c3RyaW5nLCA/c3RyaW5nIHwgPyhsZWFmTm9kZTogTm9kZSkgLT4gc3RyaW5nKSDihpIgc3RyaW5nXG4vLyBFeHRyYWN0IHRoZSB0ZXh0IGJldHdlZW4gYGZyb21gIGFuZCBgdG9gLiBTZWUgdGhlIHNhbWUgbWV0aG9kIG9uXG4vLyBbYE5vZGVgXSgjbW9kZWwuTm9kZS50ZXh0QmV0d2VlbikuXG5GcmFnbWVudC5wcm90b3R5cGUudGV4dEJldHdlZW4gPSBmdW5jdGlvbiB0ZXh0QmV0d2VlbiAoZnJvbSwgdG8sIGJsb2NrU2VwYXJhdG9yLCBsZWFmVGV4dCkge1xuICB2YXIgdGV4dCA9IFwiXCIsIHNlcGFyYXRlZCA9IHRydWU7XG4gIHRoaXMubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCBmdW5jdGlvbiAobm9kZSwgcG9zKSB7XG4gICAgaWYgKG5vZGUuaXNUZXh0KSB7XG4gICAgICB0ZXh0ICs9IG5vZGUudGV4dC5zbGljZShNYXRoLm1heChmcm9tLCBwb3MpIC0gcG9zLCB0byAtIHBvcyk7XG4gICAgICBzZXBhcmF0ZWQgPSAhYmxvY2tTZXBhcmF0b3I7XG4gICAgfSBlbHNlIGlmIChub2RlLmlzTGVhZiAmJiBsZWFmVGV4dCkge1xuICAgICAgdGV4dCArPSB0eXBlb2YgbGVhZlRleHQgPT09ICdmdW5jdGlvbicgPyBsZWFmVGV4dChub2RlKTogbGVhZlRleHQ7XG4gICAgICBzZXBhcmF0ZWQgPSAhYmxvY2tTZXBhcmF0b3I7XG4gICAgfSBlbHNlIGlmICghc2VwYXJhdGVkICYmIG5vZGUuaXNCbG9jaykge1xuICAgICAgdGV4dCArPSBibG9ja1NlcGFyYXRvcjtcbiAgICAgIHNlcGFyYXRlZCA9IHRydWU7XG4gICAgfVxuICB9LCAwKTtcbiAgcmV0dXJuIHRleHRcbn07XG5cbi8vIDo6IChGcmFnbWVudCkg4oaSIEZyYWdtZW50XG4vLyBDcmVhdGUgYSBuZXcgZnJhZ21lbnQgY29udGFpbmluZyB0aGUgY29tYmluZWQgY29udGVudCBvZiB0aGlzXG4vLyBmcmFnbWVudCBhbmQgdGhlIG90aGVyLlxuRnJhZ21lbnQucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIGFwcGVuZCAob3RoZXIpIHtcbiAgaWYgKCFvdGhlci5zaXplKSB7IHJldHVybiB0aGlzIH1cbiAgaWYgKCF0aGlzLnNpemUpIHsgcmV0dXJuIG90aGVyIH1cbiAgdmFyIGxhc3QgPSB0aGlzLmxhc3RDaGlsZCwgZmlyc3QgPSBvdGhlci5maXJzdENoaWxkLCBjb250ZW50ID0gdGhpcy5jb250ZW50LnNsaWNlKCksIGkgPSAwO1xuICBpZiAobGFzdC5pc1RleHQgJiYgbGFzdC5zYW1lTWFya3VwKGZpcnN0KSkge1xuICAgIGNvbnRlbnRbY29udGVudC5sZW5ndGggLSAxXSA9IGxhc3Qud2l0aFRleHQobGFzdC50ZXh0ICsgZmlyc3QudGV4dCk7XG4gICAgaSA9IDE7XG4gIH1cbiAgZm9yICg7IGkgPCBvdGhlci5jb250ZW50Lmxlbmd0aDsgaSsrKSB7IGNvbnRlbnQucHVzaChvdGhlci5jb250ZW50W2ldKTsgfVxuICByZXR1cm4gbmV3IEZyYWdtZW50KGNvbnRlbnQsIHRoaXMuc2l6ZSArIG90aGVyLnNpemUpXG59O1xuXG4vLyA6OiAobnVtYmVyLCA/bnVtYmVyKSDihpIgRnJhZ21lbnRcbi8vIEN1dCBvdXQgdGhlIHN1Yi1mcmFnbWVudCBiZXR3ZWVuIHRoZSB0d28gZ2l2ZW4gcG9zaXRpb25zLlxuRnJhZ21lbnQucHJvdG90eXBlLmN1dCA9IGZ1bmN0aW9uIGN1dCAoZnJvbSwgdG8pIHtcbiAgaWYgKHRvID09IG51bGwpIHsgdG8gPSB0aGlzLnNpemU7IH1cbiAgaWYgKGZyb20gPT0gMCAmJiB0byA9PSB0aGlzLnNpemUpIHsgcmV0dXJuIHRoaXMgfVxuICB2YXIgcmVzdWx0ID0gW10sIHNpemUgPSAwO1xuICBpZiAodG8gPiBmcm9tKSB7IGZvciAodmFyIGkgPSAwLCBwb3MgPSAwOyBwb3MgPCB0bzsgaSsrKSB7XG4gICAgdmFyIGNoaWxkID0gdGhpcy5jb250ZW50W2ldLCBlbmQgPSBwb3MgKyBjaGlsZC5ub2RlU2l6ZTtcbiAgICBpZiAoZW5kID4gZnJvbSkge1xuICAgICAgaWYgKHBvcyA8IGZyb20gfHwgZW5kID4gdG8pIHtcbiAgICAgICAgaWYgKGNoaWxkLmlzVGV4dClcbiAgICAgICAgICB7IGNoaWxkID0gY2hpbGQuY3V0KE1hdGgubWF4KDAsIGZyb20gLSBwb3MpLCBNYXRoLm1pbihjaGlsZC50ZXh0Lmxlbmd0aCwgdG8gLSBwb3MpKTsgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgeyBjaGlsZCA9IGNoaWxkLmN1dChNYXRoLm1heCgwLCBmcm9tIC0gcG9zIC0gMSksIE1hdGgubWluKGNoaWxkLmNvbnRlbnQuc2l6ZSwgdG8gLSBwb3MgLSAxKSk7IH1cbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKGNoaWxkKTtcbiAgICAgIHNpemUgKz0gY2hpbGQubm9kZVNpemU7XG4gICAgfVxuICAgIHBvcyA9IGVuZDtcbiAgfSB9XG4gIHJldHVybiBuZXcgRnJhZ21lbnQocmVzdWx0LCBzaXplKVxufTtcblxuRnJhZ21lbnQucHJvdG90eXBlLmN1dEJ5SW5kZXggPSBmdW5jdGlvbiBjdXRCeUluZGV4IChmcm9tLCB0bykge1xuICBpZiAoZnJvbSA9PSB0bykgeyByZXR1cm4gRnJhZ21lbnQuZW1wdHkgfVxuICBpZiAoZnJvbSA9PSAwICYmIHRvID09IHRoaXMuY29udGVudC5sZW5ndGgpIHsgcmV0dXJuIHRoaXMgfVxuICByZXR1cm4gbmV3IEZyYWdtZW50KHRoaXMuY29udGVudC5zbGljZShmcm9tLCB0bykpXG59O1xuXG4vLyA6OiAobnVtYmVyLCBOb2RlKSDihpIgRnJhZ21lbnRcbi8vIENyZWF0ZSBhIG5ldyBmcmFnbWVudCBpbiB3aGljaCB0aGUgbm9kZSBhdCB0aGUgZ2l2ZW4gaW5kZXggaXNcbi8vIHJlcGxhY2VkIGJ5IHRoZSBnaXZlbiBub2RlLlxuRnJhZ21lbnQucHJvdG90eXBlLnJlcGxhY2VDaGlsZCA9IGZ1bmN0aW9uIHJlcGxhY2VDaGlsZCAoaW5kZXgsIG5vZGUpIHtcbiAgdmFyIGN1cnJlbnQgPSB0aGlzLmNvbnRlbnRbaW5kZXhdO1xuICBpZiAoY3VycmVudCA9PSBub2RlKSB7IHJldHVybiB0aGlzIH1cbiAgdmFyIGNvcHkgPSB0aGlzLmNvbnRlbnQuc2xpY2UoKTtcbiAgdmFyIHNpemUgPSB0aGlzLnNpemUgKyBub2RlLm5vZGVTaXplIC0gY3VycmVudC5ub2RlU2l6ZTtcbiAgY29weVtpbmRleF0gPSBub2RlO1xuICByZXR1cm4gbmV3IEZyYWdtZW50KGNvcHksIHNpemUpXG59O1xuXG4vLyA6IChOb2RlKSDihpIgRnJhZ21lbnRcbi8vIENyZWF0ZSBhIG5ldyBmcmFnbWVudCBieSBwcmVwZW5kaW5nIHRoZSBnaXZlbiBub2RlIHRvIHRoaXNcbi8vIGZyYWdtZW50LlxuRnJhZ21lbnQucHJvdG90eXBlLmFkZFRvU3RhcnQgPSBmdW5jdGlvbiBhZGRUb1N0YXJ0IChub2RlKSB7XG4gIHJldHVybiBuZXcgRnJhZ21lbnQoW25vZGVdLmNvbmNhdCh0aGlzLmNvbnRlbnQpLCB0aGlzLnNpemUgKyBub2RlLm5vZGVTaXplKVxufTtcblxuLy8gOiAoTm9kZSkg4oaSIEZyYWdtZW50XG4vLyBDcmVhdGUgYSBuZXcgZnJhZ21lbnQgYnkgYXBwZW5kaW5nIHRoZSBnaXZlbiBub2RlIHRvIHRoaXNcbi8vIGZyYWdtZW50LlxuRnJhZ21lbnQucHJvdG90eXBlLmFkZFRvRW5kID0gZnVuY3Rpb24gYWRkVG9FbmQgKG5vZGUpIHtcbiAgcmV0dXJuIG5ldyBGcmFnbWVudCh0aGlzLmNvbnRlbnQuY29uY2F0KG5vZGUpLCB0aGlzLnNpemUgKyBub2RlLm5vZGVTaXplKVxufTtcblxuLy8gOjogKEZyYWdtZW50KSDihpIgYm9vbFxuLy8gQ29tcGFyZSB0aGlzIGZyYWdtZW50IHRvIGFub3RoZXIgb25lLlxuRnJhZ21lbnQucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gZXEgKG90aGVyKSB7XG4gIGlmICh0aGlzLmNvbnRlbnQubGVuZ3RoICE9IG90aGVyLmNvbnRlbnQubGVuZ3RoKSB7IHJldHVybiBmYWxzZSB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb250ZW50Lmxlbmd0aDsgaSsrKVxuICAgIHsgaWYgKCF0aGlzLmNvbnRlbnRbaV0uZXEob3RoZXIuY29udGVudFtpXSkpIHsgcmV0dXJuIGZhbHNlIH0gfVxuICByZXR1cm4gdHJ1ZVxufTtcblxuLy8gOjogP05vZGVcbi8vIFRoZSBmaXJzdCBjaGlsZCBvZiB0aGUgZnJhZ21lbnQsIG9yIGBudWxsYCBpZiBpdCBpcyBlbXB0eS5cbnByb3RvdHlwZUFjY2Vzc29ycy5maXJzdENoaWxkLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuY29udGVudC5sZW5ndGggPyB0aGlzLmNvbnRlbnRbMF0gOiBudWxsIH07XG5cbi8vIDo6ID9Ob2RlXG4vLyBUaGUgbGFzdCBjaGlsZCBvZiB0aGUgZnJhZ21lbnQsIG9yIGBudWxsYCBpZiBpdCBpcyBlbXB0eS5cbnByb3RvdHlwZUFjY2Vzc29ycy5sYXN0Q2hpbGQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5jb250ZW50Lmxlbmd0aCA/IHRoaXMuY29udGVudFt0aGlzLmNvbnRlbnQubGVuZ3RoIC0gMV0gOiBudWxsIH07XG5cbi8vIDo6IG51bWJlclxuLy8gVGhlIG51bWJlciBvZiBjaGlsZCBub2RlcyBpbiB0aGlzIGZyYWdtZW50LlxucHJvdG90eXBlQWNjZXNzb3JzLmNoaWxkQ291bnQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5jb250ZW50Lmxlbmd0aCB9O1xuXG4vLyA6OiAobnVtYmVyKSDihpIgTm9kZVxuLy8gR2V0IHRoZSBjaGlsZCBub2RlIGF0IHRoZSBnaXZlbiBpbmRleC4gUmFpc2UgYW4gZXJyb3Igd2hlbiB0aGVcbi8vIGluZGV4IGlzIG91dCBvZiByYW5nZS5cbkZyYWdtZW50LnByb3RvdHlwZS5jaGlsZCA9IGZ1bmN0aW9uIGNoaWxkIChpbmRleCkge1xuICB2YXIgZm91bmQgPSB0aGlzLmNvbnRlbnRbaW5kZXhdO1xuICBpZiAoIWZvdW5kKSB7IHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggXCIgKyBpbmRleCArIFwiIG91dCBvZiByYW5nZSBmb3IgXCIgKyB0aGlzKSB9XG4gIHJldHVybiBmb3VuZFxufTtcblxuLy8gOjogKG51bWJlcikg4oaSID9Ob2RlXG4vLyBHZXQgdGhlIGNoaWxkIG5vZGUgYXQgdGhlIGdpdmVuIGluZGV4LCBpZiBpdCBleGlzdHMuXG5GcmFnbWVudC5wcm90b3R5cGUubWF5YmVDaGlsZCA9IGZ1bmN0aW9uIG1heWJlQ2hpbGQgKGluZGV4KSB7XG4gIHJldHVybiB0aGlzLmNvbnRlbnRbaW5kZXhdXG59O1xuXG4vLyA6OiAoKG5vZGU6IE5vZGUsIG9mZnNldDogbnVtYmVyLCBpbmRleDogbnVtYmVyKSlcbi8vIENhbGwgYGZgIGZvciBldmVyeSBjaGlsZCBub2RlLCBwYXNzaW5nIHRoZSBub2RlLCBpdHMgb2Zmc2V0XG4vLyBpbnRvIHRoaXMgcGFyZW50IG5vZGUsIGFuZCBpdHMgaW5kZXguXG5GcmFnbWVudC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2ggKGYpIHtcbiAgZm9yICh2YXIgaSA9IDAsIHAgPSAwOyBpIDwgdGhpcy5jb250ZW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNoaWxkID0gdGhpcy5jb250ZW50W2ldO1xuICAgIGYoY2hpbGQsIHAsIGkpO1xuICAgIHAgKz0gY2hpbGQubm9kZVNpemU7XG4gIH1cbn07XG5cbi8vIDo6IChGcmFnbWVudCkg4oaSID9udW1iZXJcbi8vIEZpbmQgdGhlIGZpcnN0IHBvc2l0aW9uIGF0IHdoaWNoIHRoaXMgZnJhZ21lbnQgYW5kIGFub3RoZXJcbi8vIGZyYWdtZW50IGRpZmZlciwgb3IgYG51bGxgIGlmIHRoZXkgYXJlIHRoZSBzYW1lLlxuRnJhZ21lbnQucHJvdG90eXBlLmZpbmREaWZmU3RhcnQgPSBmdW5jdGlvbiBmaW5kRGlmZlN0YXJ0JDEgKG90aGVyLCBwb3MpIHtcbiAgICBpZiAoIHBvcyA9PT0gdm9pZCAwICkgcG9zID0gMDtcblxuICByZXR1cm4gZmluZERpZmZTdGFydCh0aGlzLCBvdGhlciwgcG9zKVxufTtcblxuLy8gOjogKEZyYWdtZW50KSDihpIgP3thOiBudW1iZXIsIGI6IG51bWJlcn1cbi8vIEZpbmQgdGhlIGZpcnN0IHBvc2l0aW9uLCBzZWFyY2hpbmcgZnJvbSB0aGUgZW5kLCBhdCB3aGljaCB0aGlzXG4vLyBmcmFnbWVudCBhbmQgdGhlIGdpdmVuIGZyYWdtZW50IGRpZmZlciwgb3IgYG51bGxgIGlmIHRoZXkgYXJlIHRoZVxuLy8gc2FtZS4gU2luY2UgdGhpcyBwb3NpdGlvbiB3aWxsIG5vdCBiZSB0aGUgc2FtZSBpbiBib3RoIG5vZGVzLCBhblxuLy8gb2JqZWN0IHdpdGggdHdvIHNlcGFyYXRlIHBvc2l0aW9ucyBpcyByZXR1cm5lZC5cbkZyYWdtZW50LnByb3RvdHlwZS5maW5kRGlmZkVuZCA9IGZ1bmN0aW9uIGZpbmREaWZmRW5kJDEgKG90aGVyLCBwb3MsIG90aGVyUG9zKSB7XG4gICAgaWYgKCBwb3MgPT09IHZvaWQgMCApIHBvcyA9IHRoaXMuc2l6ZTtcbiAgICBpZiAoIG90aGVyUG9zID09PSB2b2lkIDAgKSBvdGhlclBvcyA9IG90aGVyLnNpemU7XG5cbiAgcmV0dXJuIGZpbmREaWZmRW5kKHRoaXMsIG90aGVyLCBwb3MsIG90aGVyUG9zKVxufTtcblxuLy8gOiAobnVtYmVyLCA/bnVtYmVyKSDihpIge2luZGV4OiBudW1iZXIsIG9mZnNldDogbnVtYmVyfVxuLy8gRmluZCB0aGUgaW5kZXggYW5kIGlubmVyIG9mZnNldCBjb3JyZXNwb25kaW5nIHRvIGEgZ2l2ZW4gcmVsYXRpdmVcbi8vIHBvc2l0aW9uIGluIHRoaXMgZnJhZ21lbnQuIFRoZSByZXN1bHQgb2JqZWN0IHdpbGwgYmUgcmV1c2VkXG4vLyAob3ZlcndyaXR0ZW4pIHRoZSBuZXh0IHRpbWUgdGhlIGZ1bmN0aW9uIGlzIGNhbGxlZC4gKE5vdCBwdWJsaWMuKVxuRnJhZ21lbnQucHJvdG90eXBlLmZpbmRJbmRleCA9IGZ1bmN0aW9uIGZpbmRJbmRleCAocG9zLCByb3VuZCkge1xuICAgIGlmICggcm91bmQgPT09IHZvaWQgMCApIHJvdW5kID0gLTE7XG5cbiAgaWYgKHBvcyA9PSAwKSB7IHJldHVybiByZXRJbmRleCgwLCBwb3MpIH1cbiAgaWYgKHBvcyA9PSB0aGlzLnNpemUpIHsgcmV0dXJuIHJldEluZGV4KHRoaXMuY29udGVudC5sZW5ndGgsIHBvcykgfVxuICBpZiAocG9zID4gdGhpcy5zaXplIHx8IHBvcyA8IDApIHsgdGhyb3cgbmV3IFJhbmdlRXJyb3IoKFwiUG9zaXRpb24gXCIgKyBwb3MgKyBcIiBvdXRzaWRlIG9mIGZyYWdtZW50IChcIiArICh0aGlzKSArIFwiKVwiKSkgfVxuICBmb3IgKHZhciBpID0gMCwgY3VyUG9zID0gMDs7IGkrKykge1xuICAgIHZhciBjdXIgPSB0aGlzLmNoaWxkKGkpLCBlbmQgPSBjdXJQb3MgKyBjdXIubm9kZVNpemU7XG4gICAgaWYgKGVuZCA+PSBwb3MpIHtcbiAgICAgIGlmIChlbmQgPT0gcG9zIHx8IHJvdW5kID4gMCkgeyByZXR1cm4gcmV0SW5kZXgoaSArIDEsIGVuZCkgfVxuICAgICAgcmV0dXJuIHJldEluZGV4KGksIGN1clBvcylcbiAgICB9XG4gICAgY3VyUG9zID0gZW5kO1xuICB9XG59O1xuXG4vLyA6OiAoKSDihpIgc3RyaW5nXG4vLyBSZXR1cm4gYSBkZWJ1Z2dpbmcgc3RyaW5nIHRoYXQgZGVzY3JpYmVzIHRoaXMgZnJhZ21lbnQuXG5GcmFnbWVudC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7IHJldHVybiBcIjxcIiArIHRoaXMudG9TdHJpbmdJbm5lcigpICsgXCI+XCIgfTtcblxuRnJhZ21lbnQucHJvdG90eXBlLnRvU3RyaW5nSW5uZXIgPSBmdW5jdGlvbiB0b1N0cmluZ0lubmVyICgpIHsgcmV0dXJuIHRoaXMuY29udGVudC5qb2luKFwiLCBcIikgfTtcblxuLy8gOjogKCkg4oaSID9PYmplY3Rcbi8vIENyZWF0ZSBhIEpTT04tc2VyaWFsaXplYWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGZyYWdtZW50LlxuRnJhZ21lbnQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB0aGlzLmNvbnRlbnQubGVuZ3RoID8gdGhpcy5jb250ZW50Lm1hcChmdW5jdGlvbiAobikgeyByZXR1cm4gbi50b0pTT04oKTsgfSkgOiBudWxsXG59O1xuXG4vLyA6OiAoU2NoZW1hLCA/T2JqZWN0KSDihpIgRnJhZ21lbnRcbi8vIERlc2VyaWFsaXplIGEgZnJhZ21lbnQgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbi5cbkZyYWdtZW50LmZyb21KU09OID0gZnVuY3Rpb24gZnJvbUpTT04gKHNjaGVtYSwgdmFsdWUpIHtcbiAgaWYgKCF2YWx1ZSkgeyByZXR1cm4gRnJhZ21lbnQuZW1wdHkgfVxuICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7IHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgRnJhZ21lbnQuZnJvbUpTT05cIikgfVxuICByZXR1cm4gbmV3IEZyYWdtZW50KHZhbHVlLm1hcChzY2hlbWEubm9kZUZyb21KU09OKSlcbn07XG5cbi8vIDo6IChbTm9kZV0pIOKGkiBGcmFnbWVudFxuLy8gQnVpbGQgYSBmcmFnbWVudCBmcm9tIGFuIGFycmF5IG9mIG5vZGVzLiBFbnN1cmVzIHRoYXQgYWRqYWNlbnRcbi8vIHRleHQgbm9kZXMgd2l0aCB0aGUgc2FtZSBtYXJrcyBhcmUgam9pbmVkIHRvZ2V0aGVyLlxuRnJhZ21lbnQuZnJvbUFycmF5ID0gZnVuY3Rpb24gZnJvbUFycmF5IChhcnJheSkge1xuICBpZiAoIWFycmF5Lmxlbmd0aCkgeyByZXR1cm4gRnJhZ21lbnQuZW1wdHkgfVxuICB2YXIgam9pbmVkLCBzaXplID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBub2RlID0gYXJyYXlbaV07XG4gICAgc2l6ZSArPSBub2RlLm5vZGVTaXplO1xuICAgIGlmIChpICYmIG5vZGUuaXNUZXh0ICYmIGFycmF5W2kgLSAxXS5zYW1lTWFya3VwKG5vZGUpKSB7XG4gICAgICBpZiAoIWpvaW5lZCkgeyBqb2luZWQgPSBhcnJheS5zbGljZSgwLCBpKTsgfVxuICAgICAgam9pbmVkW2pvaW5lZC5sZW5ndGggLSAxXSA9IG5vZGUud2l0aFRleHQoam9pbmVkW2pvaW5lZC5sZW5ndGggLSAxXS50ZXh0ICsgbm9kZS50ZXh0KTtcbiAgICB9IGVsc2UgaWYgKGpvaW5lZCkge1xuICAgICAgam9pbmVkLnB1c2gobm9kZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgRnJhZ21lbnQoam9pbmVkIHx8IGFycmF5LCBzaXplKVxufTtcblxuLy8gOjogKD91bmlvbjxGcmFnbWVudCwgTm9kZSwgW05vZGVdPikg4oaSIEZyYWdtZW50XG4vLyBDcmVhdGUgYSBmcmFnbWVudCBmcm9tIHNvbWV0aGluZyB0aGF0IGNhbiBiZSBpbnRlcnByZXRlZCBhcyBhIHNldFxuLy8gb2Ygbm9kZXMuIEZvciBgbnVsbGAsIGl0IHJldHVybnMgdGhlIGVtcHR5IGZyYWdtZW50LiBGb3IgYVxuLy8gZnJhZ21lbnQsIHRoZSBmcmFnbWVudCBpdHNlbGYuIEZvciBhIG5vZGUgb3IgYXJyYXkgb2Ygbm9kZXMsIGFcbi8vIGZyYWdtZW50IGNvbnRhaW5pbmcgdGhvc2Ugbm9kZXMuXG5GcmFnbWVudC5mcm9tID0gZnVuY3Rpb24gZnJvbSAobm9kZXMpIHtcbiAgaWYgKCFub2RlcykgeyByZXR1cm4gRnJhZ21lbnQuZW1wdHkgfVxuICBpZiAobm9kZXMgaW5zdGFuY2VvZiBGcmFnbWVudCkgeyByZXR1cm4gbm9kZXMgfVxuICBpZiAoQXJyYXkuaXNBcnJheShub2RlcykpIHsgcmV0dXJuIHRoaXMuZnJvbUFycmF5KG5vZGVzKSB9XG4gIGlmIChub2Rlcy5hdHRycykgeyByZXR1cm4gbmV3IEZyYWdtZW50KFtub2Rlc10sIG5vZGVzLm5vZGVTaXplKSB9XG4gIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQ2FuIG5vdCBjb252ZXJ0IFwiICsgbm9kZXMgKyBcIiB0byBhIEZyYWdtZW50XCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAobm9kZXMubm9kZXNCZXR3ZWVuID8gXCIgKGxvb2tzIGxpa2UgbXVsdGlwbGUgdmVyc2lvbnMgb2YgcHJvc2VtaXJyb3ItbW9kZWwgd2VyZSBsb2FkZWQpXCIgOiBcIlwiKSlcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBGcmFnbWVudC5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyApO1xuXG52YXIgZm91bmQgPSB7aW5kZXg6IDAsIG9mZnNldDogMH07XG5mdW5jdGlvbiByZXRJbmRleChpbmRleCwgb2Zmc2V0KSB7XG4gIGZvdW5kLmluZGV4ID0gaW5kZXg7XG4gIGZvdW5kLm9mZnNldCA9IG9mZnNldDtcbiAgcmV0dXJuIGZvdW5kXG59XG5cbi8vIDo6IEZyYWdtZW50XG4vLyBBbiBlbXB0eSBmcmFnbWVudC4gSW50ZW5kZWQgdG8gYmUgcmV1c2VkIHdoZW5ldmVyIGEgbm9kZSBkb2Vzbid0XG4vLyBjb250YWluIGFueXRoaW5nIChyYXRoZXIgdGhhbiBhbGxvY2F0aW5nIGEgbmV3IGVtcHR5IGZyYWdtZW50IGZvclxuLy8gZWFjaCBsZWFmIG5vZGUpLlxuRnJhZ21lbnQuZW1wdHkgPSBuZXcgRnJhZ21lbnQoW10sIDApO1xuXG5mdW5jdGlvbiBjb21wYXJlRGVlcChhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7IHJldHVybiB0cnVlIH1cbiAgaWYgKCEoYSAmJiB0eXBlb2YgYSA9PSBcIm9iamVjdFwiKSB8fFxuICAgICAgIShiICYmIHR5cGVvZiBiID09IFwib2JqZWN0XCIpKSB7IHJldHVybiBmYWxzZSB9XG4gIHZhciBhcnJheSA9IEFycmF5LmlzQXJyYXkoYSk7XG4gIGlmIChBcnJheS5pc0FycmF5KGIpICE9IGFycmF5KSB7IHJldHVybiBmYWxzZSB9XG4gIGlmIChhcnJheSkge1xuICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aCkgeyByZXR1cm4gZmFsc2UgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykgeyBpZiAoIWNvbXBhcmVEZWVwKGFbaV0sIGJbaV0pKSB7IHJldHVybiBmYWxzZSB9IH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBwIGluIGEpIHsgaWYgKCEocCBpbiBiKSB8fCAhY29tcGFyZURlZXAoYVtwXSwgYltwXSkpIHsgcmV0dXJuIGZhbHNlIH0gfVxuICAgIGZvciAodmFyIHAkMSBpbiBiKSB7IGlmICghKHAkMSBpbiBhKSkgeyByZXR1cm4gZmFsc2UgfSB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuLy8gOjotIEEgbWFyayBpcyBhIHBpZWNlIG9mIGluZm9ybWF0aW9uIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGEgbm9kZSxcbi8vIHN1Y2ggYXMgaXQgYmVpbmcgZW1waGFzaXplZCwgaW4gY29kZSBmb250LCBvciBhIGxpbmsuIEl0IGhhcyBhIHR5cGVcbi8vIGFuZCBvcHRpb25hbGx5IGEgc2V0IG9mIGF0dHJpYnV0ZXMgdGhhdCBwcm92aWRlIGZ1cnRoZXIgaW5mb3JtYXRpb25cbi8vIChzdWNoIGFzIHRoZSB0YXJnZXQgb2YgdGhlIGxpbmspLiBNYXJrcyBhcmUgY3JlYXRlZCB0aHJvdWdoIGFcbi8vIGBTY2hlbWFgLCB3aGljaCBjb250cm9scyB3aGljaCB0eXBlcyBleGlzdCBhbmQgd2hpY2hcbi8vIGF0dHJpYnV0ZXMgdGhleSBoYXZlLlxudmFyIE1hcmsgPSBmdW5jdGlvbiBNYXJrKHR5cGUsIGF0dHJzKSB7XG4gIC8vIDo6IE1hcmtUeXBlXG4gIC8vIFRoZSB0eXBlIG9mIHRoaXMgbWFyay5cbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgLy8gOjogT2JqZWN0XG4gIC8vIFRoZSBhdHRyaWJ1dGVzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIG1hcmsuXG4gIHRoaXMuYXR0cnMgPSBhdHRycztcbn07XG5cbi8vIDo6IChbTWFya10pIOKGkiBbTWFya11cbi8vIEdpdmVuIGEgc2V0IG9mIG1hcmtzLCBjcmVhdGUgYSBuZXcgc2V0IHdoaWNoIGNvbnRhaW5zIHRoaXMgb25lIGFzXG4vLyB3ZWxsLCBpbiB0aGUgcmlnaHQgcG9zaXRpb24uIElmIHRoaXMgbWFyayBpcyBhbHJlYWR5IGluIHRoZSBzZXQsXG4vLyB0aGUgc2V0IGl0c2VsZiBpcyByZXR1cm5lZC4gSWYgYW55IG1hcmtzIHRoYXQgYXJlIHNldCB0byBiZVxuLy8gW2V4Y2x1c2l2ZV0oI21vZGVsLk1hcmtTcGVjLmV4Y2x1ZGVzKSB3aXRoIHRoaXMgbWFyayBhcmUgcHJlc2VudCxcbi8vIHRob3NlIGFyZSByZXBsYWNlZCBieSB0aGlzIG9uZS5cbk1hcmsucHJvdG90eXBlLmFkZFRvU2V0ID0gZnVuY3Rpb24gYWRkVG9TZXQgKHNldCkge1xuICB2YXIgY29weSwgcGxhY2VkID0gZmFsc2U7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG90aGVyID0gc2V0W2ldO1xuICAgIGlmICh0aGlzLmVxKG90aGVyKSkgeyByZXR1cm4gc2V0IH1cbiAgICBpZiAodGhpcy50eXBlLmV4Y2x1ZGVzKG90aGVyLnR5cGUpKSB7XG4gICAgICBpZiAoIWNvcHkpIHsgY29weSA9IHNldC5zbGljZSgwLCBpKTsgfVxuICAgIH0gZWxzZSBpZiAob3RoZXIudHlwZS5leGNsdWRlcyh0aGlzLnR5cGUpKSB7XG4gICAgICByZXR1cm4gc2V0XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghcGxhY2VkICYmIG90aGVyLnR5cGUucmFuayA+IHRoaXMudHlwZS5yYW5rKSB7XG4gICAgICAgIGlmICghY29weSkgeyBjb3B5ID0gc2V0LnNsaWNlKDAsIGkpOyB9XG4gICAgICAgIGNvcHkucHVzaCh0aGlzKTtcbiAgICAgICAgcGxhY2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChjb3B5KSB7IGNvcHkucHVzaChvdGhlcik7IH1cbiAgICB9XG4gIH1cbiAgaWYgKCFjb3B5KSB7IGNvcHkgPSBzZXQuc2xpY2UoKTsgfVxuICBpZiAoIXBsYWNlZCkgeyBjb3B5LnB1c2godGhpcyk7IH1cbiAgcmV0dXJuIGNvcHlcbn07XG5cbi8vIDo6IChbTWFya10pIOKGkiBbTWFya11cbi8vIFJlbW92ZSB0aGlzIG1hcmsgZnJvbSB0aGUgZ2l2ZW4gc2V0LCByZXR1cm5pbmcgYSBuZXcgc2V0LiBJZiB0aGlzXG4vLyBtYXJrIGlzIG5vdCBpbiB0aGUgc2V0LCB0aGUgc2V0IGl0c2VsZiBpcyByZXR1cm5lZC5cbk1hcmsucHJvdG90eXBlLnJlbW92ZUZyb21TZXQgPSBmdW5jdGlvbiByZW1vdmVGcm9tU2V0IChzZXQpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspXG4gICAgeyBpZiAodGhpcy5lcShzZXRbaV0pKVxuICAgICAgeyByZXR1cm4gc2V0LnNsaWNlKDAsIGkpLmNvbmNhdChzZXQuc2xpY2UoaSArIDEpKSB9IH1cbiAgcmV0dXJuIHNldFxufTtcblxuLy8gOjogKFtNYXJrXSkg4oaSIGJvb2xcbi8vIFRlc3Qgd2hldGhlciB0aGlzIG1hcmsgaXMgaW4gdGhlIGdpdmVuIHNldCBvZiBtYXJrcy5cbk1hcmsucHJvdG90eXBlLmlzSW5TZXQgPSBmdW5jdGlvbiBpc0luU2V0IChzZXQpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspXG4gICAgeyBpZiAodGhpcy5lcShzZXRbaV0pKSB7IHJldHVybiB0cnVlIH0gfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIDo6IChNYXJrKSDihpIgYm9vbFxuLy8gVGVzdCB3aGV0aGVyIHRoaXMgbWFyayBoYXMgdGhlIHNhbWUgdHlwZSBhbmQgYXR0cmlidXRlcyBhc1xuLy8gYW5vdGhlciBtYXJrLlxuTWFyay5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbiBlcSAob3RoZXIpIHtcbiAgcmV0dXJuIHRoaXMgPT0gb3RoZXIgfHxcbiAgICAodGhpcy50eXBlID09IG90aGVyLnR5cGUgJiYgY29tcGFyZURlZXAodGhpcy5hdHRycywgb3RoZXIuYXR0cnMpKVxufTtcblxuLy8gOjogKCkg4oaSIE9iamVjdFxuLy8gQ29udmVydCB0aGlzIG1hcmsgdG8gYSBKU09OLXNlcmlhbGl6ZWFibGUgcmVwcmVzZW50YXRpb24uXG5NYXJrLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICB2YXIgb2JqID0ge3R5cGU6IHRoaXMudHlwZS5uYW1lfTtcbiAgZm9yICh2YXIgXyBpbiB0aGlzLmF0dHJzKSB7XG4gICAgb2JqLmF0dHJzID0gdGhpcy5hdHRycztcbiAgICBicmVha1xuICB9XG4gIHJldHVybiBvYmpcbn07XG5cbi8vIDo6IChTY2hlbWEsIE9iamVjdCkg4oaSIE1hcmtcbk1hcmsuZnJvbUpTT04gPSBmdW5jdGlvbiBmcm9tSlNPTiAoc2NoZW1hLCBqc29uKSB7XG4gIGlmICghanNvbikgeyB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIE1hcmsuZnJvbUpTT05cIikgfVxuICB2YXIgdHlwZSA9IHNjaGVtYS5tYXJrc1tqc29uLnR5cGVdO1xuICBpZiAoIXR5cGUpIHsgdGhyb3cgbmV3IFJhbmdlRXJyb3IoKFwiVGhlcmUgaXMgbm8gbWFyayB0eXBlIFwiICsgKGpzb24udHlwZSkgKyBcIiBpbiB0aGlzIHNjaGVtYVwiKSkgfVxuICByZXR1cm4gdHlwZS5jcmVhdGUoanNvbi5hdHRycylcbn07XG5cbi8vIDo6IChbTWFya10sIFtNYXJrXSkg4oaSIGJvb2xcbi8vIFRlc3Qgd2hldGhlciB0d28gc2V0cyBvZiBtYXJrcyBhcmUgaWRlbnRpY2FsLlxuTWFyay5zYW1lU2V0ID0gZnVuY3Rpb24gc2FtZVNldCAoYSwgYikge1xuICBpZiAoYSA9PSBiKSB7IHJldHVybiB0cnVlIH1cbiAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKSB7IHJldHVybiBmYWxzZSB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKylcbiAgICB7IGlmICghYVtpXS5lcShiW2ldKSkgeyByZXR1cm4gZmFsc2UgfSB9XG4gIHJldHVybiB0cnVlXG59O1xuXG4vLyA6OiAoP3VuaW9uPE1hcmssIFtNYXJrXT4pIOKGkiBbTWFya11cbi8vIENyZWF0ZSBhIHByb3Blcmx5IHNvcnRlZCBtYXJrIHNldCBmcm9tIG51bGwsIGEgc2luZ2xlIG1hcmssIG9yIGFuXG4vLyB1bnNvcnRlZCBhcnJheSBvZiBtYXJrcy5cbk1hcmsuc2V0RnJvbSA9IGZ1bmN0aW9uIHNldEZyb20gKG1hcmtzKSB7XG4gIGlmICghbWFya3MgfHwgbWFya3MubGVuZ3RoID09IDApIHsgcmV0dXJuIE1hcmsubm9uZSB9XG4gIGlmIChtYXJrcyBpbnN0YW5jZW9mIE1hcmspIHsgcmV0dXJuIFttYXJrc10gfVxuICB2YXIgY29weSA9IG1hcmtzLnNsaWNlKCk7XG4gIGNvcHkuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS50eXBlLnJhbmsgLSBiLnR5cGUucmFuazsgfSk7XG4gIHJldHVybiBjb3B5XG59O1xuXG4vLyA6OiBbTWFya10gVGhlIGVtcHR5IHNldCBvZiBtYXJrcy5cbk1hcmsubm9uZSA9IFtdO1xuXG4vLyBSZXBsYWNlRXJyb3I6OiBjbGFzcyBleHRlbmRzIEVycm9yXG4vLyBFcnJvciB0eXBlIHJhaXNlZCBieSBbYE5vZGUucmVwbGFjZWBdKCNtb2RlbC5Ob2RlLnJlcGxhY2UpIHdoZW5cbi8vIGdpdmVuIGFuIGludmFsaWQgcmVwbGFjZW1lbnQuXG5cbmZ1bmN0aW9uIFJlcGxhY2VFcnJvcihtZXNzYWdlKSB7XG4gIHZhciBlcnIgPSBFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuICBlcnIuX19wcm90b19fID0gUmVwbGFjZUVycm9yLnByb3RvdHlwZTtcbiAgcmV0dXJuIGVyclxufVxuXG5SZXBsYWNlRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuUmVwbGFjZUVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJlcGxhY2VFcnJvcjtcblJlcGxhY2VFcnJvci5wcm90b3R5cGUubmFtZSA9IFwiUmVwbGFjZUVycm9yXCI7XG5cbi8vIDo6LSBBIHNsaWNlIHJlcHJlc2VudHMgYSBwaWVjZSBjdXQgb3V0IG9mIGEgbGFyZ2VyIGRvY3VtZW50LiBJdFxuLy8gc3RvcmVzIG5vdCBvbmx5IGEgZnJhZ21lbnQsIGJ1dCBhbHNvIHRoZSBkZXB0aCB1cCB0byB3aGljaCBub2RlcyBvblxuLy8gYm90aCBzaWRlIGFyZSDigJhvcGVu4oCZIChjdXQgdGhyb3VnaCkuXG52YXIgU2xpY2UgPSBmdW5jdGlvbiBTbGljZShjb250ZW50LCBvcGVuU3RhcnQsIG9wZW5FbmQpIHtcbiAgLy8gOjogRnJhZ21lbnQgVGhlIHNsaWNlJ3MgY29udGVudC5cbiAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgLy8gOjogbnVtYmVyIFRoZSBvcGVuIGRlcHRoIGF0IHRoZSBzdGFydC5cbiAgdGhpcy5vcGVuU3RhcnQgPSBvcGVuU3RhcnQ7XG4gIC8vIDo6IG51bWJlciBUaGUgb3BlbiBkZXB0aCBhdCB0aGUgZW5kLlxuICB0aGlzLm9wZW5FbmQgPSBvcGVuRW5kO1xufTtcblxudmFyIHByb3RvdHlwZUFjY2Vzc29ycyQxID0geyBzaXplOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbi8vIDo6IG51bWJlclxuLy8gVGhlIHNpemUgdGhpcyBzbGljZSB3b3VsZCBhZGQgd2hlbiBpbnNlcnRlZCBpbnRvIGEgZG9jdW1lbnQuXG5wcm90b3R5cGVBY2Nlc3NvcnMkMS5zaXplLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY29udGVudC5zaXplIC0gdGhpcy5vcGVuU3RhcnQgLSB0aGlzLm9wZW5FbmRcbn07XG5cblNsaWNlLnByb3RvdHlwZS5pbnNlcnRBdCA9IGZ1bmN0aW9uIGluc2VydEF0IChwb3MsIGZyYWdtZW50KSB7XG4gIHZhciBjb250ZW50ID0gaW5zZXJ0SW50byh0aGlzLmNvbnRlbnQsIHBvcyArIHRoaXMub3BlblN0YXJ0LCBmcmFnbWVudCwgbnVsbCk7XG4gIHJldHVybiBjb250ZW50ICYmIG5ldyBTbGljZShjb250ZW50LCB0aGlzLm9wZW5TdGFydCwgdGhpcy5vcGVuRW5kKVxufTtcblxuU2xpY2UucHJvdG90eXBlLnJlbW92ZUJldHdlZW4gPSBmdW5jdGlvbiByZW1vdmVCZXR3ZWVuIChmcm9tLCB0bykge1xuICByZXR1cm4gbmV3IFNsaWNlKHJlbW92ZVJhbmdlKHRoaXMuY29udGVudCwgZnJvbSArIHRoaXMub3BlblN0YXJ0LCB0byArIHRoaXMub3BlblN0YXJ0KSwgdGhpcy5vcGVuU3RhcnQsIHRoaXMub3BlbkVuZClcbn07XG5cbi8vIDo6IChTbGljZSkg4oaSIGJvb2xcbi8vIFRlc3RzIHdoZXRoZXIgdGhpcyBzbGljZSBpcyBlcXVhbCB0byBhbm90aGVyIHNsaWNlLlxuU2xpY2UucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gZXEgKG90aGVyKSB7XG4gIHJldHVybiB0aGlzLmNvbnRlbnQuZXEob3RoZXIuY29udGVudCkgJiYgdGhpcy5vcGVuU3RhcnQgPT0gb3RoZXIub3BlblN0YXJ0ICYmIHRoaXMub3BlbkVuZCA9PSBvdGhlci5vcGVuRW5kXG59O1xuXG5TbGljZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHJldHVybiB0aGlzLmNvbnRlbnQgKyBcIihcIiArIHRoaXMub3BlblN0YXJ0ICsgXCIsXCIgKyB0aGlzLm9wZW5FbmQgKyBcIilcIlxufTtcblxuLy8gOjogKCkg4oaSID9PYmplY3Rcbi8vIENvbnZlcnQgYSBzbGljZSB0byBhIEpTT04tc2VyaWFsaXphYmxlIHJlcHJlc2VudGF0aW9uLlxuU2xpY2UucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIGlmICghdGhpcy5jb250ZW50LnNpemUpIHsgcmV0dXJuIG51bGwgfVxuICB2YXIganNvbiA9IHtjb250ZW50OiB0aGlzLmNvbnRlbnQudG9KU09OKCl9O1xuICBpZiAodGhpcy5vcGVuU3RhcnQgPiAwKSB7IGpzb24ub3BlblN0YXJ0ID0gdGhpcy5vcGVuU3RhcnQ7IH1cbiAgaWYgKHRoaXMub3BlbkVuZCA+IDApIHsganNvbi5vcGVuRW5kID0gdGhpcy5vcGVuRW5kOyB9XG4gIHJldHVybiBqc29uXG59O1xuXG4vLyA6OiAoU2NoZW1hLCA/T2JqZWN0KSDihpIgU2xpY2Vcbi8vIERlc2VyaWFsaXplIGEgc2xpY2UgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbi5cblNsaWNlLmZyb21KU09OID0gZnVuY3Rpb24gZnJvbUpTT04gKHNjaGVtYSwganNvbikge1xuICBpZiAoIWpzb24pIHsgcmV0dXJuIFNsaWNlLmVtcHR5IH1cbiAgdmFyIG9wZW5TdGFydCA9IGpzb24ub3BlblN0YXJ0IHx8IDAsIG9wZW5FbmQgPSBqc29uLm9wZW5FbmQgfHwgMDtcbiAgaWYgKHR5cGVvZiBvcGVuU3RhcnQgIT0gXCJudW1iZXJcIiB8fCB0eXBlb2Ygb3BlbkVuZCAhPSBcIm51bWJlclwiKVxuICAgIHsgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBTbGljZS5mcm9tSlNPTlwiKSB9XG4gIHJldHVybiBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbUpTT04oc2NoZW1hLCBqc29uLmNvbnRlbnQpLCBvcGVuU3RhcnQsIG9wZW5FbmQpXG59O1xuXG4vLyA6OiAoRnJhZ21lbnQsID9ib29sKSDihpIgU2xpY2Vcbi8vIENyZWF0ZSBhIHNsaWNlIGZyb20gYSBmcmFnbWVudCBieSB0YWtpbmcgdGhlIG1heGltdW0gcG9zc2libGVcbi8vIG9wZW4gdmFsdWUgb24gYm90aCBzaWRlIG9mIHRoZSBmcmFnbWVudC5cblNsaWNlLm1heE9wZW4gPSBmdW5jdGlvbiBtYXhPcGVuIChmcmFnbWVudCwgb3Blbklzb2xhdGluZykge1xuICAgIGlmICggb3Blbklzb2xhdGluZyA9PT0gdm9pZCAwICkgb3Blbklzb2xhdGluZz10cnVlO1xuXG4gIHZhciBvcGVuU3RhcnQgPSAwLCBvcGVuRW5kID0gMDtcbiAgZm9yICh2YXIgbiA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7IG4gJiYgIW4uaXNMZWFmICYmIChvcGVuSXNvbGF0aW5nIHx8ICFuLnR5cGUuc3BlYy5pc29sYXRpbmcpOyBuID0gbi5maXJzdENoaWxkKSB7IG9wZW5TdGFydCsrOyB9XG4gIGZvciAodmFyIG4kMSA9IGZyYWdtZW50Lmxhc3RDaGlsZDsgbiQxICYmICFuJDEuaXNMZWFmICYmIChvcGVuSXNvbGF0aW5nIHx8ICFuJDEudHlwZS5zcGVjLmlzb2xhdGluZyk7IG4kMSA9IG4kMS5sYXN0Q2hpbGQpIHsgb3BlbkVuZCsrOyB9XG4gIHJldHVybiBuZXcgU2xpY2UoZnJhZ21lbnQsIG9wZW5TdGFydCwgb3BlbkVuZClcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBTbGljZS5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyQxICk7XG5cbmZ1bmN0aW9uIHJlbW92ZVJhbmdlKGNvbnRlbnQsIGZyb20sIHRvKSB7XG4gIHZhciByZWYgPSBjb250ZW50LmZpbmRJbmRleChmcm9tKTtcbiAgdmFyIGluZGV4ID0gcmVmLmluZGV4O1xuICB2YXIgb2Zmc2V0ID0gcmVmLm9mZnNldDtcbiAgdmFyIGNoaWxkID0gY29udGVudC5tYXliZUNoaWxkKGluZGV4KTtcbiAgdmFyIHJlZiQxID0gY29udGVudC5maW5kSW5kZXgodG8pO1xuICB2YXIgaW5kZXhUbyA9IHJlZiQxLmluZGV4O1xuICB2YXIgb2Zmc2V0VG8gPSByZWYkMS5vZmZzZXQ7XG4gIGlmIChvZmZzZXQgPT0gZnJvbSB8fCBjaGlsZC5pc1RleHQpIHtcbiAgICBpZiAob2Zmc2V0VG8gIT0gdG8gJiYgIWNvbnRlbnQuY2hpbGQoaW5kZXhUbykuaXNUZXh0KSB7IHRocm93IG5ldyBSYW5nZUVycm9yKFwiUmVtb3Zpbmcgbm9uLWZsYXQgcmFuZ2VcIikgfVxuICAgIHJldHVybiBjb250ZW50LmN1dCgwLCBmcm9tKS5hcHBlbmQoY29udGVudC5jdXQodG8pKVxuICB9XG4gIGlmIChpbmRleCAhPSBpbmRleFRvKSB7IHRocm93IG5ldyBSYW5nZUVycm9yKFwiUmVtb3Zpbmcgbm9uLWZsYXQgcmFuZ2VcIikgfVxuICByZXR1cm4gY29udGVudC5yZXBsYWNlQ2hpbGQoaW5kZXgsIGNoaWxkLmNvcHkocmVtb3ZlUmFuZ2UoY2hpbGQuY29udGVudCwgZnJvbSAtIG9mZnNldCAtIDEsIHRvIC0gb2Zmc2V0IC0gMSkpKVxufVxuXG5mdW5jdGlvbiBpbnNlcnRJbnRvKGNvbnRlbnQsIGRpc3QsIGluc2VydCwgcGFyZW50KSB7XG4gIHZhciByZWYgPSBjb250ZW50LmZpbmRJbmRleChkaXN0KTtcbiAgdmFyIGluZGV4ID0gcmVmLmluZGV4O1xuICB2YXIgb2Zmc2V0ID0gcmVmLm9mZnNldDtcbiAgdmFyIGNoaWxkID0gY29udGVudC5tYXliZUNoaWxkKGluZGV4KTtcbiAgaWYgKG9mZnNldCA9PSBkaXN0IHx8IGNoaWxkLmlzVGV4dCkge1xuICAgIGlmIChwYXJlbnQgJiYgIXBhcmVudC5jYW5SZXBsYWNlKGluZGV4LCBpbmRleCwgaW5zZXJ0KSkgeyByZXR1cm4gbnVsbCB9XG4gICAgcmV0dXJuIGNvbnRlbnQuY3V0KDAsIGRpc3QpLmFwcGVuZChpbnNlcnQpLmFwcGVuZChjb250ZW50LmN1dChkaXN0KSlcbiAgfVxuICB2YXIgaW5uZXIgPSBpbnNlcnRJbnRvKGNoaWxkLmNvbnRlbnQsIGRpc3QgLSBvZmZzZXQgLSAxLCBpbnNlcnQpO1xuICByZXR1cm4gaW5uZXIgJiYgY29udGVudC5yZXBsYWNlQ2hpbGQoaW5kZXgsIGNoaWxkLmNvcHkoaW5uZXIpKVxufVxuXG4vLyA6OiBTbGljZVxuLy8gVGhlIGVtcHR5IHNsaWNlLlxuU2xpY2UuZW1wdHkgPSBuZXcgU2xpY2UoRnJhZ21lbnQuZW1wdHksIDAsIDApO1xuXG5mdW5jdGlvbiByZXBsYWNlKCRmcm9tLCAkdG8sIHNsaWNlKSB7XG4gIGlmIChzbGljZS5vcGVuU3RhcnQgPiAkZnJvbS5kZXB0aClcbiAgICB7IHRocm93IG5ldyBSZXBsYWNlRXJyb3IoXCJJbnNlcnRlZCBjb250ZW50IGRlZXBlciB0aGFuIGluc2VydGlvbiBwb3NpdGlvblwiKSB9XG4gIGlmICgkZnJvbS5kZXB0aCAtIHNsaWNlLm9wZW5TdGFydCAhPSAkdG8uZGVwdGggLSBzbGljZS5vcGVuRW5kKVxuICAgIHsgdGhyb3cgbmV3IFJlcGxhY2VFcnJvcihcIkluY29uc2lzdGVudCBvcGVuIGRlcHRoc1wiKSB9XG4gIHJldHVybiByZXBsYWNlT3V0ZXIoJGZyb20sICR0bywgc2xpY2UsIDApXG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VPdXRlcigkZnJvbSwgJHRvLCBzbGljZSwgZGVwdGgpIHtcbiAgdmFyIGluZGV4ID0gJGZyb20uaW5kZXgoZGVwdGgpLCBub2RlID0gJGZyb20ubm9kZShkZXB0aCk7XG4gIGlmIChpbmRleCA9PSAkdG8uaW5kZXgoZGVwdGgpICYmIGRlcHRoIDwgJGZyb20uZGVwdGggLSBzbGljZS5vcGVuU3RhcnQpIHtcbiAgICB2YXIgaW5uZXIgPSByZXBsYWNlT3V0ZXIoJGZyb20sICR0bywgc2xpY2UsIGRlcHRoICsgMSk7XG4gICAgcmV0dXJuIG5vZGUuY29weShub2RlLmNvbnRlbnQucmVwbGFjZUNoaWxkKGluZGV4LCBpbm5lcikpXG4gIH0gZWxzZSBpZiAoIXNsaWNlLmNvbnRlbnQuc2l6ZSkge1xuICAgIHJldHVybiBjbG9zZShub2RlLCByZXBsYWNlVHdvV2F5KCRmcm9tLCAkdG8sIGRlcHRoKSlcbiAgfSBlbHNlIGlmICghc2xpY2Uub3BlblN0YXJ0ICYmICFzbGljZS5vcGVuRW5kICYmICRmcm9tLmRlcHRoID09IGRlcHRoICYmICR0by5kZXB0aCA9PSBkZXB0aCkgeyAvLyBTaW1wbGUsIGZsYXQgY2FzZVxuICAgIHZhciBwYXJlbnQgPSAkZnJvbS5wYXJlbnQsIGNvbnRlbnQgPSBwYXJlbnQuY29udGVudDtcbiAgICByZXR1cm4gY2xvc2UocGFyZW50LCBjb250ZW50LmN1dCgwLCAkZnJvbS5wYXJlbnRPZmZzZXQpLmFwcGVuZChzbGljZS5jb250ZW50KS5hcHBlbmQoY29udGVudC5jdXQoJHRvLnBhcmVudE9mZnNldCkpKVxuICB9IGVsc2Uge1xuICAgIHZhciByZWYgPSBwcmVwYXJlU2xpY2VGb3JSZXBsYWNlKHNsaWNlLCAkZnJvbSk7XG4gICAgdmFyIHN0YXJ0ID0gcmVmLnN0YXJ0O1xuICAgIHZhciBlbmQgPSByZWYuZW5kO1xuICAgIHJldHVybiBjbG9zZShub2RlLCByZXBsYWNlVGhyZWVXYXkoJGZyb20sIHN0YXJ0LCBlbmQsICR0bywgZGVwdGgpKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrSm9pbihtYWluLCBzdWIpIHtcbiAgaWYgKCFzdWIudHlwZS5jb21wYXRpYmxlQ29udGVudChtYWluLnR5cGUpKVxuICAgIHsgdGhyb3cgbmV3IFJlcGxhY2VFcnJvcihcIkNhbm5vdCBqb2luIFwiICsgc3ViLnR5cGUubmFtZSArIFwiIG9udG8gXCIgKyBtYWluLnR5cGUubmFtZSkgfVxufVxuXG5mdW5jdGlvbiBqb2luYWJsZSgkYmVmb3JlLCAkYWZ0ZXIsIGRlcHRoKSB7XG4gIHZhciBub2RlID0gJGJlZm9yZS5ub2RlKGRlcHRoKTtcbiAgY2hlY2tKb2luKG5vZGUsICRhZnRlci5ub2RlKGRlcHRoKSk7XG4gIHJldHVybiBub2RlXG59XG5cbmZ1bmN0aW9uIGFkZE5vZGUoY2hpbGQsIHRhcmdldCkge1xuICB2YXIgbGFzdCA9IHRhcmdldC5sZW5ndGggLSAxO1xuICBpZiAobGFzdCA+PSAwICYmIGNoaWxkLmlzVGV4dCAmJiBjaGlsZC5zYW1lTWFya3VwKHRhcmdldFtsYXN0XSkpXG4gICAgeyB0YXJnZXRbbGFzdF0gPSBjaGlsZC53aXRoVGV4dCh0YXJnZXRbbGFzdF0udGV4dCArIGNoaWxkLnRleHQpOyB9XG4gIGVsc2VcbiAgICB7IHRhcmdldC5wdXNoKGNoaWxkKTsgfVxufVxuXG5mdW5jdGlvbiBhZGRSYW5nZSgkc3RhcnQsICRlbmQsIGRlcHRoLCB0YXJnZXQpIHtcbiAgdmFyIG5vZGUgPSAoJGVuZCB8fCAkc3RhcnQpLm5vZGUoZGVwdGgpO1xuICB2YXIgc3RhcnRJbmRleCA9IDAsIGVuZEluZGV4ID0gJGVuZCA/ICRlbmQuaW5kZXgoZGVwdGgpIDogbm9kZS5jaGlsZENvdW50O1xuICBpZiAoJHN0YXJ0KSB7XG4gICAgc3RhcnRJbmRleCA9ICRzdGFydC5pbmRleChkZXB0aCk7XG4gICAgaWYgKCRzdGFydC5kZXB0aCA+IGRlcHRoKSB7XG4gICAgICBzdGFydEluZGV4Kys7XG4gICAgfSBlbHNlIGlmICgkc3RhcnQudGV4dE9mZnNldCkge1xuICAgICAgYWRkTm9kZSgkc3RhcnQubm9kZUFmdGVyLCB0YXJnZXQpO1xuICAgICAgc3RhcnRJbmRleCsrO1xuICAgIH1cbiAgfVxuICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA8IGVuZEluZGV4OyBpKyspIHsgYWRkTm9kZShub2RlLmNoaWxkKGkpLCB0YXJnZXQpOyB9XG4gIGlmICgkZW5kICYmICRlbmQuZGVwdGggPT0gZGVwdGggJiYgJGVuZC50ZXh0T2Zmc2V0KVxuICAgIHsgYWRkTm9kZSgkZW5kLm5vZGVCZWZvcmUsIHRhcmdldCk7IH1cbn1cblxuZnVuY3Rpb24gY2xvc2Uobm9kZSwgY29udGVudCkge1xuICBpZiAoIW5vZGUudHlwZS52YWxpZENvbnRlbnQoY29udGVudCkpXG4gICAgeyB0aHJvdyBuZXcgUmVwbGFjZUVycm9yKFwiSW52YWxpZCBjb250ZW50IGZvciBub2RlIFwiICsgbm9kZS50eXBlLm5hbWUpIH1cbiAgcmV0dXJuIG5vZGUuY29weShjb250ZW50KVxufVxuXG5mdW5jdGlvbiByZXBsYWNlVGhyZWVXYXkoJGZyb20sICRzdGFydCwgJGVuZCwgJHRvLCBkZXB0aCkge1xuICB2YXIgb3BlblN0YXJ0ID0gJGZyb20uZGVwdGggPiBkZXB0aCAmJiBqb2luYWJsZSgkZnJvbSwgJHN0YXJ0LCBkZXB0aCArIDEpO1xuICB2YXIgb3BlbkVuZCA9ICR0by5kZXB0aCA+IGRlcHRoICYmIGpvaW5hYmxlKCRlbmQsICR0bywgZGVwdGggKyAxKTtcblxuICB2YXIgY29udGVudCA9IFtdO1xuICBhZGRSYW5nZShudWxsLCAkZnJvbSwgZGVwdGgsIGNvbnRlbnQpO1xuICBpZiAob3BlblN0YXJ0ICYmIG9wZW5FbmQgJiYgJHN0YXJ0LmluZGV4KGRlcHRoKSA9PSAkZW5kLmluZGV4KGRlcHRoKSkge1xuICAgIGNoZWNrSm9pbihvcGVuU3RhcnQsIG9wZW5FbmQpO1xuICAgIGFkZE5vZGUoY2xvc2Uob3BlblN0YXJ0LCByZXBsYWNlVGhyZWVXYXkoJGZyb20sICRzdGFydCwgJGVuZCwgJHRvLCBkZXB0aCArIDEpKSwgY29udGVudCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKG9wZW5TdGFydClcbiAgICAgIHsgYWRkTm9kZShjbG9zZShvcGVuU3RhcnQsIHJlcGxhY2VUd29XYXkoJGZyb20sICRzdGFydCwgZGVwdGggKyAxKSksIGNvbnRlbnQpOyB9XG4gICAgYWRkUmFuZ2UoJHN0YXJ0LCAkZW5kLCBkZXB0aCwgY29udGVudCk7XG4gICAgaWYgKG9wZW5FbmQpXG4gICAgICB7IGFkZE5vZGUoY2xvc2Uob3BlbkVuZCwgcmVwbGFjZVR3b1dheSgkZW5kLCAkdG8sIGRlcHRoICsgMSkpLCBjb250ZW50KTsgfVxuICB9XG4gIGFkZFJhbmdlKCR0bywgbnVsbCwgZGVwdGgsIGNvbnRlbnQpO1xuICByZXR1cm4gbmV3IEZyYWdtZW50KGNvbnRlbnQpXG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VUd29XYXkoJGZyb20sICR0bywgZGVwdGgpIHtcbiAgdmFyIGNvbnRlbnQgPSBbXTtcbiAgYWRkUmFuZ2UobnVsbCwgJGZyb20sIGRlcHRoLCBjb250ZW50KTtcbiAgaWYgKCRmcm9tLmRlcHRoID4gZGVwdGgpIHtcbiAgICB2YXIgdHlwZSA9IGpvaW5hYmxlKCRmcm9tLCAkdG8sIGRlcHRoICsgMSk7XG4gICAgYWRkTm9kZShjbG9zZSh0eXBlLCByZXBsYWNlVHdvV2F5KCRmcm9tLCAkdG8sIGRlcHRoICsgMSkpLCBjb250ZW50KTtcbiAgfVxuICBhZGRSYW5nZSgkdG8sIG51bGwsIGRlcHRoLCBjb250ZW50KTtcbiAgcmV0dXJuIG5ldyBGcmFnbWVudChjb250ZW50KVxufVxuXG5mdW5jdGlvbiBwcmVwYXJlU2xpY2VGb3JSZXBsYWNlKHNsaWNlLCAkYWxvbmcpIHtcbiAgdmFyIGV4dHJhID0gJGFsb25nLmRlcHRoIC0gc2xpY2Uub3BlblN0YXJ0LCBwYXJlbnQgPSAkYWxvbmcubm9kZShleHRyYSk7XG4gIHZhciBub2RlID0gcGFyZW50LmNvcHkoc2xpY2UuY29udGVudCk7XG4gIGZvciAodmFyIGkgPSBleHRyYSAtIDE7IGkgPj0gMDsgaS0tKVxuICAgIHsgbm9kZSA9ICRhbG9uZy5ub2RlKGkpLmNvcHkoRnJhZ21lbnQuZnJvbShub2RlKSk7IH1cbiAgcmV0dXJuIHtzdGFydDogbm9kZS5yZXNvbHZlTm9DYWNoZShzbGljZS5vcGVuU3RhcnQgKyBleHRyYSksXG4gICAgICAgICAgZW5kOiBub2RlLnJlc29sdmVOb0NhY2hlKG5vZGUuY29udGVudC5zaXplIC0gc2xpY2Uub3BlbkVuZCAtIGV4dHJhKX1cbn1cblxuLy8gOjotIFlvdSBjYW4gW19yZXNvbHZlX10oI21vZGVsLk5vZGUucmVzb2x2ZSkgYSBwb3NpdGlvbiB0byBnZXQgbW9yZVxuLy8gaW5mb3JtYXRpb24gYWJvdXQgaXQuIE9iamVjdHMgb2YgdGhpcyBjbGFzcyByZXByZXNlbnQgc3VjaCBhXG4vLyByZXNvbHZlZCBwb3NpdGlvbiwgcHJvdmlkaW5nIHZhcmlvdXMgcGllY2VzIG9mIGNvbnRleHQgaW5mb3JtYXRpb24sXG4vLyBhbmQgc29tZSBoZWxwZXIgbWV0aG9kcy5cbi8vXG4vLyBUaHJvdWdob3V0IHRoaXMgaW50ZXJmYWNlLCBtZXRob2RzIHRoYXQgdGFrZSBhbiBvcHRpb25hbCBgZGVwdGhgXG4vLyBwYXJhbWV0ZXIgd2lsbCBpbnRlcnByZXQgdW5kZWZpbmVkIGFzIGB0aGlzLmRlcHRoYCBhbmQgbmVnYXRpdmVcbi8vIG51bWJlcnMgYXMgYHRoaXMuZGVwdGggKyB2YWx1ZWAuXG52YXIgUmVzb2x2ZWRQb3MgPSBmdW5jdGlvbiBSZXNvbHZlZFBvcyhwb3MsIHBhdGgsIHBhcmVudE9mZnNldCkge1xuICAvLyA6OiBudW1iZXIgVGhlIHBvc2l0aW9uIHRoYXQgd2FzIHJlc29sdmVkLlxuICB0aGlzLnBvcyA9IHBvcztcbiAgdGhpcy5wYXRoID0gcGF0aDtcbiAgLy8gOjogbnVtYmVyXG4gIC8vIFRoZSBudW1iZXIgb2YgbGV2ZWxzIHRoZSBwYXJlbnQgbm9kZSBpcyBmcm9tIHRoZSByb290LiBJZiB0aGlzXG4gIC8vIHBvc2l0aW9uIHBvaW50cyBkaXJlY3RseSBpbnRvIHRoZSByb290IG5vZGUsIGl0IGlzIDAuIElmIGl0XG4gIC8vIHBvaW50cyBpbnRvIGEgdG9wLWxldmVsIHBhcmFncmFwaCwgMSwgYW5kIHNvIG9uLlxuICB0aGlzLmRlcHRoID0gcGF0aC5sZW5ndGggLyAzIC0gMTtcbiAgLy8gOjogbnVtYmVyIFRoZSBvZmZzZXQgdGhpcyBwb3NpdGlvbiBoYXMgaW50byBpdHMgcGFyZW50IG5vZGUuXG4gIHRoaXMucGFyZW50T2Zmc2V0ID0gcGFyZW50T2Zmc2V0O1xufTtcblxudmFyIHByb3RvdHlwZUFjY2Vzc29ycyQyID0geyBwYXJlbnQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sZG9jOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LHRleHRPZmZzZXQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sbm9kZUFmdGVyOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LG5vZGVCZWZvcmU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxuUmVzb2x2ZWRQb3MucHJvdG90eXBlLnJlc29sdmVEZXB0aCA9IGZ1bmN0aW9uIHJlc29sdmVEZXB0aCAodmFsKSB7XG4gIGlmICh2YWwgPT0gbnVsbCkgeyByZXR1cm4gdGhpcy5kZXB0aCB9XG4gIGlmICh2YWwgPCAwKSB7IHJldHVybiB0aGlzLmRlcHRoICsgdmFsIH1cbiAgcmV0dXJuIHZhbFxufTtcblxuLy8gOjogTm9kZVxuLy8gVGhlIHBhcmVudCBub2RlIHRoYXQgdGhlIHBvc2l0aW9uIHBvaW50cyBpbnRvLiBOb3RlIHRoYXQgZXZlbiBpZlxuLy8gYSBwb3NpdGlvbiBwb2ludHMgaW50byBhIHRleHQgbm9kZSwgdGhhdCBub2RlIGlzIG5vdCBjb25zaWRlcmVkXG4vLyB0aGUgcGFyZW504oCUdGV4dCBub2RlcyBhcmUg4oCYZmxhdOKAmSBpbiB0aGlzIG1vZGVsLCBhbmQgaGF2ZSBubyBjb250ZW50LlxucHJvdG90eXBlQWNjZXNzb3JzJDIucGFyZW50LmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubm9kZSh0aGlzLmRlcHRoKSB9O1xuXG4vLyA6OiBOb2RlXG4vLyBUaGUgcm9vdCBub2RlIGluIHdoaWNoIHRoZSBwb3NpdGlvbiB3YXMgcmVzb2x2ZWQuXG5wcm90b3R5cGVBY2Nlc3NvcnMkMi5kb2MuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5ub2RlKDApIH07XG5cbi8vIDo6ICg/bnVtYmVyKSDihpIgTm9kZVxuLy8gVGhlIGFuY2VzdG9yIG5vZGUgYXQgdGhlIGdpdmVuIGxldmVsLiBgcC5ub2RlKHAuZGVwdGgpYCBpcyB0aGVcbi8vIHNhbWUgYXMgYHAucGFyZW50YC5cblJlc29sdmVkUG9zLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24gbm9kZSAoZGVwdGgpIHsgcmV0dXJuIHRoaXMucGF0aFt0aGlzLnJlc29sdmVEZXB0aChkZXB0aCkgKiAzXSB9O1xuXG4vLyA6OiAoP251bWJlcikg4oaSIG51bWJlclxuLy8gVGhlIGluZGV4IGludG8gdGhlIGFuY2VzdG9yIGF0IHRoZSBnaXZlbiBsZXZlbC4gSWYgdGhpcyBwb2ludHMgYXRcbi8vIHRoZSAzcmQgbm9kZSBpbiB0aGUgMm5kIHBhcmFncmFwaCBvbiB0aGUgdG9wIGxldmVsLCBmb3IgZXhhbXBsZSxcbi8vIGBwLmluZGV4KDApYCBpcyAxIGFuZCBgcC5pbmRleCgxKWAgaXMgMi5cblJlc29sdmVkUG9zLnByb3RvdHlwZS5pbmRleCA9IGZ1bmN0aW9uIGluZGV4IChkZXB0aCkgeyByZXR1cm4gdGhpcy5wYXRoW3RoaXMucmVzb2x2ZURlcHRoKGRlcHRoKSAqIDMgKyAxXSB9O1xuXG4vLyA6OiAoP251bWJlcikg4oaSIG51bWJlclxuLy8gVGhlIGluZGV4IHBvaW50aW5nIGFmdGVyIHRoaXMgcG9zaXRpb24gaW50byB0aGUgYW5jZXN0b3IgYXQgdGhlXG4vLyBnaXZlbiBsZXZlbC5cblJlc29sdmVkUG9zLnByb3RvdHlwZS5pbmRleEFmdGVyID0gZnVuY3Rpb24gaW5kZXhBZnRlciAoZGVwdGgpIHtcbiAgZGVwdGggPSB0aGlzLnJlc29sdmVEZXB0aChkZXB0aCk7XG4gIHJldHVybiB0aGlzLmluZGV4KGRlcHRoKSArIChkZXB0aCA9PSB0aGlzLmRlcHRoICYmICF0aGlzLnRleHRPZmZzZXQgPyAwIDogMSlcbn07XG5cbi8vIDo6ICg/bnVtYmVyKSDihpIgbnVtYmVyXG4vLyBUaGUgKGFic29sdXRlKSBwb3NpdGlvbiBhdCB0aGUgc3RhcnQgb2YgdGhlIG5vZGUgYXQgdGhlIGdpdmVuXG4vLyBsZXZlbC5cblJlc29sdmVkUG9zLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uIHN0YXJ0IChkZXB0aCkge1xuICBkZXB0aCA9IHRoaXMucmVzb2x2ZURlcHRoKGRlcHRoKTtcbiAgcmV0dXJuIGRlcHRoID09IDAgPyAwIDogdGhpcy5wYXRoW2RlcHRoICogMyAtIDFdICsgMVxufTtcblxuLy8gOjogKD9udW1iZXIpIOKGkiBudW1iZXJcbi8vIFRoZSAoYWJzb2x1dGUpIHBvc2l0aW9uIGF0IHRoZSBlbmQgb2YgdGhlIG5vZGUgYXQgdGhlIGdpdmVuXG4vLyBsZXZlbC5cblJlc29sdmVkUG9zLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiBlbmQgKGRlcHRoKSB7XG4gIGRlcHRoID0gdGhpcy5yZXNvbHZlRGVwdGgoZGVwdGgpO1xuICByZXR1cm4gdGhpcy5zdGFydChkZXB0aCkgKyB0aGlzLm5vZGUoZGVwdGgpLmNvbnRlbnQuc2l6ZVxufTtcblxuLy8gOjogKD9udW1iZXIpIOKGkiBudW1iZXJcbi8vIFRoZSAoYWJzb2x1dGUpIHBvc2l0aW9uIGRpcmVjdGx5IGJlZm9yZSB0aGUgd3JhcHBpbmcgbm9kZSBhdCB0aGVcbi8vIGdpdmVuIGxldmVsLCBvciwgd2hlbiBgZGVwdGhgIGlzIGB0aGlzLmRlcHRoICsgMWAsIHRoZSBvcmlnaW5hbFxuLy8gcG9zaXRpb24uXG5SZXNvbHZlZFBvcy5wcm90b3R5cGUuYmVmb3JlID0gZnVuY3Rpb24gYmVmb3JlIChkZXB0aCkge1xuICBkZXB0aCA9IHRoaXMucmVzb2x2ZURlcHRoKGRlcHRoKTtcbiAgaWYgKCFkZXB0aCkgeyB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZXJlIGlzIG5vIHBvc2l0aW9uIGJlZm9yZSB0aGUgdG9wLWxldmVsIG5vZGVcIikgfVxuICByZXR1cm4gZGVwdGggPT0gdGhpcy5kZXB0aCArIDEgPyB0aGlzLnBvcyA6IHRoaXMucGF0aFtkZXB0aCAqIDMgLSAxXVxufTtcblxuLy8gOjogKD9udW1iZXIpIOKGkiBudW1iZXJcbi8vIFRoZSAoYWJzb2x1dGUpIHBvc2l0aW9uIGRpcmVjdGx5IGFmdGVyIHRoZSB3cmFwcGluZyBub2RlIGF0IHRoZVxuLy8gZ2l2ZW4gbGV2ZWwsIG9yIHRoZSBvcmlnaW5hbCBwb3NpdGlvbiB3aGVuIGBkZXB0aGAgaXMgYHRoaXMuZGVwdGggKyAxYC5cblJlc29sdmVkUG9zLnByb3RvdHlwZS5hZnRlciA9IGZ1bmN0aW9uIGFmdGVyIChkZXB0aCkge1xuICBkZXB0aCA9IHRoaXMucmVzb2x2ZURlcHRoKGRlcHRoKTtcbiAgaWYgKCFkZXB0aCkgeyB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZXJlIGlzIG5vIHBvc2l0aW9uIGFmdGVyIHRoZSB0b3AtbGV2ZWwgbm9kZVwiKSB9XG4gIHJldHVybiBkZXB0aCA9PSB0aGlzLmRlcHRoICsgMSA/IHRoaXMucG9zIDogdGhpcy5wYXRoW2RlcHRoICogMyAtIDFdICsgdGhpcy5wYXRoW2RlcHRoICogM10ubm9kZVNpemVcbn07XG5cbi8vIDo6IG51bWJlclxuLy8gV2hlbiB0aGlzIHBvc2l0aW9uIHBvaW50cyBpbnRvIGEgdGV4dCBub2RlLCB0aGlzIHJldHVybnMgdGhlXG4vLyBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBwb3NpdGlvbiBhbmQgdGhlIHN0YXJ0IG9mIHRoZSB0ZXh0IG5vZGUuXG4vLyBXaWxsIGJlIHplcm8gZm9yIHBvc2l0aW9ucyB0aGF0IHBvaW50IGJldHdlZW4gbm9kZXMuXG5wcm90b3R5cGVBY2Nlc3NvcnMkMi50ZXh0T2Zmc2V0LmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucG9zIC0gdGhpcy5wYXRoW3RoaXMucGF0aC5sZW5ndGggLSAxXSB9O1xuXG4vLyA6OiA/Tm9kZVxuLy8gR2V0IHRoZSBub2RlIGRpcmVjdGx5IGFmdGVyIHRoZSBwb3NpdGlvbiwgaWYgYW55LiBJZiB0aGUgcG9zaXRpb25cbi8vIHBvaW50cyBpbnRvIGEgdGV4dCBub2RlLCBvbmx5IHRoZSBwYXJ0IG9mIHRoYXQgbm9kZSBhZnRlciB0aGVcbi8vIHBvc2l0aW9uIGlzIHJldHVybmVkLlxucHJvdG90eXBlQWNjZXNzb3JzJDIubm9kZUFmdGVyLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50LCBpbmRleCA9IHRoaXMuaW5kZXgodGhpcy5kZXB0aCk7XG4gIGlmIChpbmRleCA9PSBwYXJlbnQuY2hpbGRDb3VudCkgeyByZXR1cm4gbnVsbCB9XG4gIHZhciBkT2ZmID0gdGhpcy5wb3MgLSB0aGlzLnBhdGhbdGhpcy5wYXRoLmxlbmd0aCAtIDFdLCBjaGlsZCA9IHBhcmVudC5jaGlsZChpbmRleCk7XG4gIHJldHVybiBkT2ZmID8gcGFyZW50LmNoaWxkKGluZGV4KS5jdXQoZE9mZikgOiBjaGlsZFxufTtcblxuLy8gOjogP05vZGVcbi8vIEdldCB0aGUgbm9kZSBkaXJlY3RseSBiZWZvcmUgdGhlIHBvc2l0aW9uLCBpZiBhbnkuIElmIHRoZVxuLy8gcG9zaXRpb24gcG9pbnRzIGludG8gYSB0ZXh0IG5vZGUsIG9ubHkgdGhlIHBhcnQgb2YgdGhhdCBub2RlXG4vLyBiZWZvcmUgdGhlIHBvc2l0aW9uIGlzIHJldHVybmVkLlxucHJvdG90eXBlQWNjZXNzb3JzJDIubm9kZUJlZm9yZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpbmRleCA9IHRoaXMuaW5kZXgodGhpcy5kZXB0aCk7XG4gIHZhciBkT2ZmID0gdGhpcy5wb3MgLSB0aGlzLnBhdGhbdGhpcy5wYXRoLmxlbmd0aCAtIDFdO1xuICBpZiAoZE9mZikgeyByZXR1cm4gdGhpcy5wYXJlbnQuY2hpbGQoaW5kZXgpLmN1dCgwLCBkT2ZmKSB9XG4gIHJldHVybiBpbmRleCA9PSAwID8gbnVsbCA6IHRoaXMucGFyZW50LmNoaWxkKGluZGV4IC0gMSlcbn07XG5cbi8vIDo6IChudW1iZXIsID9udW1iZXIpIOKGkiBudW1iZXJcbi8vIEdldCB0aGUgcG9zaXRpb24gYXQgdGhlIGdpdmVuIGluZGV4IGluIHRoZSBwYXJlbnQgbm9kZSBhdCB0aGVcbi8vIGdpdmVuIGRlcHRoICh3aGljaCBkZWZhdWx0cyB0byBgdGhpcy5kZXB0aGApLlxuUmVzb2x2ZWRQb3MucHJvdG90eXBlLnBvc0F0SW5kZXggPSBmdW5jdGlvbiBwb3NBdEluZGV4IChpbmRleCwgZGVwdGgpIHtcbiAgZGVwdGggPSB0aGlzLnJlc29sdmVEZXB0aChkZXB0aCk7XG4gIHZhciBub2RlID0gdGhpcy5wYXRoW2RlcHRoICogM10sIHBvcyA9IGRlcHRoID09IDAgPyAwIDogdGhpcy5wYXRoW2RlcHRoICogMyAtIDFdICsgMTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmRleDsgaSsrKSB7IHBvcyArPSBub2RlLmNoaWxkKGkpLm5vZGVTaXplOyB9XG4gIHJldHVybiBwb3Ncbn07XG5cbi8vIDo6ICgpIOKGkiBbTWFya11cbi8vIEdldCB0aGUgbWFya3MgYXQgdGhpcyBwb3NpdGlvbiwgZmFjdG9yaW5nIGluIHRoZSBzdXJyb3VuZGluZ1xuLy8gbWFya3MnIFtgaW5jbHVzaXZlYF0oI21vZGVsLk1hcmtTcGVjLmluY2x1c2l2ZSkgcHJvcGVydHkuIElmIHRoZVxuLy8gcG9zaXRpb24gaXMgYXQgdGhlIHN0YXJ0IG9mIGEgbm9uLWVtcHR5IG5vZGUsIHRoZSBtYXJrcyBvZiB0aGVcbi8vIG5vZGUgYWZ0ZXIgaXQgKGlmIGFueSkgYXJlIHJldHVybmVkLlxuUmVzb2x2ZWRQb3MucHJvdG90eXBlLm1hcmtzID0gZnVuY3Rpb24gbWFya3MgKCkge1xuICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQsIGluZGV4ID0gdGhpcy5pbmRleCgpO1xuXG4gIC8vIEluIGFuIGVtcHR5IHBhcmVudCwgcmV0dXJuIHRoZSBlbXB0eSBhcnJheVxuICBpZiAocGFyZW50LmNvbnRlbnQuc2l6ZSA9PSAwKSB7IHJldHVybiBNYXJrLm5vbmUgfVxuXG4gIC8vIFdoZW4gaW5zaWRlIGEgdGV4dCBub2RlLCBqdXN0IHJldHVybiB0aGUgdGV4dCBub2RlJ3MgbWFya3NcbiAgaWYgKHRoaXMudGV4dE9mZnNldCkgeyByZXR1cm4gcGFyZW50LmNoaWxkKGluZGV4KS5tYXJrcyB9XG5cbiAgdmFyIG1haW4gPSBwYXJlbnQubWF5YmVDaGlsZChpbmRleCAtIDEpLCBvdGhlciA9IHBhcmVudC5tYXliZUNoaWxkKGluZGV4KTtcbiAgLy8gSWYgdGhlIGBhZnRlcmAgZmxhZyBpcyB0cnVlIG9mIHRoZXJlIGlzIG5vIG5vZGUgYmVmb3JlLCBtYWtlXG4gIC8vIHRoZSBub2RlIGFmdGVyIHRoaXMgcG9zaXRpb24gdGhlIG1haW4gcmVmZXJlbmNlLlxuICBpZiAoIW1haW4pIHsgdmFyIHRtcCA9IG1haW47IG1haW4gPSBvdGhlcjsgb3RoZXIgPSB0bXA7IH1cblxuICAvLyBVc2UgYWxsIG1hcmtzIGluIHRoZSBtYWluIG5vZGUsIGV4Y2VwdCB0aG9zZSB0aGF0IGhhdmVcbiAgLy8gYGluY2x1c2l2ZWAgc2V0IHRvIGZhbHNlIGFuZCBhcmUgbm90IHByZXNlbnQgaW4gdGhlIG90aGVyIG5vZGUuXG4gIHZhciBtYXJrcyA9IG1haW4ubWFya3M7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWFya3MubGVuZ3RoOyBpKyspXG4gICAgeyBpZiAobWFya3NbaV0udHlwZS5zcGVjLmluY2x1c2l2ZSA9PT0gZmFsc2UgJiYgKCFvdGhlciB8fCAhbWFya3NbaV0uaXNJblNldChvdGhlci5tYXJrcykpKVxuICAgICAgeyBtYXJrcyA9IG1hcmtzW2ktLV0ucmVtb3ZlRnJvbVNldChtYXJrcyk7IH0gfVxuXG4gIHJldHVybiBtYXJrc1xufTtcblxuLy8gOjogKFJlc29sdmVkUG9zKSDihpIgP1tNYXJrXVxuLy8gR2V0IHRoZSBtYXJrcyBhZnRlciB0aGUgY3VycmVudCBwb3NpdGlvbiwgaWYgYW55LCBleGNlcHQgdGhvc2Vcbi8vIHRoYXQgYXJlIG5vbi1pbmNsdXNpdmUgYW5kIG5vdCBwcmVzZW50IGF0IHBvc2l0aW9uIGAkZW5kYC4gVGhpc1xuLy8gaXMgbW9zdGx5IHVzZWZ1bCBmb3IgZ2V0dGluZyB0aGUgc2V0IG9mIG1hcmtzIHRvIHByZXNlcnZlIGFmdGVyIGFcbi8vIGRlbGV0aW9uLiBXaWxsIHJldHVybiBgbnVsbGAgaWYgdGhpcyBwb3NpdGlvbiBpcyBhdCB0aGUgZW5kIG9mXG4vLyBpdHMgcGFyZW50IG5vZGUgb3IgaXRzIHBhcmVudCBub2RlIGlzbid0IGEgdGV4dGJsb2NrIChpbiB3aGljaFxuLy8gY2FzZSBubyBtYXJrcyBzaG91bGQgYmUgcHJlc2VydmVkKS5cblJlc29sdmVkUG9zLnByb3RvdHlwZS5tYXJrc0Fjcm9zcyA9IGZ1bmN0aW9uIG1hcmtzQWNyb3NzICgkZW5kKSB7XG4gIHZhciBhZnRlciA9IHRoaXMucGFyZW50Lm1heWJlQ2hpbGQodGhpcy5pbmRleCgpKTtcbiAgaWYgKCFhZnRlciB8fCAhYWZ0ZXIuaXNJbmxpbmUpIHsgcmV0dXJuIG51bGwgfVxuXG4gIHZhciBtYXJrcyA9IGFmdGVyLm1hcmtzLCBuZXh0ID0gJGVuZC5wYXJlbnQubWF5YmVDaGlsZCgkZW5kLmluZGV4KCkpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcmtzLmxlbmd0aDsgaSsrKVxuICAgIHsgaWYgKG1hcmtzW2ldLnR5cGUuc3BlYy5pbmNsdXNpdmUgPT09IGZhbHNlICYmICghbmV4dCB8fCAhbWFya3NbaV0uaXNJblNldChuZXh0Lm1hcmtzKSkpXG4gICAgICB7IG1hcmtzID0gbWFya3NbaS0tXS5yZW1vdmVGcm9tU2V0KG1hcmtzKTsgfSB9XG4gIHJldHVybiBtYXJrc1xufTtcblxuLy8gOjogKG51bWJlcikg4oaSIG51bWJlclxuLy8gVGhlIGRlcHRoIHVwIHRvIHdoaWNoIHRoaXMgcG9zaXRpb24gYW5kIHRoZSBnaXZlbiAobm9uLXJlc29sdmVkKVxuLy8gcG9zaXRpb24gc2hhcmUgdGhlIHNhbWUgcGFyZW50IG5vZGVzLlxuUmVzb2x2ZWRQb3MucHJvdG90eXBlLnNoYXJlZERlcHRoID0gZnVuY3Rpb24gc2hhcmVkRGVwdGggKHBvcykge1xuICBmb3IgKHZhciBkZXB0aCA9IHRoaXMuZGVwdGg7IGRlcHRoID4gMDsgZGVwdGgtLSlcbiAgICB7IGlmICh0aGlzLnN0YXJ0KGRlcHRoKSA8PSBwb3MgJiYgdGhpcy5lbmQoZGVwdGgpID49IHBvcykgeyByZXR1cm4gZGVwdGggfSB9XG4gIHJldHVybiAwXG59O1xuXG4vLyA6OiAoP1Jlc29sdmVkUG9zLCA/KE5vZGUpIOKGkiBib29sKSDihpIgP05vZGVSYW5nZVxuLy8gUmV0dXJucyBhIHJhbmdlIGJhc2VkIG9uIHRoZSBwbGFjZSB3aGVyZSB0aGlzIHBvc2l0aW9uIGFuZCB0aGVcbi8vIGdpdmVuIHBvc2l0aW9uIGRpdmVyZ2UgYXJvdW5kIGJsb2NrIGNvbnRlbnQuIElmIGJvdGggcG9pbnQgaW50b1xuLy8gdGhlIHNhbWUgdGV4dGJsb2NrLCBmb3IgZXhhbXBsZSwgYSByYW5nZSBhcm91bmQgdGhhdCB0ZXh0YmxvY2tcbi8vIHdpbGwgYmUgcmV0dXJuZWQuIElmIHRoZXkgcG9pbnQgaW50byBkaWZmZXJlbnQgYmxvY2tzLCB0aGUgcmFuZ2Vcbi8vIGFyb3VuZCB0aG9zZSBibG9ja3MgaW4gdGhlaXIgc2hhcmVkIGFuY2VzdG9yIGlzIHJldHVybmVkLiBZb3UgY2FuXG4vLyBwYXNzIGluIGFuIG9wdGlvbmFsIHByZWRpY2F0ZSB0aGF0IHdpbGwgYmUgY2FsbGVkIHdpdGggYSBwYXJlbnRcbi8vIG5vZGUgdG8gc2VlIGlmIGEgcmFuZ2UgaW50byB0aGF0IHBhcmVudCBpcyBhY2NlcHRhYmxlLlxuUmVzb2x2ZWRQb3MucHJvdG90eXBlLmJsb2NrUmFuZ2UgPSBmdW5jdGlvbiBibG9ja1JhbmdlIChvdGhlciwgcHJlZCkge1xuICAgIGlmICggb3RoZXIgPT09IHZvaWQgMCApIG90aGVyID0gdGhpcztcblxuICBpZiAob3RoZXIucG9zIDwgdGhpcy5wb3MpIHsgcmV0dXJuIG90aGVyLmJsb2NrUmFuZ2UodGhpcykgfVxuICBmb3IgKHZhciBkID0gdGhpcy5kZXB0aCAtICh0aGlzLnBhcmVudC5pbmxpbmVDb250ZW50IHx8IHRoaXMucG9zID09IG90aGVyLnBvcyA/IDEgOiAwKTsgZCA+PSAwOyBkLS0pXG4gICAgeyBpZiAob3RoZXIucG9zIDw9IHRoaXMuZW5kKGQpICYmICghcHJlZCB8fCBwcmVkKHRoaXMubm9kZShkKSkpKVxuICAgICAgeyByZXR1cm4gbmV3IE5vZGVSYW5nZSh0aGlzLCBvdGhlciwgZCkgfSB9XG59O1xuXG4vLyA6OiAoUmVzb2x2ZWRQb3MpIOKGkiBib29sXG4vLyBRdWVyeSB3aGV0aGVyIHRoZSBnaXZlbiBwb3NpdGlvbiBzaGFyZXMgdGhlIHNhbWUgcGFyZW50IG5vZGUuXG5SZXNvbHZlZFBvcy5wcm90b3R5cGUuc2FtZVBhcmVudCA9IGZ1bmN0aW9uIHNhbWVQYXJlbnQgKG90aGVyKSB7XG4gIHJldHVybiB0aGlzLnBvcyAtIHRoaXMucGFyZW50T2Zmc2V0ID09IG90aGVyLnBvcyAtIG90aGVyLnBhcmVudE9mZnNldFxufTtcblxuLy8gOjogKFJlc29sdmVkUG9zKSDihpIgUmVzb2x2ZWRQb3Ncbi8vIFJldHVybiB0aGUgZ3JlYXRlciBvZiB0aGlzIGFuZCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG5SZXNvbHZlZFBvcy5wcm90b3R5cGUubWF4ID0gZnVuY3Rpb24gbWF4IChvdGhlcikge1xuICByZXR1cm4gb3RoZXIucG9zID4gdGhpcy5wb3MgPyBvdGhlciA6IHRoaXNcbn07XG5cbi8vIDo6IChSZXNvbHZlZFBvcykg4oaSIFJlc29sdmVkUG9zXG4vLyBSZXR1cm4gdGhlIHNtYWxsZXIgb2YgdGhpcyBhbmQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuUmVzb2x2ZWRQb3MucHJvdG90eXBlLm1pbiA9IGZ1bmN0aW9uIG1pbiAob3RoZXIpIHtcbiAgcmV0dXJuIG90aGVyLnBvcyA8IHRoaXMucG9zID8gb3RoZXIgOiB0aGlzXG59O1xuXG5SZXNvbHZlZFBvcy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBzdHIgPSBcIlwiO1xuICBmb3IgKHZhciBpID0gMTsgaSA8PSB0aGlzLmRlcHRoOyBpKyspXG4gICAgeyBzdHIgKz0gKHN0ciA/IFwiL1wiIDogXCJcIikgKyB0aGlzLm5vZGUoaSkudHlwZS5uYW1lICsgXCJfXCIgKyB0aGlzLmluZGV4KGkgLSAxKTsgfVxuICByZXR1cm4gc3RyICsgXCI6XCIgKyB0aGlzLnBhcmVudE9mZnNldFxufTtcblxuUmVzb2x2ZWRQb3MucmVzb2x2ZSA9IGZ1bmN0aW9uIHJlc29sdmUgKGRvYywgcG9zKSB7XG4gIGlmICghKHBvcyA+PSAwICYmIHBvcyA8PSBkb2MuY29udGVudC5zaXplKSkgeyB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlBvc2l0aW9uIFwiICsgcG9zICsgXCIgb3V0IG9mIHJhbmdlXCIpIH1cbiAgdmFyIHBhdGggPSBbXTtcbiAgdmFyIHN0YXJ0ID0gMCwgcGFyZW50T2Zmc2V0ID0gcG9zO1xuICBmb3IgKHZhciBub2RlID0gZG9jOzspIHtcbiAgICB2YXIgcmVmID0gbm9kZS5jb250ZW50LmZpbmRJbmRleChwYXJlbnRPZmZzZXQpO1xuICAgICAgdmFyIGluZGV4ID0gcmVmLmluZGV4O1xuICAgICAgdmFyIG9mZnNldCA9IHJlZi5vZmZzZXQ7XG4gICAgdmFyIHJlbSA9IHBhcmVudE9mZnNldCAtIG9mZnNldDtcbiAgICBwYXRoLnB1c2gobm9kZSwgaW5kZXgsIHN0YXJ0ICsgb2Zmc2V0KTtcbiAgICBpZiAoIXJlbSkgeyBicmVhayB9XG4gICAgbm9kZSA9IG5vZGUuY2hpbGQoaW5kZXgpO1xuICAgIGlmIChub2RlLmlzVGV4dCkgeyBicmVhayB9XG4gICAgcGFyZW50T2Zmc2V0ID0gcmVtIC0gMTtcbiAgICBzdGFydCArPSBvZmZzZXQgKyAxO1xuICB9XG4gIHJldHVybiBuZXcgUmVzb2x2ZWRQb3MocG9zLCBwYXRoLCBwYXJlbnRPZmZzZXQpXG59O1xuXG5SZXNvbHZlZFBvcy5yZXNvbHZlQ2FjaGVkID0gZnVuY3Rpb24gcmVzb2x2ZUNhY2hlZCAoZG9jLCBwb3MpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXNvbHZlQ2FjaGUubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2FjaGVkID0gcmVzb2x2ZUNhY2hlW2ldO1xuICAgIGlmIChjYWNoZWQucG9zID09IHBvcyAmJiBjYWNoZWQuZG9jID09IGRvYykgeyByZXR1cm4gY2FjaGVkIH1cbiAgfVxuICB2YXIgcmVzdWx0ID0gcmVzb2x2ZUNhY2hlW3Jlc29sdmVDYWNoZVBvc10gPSBSZXNvbHZlZFBvcy5yZXNvbHZlKGRvYywgcG9zKTtcbiAgcmVzb2x2ZUNhY2hlUG9zID0gKHJlc29sdmVDYWNoZVBvcyArIDEpICUgcmVzb2x2ZUNhY2hlU2l6ZTtcbiAgcmV0dXJuIHJlc3VsdFxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFJlc29sdmVkUG9zLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzJDIgKTtcblxudmFyIHJlc29sdmVDYWNoZSA9IFtdLCByZXNvbHZlQ2FjaGVQb3MgPSAwLCByZXNvbHZlQ2FjaGVTaXplID0gMTI7XG5cbi8vIDo6LSBSZXByZXNlbnRzIGEgZmxhdCByYW5nZSBvZiBjb250ZW50LCBpLmUuIG9uZSB0aGF0IHN0YXJ0cyBhbmRcbi8vIGVuZHMgaW4gdGhlIHNhbWUgbm9kZS5cbnZhciBOb2RlUmFuZ2UgPSBmdW5jdGlvbiBOb2RlUmFuZ2UoJGZyb20sICR0bywgZGVwdGgpIHtcbiAgLy8gOjogUmVzb2x2ZWRQb3MgQSByZXNvbHZlZCBwb3NpdGlvbiBhbG9uZyB0aGUgc3RhcnQgb2YgdGhlXG4gIC8vIGNvbnRlbnQuIE1heSBoYXZlIGEgYGRlcHRoYCBncmVhdGVyIHRoYW4gdGhpcyBvYmplY3QncyBgZGVwdGhgXG4gIC8vIHByb3BlcnR5LCBzaW5jZSB0aGVzZSBhcmUgdGhlIHBvc2l0aW9ucyB0aGF0IHdlcmUgdXNlZCB0b1xuICAvLyBjb21wdXRlIHRoZSByYW5nZSwgbm90IHJlLXJlc29sdmVkIHBvc2l0aW9ucyBkaXJlY3RseSBhdCBpdHNcbiAgLy8gYm91bmRhcmllcy5cbiAgdGhpcy4kZnJvbSA9ICRmcm9tO1xuICAvLyA6OiBSZXNvbHZlZFBvcyBBIHBvc2l0aW9uIGFsb25nIHRoZSBlbmQgb2YgdGhlIGNvbnRlbnQuIFNlZVxuICAvLyBjYXZlYXQgZm9yIFtgJGZyb21gXSgjbW9kZWwuTm9kZVJhbmdlLiRmcm9tKS5cbiAgdGhpcy4kdG8gPSAkdG87XG4gIC8vIDo6IG51bWJlciBUaGUgZGVwdGggb2YgdGhlIG5vZGUgdGhhdCB0aGlzIHJhbmdlIHBvaW50cyBpbnRvLlxuICB0aGlzLmRlcHRoID0gZGVwdGg7XG59O1xuXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzJDEkMSA9IHsgc3RhcnQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sZW5kOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LHBhcmVudDogeyBjb25maWd1cmFibGU6IHRydWUgfSxzdGFydEluZGV4OiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGVuZEluZGV4OiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbi8vIDo6IG51bWJlciBUaGUgcG9zaXRpb24gYXQgdGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbnByb3RvdHlwZUFjY2Vzc29ycyQxJDEuc3RhcnQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy4kZnJvbS5iZWZvcmUodGhpcy5kZXB0aCArIDEpIH07XG4vLyA6OiBudW1iZXIgVGhlIHBvc2l0aW9uIGF0IHRoZSBlbmQgb2YgdGhlIHJhbmdlLlxucHJvdG90eXBlQWNjZXNzb3JzJDEkMS5lbmQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy4kdG8uYWZ0ZXIodGhpcy5kZXB0aCArIDEpIH07XG5cbi8vIDo6IE5vZGUgVGhlIHBhcmVudCBub2RlIHRoYXQgdGhlIHJhbmdlIHBvaW50cyBpbnRvLlxucHJvdG90eXBlQWNjZXNzb3JzJDEkMS5wYXJlbnQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy4kZnJvbS5ub2RlKHRoaXMuZGVwdGgpIH07XG4vLyA6OiBudW1iZXIgVGhlIHN0YXJ0IGluZGV4IG9mIHRoZSByYW5nZSBpbiB0aGUgcGFyZW50IG5vZGUuXG5wcm90b3R5cGVBY2Nlc3NvcnMkMSQxLnN0YXJ0SW5kZXguZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy4kZnJvbS5pbmRleCh0aGlzLmRlcHRoKSB9O1xuLy8gOjogbnVtYmVyIFRoZSBlbmQgaW5kZXggb2YgdGhlIHJhbmdlIGluIHRoZSBwYXJlbnQgbm9kZS5cbnByb3RvdHlwZUFjY2Vzc29ycyQxJDEuZW5kSW5kZXguZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy4kdG8uaW5kZXhBZnRlcih0aGlzLmRlcHRoKSB9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggTm9kZVJhbmdlLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzJDEkMSApO1xuXG52YXIgZW1wdHlBdHRycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbi8vIDo6LSBUaGlzIGNsYXNzIHJlcHJlc2VudHMgYSBub2RlIGluIHRoZSB0cmVlIHRoYXQgbWFrZXMgdXAgYVxuLy8gUHJvc2VNaXJyb3IgZG9jdW1lbnQuIFNvIGEgZG9jdW1lbnQgaXMgYW4gaW5zdGFuY2Ugb2YgYE5vZGVgLCB3aXRoXG4vLyBjaGlsZHJlbiB0aGF0IGFyZSBhbHNvIGluc3RhbmNlcyBvZiBgTm9kZWAuXG4vL1xuLy8gTm9kZXMgYXJlIHBlcnNpc3RlbnQgZGF0YSBzdHJ1Y3R1cmVzLiBJbnN0ZWFkIG9mIGNoYW5naW5nIHRoZW0sIHlvdVxuLy8gY3JlYXRlIG5ldyBvbmVzIHdpdGggdGhlIGNvbnRlbnQgeW91IHdhbnQuIE9sZCBvbmVzIGtlZXAgcG9pbnRpbmdcbi8vIGF0IHRoZSBvbGQgZG9jdW1lbnQgc2hhcGUuIFRoaXMgaXMgbWFkZSBjaGVhcGVyIGJ5IHNoYXJpbmdcbi8vIHN0cnVjdHVyZSBiZXR3ZWVuIHRoZSBvbGQgYW5kIG5ldyBkYXRhIGFzIG11Y2ggYXMgcG9zc2libGUsIHdoaWNoIGFcbi8vIHRyZWUgc2hhcGUgbGlrZSB0aGlzICh3aXRob3V0IGJhY2sgcG9pbnRlcnMpIG1ha2VzIGVhc3kuXG4vL1xuLy8gKipEbyBub3QqKiBkaXJlY3RseSBtdXRhdGUgdGhlIHByb3BlcnRpZXMgb2YgYSBgTm9kZWAgb2JqZWN0LiBTZWVcbi8vIFt0aGUgZ3VpZGVdKC9kb2NzL2d1aWRlLyNkb2MpIGZvciBtb3JlIGluZm9ybWF0aW9uLlxudmFyIE5vZGUgPSBmdW5jdGlvbiBOb2RlKHR5cGUsIGF0dHJzLCBjb250ZW50LCBtYXJrcykge1xuICAvLyA6OiBOb2RlVHlwZVxuICAvLyBUaGUgdHlwZSBvZiBub2RlIHRoYXQgdGhpcyBpcy5cbiAgdGhpcy50eXBlID0gdHlwZTtcblxuICAvLyA6OiBPYmplY3RcbiAgLy8gQW4gb2JqZWN0IG1hcHBpbmcgYXR0cmlidXRlIG5hbWVzIHRvIHZhbHVlcy4gVGhlIGtpbmQgb2ZcbiAgLy8gYXR0cmlidXRlcyBhbGxvd2VkIGFuZCByZXF1aXJlZCBhcmVcbiAgLy8gW2RldGVybWluZWRdKCNtb2RlbC5Ob2RlU3BlYy5hdHRycykgYnkgdGhlIG5vZGUgdHlwZS5cbiAgdGhpcy5hdHRycyA9IGF0dHJzO1xuXG4gIC8vIDo6IEZyYWdtZW50XG4gIC8vIEEgY29udGFpbmVyIGhvbGRpbmcgdGhlIG5vZGUncyBjaGlsZHJlbi5cbiAgdGhpcy5jb250ZW50ID0gY29udGVudCB8fCBGcmFnbWVudC5lbXB0eTtcblxuICAvLyA6OiBbTWFya11cbiAgLy8gVGhlIG1hcmtzICh0aGluZ3MgbGlrZSB3aGV0aGVyIGl0IGlzIGVtcGhhc2l6ZWQgb3IgcGFydCBvZiBhXG4gIC8vIGxpbmspIGFwcGxpZWQgdG8gdGhpcyBub2RlLlxuICB0aGlzLm1hcmtzID0gbWFya3MgfHwgTWFyay5ub25lO1xufTtcblxudmFyIHByb3RvdHlwZUFjY2Vzc29ycyQzID0geyBub2RlU2l6ZTogeyBjb25maWd1cmFibGU6IHRydWUgfSxjaGlsZENvdW50OiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LHRleHRDb250ZW50OiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGZpcnN0Q2hpbGQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sbGFzdENoaWxkOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGlzQmxvY2s6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0saXNUZXh0YmxvY2s6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0saW5saW5lQ29udGVudDogeyBjb25maWd1cmFibGU6IHRydWUgfSxpc0lubGluZTogeyBjb25maWd1cmFibGU6IHRydWUgfSxpc1RleHQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0saXNMZWFmOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGlzQXRvbTogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG4vLyB0ZXh0OjogP3N0cmluZ1xuLy8gRm9yIHRleHQgbm9kZXMsIHRoaXMgY29udGFpbnMgdGhlIG5vZGUncyB0ZXh0IGNvbnRlbnQuXG5cbi8vIDo6IG51bWJlclxuLy8gVGhlIHNpemUgb2YgdGhpcyBub2RlLCBhcyBkZWZpbmVkIGJ5IHRoZSBpbnRlZ2VyLWJhc2VkIFtpbmRleGluZ1xuLy8gc2NoZW1lXSgvZG9jcy9ndWlkZS8jZG9jLmluZGV4aW5nKS4gRm9yIHRleHQgbm9kZXMsIHRoaXMgaXMgdGhlXG4vLyBhbW91bnQgb2YgY2hhcmFjdGVycy4gRm9yIG90aGVyIGxlYWYgbm9kZXMsIGl0IGlzIG9uZS4gRm9yXG4vLyBub24tbGVhZiBub2RlcywgaXQgaXMgdGhlIHNpemUgb2YgdGhlIGNvbnRlbnQgcGx1cyB0d28gKHRoZSBzdGFydFxuLy8gYW5kIGVuZCB0b2tlbikuXG5wcm90b3R5cGVBY2Nlc3NvcnMkMy5ub2RlU2l6ZS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmlzTGVhZiA/IDEgOiAyICsgdGhpcy5jb250ZW50LnNpemUgfTtcblxuLy8gOjogbnVtYmVyXG4vLyBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIHRoYXQgdGhlIG5vZGUgaGFzLlxucHJvdG90eXBlQWNjZXNzb3JzJDMuY2hpbGRDb3VudC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmNvbnRlbnQuY2hpbGRDb3VudCB9O1xuXG4vLyA6OiAobnVtYmVyKSDihpIgTm9kZVxuLy8gR2V0IHRoZSBjaGlsZCBub2RlIGF0IHRoZSBnaXZlbiBpbmRleC4gUmFpc2VzIGFuIGVycm9yIHdoZW4gdGhlXG4vLyBpbmRleCBpcyBvdXQgb2YgcmFuZ2UuXG5Ob2RlLnByb3RvdHlwZS5jaGlsZCA9IGZ1bmN0aW9uIGNoaWxkIChpbmRleCkgeyByZXR1cm4gdGhpcy5jb250ZW50LmNoaWxkKGluZGV4KSB9O1xuXG4vLyA6OiAobnVtYmVyKSDihpIgP05vZGVcbi8vIEdldCB0aGUgY2hpbGQgbm9kZSBhdCB0aGUgZ2l2ZW4gaW5kZXgsIGlmIGl0IGV4aXN0cy5cbk5vZGUucHJvdG90eXBlLm1heWJlQ2hpbGQgPSBmdW5jdGlvbiBtYXliZUNoaWxkIChpbmRleCkgeyByZXR1cm4gdGhpcy5jb250ZW50Lm1heWJlQ2hpbGQoaW5kZXgpIH07XG5cbi8vIDo6ICgobm9kZTogTm9kZSwgb2Zmc2V0OiBudW1iZXIsIGluZGV4OiBudW1iZXIpKVxuLy8gQ2FsbCBgZmAgZm9yIGV2ZXJ5IGNoaWxkIG5vZGUsIHBhc3NpbmcgdGhlIG5vZGUsIGl0cyBvZmZzZXRcbi8vIGludG8gdGhpcyBwYXJlbnQgbm9kZSwgYW5kIGl0cyBpbmRleC5cbk5vZGUucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoIChmKSB7IHRoaXMuY29udGVudC5mb3JFYWNoKGYpOyB9O1xuXG4vLyA6OiAobnVtYmVyLCBudW1iZXIsIChub2RlOiBOb2RlLCBwb3M6IG51bWJlciwgcGFyZW50OiBOb2RlLCBpbmRleDogbnVtYmVyKSDihpIgP2Jvb2wsID9udW1iZXIpXG4vLyBJbnZva2UgYSBjYWxsYmFjayBmb3IgYWxsIGRlc2NlbmRhbnQgbm9kZXMgcmVjdXJzaXZlbHkgYmV0d2VlblxuLy8gdGhlIGdpdmVuIHR3byBwb3NpdGlvbnMgdGhhdCBhcmUgcmVsYXRpdmUgdG8gc3RhcnQgb2YgdGhpcyBub2RlJ3Ncbi8vIGNvbnRlbnQuIFRoZSBjYWxsYmFjayBpcyBpbnZva2VkIHdpdGggdGhlIG5vZGUsIGl0c1xuLy8gcGFyZW50LXJlbGF0aXZlIHBvc2l0aW9uLCBpdHMgcGFyZW50IG5vZGUsIGFuZCBpdHMgY2hpbGQgaW5kZXguXG4vLyBXaGVuIHRoZSBjYWxsYmFjayByZXR1cm5zIGZhbHNlIGZvciBhIGdpdmVuIG5vZGUsIHRoYXQgbm9kZSdzXG4vLyBjaGlsZHJlbiB3aWxsIG5vdCBiZSByZWN1cnNlZCBvdmVyLiBUaGUgbGFzdCBwYXJhbWV0ZXIgY2FuIGJlXG4vLyB1c2VkIHRvIHNwZWNpZnkgYSBzdGFydGluZyBwb3NpdGlvbiB0byBjb3VudCBmcm9tLlxuTm9kZS5wcm90b3R5cGUubm9kZXNCZXR3ZWVuID0gZnVuY3Rpb24gbm9kZXNCZXR3ZWVuIChmcm9tLCB0bywgZiwgc3RhcnRQb3MpIHtcbiAgICBpZiAoIHN0YXJ0UG9zID09PSB2b2lkIDAgKSBzdGFydFBvcyA9IDA7XG5cbiAgdGhpcy5jb250ZW50Lm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgZiwgc3RhcnRQb3MsIHRoaXMpO1xufTtcblxuLy8gOjogKChub2RlOiBOb2RlLCBwb3M6IG51bWJlciwgcGFyZW50OiBOb2RlKSDihpIgP2Jvb2wpXG4vLyBDYWxsIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgZXZlcnkgZGVzY2VuZGFudCBub2RlLiBEb2Vzbid0XG4vLyBkZXNjZW5kIGludG8gYSBub2RlIHdoZW4gdGhlIGNhbGxiYWNrIHJldHVybnMgYGZhbHNlYC5cbk5vZGUucHJvdG90eXBlLmRlc2NlbmRhbnRzID0gZnVuY3Rpb24gZGVzY2VuZGFudHMgKGYpIHtcbiAgdGhpcy5ub2Rlc0JldHdlZW4oMCwgdGhpcy5jb250ZW50LnNpemUsIGYpO1xufTtcblxuLy8gOjogc3RyaW5nXG4vLyBDb25jYXRlbmF0ZXMgYWxsIHRoZSB0ZXh0IG5vZGVzIGZvdW5kIGluIHRoaXMgZnJhZ21lbnQgYW5kIGl0c1xuLy8gY2hpbGRyZW4uXG5wcm90b3R5cGVBY2Nlc3NvcnMkMy50ZXh0Q29udGVudC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnRleHRCZXR3ZWVuKDAsIHRoaXMuY29udGVudC5zaXplLCBcIlwiKSB9O1xuXG4vLyA6OiAobnVtYmVyLCBudW1iZXIsID9zdHJpbmcsID9zdHJpbmcgfCA/KGxlYWZOb2RlOiBOb2RlKSAtPiBzdHJpbmcpIOKGkiBzdHJpbmdcbi8vIEdldCBhbGwgdGV4dCBiZXR3ZWVuIHBvc2l0aW9ucyBgZnJvbWAgYW5kIGB0b2AuIFdoZW5cbi8vIGBibG9ja1NlcGFyYXRvcmAgaXMgZ2l2ZW4sIGl0IHdpbGwgYmUgaW5zZXJ0ZWQgd2hlbmV2ZXIgYSBuZXdcbi8vIGJsb2NrIG5vZGUgaXMgc3RhcnRlZC4gV2hlbiBgbGVhZlRleHRgIGlzIGdpdmVuLCBpdCdsbCBiZVxuLy8gaW5zZXJ0ZWQgZm9yIGV2ZXJ5IG5vbi10ZXh0IGxlYWYgbm9kZSBlbmNvdW50ZXJlZC5cbk5vZGUucHJvdG90eXBlLnRleHRCZXR3ZWVuID0gZnVuY3Rpb24gdGV4dEJldHdlZW4gKGZyb20sIHRvLCBibG9ja1NlcGFyYXRvciwgbGVhZlRleHQpIHtcbiAgcmV0dXJuIHRoaXMuY29udGVudC50ZXh0QmV0d2Vlbihmcm9tLCB0bywgYmxvY2tTZXBhcmF0b3IsIGxlYWZUZXh0KVxufTtcblxuLy8gOjogP05vZGVcbi8vIFJldHVybnMgdGhpcyBub2RlJ3MgZmlyc3QgY2hpbGQsIG9yIGBudWxsYCBpZiB0aGVyZSBhcmUgbm9cbi8vIGNoaWxkcmVuLlxucHJvdG90eXBlQWNjZXNzb3JzJDMuZmlyc3RDaGlsZC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmNvbnRlbnQuZmlyc3RDaGlsZCB9O1xuXG4vLyA6OiA/Tm9kZVxuLy8gUmV0dXJucyB0aGlzIG5vZGUncyBsYXN0IGNoaWxkLCBvciBgbnVsbGAgaWYgdGhlcmUgYXJlIG5vXG4vLyBjaGlsZHJlbi5cbnByb3RvdHlwZUFjY2Vzc29ycyQzLmxhc3RDaGlsZC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmNvbnRlbnQubGFzdENoaWxkIH07XG5cbi8vIDo6IChOb2RlKSDihpIgYm9vbFxuLy8gVGVzdCB3aGV0aGVyIHR3byBub2RlcyByZXByZXNlbnQgdGhlIHNhbWUgcGllY2Ugb2YgZG9jdW1lbnQuXG5Ob2RlLnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIGVxIChvdGhlcikge1xuICByZXR1cm4gdGhpcyA9PSBvdGhlciB8fCAodGhpcy5zYW1lTWFya3VwKG90aGVyKSAmJiB0aGlzLmNvbnRlbnQuZXEob3RoZXIuY29udGVudCkpXG59O1xuXG4vLyA6OiAoTm9kZSkg4oaSIGJvb2xcbi8vIENvbXBhcmUgdGhlIG1hcmt1cCAodHlwZSwgYXR0cmlidXRlcywgYW5kIG1hcmtzKSBvZiB0aGlzIG5vZGUgdG9cbi8vIHRob3NlIG9mIGFub3RoZXIuIFJldHVybnMgYHRydWVgIGlmIGJvdGggaGF2ZSB0aGUgc2FtZSBtYXJrdXAuXG5Ob2RlLnByb3RvdHlwZS5zYW1lTWFya3VwID0gZnVuY3Rpb24gc2FtZU1hcmt1cCAob3RoZXIpIHtcbiAgcmV0dXJuIHRoaXMuaGFzTWFya3VwKG90aGVyLnR5cGUsIG90aGVyLmF0dHJzLCBvdGhlci5tYXJrcylcbn07XG5cbi8vIDo6IChOb2RlVHlwZSwgP09iamVjdCwgP1tNYXJrXSkg4oaSIGJvb2xcbi8vIENoZWNrIHdoZXRoZXIgdGhpcyBub2RlJ3MgbWFya3VwIGNvcnJlc3BvbmQgdG8gdGhlIGdpdmVuIHR5cGUsXG4vLyBhdHRyaWJ1dGVzLCBhbmQgbWFya3MuXG5Ob2RlLnByb3RvdHlwZS5oYXNNYXJrdXAgPSBmdW5jdGlvbiBoYXNNYXJrdXAgKHR5cGUsIGF0dHJzLCBtYXJrcykge1xuICByZXR1cm4gdGhpcy50eXBlID09IHR5cGUgJiZcbiAgICBjb21wYXJlRGVlcCh0aGlzLmF0dHJzLCBhdHRycyB8fCB0eXBlLmRlZmF1bHRBdHRycyB8fCBlbXB0eUF0dHJzKSAmJlxuICAgIE1hcmsuc2FtZVNldCh0aGlzLm1hcmtzLCBtYXJrcyB8fCBNYXJrLm5vbmUpXG59O1xuXG4vLyA6OiAoP0ZyYWdtZW50KSDihpIgTm9kZVxuLy8gQ3JlYXRlIGEgbmV3IG5vZGUgd2l0aCB0aGUgc2FtZSBtYXJrdXAgYXMgdGhpcyBub2RlLCBjb250YWluaW5nXG4vLyB0aGUgZ2l2ZW4gY29udGVudCAob3IgZW1wdHksIGlmIG5vIGNvbnRlbnQgaXMgZ2l2ZW4pLlxuTm9kZS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKGNvbnRlbnQpIHtcbiAgICBpZiAoIGNvbnRlbnQgPT09IHZvaWQgMCApIGNvbnRlbnQgPSBudWxsO1xuXG4gIGlmIChjb250ZW50ID09IHRoaXMuY29udGVudCkgeyByZXR1cm4gdGhpcyB9XG4gIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLnR5cGUsIHRoaXMuYXR0cnMsIGNvbnRlbnQsIHRoaXMubWFya3MpXG59O1xuXG4vLyA6OiAoW01hcmtdKSDihpIgTm9kZVxuLy8gQ3JlYXRlIGEgY29weSBvZiB0aGlzIG5vZGUsIHdpdGggdGhlIGdpdmVuIHNldCBvZiBtYXJrcyBpbnN0ZWFkXG4vLyBvZiB0aGUgbm9kZSdzIG93biBtYXJrcy5cbk5vZGUucHJvdG90eXBlLm1hcmsgPSBmdW5jdGlvbiBtYXJrIChtYXJrcykge1xuICByZXR1cm4gbWFya3MgPT0gdGhpcy5tYXJrcyA/IHRoaXMgOiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLnR5cGUsIHRoaXMuYXR0cnMsIHRoaXMuY29udGVudCwgbWFya3MpXG59O1xuXG4vLyA6OiAobnVtYmVyLCA/bnVtYmVyKSDihpIgTm9kZVxuLy8gQ3JlYXRlIGEgY29weSBvZiB0aGlzIG5vZGUgd2l0aCBvbmx5IHRoZSBjb250ZW50IGJldHdlZW4gdGhlXG4vLyBnaXZlbiBwb3NpdGlvbnMuIElmIGB0b2AgaXMgbm90IGdpdmVuLCBpdCBkZWZhdWx0cyB0byB0aGUgZW5kIG9mXG4vLyB0aGUgbm9kZS5cbk5vZGUucHJvdG90eXBlLmN1dCA9IGZ1bmN0aW9uIGN1dCAoZnJvbSwgdG8pIHtcbiAgaWYgKGZyb20gPT0gMCAmJiB0byA9PSB0aGlzLmNvbnRlbnQuc2l6ZSkgeyByZXR1cm4gdGhpcyB9XG4gIHJldHVybiB0aGlzLmNvcHkodGhpcy5jb250ZW50LmN1dChmcm9tLCB0bykpXG59O1xuXG4vLyA6OiAobnVtYmVyLCA/bnVtYmVyKSDihpIgU2xpY2Vcbi8vIEN1dCBvdXQgdGhlIHBhcnQgb2YgdGhlIGRvY3VtZW50IGJldHdlZW4gdGhlIGdpdmVuIHBvc2l0aW9ucywgYW5kXG4vLyByZXR1cm4gaXQgYXMgYSBgU2xpY2VgIG9iamVjdC5cbk5vZGUucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKGZyb20sIHRvLCBpbmNsdWRlUGFyZW50cykge1xuICAgIGlmICggdG8gPT09IHZvaWQgMCApIHRvID0gdGhpcy5jb250ZW50LnNpemU7XG4gICAgaWYgKCBpbmNsdWRlUGFyZW50cyA9PT0gdm9pZCAwICkgaW5jbHVkZVBhcmVudHMgPSBmYWxzZTtcblxuICBpZiAoZnJvbSA9PSB0bykgeyByZXR1cm4gU2xpY2UuZW1wdHkgfVxuXG4gIHZhciAkZnJvbSA9IHRoaXMucmVzb2x2ZShmcm9tKSwgJHRvID0gdGhpcy5yZXNvbHZlKHRvKTtcbiAgdmFyIGRlcHRoID0gaW5jbHVkZVBhcmVudHMgPyAwIDogJGZyb20uc2hhcmVkRGVwdGgodG8pO1xuICB2YXIgc3RhcnQgPSAkZnJvbS5zdGFydChkZXB0aCksIG5vZGUgPSAkZnJvbS5ub2RlKGRlcHRoKTtcbiAgdmFyIGNvbnRlbnQgPSBub2RlLmNvbnRlbnQuY3V0KCRmcm9tLnBvcyAtIHN0YXJ0LCAkdG8ucG9zIC0gc3RhcnQpO1xuICByZXR1cm4gbmV3IFNsaWNlKGNvbnRlbnQsICRmcm9tLmRlcHRoIC0gZGVwdGgsICR0by5kZXB0aCAtIGRlcHRoKVxufTtcblxuLy8gOjogKG51bWJlciwgbnVtYmVyLCBTbGljZSkg4oaSIE5vZGVcbi8vIFJlcGxhY2UgdGhlIHBhcnQgb2YgdGhlIGRvY3VtZW50IGJldHdlZW4gdGhlIGdpdmVuIHBvc2l0aW9ucyB3aXRoXG4vLyB0aGUgZ2l2ZW4gc2xpY2UuIFRoZSBzbGljZSBtdXN0ICdmaXQnLCBtZWFuaW5nIGl0cyBvcGVuIHNpZGVzXG4vLyBtdXN0IGJlIGFibGUgdG8gY29ubmVjdCB0byB0aGUgc3Vycm91bmRpbmcgY29udGVudCwgYW5kIGl0c1xuLy8gY29udGVudCBub2RlcyBtdXN0IGJlIHZhbGlkIGNoaWxkcmVuIGZvciB0aGUgbm9kZSB0aGV5IGFyZSBwbGFjZWRcbi8vIGludG8uIElmIGFueSBvZiB0aGlzIGlzIHZpb2xhdGVkLCBhbiBlcnJvciBvZiB0eXBlXG4vLyBbYFJlcGxhY2VFcnJvcmBdKCNtb2RlbC5SZXBsYWNlRXJyb3IpIGlzIHRocm93bi5cbk5vZGUucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlJDEgKGZyb20sIHRvLCBzbGljZSkge1xuICByZXR1cm4gcmVwbGFjZSh0aGlzLnJlc29sdmUoZnJvbSksIHRoaXMucmVzb2x2ZSh0byksIHNsaWNlKVxufTtcblxuLy8gOjogKG51bWJlcikg4oaSID9Ob2RlXG4vLyBGaW5kIHRoZSBub2RlIGRpcmVjdGx5IGFmdGVyIHRoZSBnaXZlbiBwb3NpdGlvbi5cbk5vZGUucHJvdG90eXBlLm5vZGVBdCA9IGZ1bmN0aW9uIG5vZGVBdCAocG9zKSB7XG4gIGZvciAodmFyIG5vZGUgPSB0aGlzOzspIHtcbiAgICB2YXIgcmVmID0gbm9kZS5jb250ZW50LmZpbmRJbmRleChwb3MpO1xuICAgICAgdmFyIGluZGV4ID0gcmVmLmluZGV4O1xuICAgICAgdmFyIG9mZnNldCA9IHJlZi5vZmZzZXQ7XG4gICAgbm9kZSA9IG5vZGUubWF5YmVDaGlsZChpbmRleCk7XG4gICAgaWYgKCFub2RlKSB7IHJldHVybiBudWxsIH1cbiAgICBpZiAob2Zmc2V0ID09IHBvcyB8fCBub2RlLmlzVGV4dCkgeyByZXR1cm4gbm9kZSB9XG4gICAgcG9zIC09IG9mZnNldCArIDE7XG4gIH1cbn07XG5cbi8vIDo6IChudW1iZXIpIOKGkiB7bm9kZTogP05vZGUsIGluZGV4OiBudW1iZXIsIG9mZnNldDogbnVtYmVyfVxuLy8gRmluZCB0aGUgKGRpcmVjdCkgY2hpbGQgbm9kZSBhZnRlciB0aGUgZ2l2ZW4gb2Zmc2V0LCBpZiBhbnksXG4vLyBhbmQgcmV0dXJuIGl0IGFsb25nIHdpdGggaXRzIGluZGV4IGFuZCBvZmZzZXQgcmVsYXRpdmUgdG8gdGhpc1xuLy8gbm9kZS5cbk5vZGUucHJvdG90eXBlLmNoaWxkQWZ0ZXIgPSBmdW5jdGlvbiBjaGlsZEFmdGVyIChwb3MpIHtcbiAgdmFyIHJlZiA9IHRoaXMuY29udGVudC5maW5kSW5kZXgocG9zKTtcbiAgICB2YXIgaW5kZXggPSByZWYuaW5kZXg7XG4gICAgdmFyIG9mZnNldCA9IHJlZi5vZmZzZXQ7XG4gIHJldHVybiB7bm9kZTogdGhpcy5jb250ZW50Lm1heWJlQ2hpbGQoaW5kZXgpLCBpbmRleDogaW5kZXgsIG9mZnNldDogb2Zmc2V0fVxufTtcblxuLy8gOjogKG51bWJlcikg4oaSIHtub2RlOiA/Tm9kZSwgaW5kZXg6IG51bWJlciwgb2Zmc2V0OiBudW1iZXJ9XG4vLyBGaW5kIHRoZSAoZGlyZWN0KSBjaGlsZCBub2RlIGJlZm9yZSB0aGUgZ2l2ZW4gb2Zmc2V0LCBpZiBhbnksXG4vLyBhbmQgcmV0dXJuIGl0IGFsb25nIHdpdGggaXRzIGluZGV4IGFuZCBvZmZzZXQgcmVsYXRpdmUgdG8gdGhpc1xuLy8gbm9kZS5cbk5vZGUucHJvdG90eXBlLmNoaWxkQmVmb3JlID0gZnVuY3Rpb24gY2hpbGRCZWZvcmUgKHBvcykge1xuICBpZiAocG9zID09IDApIHsgcmV0dXJuIHtub2RlOiBudWxsLCBpbmRleDogMCwgb2Zmc2V0OiAwfSB9XG4gIHZhciByZWYgPSB0aGlzLmNvbnRlbnQuZmluZEluZGV4KHBvcyk7XG4gICAgdmFyIGluZGV4ID0gcmVmLmluZGV4O1xuICAgIHZhciBvZmZzZXQgPSByZWYub2Zmc2V0O1xuICBpZiAob2Zmc2V0IDwgcG9zKSB7IHJldHVybiB7bm9kZTogdGhpcy5jb250ZW50LmNoaWxkKGluZGV4KSwgaW5kZXg6IGluZGV4LCBvZmZzZXQ6IG9mZnNldH0gfVxuICB2YXIgbm9kZSA9IHRoaXMuY29udGVudC5jaGlsZChpbmRleCAtIDEpO1xuICByZXR1cm4ge25vZGU6IG5vZGUsIGluZGV4OiBpbmRleCAtIDEsIG9mZnNldDogb2Zmc2V0IC0gbm9kZS5ub2RlU2l6ZX1cbn07XG5cbi8vIDo6IChudW1iZXIpIOKGkiBSZXNvbHZlZFBvc1xuLy8gUmVzb2x2ZSB0aGUgZ2l2ZW4gcG9zaXRpb24gaW4gdGhlIGRvY3VtZW50LCByZXR1cm5pbmcgYW5cbi8vIFtvYmplY3RdKCNtb2RlbC5SZXNvbHZlZFBvcykgd2l0aCBpbmZvcm1hdGlvbiBhYm91dCBpdHMgY29udGV4dC5cbk5vZGUucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiByZXNvbHZlIChwb3MpIHsgcmV0dXJuIFJlc29sdmVkUG9zLnJlc29sdmVDYWNoZWQodGhpcywgcG9zKSB9O1xuXG5Ob2RlLnByb3RvdHlwZS5yZXNvbHZlTm9DYWNoZSA9IGZ1bmN0aW9uIHJlc29sdmVOb0NhY2hlIChwb3MpIHsgcmV0dXJuIFJlc29sdmVkUG9zLnJlc29sdmUodGhpcywgcG9zKSB9O1xuXG4vLyA6OiAobnVtYmVyLCBudW1iZXIsIHVuaW9uPE1hcmssIE1hcmtUeXBlPikg4oaSIGJvb2xcbi8vIFRlc3Qgd2hldGhlciBhIGdpdmVuIG1hcmsgb3IgbWFyayB0eXBlIG9jY3VycyBpbiB0aGlzIGRvY3VtZW50XG4vLyBiZXR3ZWVuIHRoZSB0d28gZ2l2ZW4gcG9zaXRpb25zLlxuTm9kZS5wcm90b3R5cGUucmFuZ2VIYXNNYXJrID0gZnVuY3Rpb24gcmFuZ2VIYXNNYXJrIChmcm9tLCB0bywgdHlwZSkge1xuICB2YXIgZm91bmQgPSBmYWxzZTtcbiAgaWYgKHRvID4gZnJvbSkgeyB0aGlzLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBpZiAodHlwZS5pc0luU2V0KG5vZGUubWFya3MpKSB7IGZvdW5kID0gdHJ1ZTsgfVxuICAgIHJldHVybiAhZm91bmRcbiAgfSk7IH1cbiAgcmV0dXJuIGZvdW5kXG59O1xuXG4vLyA6OiBib29sXG4vLyBUcnVlIHdoZW4gdGhpcyBpcyBhIGJsb2NrIChub24taW5saW5lIG5vZGUpXG5wcm90b3R5cGVBY2Nlc3NvcnMkMy5pc0Jsb2NrLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudHlwZS5pc0Jsb2NrIH07XG5cbi8vIDo6IGJvb2xcbi8vIFRydWUgd2hlbiB0aGlzIGlzIGEgdGV4dGJsb2NrIG5vZGUsIGEgYmxvY2sgbm9kZSB3aXRoIGlubGluZVxuLy8gY29udGVudC5cbnByb3RvdHlwZUFjY2Vzc29ycyQzLmlzVGV4dGJsb2NrLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudHlwZS5pc1RleHRibG9jayB9O1xuXG4vLyA6OiBib29sXG4vLyBUcnVlIHdoZW4gdGhpcyBub2RlIGFsbG93cyBpbmxpbmUgY29udGVudC5cbnByb3RvdHlwZUFjY2Vzc29ycyQzLmlubGluZUNvbnRlbnQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50eXBlLmlubGluZUNvbnRlbnQgfTtcblxuLy8gOjogYm9vbFxuLy8gVHJ1ZSB3aGVuIHRoaXMgaXMgYW4gaW5saW5lIG5vZGUgKGEgdGV4dCBub2RlIG9yIGEgbm9kZSB0aGF0IGNhblxuLy8gYXBwZWFyIGFtb25nIHRleHQpLlxucHJvdG90eXBlQWNjZXNzb3JzJDMuaXNJbmxpbmUuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50eXBlLmlzSW5saW5lIH07XG5cbi8vIDo6IGJvb2xcbi8vIFRydWUgd2hlbiB0aGlzIGlzIGEgdGV4dCBub2RlLlxucHJvdG90eXBlQWNjZXNzb3JzJDMuaXNUZXh0LmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudHlwZS5pc1RleHQgfTtcblxuLy8gOjogYm9vbFxuLy8gVHJ1ZSB3aGVuIHRoaXMgaXMgYSBsZWFmIG5vZGUuXG5wcm90b3R5cGVBY2Nlc3NvcnMkMy5pc0xlYWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50eXBlLmlzTGVhZiB9O1xuXG4vLyA6OiBib29sXG4vLyBUcnVlIHdoZW4gdGhpcyBpcyBhbiBhdG9tLCBpLmUuIHdoZW4gaXQgZG9lcyBub3QgaGF2ZSBkaXJlY3RseVxuLy8gZWRpdGFibGUgY29udGVudC4gVGhpcyBpcyB1c3VhbGx5IHRoZSBzYW1lIGFzIGBpc0xlYWZgLCBidXQgY2FuXG4vLyBiZSBjb25maWd1cmVkIHdpdGggdGhlIFtgYXRvbWAgcHJvcGVydHldKCNtb2RlbC5Ob2RlU3BlYy5hdG9tKSBvblxuLy8gYSBub2RlJ3Mgc3BlYyAodHlwaWNhbGx5IHVzZWQgd2hlbiB0aGUgbm9kZSBpcyBkaXNwbGF5ZWQgYXMgYW5cbi8vIHVuZWRpdGFibGUgW25vZGUgdmlld10oI3ZpZXcuTm9kZVZpZXcpKS5cbnByb3RvdHlwZUFjY2Vzc29ycyQzLmlzQXRvbS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnR5cGUuaXNBdG9tIH07XG5cbi8vIDo6ICgpIOKGkiBzdHJpbmdcbi8vIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG5vZGUgZm9yIGRlYnVnZ2luZ1xuLy8gcHVycG9zZXMuXG5Ob2RlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgaWYgKHRoaXMudHlwZS5zcGVjLnRvRGVidWdTdHJpbmcpIHsgcmV0dXJuIHRoaXMudHlwZS5zcGVjLnRvRGVidWdTdHJpbmcodGhpcykgfVxuICB2YXIgbmFtZSA9IHRoaXMudHlwZS5uYW1lO1xuICBpZiAodGhpcy5jb250ZW50LnNpemUpXG4gICAgeyBuYW1lICs9IFwiKFwiICsgdGhpcy5jb250ZW50LnRvU3RyaW5nSW5uZXIoKSArIFwiKVwiOyB9XG4gIHJldHVybiB3cmFwTWFya3ModGhpcy5tYXJrcywgbmFtZSlcbn07XG5cbi8vIDo6IChudW1iZXIpIOKGkiBDb250ZW50TWF0Y2hcbi8vIEdldCB0aGUgY29udGVudCBtYXRjaCBpbiB0aGlzIG5vZGUgYXQgdGhlIGdpdmVuIGluZGV4LlxuTm9kZS5wcm90b3R5cGUuY29udGVudE1hdGNoQXQgPSBmdW5jdGlvbiBjb250ZW50TWF0Y2hBdCAoaW5kZXgpIHtcbiAgdmFyIG1hdGNoID0gdGhpcy50eXBlLmNvbnRlbnRNYXRjaC5tYXRjaEZyYWdtZW50KHRoaXMuY29udGVudCwgMCwgaW5kZXgpO1xuICBpZiAoIW1hdGNoKSB7IHRocm93IG5ldyBFcnJvcihcIkNhbGxlZCBjb250ZW50TWF0Y2hBdCBvbiBhIG5vZGUgd2l0aCBpbnZhbGlkIGNvbnRlbnRcIikgfVxuICByZXR1cm4gbWF0Y2hcbn07XG5cbi8vIDo6IChudW1iZXIsIG51bWJlciwgP0ZyYWdtZW50LCA/bnVtYmVyLCA/bnVtYmVyKSDihpIgYm9vbFxuLy8gVGVzdCB3aGV0aGVyIHJlcGxhY2luZyB0aGUgcmFuZ2UgYmV0d2VlbiBgZnJvbWAgYW5kIGB0b2AgKGJ5XG4vLyBjaGlsZCBpbmRleCkgd2l0aCB0aGUgZ2l2ZW4gcmVwbGFjZW1lbnQgZnJhZ21lbnQgKHdoaWNoIGRlZmF1bHRzXG4vLyB0byB0aGUgZW1wdHkgZnJhZ21lbnQpIHdvdWxkIGxlYXZlIHRoZSBub2RlJ3MgY29udGVudCB2YWxpZC4gWW91XG4vLyBjYW4gb3B0aW9uYWxseSBwYXNzIGBzdGFydGAgYW5kIGBlbmRgIGluZGljZXMgaW50byB0aGVcbi8vIHJlcGxhY2VtZW50IGZyYWdtZW50LlxuTm9kZS5wcm90b3R5cGUuY2FuUmVwbGFjZSA9IGZ1bmN0aW9uIGNhblJlcGxhY2UgKGZyb20sIHRvLCByZXBsYWNlbWVudCwgc3RhcnQsIGVuZCkge1xuICAgIGlmICggcmVwbGFjZW1lbnQgPT09IHZvaWQgMCApIHJlcGxhY2VtZW50ID0gRnJhZ21lbnQuZW1wdHk7XG4gICAgaWYgKCBzdGFydCA9PT0gdm9pZCAwICkgc3RhcnQgPSAwO1xuICAgIGlmICggZW5kID09PSB2b2lkIDAgKSBlbmQgPSByZXBsYWNlbWVudC5jaGlsZENvdW50O1xuXG4gIHZhciBvbmUgPSB0aGlzLmNvbnRlbnRNYXRjaEF0KGZyb20pLm1hdGNoRnJhZ21lbnQocmVwbGFjZW1lbnQsIHN0YXJ0LCBlbmQpO1xuICB2YXIgdHdvID0gb25lICYmIG9uZS5tYXRjaEZyYWdtZW50KHRoaXMuY29udGVudCwgdG8pO1xuICBpZiAoIXR3byB8fCAhdHdvLnZhbGlkRW5kKSB7IHJldHVybiBmYWxzZSB9XG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7IGlmICghdGhpcy50eXBlLmFsbG93c01hcmtzKHJlcGxhY2VtZW50LmNoaWxkKGkpLm1hcmtzKSkgeyByZXR1cm4gZmFsc2UgfSB9XG4gIHJldHVybiB0cnVlXG59O1xuXG4vLyA6OiAobnVtYmVyLCBudW1iZXIsIE5vZGVUeXBlLCA/W01hcmtdKSDihpIgYm9vbFxuLy8gVGVzdCB3aGV0aGVyIHJlcGxhY2luZyB0aGUgcmFuZ2UgYGZyb21gIHRvIGB0b2AgKGJ5IGluZGV4KSB3aXRoIGFcbi8vIG5vZGUgb2YgdGhlIGdpdmVuIHR5cGUgd291bGQgbGVhdmUgdGhlIG5vZGUncyBjb250ZW50IHZhbGlkLlxuTm9kZS5wcm90b3R5cGUuY2FuUmVwbGFjZVdpdGggPSBmdW5jdGlvbiBjYW5SZXBsYWNlV2l0aCAoZnJvbSwgdG8sIHR5cGUsIG1hcmtzKSB7XG4gIGlmIChtYXJrcyAmJiAhdGhpcy50eXBlLmFsbG93c01hcmtzKG1hcmtzKSkgeyByZXR1cm4gZmFsc2UgfVxuICB2YXIgc3RhcnQgPSB0aGlzLmNvbnRlbnRNYXRjaEF0KGZyb20pLm1hdGNoVHlwZSh0eXBlKTtcbiAgdmFyIGVuZCA9IHN0YXJ0ICYmIHN0YXJ0Lm1hdGNoRnJhZ21lbnQodGhpcy5jb250ZW50LCB0byk7XG4gIHJldHVybiBlbmQgPyBlbmQudmFsaWRFbmQgOiBmYWxzZVxufTtcblxuLy8gOjogKE5vZGUpIOKGkiBib29sXG4vLyBUZXN0IHdoZXRoZXIgdGhlIGdpdmVuIG5vZGUncyBjb250ZW50IGNvdWxkIGJlIGFwcGVuZGVkIHRvIHRoaXNcbi8vIG5vZGUuIElmIHRoYXQgbm9kZSBpcyBlbXB0eSwgdGhpcyB3aWxsIG9ubHkgcmV0dXJuIHRydWUgaWYgdGhlcmVcbi8vIGlzIGF0IGxlYXN0IG9uZSBub2RlIHR5cGUgdGhhdCBjYW4gYXBwZWFyIGluIGJvdGggbm9kZXMgKHRvIGF2b2lkXG4vLyBtZXJnaW5nIGNvbXBsZXRlbHkgaW5jb21wYXRpYmxlIG5vZGVzKS5cbk5vZGUucHJvdG90eXBlLmNhbkFwcGVuZCA9IGZ1bmN0aW9uIGNhbkFwcGVuZCAob3RoZXIpIHtcbiAgaWYgKG90aGVyLmNvbnRlbnQuc2l6ZSkgeyByZXR1cm4gdGhpcy5jYW5SZXBsYWNlKHRoaXMuY2hpbGRDb3VudCwgdGhpcy5jaGlsZENvdW50LCBvdGhlci5jb250ZW50KSB9XG4gIGVsc2UgeyByZXR1cm4gdGhpcy50eXBlLmNvbXBhdGlibGVDb250ZW50KG90aGVyLnR5cGUpIH1cbn07XG5cbi8vIDo6ICgpXG4vLyBDaGVjayB3aGV0aGVyIHRoaXMgbm9kZSBhbmQgaXRzIGRlc2NlbmRhbnRzIGNvbmZvcm0gdG8gdGhlXG4vLyBzY2hlbWEsIGFuZCByYWlzZSBlcnJvciB3aGVuIHRoZXkgZG8gbm90LlxuTm9kZS5wcm90b3R5cGUuY2hlY2sgPSBmdW5jdGlvbiBjaGVjayAoKSB7XG4gIGlmICghdGhpcy50eXBlLnZhbGlkQ29udGVudCh0aGlzLmNvbnRlbnQpKVxuICAgIHsgdGhyb3cgbmV3IFJhbmdlRXJyb3IoKFwiSW52YWxpZCBjb250ZW50IGZvciBub2RlIFwiICsgKHRoaXMudHlwZS5uYW1lKSArIFwiOiBcIiArICh0aGlzLmNvbnRlbnQudG9TdHJpbmcoKS5zbGljZSgwLCA1MCkpKSkgfVxuICB2YXIgY29weSA9IE1hcmsubm9uZTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1hcmtzLmxlbmd0aDsgaSsrKSB7IGNvcHkgPSB0aGlzLm1hcmtzW2ldLmFkZFRvU2V0KGNvcHkpOyB9XG4gIGlmICghTWFyay5zYW1lU2V0KGNvcHksIHRoaXMubWFya3MpKVxuICAgIHsgdGhyb3cgbmV3IFJhbmdlRXJyb3IoKFwiSW52YWxpZCBjb2xsZWN0aW9uIG9mIG1hcmtzIGZvciBub2RlIFwiICsgKHRoaXMudHlwZS5uYW1lKSArIFwiOiBcIiArICh0aGlzLm1hcmtzLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gbS50eXBlLm5hbWU7IH0pKSkpIH1cbiAgdGhpcy5jb250ZW50LmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUuY2hlY2soKTsgfSk7XG59O1xuXG4vLyA6OiAoKSDihpIgT2JqZWN0XG4vLyBSZXR1cm4gYSBKU09OLXNlcmlhbGl6ZWFibGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBub2RlLlxuTm9kZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgdmFyIG9iaiA9IHt0eXBlOiB0aGlzLnR5cGUubmFtZX07XG4gIGZvciAodmFyIF8gaW4gdGhpcy5hdHRycykge1xuICAgIG9iai5hdHRycyA9IHRoaXMuYXR0cnM7XG4gICAgYnJlYWtcbiAgfVxuICBpZiAodGhpcy5jb250ZW50LnNpemUpXG4gICAgeyBvYmouY29udGVudCA9IHRoaXMuY29udGVudC50b0pTT04oKTsgfVxuICBpZiAodGhpcy5tYXJrcy5sZW5ndGgpXG4gICAgeyBvYmoubWFya3MgPSB0aGlzLm1hcmtzLm1hcChmdW5jdGlvbiAobikgeyByZXR1cm4gbi50b0pTT04oKTsgfSk7IH1cbiAgcmV0dXJuIG9ialxufTtcblxuLy8gOjogKFNjaGVtYSwgT2JqZWN0KSDihpIgTm9kZVxuLy8gRGVzZXJpYWxpemUgYSBub2RlIGZyb20gaXRzIEpTT04gcmVwcmVzZW50YXRpb24uXG5Ob2RlLmZyb21KU09OID0gZnVuY3Rpb24gZnJvbUpTT04gKHNjaGVtYSwganNvbikge1xuICBpZiAoIWpzb24pIHsgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBOb2RlLmZyb21KU09OXCIpIH1cbiAgdmFyIG1hcmtzID0gbnVsbDtcbiAgaWYgKGpzb24ubWFya3MpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoanNvbi5tYXJrcykpIHsgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIG1hcmsgZGF0YSBmb3IgTm9kZS5mcm9tSlNPTlwiKSB9XG4gICAgbWFya3MgPSBqc29uLm1hcmtzLm1hcChzY2hlbWEubWFya0Zyb21KU09OKTtcbiAgfVxuICBpZiAoanNvbi50eXBlID09IFwidGV4dFwiKSB7XG4gICAgaWYgKHR5cGVvZiBqc29uLnRleHQgIT0gXCJzdHJpbmdcIikgeyB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgdGV4dCBub2RlIGluIEpTT05cIikgfVxuICAgIHJldHVybiBzY2hlbWEudGV4dChqc29uLnRleHQsIG1hcmtzKVxuICB9XG4gIHZhciBjb250ZW50ID0gRnJhZ21lbnQuZnJvbUpTT04oc2NoZW1hLCBqc29uLmNvbnRlbnQpO1xuICByZXR1cm4gc2NoZW1hLm5vZGVUeXBlKGpzb24udHlwZSkuY3JlYXRlKGpzb24uYXR0cnMsIGNvbnRlbnQsIG1hcmtzKVxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIE5vZGUucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMkMyApO1xuXG52YXIgVGV4dE5vZGUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChOb2RlKSB7XG4gIGZ1bmN0aW9uIFRleHROb2RlKHR5cGUsIGF0dHJzLCBjb250ZW50LCBtYXJrcykge1xuICAgIE5vZGUuY2FsbCh0aGlzLCB0eXBlLCBhdHRycywgbnVsbCwgbWFya3MpO1xuXG4gICAgaWYgKCFjb250ZW50KSB7IHRocm93IG5ldyBSYW5nZUVycm9yKFwiRW1wdHkgdGV4dCBub2RlcyBhcmUgbm90IGFsbG93ZWRcIikgfVxuXG4gICAgdGhpcy50ZXh0ID0gY29udGVudDtcbiAgfVxuXG4gIGlmICggTm9kZSApIFRleHROb2RlLl9fcHJvdG9fXyA9IE5vZGU7XG4gIFRleHROb2RlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE5vZGUgJiYgTm9kZS5wcm90b3R5cGUgKTtcbiAgVGV4dE5vZGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVGV4dE5vZGU7XG5cbiAgdmFyIHByb3RvdHlwZUFjY2Vzc29ycyQxID0geyB0ZXh0Q29udGVudDogeyBjb25maWd1cmFibGU6IHRydWUgfSxub2RlU2l6ZTogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG4gIFRleHROb2RlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgICBpZiAodGhpcy50eXBlLnNwZWMudG9EZWJ1Z1N0cmluZykgeyByZXR1cm4gdGhpcy50eXBlLnNwZWMudG9EZWJ1Z1N0cmluZyh0aGlzKSB9XG4gICAgcmV0dXJuIHdyYXBNYXJrcyh0aGlzLm1hcmtzLCBKU09OLnN0cmluZ2lmeSh0aGlzLnRleHQpKVxuICB9O1xuXG4gIHByb3RvdHlwZUFjY2Vzc29ycyQxLnRleHRDb250ZW50LmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudGV4dCB9O1xuXG4gIFRleHROb2RlLnByb3RvdHlwZS50ZXh0QmV0d2VlbiA9IGZ1bmN0aW9uIHRleHRCZXR3ZWVuIChmcm9tLCB0bykgeyByZXR1cm4gdGhpcy50ZXh0LnNsaWNlKGZyb20sIHRvKSB9O1xuXG4gIHByb3RvdHlwZUFjY2Vzc29ycyQxLm5vZGVTaXplLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudGV4dC5sZW5ndGggfTtcblxuICBUZXh0Tm9kZS5wcm90b3R5cGUubWFyayA9IGZ1bmN0aW9uIG1hcmsgKG1hcmtzKSB7XG4gICAgcmV0dXJuIG1hcmtzID09IHRoaXMubWFya3MgPyB0aGlzIDogbmV3IFRleHROb2RlKHRoaXMudHlwZSwgdGhpcy5hdHRycywgdGhpcy50ZXh0LCBtYXJrcylcbiAgfTtcblxuICBUZXh0Tm9kZS5wcm90b3R5cGUud2l0aFRleHQgPSBmdW5jdGlvbiB3aXRoVGV4dCAodGV4dCkge1xuICAgIGlmICh0ZXh0ID09IHRoaXMudGV4dCkgeyByZXR1cm4gdGhpcyB9XG4gICAgcmV0dXJuIG5ldyBUZXh0Tm9kZSh0aGlzLnR5cGUsIHRoaXMuYXR0cnMsIHRleHQsIHRoaXMubWFya3MpXG4gIH07XG5cbiAgVGV4dE5vZGUucHJvdG90eXBlLmN1dCA9IGZ1bmN0aW9uIGN1dCAoZnJvbSwgdG8pIHtcbiAgICBpZiAoIGZyb20gPT09IHZvaWQgMCApIGZyb20gPSAwO1xuICAgIGlmICggdG8gPT09IHZvaWQgMCApIHRvID0gdGhpcy50ZXh0Lmxlbmd0aDtcblxuICAgIGlmIChmcm9tID09IDAgJiYgdG8gPT0gdGhpcy50ZXh0Lmxlbmd0aCkgeyByZXR1cm4gdGhpcyB9XG4gICAgcmV0dXJuIHRoaXMud2l0aFRleHQodGhpcy50ZXh0LnNsaWNlKGZyb20sIHRvKSlcbiAgfTtcblxuICBUZXh0Tm9kZS5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbiBlcSAob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5zYW1lTWFya3VwKG90aGVyKSAmJiB0aGlzLnRleHQgPT0gb3RoZXIudGV4dFxuICB9O1xuXG4gIFRleHROb2RlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICAgIHZhciBiYXNlID0gTm9kZS5wcm90b3R5cGUudG9KU09OLmNhbGwodGhpcyk7XG4gICAgYmFzZS50ZXh0ID0gdGhpcy50ZXh0O1xuICAgIHJldHVybiBiYXNlXG4gIH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFRleHROb2RlLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzJDEgKTtcblxuICByZXR1cm4gVGV4dE5vZGU7XG59KE5vZGUpKTtcblxuZnVuY3Rpb24gd3JhcE1hcmtzKG1hcmtzLCBzdHIpIHtcbiAgZm9yICh2YXIgaSA9IG1hcmtzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgIHsgc3RyID0gbWFya3NbaV0udHlwZS5uYW1lICsgXCIoXCIgKyBzdHIgKyBcIilcIjsgfVxuICByZXR1cm4gc3RyXG59XG5cbi8vIDo6LSBJbnN0YW5jZXMgb2YgdGhpcyBjbGFzcyByZXByZXNlbnQgYSBtYXRjaCBzdGF0ZSBvZiBhIG5vZGVcbi8vIHR5cGUncyBbY29udGVudCBleHByZXNzaW9uXSgjbW9kZWwuTm9kZVNwZWMuY29udGVudCksIGFuZCBjYW4gYmVcbi8vIHVzZWQgdG8gZmluZCBvdXQgd2hldGhlciBmdXJ0aGVyIGNvbnRlbnQgbWF0Y2hlcyBoZXJlLCBhbmQgd2hldGhlclxuLy8gYSBnaXZlbiBwb3NpdGlvbiBpcyBhIHZhbGlkIGVuZCBvZiB0aGUgbm9kZS5cbnZhciBDb250ZW50TWF0Y2ggPSBmdW5jdGlvbiBDb250ZW50TWF0Y2godmFsaWRFbmQpIHtcbiAgLy8gOjogYm9vbFxuICAvLyBUcnVlIHdoZW4gdGhpcyBtYXRjaCBzdGF0ZSByZXByZXNlbnRzIGEgdmFsaWQgZW5kIG9mIHRoZSBub2RlLlxuICB0aGlzLnZhbGlkRW5kID0gdmFsaWRFbmQ7XG4gIHRoaXMubmV4dCA9IFtdO1xuICB0aGlzLndyYXBDYWNoZSA9IFtdO1xufTtcblxudmFyIHByb3RvdHlwZUFjY2Vzc29ycyQ0ID0geyBpbmxpbmVDb250ZW50OiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGRlZmF1bHRUeXBlOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGVkZ2VDb3VudDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG5Db250ZW50TWF0Y2gucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSAoc3RyaW5nLCBub2RlVHlwZXMpIHtcbiAgdmFyIHN0cmVhbSA9IG5ldyBUb2tlblN0cmVhbShzdHJpbmcsIG5vZGVUeXBlcyk7XG4gIGlmIChzdHJlYW0ubmV4dCA9PSBudWxsKSB7IHJldHVybiBDb250ZW50TWF0Y2guZW1wdHkgfVxuICB2YXIgZXhwciA9IHBhcnNlRXhwcihzdHJlYW0pO1xuICBpZiAoc3RyZWFtLm5leHQpIHsgc3RyZWFtLmVycihcIlVuZXhwZWN0ZWQgdHJhaWxpbmcgdGV4dFwiKTsgfVxuICB2YXIgbWF0Y2ggPSBkZmEobmZhKGV4cHIpKTtcbiAgY2hlY2tGb3JEZWFkRW5kcyhtYXRjaCwgc3RyZWFtKTtcbiAgcmV0dXJuIG1hdGNoXG59O1xuXG4vLyA6OiAoTm9kZVR5cGUpIOKGkiA/Q29udGVudE1hdGNoXG4vLyBNYXRjaCBhIG5vZGUgdHlwZSwgcmV0dXJuaW5nIGEgbWF0Y2ggYWZ0ZXIgdGhhdCBub2RlIGlmXG4vLyBzdWNjZXNzZnVsLlxuQ29udGVudE1hdGNoLnByb3RvdHlwZS5tYXRjaFR5cGUgPSBmdW5jdGlvbiBtYXRjaFR5cGUgKHR5cGUpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm5leHQubGVuZ3RoOyBpICs9IDIpXG4gICAgeyBpZiAodGhpcy5uZXh0W2ldID09IHR5cGUpIHsgcmV0dXJuIHRoaXMubmV4dFtpICsgMV0gfSB9XG4gIHJldHVybiBudWxsXG59O1xuXG4vLyA6OiAoRnJhZ21lbnQsID9udW1iZXIsID9udW1iZXIpIOKGkiA/Q29udGVudE1hdGNoXG4vLyBUcnkgdG8gbWF0Y2ggYSBmcmFnbWVudC4gUmV0dXJucyB0aGUgcmVzdWx0aW5nIG1hdGNoIHdoZW5cbi8vIHN1Y2Nlc3NmdWwuXG5Db250ZW50TWF0Y2gucHJvdG90eXBlLm1hdGNoRnJhZ21lbnQgPSBmdW5jdGlvbiBtYXRjaEZyYWdtZW50IChmcmFnLCBzdGFydCwgZW5kKSB7XG4gICAgaWYgKCBzdGFydCA9PT0gdm9pZCAwICkgc3RhcnQgPSAwO1xuICAgIGlmICggZW5kID09PSB2b2lkIDAgKSBlbmQgPSBmcmFnLmNoaWxkQ291bnQ7XG5cbiAgdmFyIGN1ciA9IHRoaXM7XG4gIGZvciAodmFyIGkgPSBzdGFydDsgY3VyICYmIGkgPCBlbmQ7IGkrKylcbiAgICB7IGN1ciA9IGN1ci5tYXRjaFR5cGUoZnJhZy5jaGlsZChpKS50eXBlKTsgfVxuICByZXR1cm4gY3VyXG59O1xuXG5wcm90b3R5cGVBY2Nlc3NvcnMkNC5pbmxpbmVDb250ZW50LmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGZpcnN0ID0gdGhpcy5uZXh0WzBdO1xuICByZXR1cm4gZmlyc3QgPyBmaXJzdC5pc0lubGluZSA6IGZhbHNlXG59O1xuXG4vLyA6OiA/Tm9kZVR5cGVcbi8vIEdldCB0aGUgZmlyc3QgbWF0Y2hpbmcgbm9kZSB0eXBlIGF0IHRoaXMgbWF0Y2ggcG9zaXRpb24gdGhhdCBjYW5cbi8vIGJlIGdlbmVyYXRlZC5cbnByb3RvdHlwZUFjY2Vzc29ycyQ0LmRlZmF1bHRUeXBlLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm5leHQubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB2YXIgdHlwZSA9IHRoaXMubmV4dFtpXTtcbiAgICBpZiAoISh0eXBlLmlzVGV4dCB8fCB0eXBlLmhhc1JlcXVpcmVkQXR0cnMoKSkpIHsgcmV0dXJuIHR5cGUgfVxuICB9XG59O1xuXG5Db250ZW50TWF0Y2gucHJvdG90eXBlLmNvbXBhdGlibGUgPSBmdW5jdGlvbiBjb21wYXRpYmxlIChvdGhlcikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubmV4dC5sZW5ndGg7IGkgKz0gMilcbiAgICB7IGZvciAodmFyIGogPSAwOyBqIDwgb3RoZXIubmV4dC5sZW5ndGg7IGogKz0gMilcbiAgICAgIHsgaWYgKHRoaXMubmV4dFtpXSA9PSBvdGhlci5uZXh0W2pdKSB7IHJldHVybiB0cnVlIH0gfSB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gOjogKEZyYWdtZW50LCBib29sLCA/bnVtYmVyKSDihpIgP0ZyYWdtZW50XG4vLyBUcnkgdG8gbWF0Y2ggdGhlIGdpdmVuIGZyYWdtZW50LCBhbmQgaWYgdGhhdCBmYWlscywgc2VlIGlmIGl0IGNhblxuLy8gYmUgbWFkZSB0byBtYXRjaCBieSBpbnNlcnRpbmcgbm9kZXMgaW4gZnJvbnQgb2YgaXQuIFdoZW5cbi8vIHN1Y2Nlc3NmdWwsIHJldHVybiBhIGZyYWdtZW50IG9mIGluc2VydGVkIG5vZGVzICh3aGljaCBtYXkgYmVcbi8vIGVtcHR5IGlmIG5vdGhpbmcgaGFkIHRvIGJlIGluc2VydGVkKS4gV2hlbiBgdG9FbmRgIGlzIHRydWUsIG9ubHlcbi8vIHJldHVybiBhIGZyYWdtZW50IGlmIHRoZSByZXN1bHRpbmcgbWF0Y2ggZ29lcyB0byB0aGUgZW5kIG9mIHRoZVxuLy8gY29udGVudCBleHByZXNzaW9uLlxuQ29udGVudE1hdGNoLnByb3RvdHlwZS5maWxsQmVmb3JlID0gZnVuY3Rpb24gZmlsbEJlZm9yZSAoYWZ0ZXIsIHRvRW5kLCBzdGFydEluZGV4KSB7XG4gICAgaWYgKCB0b0VuZCA9PT0gdm9pZCAwICkgdG9FbmQgPSBmYWxzZTtcbiAgICBpZiAoIHN0YXJ0SW5kZXggPT09IHZvaWQgMCApIHN0YXJ0SW5kZXggPSAwO1xuXG4gIHZhciBzZWVuID0gW3RoaXNdO1xuICBmdW5jdGlvbiBzZWFyY2gobWF0Y2gsIHR5cGVzKSB7XG4gICAgdmFyIGZpbmlzaGVkID0gbWF0Y2gubWF0Y2hGcmFnbWVudChhZnRlciwgc3RhcnRJbmRleCk7XG4gICAgaWYgKGZpbmlzaGVkICYmICghdG9FbmQgfHwgZmluaXNoZWQudmFsaWRFbmQpKVxuICAgICAgeyByZXR1cm4gRnJhZ21lbnQuZnJvbSh0eXBlcy5tYXAoZnVuY3Rpb24gKHRwKSB7IHJldHVybiB0cC5jcmVhdGVBbmRGaWxsKCk7IH0pKSB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hdGNoLm5leHQubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIHZhciB0eXBlID0gbWF0Y2gubmV4dFtpXSwgbmV4dCA9IG1hdGNoLm5leHRbaSArIDFdO1xuICAgICAgaWYgKCEodHlwZS5pc1RleHQgfHwgdHlwZS5oYXNSZXF1aXJlZEF0dHJzKCkpICYmIHNlZW4uaW5kZXhPZihuZXh0KSA9PSAtMSkge1xuICAgICAgICBzZWVuLnB1c2gobmV4dCk7XG4gICAgICAgIHZhciBmb3VuZCA9IHNlYXJjaChuZXh0LCB0eXBlcy5jb25jYXQodHlwZSkpO1xuICAgICAgICBpZiAoZm91bmQpIHsgcmV0dXJuIGZvdW5kIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2VhcmNoKHRoaXMsIFtdKVxufTtcblxuLy8gOjogKE5vZGVUeXBlKSDihpIgP1tOb2RlVHlwZV1cbi8vIEZpbmQgYSBzZXQgb2Ygd3JhcHBpbmcgbm9kZSB0eXBlcyB0aGF0IHdvdWxkIGFsbG93IGEgbm9kZSBvZiB0aGVcbi8vIGdpdmVuIHR5cGUgdG8gYXBwZWFyIGF0IHRoaXMgcG9zaXRpb24uIFRoZSByZXN1bHQgbWF5IGJlIGVtcHR5XG4vLyAod2hlbiBpdCBmaXRzIGRpcmVjdGx5KSBhbmQgd2lsbCBiZSBudWxsIHdoZW4gbm8gc3VjaCB3cmFwcGluZ1xuLy8gZXhpc3RzLlxuQ29udGVudE1hdGNoLnByb3RvdHlwZS5maW5kV3JhcHBpbmcgPSBmdW5jdGlvbiBmaW5kV3JhcHBpbmcgKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMud3JhcENhY2hlLmxlbmd0aDsgaSArPSAyKVxuICAgIHsgaWYgKHRoaXMud3JhcENhY2hlW2ldID09IHRhcmdldCkgeyByZXR1cm4gdGhpcy53cmFwQ2FjaGVbaSArIDFdIH0gfVxuICB2YXIgY29tcHV0ZWQgPSB0aGlzLmNvbXB1dGVXcmFwcGluZyh0YXJnZXQpO1xuICB0aGlzLndyYXBDYWNoZS5wdXNoKHRhcmdldCwgY29tcHV0ZWQpO1xuICByZXR1cm4gY29tcHV0ZWRcbn07XG5cbkNvbnRlbnRNYXRjaC5wcm90b3R5cGUuY29tcHV0ZVdyYXBwaW5nID0gZnVuY3Rpb24gY29tcHV0ZVdyYXBwaW5nICh0YXJnZXQpIHtcbiAgdmFyIHNlZW4gPSBPYmplY3QuY3JlYXRlKG51bGwpLCBhY3RpdmUgPSBbe21hdGNoOiB0aGlzLCB0eXBlOiBudWxsLCB2aWE6IG51bGx9XTtcbiAgd2hpbGUgKGFjdGl2ZS5sZW5ndGgpIHtcbiAgICB2YXIgY3VycmVudCA9IGFjdGl2ZS5zaGlmdCgpLCBtYXRjaCA9IGN1cnJlbnQubWF0Y2g7XG4gICAgaWYgKG1hdGNoLm1hdGNoVHlwZSh0YXJnZXQpKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBmb3IgKHZhciBvYmogPSBjdXJyZW50OyBvYmoudHlwZTsgb2JqID0gb2JqLnZpYSlcbiAgICAgICAgeyByZXN1bHQucHVzaChvYmoudHlwZSk7IH1cbiAgICAgIHJldHVybiByZXN1bHQucmV2ZXJzZSgpXG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF0Y2gubmV4dC5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgdmFyIHR5cGUgPSBtYXRjaC5uZXh0W2ldO1xuICAgICAgaWYgKCF0eXBlLmlzTGVhZiAmJiAhdHlwZS5oYXNSZXF1aXJlZEF0dHJzKCkgJiYgISh0eXBlLm5hbWUgaW4gc2VlbikgJiYgKCFjdXJyZW50LnR5cGUgfHwgbWF0Y2gubmV4dFtpICsgMV0udmFsaWRFbmQpKSB7XG4gICAgICAgIGFjdGl2ZS5wdXNoKHttYXRjaDogdHlwZS5jb250ZW50TWF0Y2gsIHR5cGU6IHR5cGUsIHZpYTogY3VycmVudH0pO1xuICAgICAgICBzZWVuW3R5cGUubmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLy8gOjogbnVtYmVyXG4vLyBUaGUgbnVtYmVyIG9mIG91dGdvaW5nIGVkZ2VzIHRoaXMgbm9kZSBoYXMgaW4gdGhlIGZpbml0ZVxuLy8gYXV0b21hdG9uIHRoYXQgZGVzY3JpYmVzIHRoZSBjb250ZW50IGV4cHJlc3Npb24uXG5wcm90b3R5cGVBY2Nlc3NvcnMkNC5lZGdlQ291bnQuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5uZXh0Lmxlbmd0aCA+PiAxXG59O1xuXG4vLyA6OiAobnVtYmVyKSDihpIge3R5cGU6IE5vZGVUeXBlLCBuZXh0OiBDb250ZW50TWF0Y2h9XG4vLyBHZXQgdGhlIF9uX+KAi3RoIG91dGdvaW5nIGVkZ2UgZnJvbSB0aGlzIG5vZGUgaW4gdGhlIGZpbml0ZVxuLy8gYXV0b21hdG9uIHRoYXQgZGVzY3JpYmVzIHRoZSBjb250ZW50IGV4cHJlc3Npb24uXG5Db250ZW50TWF0Y2gucHJvdG90eXBlLmVkZ2UgPSBmdW5jdGlvbiBlZGdlIChuKSB7XG4gIHZhciBpID0gbiA8PCAxO1xuICBpZiAoaSA+PSB0aGlzLm5leHQubGVuZ3RoKSB7IHRocm93IG5ldyBSYW5nZUVycm9yKChcIlRoZXJlJ3Mgbm8gXCIgKyBuICsgXCJ0aCBlZGdlIGluIHRoaXMgY29udGVudCBtYXRjaFwiKSkgfVxuICByZXR1cm4ge3R5cGU6IHRoaXMubmV4dFtpXSwgbmV4dDogdGhpcy5uZXh0W2kgKyAxXX1cbn07XG5cbkNvbnRlbnRNYXRjaC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBzZWVuID0gW107XG4gIGZ1bmN0aW9uIHNjYW4obSkge1xuICAgIHNlZW4ucHVzaChtKTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IG0ubmV4dC5sZW5ndGg7IGkgKz0gMilcbiAgICAgIHsgaWYgKHNlZW4uaW5kZXhPZihtLm5leHRbaV0pID09IC0xKSB7IHNjYW4obS5uZXh0W2ldKTsgfSB9XG4gIH1cbiAgc2Nhbih0aGlzKTtcbiAgcmV0dXJuIHNlZW4ubWFwKGZ1bmN0aW9uIChtLCBpKSB7XG4gICAgdmFyIG91dCA9IGkgKyAobS52YWxpZEVuZCA/IFwiKlwiIDogXCIgXCIpICsgXCIgXCI7XG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgbS5uZXh0Lmxlbmd0aDsgaSQxICs9IDIpXG4gICAgICB7IG91dCArPSAoaSQxID8gXCIsIFwiIDogXCJcIikgKyBtLm5leHRbaSQxXS5uYW1lICsgXCItPlwiICsgc2Vlbi5pbmRleE9mKG0ubmV4dFtpJDEgKyAxXSk7IH1cbiAgICByZXR1cm4gb3V0XG4gIH0pLmpvaW4oXCJcXG5cIilcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBDb250ZW50TWF0Y2gucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMkNCApO1xuXG5Db250ZW50TWF0Y2guZW1wdHkgPSBuZXcgQ29udGVudE1hdGNoKHRydWUpO1xuXG52YXIgVG9rZW5TdHJlYW0gPSBmdW5jdGlvbiBUb2tlblN0cmVhbShzdHJpbmcsIG5vZGVUeXBlcykge1xuICB0aGlzLnN0cmluZyA9IHN0cmluZztcbiAgdGhpcy5ub2RlVHlwZXMgPSBub2RlVHlwZXM7XG4gIHRoaXMuaW5saW5lID0gbnVsbDtcbiAgdGhpcy5wb3MgPSAwO1xuICB0aGlzLnRva2VucyA9IHN0cmluZy5zcGxpdCgvXFxzKig/PVxcYnxcXFd8JCkvKTtcbiAgaWYgKHRoaXMudG9rZW5zW3RoaXMudG9rZW5zLmxlbmd0aCAtIDFdID09IFwiXCIpIHsgdGhpcy50b2tlbnMucG9wKCk7IH1cbiAgaWYgKHRoaXMudG9rZW5zWzBdID09IFwiXCIpIHsgdGhpcy50b2tlbnMuc2hpZnQoKTsgfVxufTtcblxudmFyIHByb3RvdHlwZUFjY2Vzc29ycyQxJDIgPSB7IG5leHQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxucHJvdG90eXBlQWNjZXNzb3JzJDEkMi5uZXh0LmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudG9rZW5zW3RoaXMucG9zXSB9O1xuXG5Ub2tlblN0cmVhbS5wcm90b3R5cGUuZWF0ID0gZnVuY3Rpb24gZWF0ICh0b2spIHsgcmV0dXJuIHRoaXMubmV4dCA9PSB0b2sgJiYgKHRoaXMucG9zKysgfHwgdHJ1ZSkgfTtcblxuVG9rZW5TdHJlYW0ucHJvdG90eXBlLmVyciA9IGZ1bmN0aW9uIGVyciAoc3RyKSB7IHRocm93IG5ldyBTeW50YXhFcnJvcihzdHIgKyBcIiAoaW4gY29udGVudCBleHByZXNzaW9uICdcIiArIHRoaXMuc3RyaW5nICsgXCInKVwiKSB9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggVG9rZW5TdHJlYW0ucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMkMSQyICk7XG5cbmZ1bmN0aW9uIHBhcnNlRXhwcihzdHJlYW0pIHtcbiAgdmFyIGV4cHJzID0gW107XG4gIGRvIHsgZXhwcnMucHVzaChwYXJzZUV4cHJTZXEoc3RyZWFtKSk7IH1cbiAgd2hpbGUgKHN0cmVhbS5lYXQoXCJ8XCIpKVxuICByZXR1cm4gZXhwcnMubGVuZ3RoID09IDEgPyBleHByc1swXSA6IHt0eXBlOiBcImNob2ljZVwiLCBleHByczogZXhwcnN9XG59XG5cbmZ1bmN0aW9uIHBhcnNlRXhwclNlcShzdHJlYW0pIHtcbiAgdmFyIGV4cHJzID0gW107XG4gIGRvIHsgZXhwcnMucHVzaChwYXJzZUV4cHJTdWJzY3JpcHQoc3RyZWFtKSk7IH1cbiAgd2hpbGUgKHN0cmVhbS5uZXh0ICYmIHN0cmVhbS5uZXh0ICE9IFwiKVwiICYmIHN0cmVhbS5uZXh0ICE9IFwifFwiKVxuICByZXR1cm4gZXhwcnMubGVuZ3RoID09IDEgPyBleHByc1swXSA6IHt0eXBlOiBcInNlcVwiLCBleHByczogZXhwcnN9XG59XG5cbmZ1bmN0aW9uIHBhcnNlRXhwclN1YnNjcmlwdChzdHJlYW0pIHtcbiAgdmFyIGV4cHIgPSBwYXJzZUV4cHJBdG9tKHN0cmVhbSk7XG4gIGZvciAoOzspIHtcbiAgICBpZiAoc3RyZWFtLmVhdChcIitcIikpXG4gICAgICB7IGV4cHIgPSB7dHlwZTogXCJwbHVzXCIsIGV4cHI6IGV4cHJ9OyB9XG4gICAgZWxzZSBpZiAoc3RyZWFtLmVhdChcIipcIikpXG4gICAgICB7IGV4cHIgPSB7dHlwZTogXCJzdGFyXCIsIGV4cHI6IGV4cHJ9OyB9XG4gICAgZWxzZSBpZiAoc3RyZWFtLmVhdChcIj9cIikpXG4gICAgICB7IGV4cHIgPSB7dHlwZTogXCJvcHRcIiwgZXhwcjogZXhwcn07IH1cbiAgICBlbHNlIGlmIChzdHJlYW0uZWF0KFwie1wiKSlcbiAgICAgIHsgZXhwciA9IHBhcnNlRXhwclJhbmdlKHN0cmVhbSwgZXhwcik7IH1cbiAgICBlbHNlIHsgYnJlYWsgfVxuICB9XG4gIHJldHVybiBleHByXG59XG5cbmZ1bmN0aW9uIHBhcnNlTnVtKHN0cmVhbSkge1xuICBpZiAoL1xcRC8udGVzdChzdHJlYW0ubmV4dCkpIHsgc3RyZWFtLmVycihcIkV4cGVjdGVkIG51bWJlciwgZ290ICdcIiArIHN0cmVhbS5uZXh0ICsgXCInXCIpOyB9XG4gIHZhciByZXN1bHQgPSBOdW1iZXIoc3RyZWFtLm5leHQpO1xuICBzdHJlYW0ucG9zKys7XG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gcGFyc2VFeHByUmFuZ2Uoc3RyZWFtLCBleHByKSB7XG4gIHZhciBtaW4gPSBwYXJzZU51bShzdHJlYW0pLCBtYXggPSBtaW47XG4gIGlmIChzdHJlYW0uZWF0KFwiLFwiKSkge1xuICAgIGlmIChzdHJlYW0ubmV4dCAhPSBcIn1cIikgeyBtYXggPSBwYXJzZU51bShzdHJlYW0pOyB9XG4gICAgZWxzZSB7IG1heCA9IC0xOyB9XG4gIH1cbiAgaWYgKCFzdHJlYW0uZWF0KFwifVwiKSkgeyBzdHJlYW0uZXJyKFwiVW5jbG9zZWQgYnJhY2VkIHJhbmdlXCIpOyB9XG4gIHJldHVybiB7dHlwZTogXCJyYW5nZVwiLCBtaW46IG1pbiwgbWF4OiBtYXgsIGV4cHI6IGV4cHJ9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVOYW1lKHN0cmVhbSwgbmFtZSkge1xuICB2YXIgdHlwZXMgPSBzdHJlYW0ubm9kZVR5cGVzLCB0eXBlID0gdHlwZXNbbmFtZV07XG4gIGlmICh0eXBlKSB7IHJldHVybiBbdHlwZV0gfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIHR5cGVOYW1lIGluIHR5cGVzKSB7XG4gICAgdmFyIHR5cGUkMSA9IHR5cGVzW3R5cGVOYW1lXTtcbiAgICBpZiAodHlwZSQxLmdyb3Vwcy5pbmRleE9mKG5hbWUpID4gLTEpIHsgcmVzdWx0LnB1c2godHlwZSQxKTsgfVxuICB9XG4gIGlmIChyZXN1bHQubGVuZ3RoID09IDApIHsgc3RyZWFtLmVycihcIk5vIG5vZGUgdHlwZSBvciBncm91cCAnXCIgKyBuYW1lICsgXCInIGZvdW5kXCIpOyB9XG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gcGFyc2VFeHByQXRvbShzdHJlYW0pIHtcbiAgaWYgKHN0cmVhbS5lYXQoXCIoXCIpKSB7XG4gICAgdmFyIGV4cHIgPSBwYXJzZUV4cHIoc3RyZWFtKTtcbiAgICBpZiAoIXN0cmVhbS5lYXQoXCIpXCIpKSB7IHN0cmVhbS5lcnIoXCJNaXNzaW5nIGNsb3NpbmcgcGFyZW5cIik7IH1cbiAgICByZXR1cm4gZXhwclxuICB9IGVsc2UgaWYgKCEvXFxXLy50ZXN0KHN0cmVhbS5uZXh0KSkge1xuICAgIHZhciBleHBycyA9IHJlc29sdmVOYW1lKHN0cmVhbSwgc3RyZWFtLm5leHQpLm1hcChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgaWYgKHN0cmVhbS5pbmxpbmUgPT0gbnVsbCkgeyBzdHJlYW0uaW5saW5lID0gdHlwZS5pc0lubGluZTsgfVxuICAgICAgZWxzZSBpZiAoc3RyZWFtLmlubGluZSAhPSB0eXBlLmlzSW5saW5lKSB7IHN0cmVhbS5lcnIoXCJNaXhpbmcgaW5saW5lIGFuZCBibG9jayBjb250ZW50XCIpOyB9XG4gICAgICByZXR1cm4ge3R5cGU6IFwibmFtZVwiLCB2YWx1ZTogdHlwZX1cbiAgICB9KTtcbiAgICBzdHJlYW0ucG9zKys7XG4gICAgcmV0dXJuIGV4cHJzLmxlbmd0aCA9PSAxID8gZXhwcnNbMF0gOiB7dHlwZTogXCJjaG9pY2VcIiwgZXhwcnM6IGV4cHJzfVxuICB9IGVsc2Uge1xuICAgIHN0cmVhbS5lcnIoXCJVbmV4cGVjdGVkIHRva2VuICdcIiArIHN0cmVhbS5uZXh0ICsgXCInXCIpO1xuICB9XG59XG5cbi8vIFRoZSBjb2RlIGJlbG93IGhlbHBzIGNvbXBpbGUgYSByZWd1bGFyLWV4cHJlc3Npb24tbGlrZSBsYW5ndWFnZVxuLy8gaW50byBhIGRldGVybWluaXN0aWMgZmluaXRlIGF1dG9tYXRvbi4gRm9yIGEgZ29vZCBpbnRyb2R1Y3Rpb24gdG9cbi8vIHRoZXNlIGNvbmNlcHRzLCBzZWUgaHR0cHM6Ly9zd3RjaC5jb20vfnJzYy9yZWdleHAvcmVnZXhwMS5odG1sXG5cbi8vIDogKE9iamVjdCkg4oaSIFtbe3Rlcm06ID9hbnksIHRvOiBudW1iZXJ9XV1cbi8vIENvbnN0cnVjdCBhbiBORkEgZnJvbSBhbiBleHByZXNzaW9uIGFzIHJldHVybmVkIGJ5IHRoZSBwYXJzZXIuIFRoZVxuLy8gTkZBIGlzIHJlcHJlc2VudGVkIGFzIGFuIGFycmF5IG9mIHN0YXRlcywgd2hpY2ggYXJlIHRoZW1zZWx2ZXNcbi8vIGFycmF5cyBvZiBlZGdlcywgd2hpY2ggYXJlIGB7dGVybSwgdG99YCBvYmplY3RzLiBUaGUgZmlyc3Qgc3RhdGUgaXNcbi8vIHRoZSBlbnRyeSBzdGF0ZSBhbmQgdGhlIGxhc3Qgbm9kZSBpcyB0aGUgc3VjY2VzcyBzdGF0ZS5cbi8vXG4vLyBOb3RlIHRoYXQgdW5saWtlIHR5cGljYWwgTkZBcywgdGhlIGVkZ2Ugb3JkZXJpbmcgaW4gdGhpcyBvbmUgaXNcbi8vIHNpZ25pZmljYW50LCBpbiB0aGF0IGl0IGlzIHVzZWQgdG8gY29udHJ1Y3QgZmlsbGVyIGNvbnRlbnQgd2hlblxuLy8gbmVjZXNzYXJ5LlxuZnVuY3Rpb24gbmZhKGV4cHIpIHtcbiAgdmFyIG5mYSA9IFtbXV07XG4gIGNvbm5lY3QoY29tcGlsZShleHByLCAwKSwgbm9kZSgpKTtcbiAgcmV0dXJuIG5mYVxuXG4gIGZ1bmN0aW9uIG5vZGUoKSB7IHJldHVybiBuZmEucHVzaChbXSkgLSAxIH1cbiAgZnVuY3Rpb24gZWRnZShmcm9tLCB0bywgdGVybSkge1xuICAgIHZhciBlZGdlID0ge3Rlcm06IHRlcm0sIHRvOiB0b307XG4gICAgbmZhW2Zyb21dLnB1c2goZWRnZSk7XG4gICAgcmV0dXJuIGVkZ2VcbiAgfVxuICBmdW5jdGlvbiBjb25uZWN0KGVkZ2VzLCB0bykgeyBlZGdlcy5mb3JFYWNoKGZ1bmN0aW9uIChlZGdlKSB7IHJldHVybiBlZGdlLnRvID0gdG87IH0pOyB9XG5cbiAgZnVuY3Rpb24gY29tcGlsZShleHByLCBmcm9tKSB7XG4gICAgaWYgKGV4cHIudHlwZSA9PSBcImNob2ljZVwiKSB7XG4gICAgICByZXR1cm4gZXhwci5leHBycy5yZWR1Y2UoZnVuY3Rpb24gKG91dCwgZXhwcikgeyByZXR1cm4gb3V0LmNvbmNhdChjb21waWxlKGV4cHIsIGZyb20pKTsgfSwgW10pXG4gICAgfSBlbHNlIGlmIChleHByLnR5cGUgPT0gXCJzZXFcIikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7OyBpKyspIHtcbiAgICAgICAgdmFyIG5leHQgPSBjb21waWxlKGV4cHIuZXhwcnNbaV0sIGZyb20pO1xuICAgICAgICBpZiAoaSA9PSBleHByLmV4cHJzLmxlbmd0aCAtIDEpIHsgcmV0dXJuIG5leHQgfVxuICAgICAgICBjb25uZWN0KG5leHQsIGZyb20gPSBub2RlKCkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZXhwci50eXBlID09IFwic3RhclwiKSB7XG4gICAgICB2YXIgbG9vcCA9IG5vZGUoKTtcbiAgICAgIGVkZ2UoZnJvbSwgbG9vcCk7XG4gICAgICBjb25uZWN0KGNvbXBpbGUoZXhwci5leHByLCBsb29wKSwgbG9vcCk7XG4gICAgICByZXR1cm4gW2VkZ2UobG9vcCldXG4gICAgfSBlbHNlIGlmIChleHByLnR5cGUgPT0gXCJwbHVzXCIpIHtcbiAgICAgIHZhciBsb29wJDEgPSBub2RlKCk7XG4gICAgICBjb25uZWN0KGNvbXBpbGUoZXhwci5leHByLCBmcm9tKSwgbG9vcCQxKTtcbiAgICAgIGNvbm5lY3QoY29tcGlsZShleHByLmV4cHIsIGxvb3AkMSksIGxvb3AkMSk7XG4gICAgICByZXR1cm4gW2VkZ2UobG9vcCQxKV1cbiAgICB9IGVsc2UgaWYgKGV4cHIudHlwZSA9PSBcIm9wdFwiKSB7XG4gICAgICByZXR1cm4gW2VkZ2UoZnJvbSldLmNvbmNhdChjb21waWxlKGV4cHIuZXhwciwgZnJvbSkpXG4gICAgfSBlbHNlIGlmIChleHByLnR5cGUgPT0gXCJyYW5nZVwiKSB7XG4gICAgICB2YXIgY3VyID0gZnJvbTtcbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGV4cHIubWluOyBpJDErKykge1xuICAgICAgICB2YXIgbmV4dCQxID0gbm9kZSgpO1xuICAgICAgICBjb25uZWN0KGNvbXBpbGUoZXhwci5leHByLCBjdXIpLCBuZXh0JDEpO1xuICAgICAgICBjdXIgPSBuZXh0JDE7XG4gICAgICB9XG4gICAgICBpZiAoZXhwci5tYXggPT0gLTEpIHtcbiAgICAgICAgY29ubmVjdChjb21waWxlKGV4cHIuZXhwciwgY3VyKSwgY3VyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkkMiA9IGV4cHIubWluOyBpJDIgPCBleHByLm1heDsgaSQyKyspIHtcbiAgICAgICAgICB2YXIgbmV4dCQyID0gbm9kZSgpO1xuICAgICAgICAgIGVkZ2UoY3VyLCBuZXh0JDIpO1xuICAgICAgICAgIGNvbm5lY3QoY29tcGlsZShleHByLmV4cHIsIGN1ciksIG5leHQkMik7XG4gICAgICAgICAgY3VyID0gbmV4dCQyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gW2VkZ2UoY3VyKV1cbiAgICB9IGVsc2UgaWYgKGV4cHIudHlwZSA9PSBcIm5hbWVcIikge1xuICAgICAgcmV0dXJuIFtlZGdlKGZyb20sIG51bGwsIGV4cHIudmFsdWUpXVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjbXAoYSwgYikgeyByZXR1cm4gYiAtIGEgfVxuXG4vLyBHZXQgdGhlIHNldCBvZiBub2RlcyByZWFjaGFibGUgYnkgbnVsbCBlZGdlcyBmcm9tIGBub2RlYC4gT21pdFxuLy8gbm9kZXMgd2l0aCBvbmx5IGEgc2luZ2xlIG51bGwtb3V0LWVkZ2UsIHNpbmNlIHRoZXkgbWF5IGxlYWQgdG9cbi8vIG5lZWRsZXNzIGR1cGxpY2F0ZWQgbm9kZXMuXG5mdW5jdGlvbiBudWxsRnJvbShuZmEsIG5vZGUpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBzY2FuKG5vZGUpO1xuICByZXR1cm4gcmVzdWx0LnNvcnQoY21wKVxuXG4gIGZ1bmN0aW9uIHNjYW4obm9kZSkge1xuICAgIHZhciBlZGdlcyA9IG5mYVtub2RlXTtcbiAgICBpZiAoZWRnZXMubGVuZ3RoID09IDEgJiYgIWVkZ2VzWzBdLnRlcm0pIHsgcmV0dXJuIHNjYW4oZWRnZXNbMF0udG8pIH1cbiAgICByZXN1bHQucHVzaChub2RlKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcmVmID0gZWRnZXNbaV07XG4gICAgICB2YXIgdGVybSA9IHJlZi50ZXJtO1xuICAgICAgdmFyIHRvID0gcmVmLnRvO1xuICAgICAgaWYgKCF0ZXJtICYmIHJlc3VsdC5pbmRleE9mKHRvKSA9PSAtMSkgeyBzY2FuKHRvKTsgfVxuICAgIH1cbiAgfVxufVxuXG4vLyA6IChbW3t0ZXJtOiA/YW55LCB0bzogbnVtYmVyfV1dKSDihpIgQ29udGVudE1hdGNoXG4vLyBDb21waWxlcyBhbiBORkEgYXMgcHJvZHVjZWQgYnkgYG5mYWAgaW50byBhIERGQSwgbW9kZWxlZCBhcyBhIHNldFxuLy8gb2Ygc3RhdGUgb2JqZWN0cyAoYENvbnRlbnRNYXRjaGAgaW5zdGFuY2VzKSB3aXRoIHRyYW5zaXRpb25zXG4vLyBiZXR3ZWVuIHRoZW0uXG5mdW5jdGlvbiBkZmEobmZhKSB7XG4gIHZhciBsYWJlbGVkID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmV0dXJuIGV4cGxvcmUobnVsbEZyb20obmZhLCAwKSlcblxuICBmdW5jdGlvbiBleHBsb3JlKHN0YXRlcykge1xuICAgIHZhciBvdXQgPSBbXTtcbiAgICBzdGF0ZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgbmZhW25vZGVdLmZvckVhY2goZnVuY3Rpb24gKHJlZikge1xuICAgICAgICB2YXIgdGVybSA9IHJlZi50ZXJtO1xuICAgICAgICB2YXIgdG8gPSByZWYudG87XG5cbiAgICAgICAgaWYgKCF0ZXJtKSB7IHJldHVybiB9XG4gICAgICAgIHZhciBrbm93biA9IG91dC5pbmRleE9mKHRlcm0pLCBzZXQgPSBrbm93biA+IC0xICYmIG91dFtrbm93biArIDFdO1xuICAgICAgICBudWxsRnJvbShuZmEsIHRvKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgaWYgKCFzZXQpIHsgb3V0LnB1c2godGVybSwgc2V0ID0gW10pOyB9XG4gICAgICAgICAgaWYgKHNldC5pbmRleE9mKG5vZGUpID09IC0xKSB7IHNldC5wdXNoKG5vZGUpOyB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgdmFyIHN0YXRlID0gbGFiZWxlZFtzdGF0ZXMuam9pbihcIixcIildID0gbmV3IENvbnRlbnRNYXRjaChzdGF0ZXMuaW5kZXhPZihuZmEubGVuZ3RoIC0gMSkgPiAtMSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXQubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIHZhciBzdGF0ZXMkMSA9IG91dFtpICsgMV0uc29ydChjbXApO1xuICAgICAgc3RhdGUubmV4dC5wdXNoKG91dFtpXSwgbGFiZWxlZFtzdGF0ZXMkMS5qb2luKFwiLFwiKV0gfHwgZXhwbG9yZShzdGF0ZXMkMSkpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGVcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0ZvckRlYWRFbmRzKG1hdGNoLCBzdHJlYW0pIHtcbiAgZm9yICh2YXIgaSA9IDAsIHdvcmsgPSBbbWF0Y2hdOyBpIDwgd29yay5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzdGF0ZSA9IHdvcmtbaV0sIGRlYWQgPSAhc3RhdGUudmFsaWRFbmQsIG5vZGVzID0gW107XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBzdGF0ZS5uZXh0Lmxlbmd0aDsgaiArPSAyKSB7XG4gICAgICB2YXIgbm9kZSA9IHN0YXRlLm5leHRbal0sIG5leHQgPSBzdGF0ZS5uZXh0W2ogKyAxXTtcbiAgICAgIG5vZGVzLnB1c2gobm9kZS5uYW1lKTtcbiAgICAgIGlmIChkZWFkICYmICEobm9kZS5pc1RleHQgfHwgbm9kZS5oYXNSZXF1aXJlZEF0dHJzKCkpKSB7IGRlYWQgPSBmYWxzZTsgfVxuICAgICAgaWYgKHdvcmsuaW5kZXhPZihuZXh0KSA9PSAtMSkgeyB3b3JrLnB1c2gobmV4dCk7IH1cbiAgICB9XG4gICAgaWYgKGRlYWQpIHsgc3RyZWFtLmVycihcIk9ubHkgbm9uLWdlbmVyYXRhYmxlIG5vZGVzIChcIiArIG5vZGVzLmpvaW4oXCIsIFwiKSArIFwiKSBpbiBhIHJlcXVpcmVkIHBvc2l0aW9uIChzZWUgaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9ndWlkZS8jZ2VuZXJhdGFibGUpXCIpOyB9XG4gIH1cbn1cblxuLy8gRm9yIG5vZGUgdHlwZXMgd2hlcmUgYWxsIGF0dHJzIGhhdmUgYSBkZWZhdWx0IHZhbHVlIChvciB3aGljaCBkb24ndFxuLy8gaGF2ZSBhbnkgYXR0cmlidXRlcyksIGJ1aWxkIHVwIGEgc2luZ2xlIHJldXNhYmxlIGRlZmF1bHQgYXR0cmlidXRlXG4vLyBvYmplY3QsIGFuZCB1c2UgaXQgZm9yIGFsbCBub2RlcyB0aGF0IGRvbid0IHNwZWNpZnkgc3BlY2lmaWNcbi8vIGF0dHJpYnV0ZXMuXG5mdW5jdGlvbiBkZWZhdWx0QXR0cnMoYXR0cnMpIHtcbiAgdmFyIGRlZmF1bHRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZm9yICh2YXIgYXR0ck5hbWUgaW4gYXR0cnMpIHtcbiAgICB2YXIgYXR0ciA9IGF0dHJzW2F0dHJOYW1lXTtcbiAgICBpZiAoIWF0dHIuaGFzRGVmYXVsdCkgeyByZXR1cm4gbnVsbCB9XG4gICAgZGVmYXVsdHNbYXR0ck5hbWVdID0gYXR0ci5kZWZhdWx0O1xuICB9XG4gIHJldHVybiBkZWZhdWx0c1xufVxuXG5mdW5jdGlvbiBjb21wdXRlQXR0cnMoYXR0cnMsIHZhbHVlKSB7XG4gIHZhciBidWlsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGZvciAodmFyIG5hbWUgaW4gYXR0cnMpIHtcbiAgICB2YXIgZ2l2ZW4gPSB2YWx1ZSAmJiB2YWx1ZVtuYW1lXTtcbiAgICBpZiAoZ2l2ZW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGF0dHIgPSBhdHRyc1tuYW1lXTtcbiAgICAgIGlmIChhdHRyLmhhc0RlZmF1bHQpIHsgZ2l2ZW4gPSBhdHRyLmRlZmF1bHQ7IH1cbiAgICAgIGVsc2UgeyB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk5vIHZhbHVlIHN1cHBsaWVkIGZvciBhdHRyaWJ1dGUgXCIgKyBuYW1lKSB9XG4gICAgfVxuICAgIGJ1aWx0W25hbWVdID0gZ2l2ZW47XG4gIH1cbiAgcmV0dXJuIGJ1aWx0XG59XG5cbmZ1bmN0aW9uIGluaXRBdHRycyhhdHRycykge1xuICB2YXIgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWYgKGF0dHJzKSB7IGZvciAodmFyIG5hbWUgaW4gYXR0cnMpIHsgcmVzdWx0W25hbWVdID0gbmV3IEF0dHJpYnV0ZShhdHRyc1tuYW1lXSk7IH0gfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8vIDo6LSBOb2RlIHR5cGVzIGFyZSBvYmplY3RzIGFsbG9jYXRlZCBvbmNlIHBlciBgU2NoZW1hYCBhbmQgdXNlZCB0b1xuLy8gW3RhZ10oI21vZGVsLk5vZGUudHlwZSkgYE5vZGVgIGluc3RhbmNlcy4gVGhleSBjb250YWluIGluZm9ybWF0aW9uXG4vLyBhYm91dCB0aGUgbm9kZSB0eXBlLCBzdWNoIGFzIGl0cyBuYW1lIGFuZCB3aGF0IGtpbmQgb2Ygbm9kZSBpdFxuLy8gcmVwcmVzZW50cy5cbnZhciBOb2RlVHlwZSA9IGZ1bmN0aW9uIE5vZGVUeXBlKG5hbWUsIHNjaGVtYSwgc3BlYykge1xuICAvLyA6OiBzdHJpbmdcbiAgLy8gVGhlIG5hbWUgdGhlIG5vZGUgdHlwZSBoYXMgaW4gdGhpcyBzY2hlbWEuXG4gIHRoaXMubmFtZSA9IG5hbWU7XG5cbiAgLy8gOjogU2NoZW1hXG4gIC8vIEEgbGluayBiYWNrIHRvIHRoZSBgU2NoZW1hYCB0aGUgbm9kZSB0eXBlIGJlbG9uZ3MgdG8uXG4gIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuXG4gIC8vIDo6IE5vZGVTcGVjXG4gIC8vIFRoZSBzcGVjIHRoYXQgdGhpcyB0eXBlIGlzIGJhc2VkIG9uXG4gIHRoaXMuc3BlYyA9IHNwZWM7XG5cbiAgdGhpcy5ncm91cHMgPSBzcGVjLmdyb3VwID8gc3BlYy5ncm91cC5zcGxpdChcIiBcIikgOiBbXTtcbiAgdGhpcy5hdHRycyA9IGluaXRBdHRycyhzcGVjLmF0dHJzKTtcblxuICB0aGlzLmRlZmF1bHRBdHRycyA9IGRlZmF1bHRBdHRycyh0aGlzLmF0dHJzKTtcblxuICAvLyA6OiBDb250ZW50TWF0Y2hcbiAgLy8gVGhlIHN0YXJ0aW5nIG1hdGNoIG9mIHRoZSBub2RlIHR5cGUncyBjb250ZW50IGV4cHJlc3Npb24uXG4gIHRoaXMuY29udGVudE1hdGNoID0gbnVsbDtcblxuICAvLyA6ID9bTWFya1R5cGVdXG4gIC8vIFRoZSBzZXQgb2YgbWFya3MgYWxsb3dlZCBpbiB0aGlzIG5vZGUuIGBudWxsYCBtZWFucyBhbGwgbWFya3NcbiAgLy8gYXJlIGFsbG93ZWQuXG4gIHRoaXMubWFya1NldCA9IG51bGw7XG5cbiAgLy8gOjogYm9vbFxuICAvLyBUcnVlIGlmIHRoaXMgbm9kZSB0eXBlIGhhcyBpbmxpbmUgY29udGVudC5cbiAgdGhpcy5pbmxpbmVDb250ZW50ID0gbnVsbDtcblxuICAvLyA6OiBib29sXG4gIC8vIFRydWUgaWYgdGhpcyBpcyBhIGJsb2NrIHR5cGVcbiAgdGhpcy5pc0Jsb2NrID0gIShzcGVjLmlubGluZSB8fCBuYW1lID09IFwidGV4dFwiKTtcblxuICAvLyA6OiBib29sXG4gIC8vIFRydWUgaWYgdGhpcyBpcyB0aGUgdGV4dCBub2RlIHR5cGUuXG4gIHRoaXMuaXNUZXh0ID0gbmFtZSA9PSBcInRleHRcIjtcbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMkNSA9IHsgaXNJbmxpbmU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0saXNUZXh0YmxvY2s6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0saXNMZWFmOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGlzQXRvbTogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG4vLyA6OiBib29sXG4vLyBUcnVlIGlmIHRoaXMgaXMgYW4gaW5saW5lIHR5cGUuXG5wcm90b3R5cGVBY2Nlc3NvcnMkNS5pc0lubGluZS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAhdGhpcy5pc0Jsb2NrIH07XG5cbi8vIDo6IGJvb2xcbi8vIFRydWUgaWYgdGhpcyBpcyBhIHRleHRibG9jayB0eXBlLCBhIGJsb2NrIHRoYXQgY29udGFpbnMgaW5saW5lXG4vLyBjb250ZW50LlxucHJvdG90eXBlQWNjZXNzb3JzJDUuaXNUZXh0YmxvY2suZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5pc0Jsb2NrICYmIHRoaXMuaW5saW5lQ29udGVudCB9O1xuXG4vLyA6OiBib29sXG4vLyBUcnVlIGZvciBub2RlIHR5cGVzIHRoYXQgYWxsb3cgbm8gY29udGVudC5cbnByb3RvdHlwZUFjY2Vzc29ycyQ1LmlzTGVhZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmNvbnRlbnRNYXRjaCA9PSBDb250ZW50TWF0Y2guZW1wdHkgfTtcblxuLy8gOjogYm9vbFxuLy8gVHJ1ZSB3aGVuIHRoaXMgbm9kZSBpcyBhbiBhdG9tLCBpLmUuIHdoZW4gaXQgZG9lcyBub3QgaGF2ZVxuLy8gZGlyZWN0bHkgZWRpdGFibGUgY29udGVudC5cbnByb3RvdHlwZUFjY2Vzc29ycyQ1LmlzQXRvbS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmlzTGVhZiB8fCB0aGlzLnNwZWMuYXRvbSB9O1xuXG4vLyA6OiAoKSDihpIgYm9vbFxuLy8gVGVsbHMgeW91IHdoZXRoZXIgdGhpcyBub2RlIHR5cGUgaGFzIGFueSByZXF1aXJlZCBhdHRyaWJ1dGVzLlxuTm9kZVR5cGUucHJvdG90eXBlLmhhc1JlcXVpcmVkQXR0cnMgPSBmdW5jdGlvbiBoYXNSZXF1aXJlZEF0dHJzICgpIHtcbiAgZm9yICh2YXIgbiBpbiB0aGlzLmF0dHJzKSB7IGlmICh0aGlzLmF0dHJzW25dLmlzUmVxdWlyZWQpIHsgcmV0dXJuIHRydWUgfSB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuTm9kZVR5cGUucHJvdG90eXBlLmNvbXBhdGlibGVDb250ZW50ID0gZnVuY3Rpb24gY29tcGF0aWJsZUNvbnRlbnQgKG90aGVyKSB7XG4gIHJldHVybiB0aGlzID09IG90aGVyIHx8IHRoaXMuY29udGVudE1hdGNoLmNvbXBhdGlibGUob3RoZXIuY29udGVudE1hdGNoKVxufTtcblxuTm9kZVR5cGUucHJvdG90eXBlLmNvbXB1dGVBdHRycyA9IGZ1bmN0aW9uIGNvbXB1dGVBdHRycyQxIChhdHRycykge1xuICBpZiAoIWF0dHJzICYmIHRoaXMuZGVmYXVsdEF0dHJzKSB7IHJldHVybiB0aGlzLmRlZmF1bHRBdHRycyB9XG4gIGVsc2UgeyByZXR1cm4gY29tcHV0ZUF0dHJzKHRoaXMuYXR0cnMsIGF0dHJzKSB9XG59O1xuXG4vLyA6OiAoP09iamVjdCwgP3VuaW9uPEZyYWdtZW50LCBOb2RlLCBbTm9kZV0+LCA/W01hcmtdKSDihpIgTm9kZVxuLy8gQ3JlYXRlIGEgYE5vZGVgIG9mIHRoaXMgdHlwZS4gVGhlIGdpdmVuIGF0dHJpYnV0ZXMgYXJlXG4vLyBjaGVja2VkIGFuZCBkZWZhdWx0ZWQgKHlvdSBjYW4gcGFzcyBgbnVsbGAgdG8gdXNlIHRoZSB0eXBlJ3Ncbi8vIGRlZmF1bHRzIGVudGlyZWx5LCBpZiBubyByZXF1aXJlZCBhdHRyaWJ1dGVzIGV4aXN0KS4gYGNvbnRlbnRgXG4vLyBtYXkgYmUgYSBgRnJhZ21lbnRgLCBhIG5vZGUsIGFuIGFycmF5IG9mIG5vZGVzLCBvclxuLy8gYG51bGxgLiBTaW1pbGFybHkgYG1hcmtzYCBtYXkgYmUgYG51bGxgIHRvIGRlZmF1bHQgdG8gdGhlIGVtcHR5XG4vLyBzZXQgb2YgbWFya3MuXG5Ob2RlVHlwZS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlIChhdHRycywgY29udGVudCwgbWFya3MpIHtcbiAgaWYgKHRoaXMuaXNUZXh0KSB7IHRocm93IG5ldyBFcnJvcihcIk5vZGVUeXBlLmNyZWF0ZSBjYW4ndCBjb25zdHJ1Y3QgdGV4dCBub2Rlc1wiKSB9XG4gIHJldHVybiBuZXcgTm9kZSh0aGlzLCB0aGlzLmNvbXB1dGVBdHRycyhhdHRycyksIEZyYWdtZW50LmZyb20oY29udGVudCksIE1hcmsuc2V0RnJvbShtYXJrcykpXG59O1xuXG4vLyA6OiAoP09iamVjdCwgP3VuaW9uPEZyYWdtZW50LCBOb2RlLCBbTm9kZV0+LCA/W01hcmtdKSDihpIgTm9kZVxuLy8gTGlrZSBbYGNyZWF0ZWBdKCNtb2RlbC5Ob2RlVHlwZS5jcmVhdGUpLCBidXQgY2hlY2sgdGhlIGdpdmVuIGNvbnRlbnRcbi8vIGFnYWluc3QgdGhlIG5vZGUgdHlwZSdzIGNvbnRlbnQgcmVzdHJpY3Rpb25zLCBhbmQgdGhyb3cgYW4gZXJyb3Jcbi8vIGlmIGl0IGRvZXNuJ3QgbWF0Y2guXG5Ob2RlVHlwZS5wcm90b3R5cGUuY3JlYXRlQ2hlY2tlZCA9IGZ1bmN0aW9uIGNyZWF0ZUNoZWNrZWQgKGF0dHJzLCBjb250ZW50LCBtYXJrcykge1xuICBjb250ZW50ID0gRnJhZ21lbnQuZnJvbShjb250ZW50KTtcbiAgaWYgKCF0aGlzLnZhbGlkQ29udGVudChjb250ZW50KSlcbiAgICB7IHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBjb250ZW50IGZvciBub2RlIFwiICsgdGhpcy5uYW1lKSB9XG4gIHJldHVybiBuZXcgTm9kZSh0aGlzLCB0aGlzLmNvbXB1dGVBdHRycyhhdHRycyksIGNvbnRlbnQsIE1hcmsuc2V0RnJvbShtYXJrcykpXG59O1xuXG4vLyA6OiAoP09iamVjdCwgP3VuaW9uPEZyYWdtZW50LCBOb2RlLCBbTm9kZV0+LCA/W01hcmtdKSDihpIgP05vZGVcbi8vIExpa2UgW2BjcmVhdGVgXSgjbW9kZWwuTm9kZVR5cGUuY3JlYXRlKSwgYnV0IHNlZSBpZiBpdCBpcyBuZWNlc3NhcnkgdG9cbi8vIGFkZCBub2RlcyB0byB0aGUgc3RhcnQgb3IgZW5kIG9mIHRoZSBnaXZlbiBmcmFnbWVudCB0byBtYWtlIGl0XG4vLyBmaXQgdGhlIG5vZGUuIElmIG5vIGZpdHRpbmcgd3JhcHBpbmcgY2FuIGJlIGZvdW5kLCByZXR1cm4gbnVsbC5cbi8vIE5vdGUgdGhhdCwgZHVlIHRvIHRoZSBmYWN0IHRoYXQgcmVxdWlyZWQgbm9kZXMgY2FuIGFsd2F5cyBiZVxuLy8gY3JlYXRlZCwgdGhpcyB3aWxsIGFsd2F5cyBzdWNjZWVkIGlmIHlvdSBwYXNzIG51bGwgb3Jcbi8vIGBGcmFnbWVudC5lbXB0eWAgYXMgY29udGVudC5cbk5vZGVUeXBlLnByb3RvdHlwZS5jcmVhdGVBbmRGaWxsID0gZnVuY3Rpb24gY3JlYXRlQW5kRmlsbCAoYXR0cnMsIGNvbnRlbnQsIG1hcmtzKSB7XG4gIGF0dHJzID0gdGhpcy5jb21wdXRlQXR0cnMoYXR0cnMpO1xuICBjb250ZW50ID0gRnJhZ21lbnQuZnJvbShjb250ZW50KTtcbiAgaWYgKGNvbnRlbnQuc2l6ZSkge1xuICAgIHZhciBiZWZvcmUgPSB0aGlzLmNvbnRlbnRNYXRjaC5maWxsQmVmb3JlKGNvbnRlbnQpO1xuICAgIGlmICghYmVmb3JlKSB7IHJldHVybiBudWxsIH1cbiAgICBjb250ZW50ID0gYmVmb3JlLmFwcGVuZChjb250ZW50KTtcbiAgfVxuICB2YXIgYWZ0ZXIgPSB0aGlzLmNvbnRlbnRNYXRjaC5tYXRjaEZyYWdtZW50KGNvbnRlbnQpLmZpbGxCZWZvcmUoRnJhZ21lbnQuZW1wdHksIHRydWUpO1xuICBpZiAoIWFmdGVyKSB7IHJldHVybiBudWxsIH1cbiAgcmV0dXJuIG5ldyBOb2RlKHRoaXMsIGF0dHJzLCBjb250ZW50LmFwcGVuZChhZnRlciksIE1hcmsuc2V0RnJvbShtYXJrcykpXG59O1xuXG4vLyA6OiAoRnJhZ21lbnQpIOKGkiBib29sXG4vLyBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGZyYWdtZW50IGlzIHZhbGlkIGNvbnRlbnQgZm9yIHRoaXMgbm9kZVxuLy8gdHlwZSB3aXRoIHRoZSBnaXZlbiBhdHRyaWJ1dGVzLlxuTm9kZVR5cGUucHJvdG90eXBlLnZhbGlkQ29udGVudCA9IGZ1bmN0aW9uIHZhbGlkQ29udGVudCAoY29udGVudCkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5jb250ZW50TWF0Y2gubWF0Y2hGcmFnbWVudChjb250ZW50KTtcbiAgaWYgKCFyZXN1bHQgfHwgIXJlc3VsdC52YWxpZEVuZCkgeyByZXR1cm4gZmFsc2UgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRlbnQuY2hpbGRDb3VudDsgaSsrKVxuICAgIHsgaWYgKCF0aGlzLmFsbG93c01hcmtzKGNvbnRlbnQuY2hpbGQoaSkubWFya3MpKSB7IHJldHVybiBmYWxzZSB9IH1cbiAgcmV0dXJuIHRydWVcbn07XG5cbi8vIDo6IChNYXJrVHlwZSkg4oaSIGJvb2xcbi8vIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIG1hcmsgdHlwZSBpcyBhbGxvd2VkIGluIHRoaXMgbm9kZS5cbk5vZGVUeXBlLnByb3RvdHlwZS5hbGxvd3NNYXJrVHlwZSA9IGZ1bmN0aW9uIGFsbG93c01hcmtUeXBlIChtYXJrVHlwZSkge1xuICByZXR1cm4gdGhpcy5tYXJrU2V0ID09IG51bGwgfHwgdGhpcy5tYXJrU2V0LmluZGV4T2YobWFya1R5cGUpID4gLTFcbn07XG5cbi8vIDo6IChbTWFya10pIOKGkiBib29sXG4vLyBUZXN0IHdoZXRoZXIgdGhlIGdpdmVuIHNldCBvZiBtYXJrcyBhcmUgYWxsb3dlZCBpbiB0aGlzIG5vZGUuXG5Ob2RlVHlwZS5wcm90b3R5cGUuYWxsb3dzTWFya3MgPSBmdW5jdGlvbiBhbGxvd3NNYXJrcyAobWFya3MpIHtcbiAgaWYgKHRoaXMubWFya1NldCA9PSBudWxsKSB7IHJldHVybiB0cnVlIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXJrcy5sZW5ndGg7IGkrKykgeyBpZiAoIXRoaXMuYWxsb3dzTWFya1R5cGUobWFya3NbaV0udHlwZSkpIHsgcmV0dXJuIGZhbHNlIH0gfVxuICByZXR1cm4gdHJ1ZVxufTtcblxuLy8gOjogKFtNYXJrXSkg4oaSIFtNYXJrXVxuLy8gUmVtb3ZlcyB0aGUgbWFya3MgdGhhdCBhcmUgbm90IGFsbG93ZWQgaW4gdGhpcyBub2RlIGZyb20gdGhlIGdpdmVuIHNldC5cbk5vZGVUeXBlLnByb3RvdHlwZS5hbGxvd2VkTWFya3MgPSBmdW5jdGlvbiBhbGxvd2VkTWFya3MgKG1hcmtzKSB7XG4gIGlmICh0aGlzLm1hcmtTZXQgPT0gbnVsbCkgeyByZXR1cm4gbWFya3MgfVxuICB2YXIgY29weTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXJrcy5sZW5ndGg7IGkrKykge1xuICAgIGlmICghdGhpcy5hbGxvd3NNYXJrVHlwZShtYXJrc1tpXS50eXBlKSkge1xuICAgICAgaWYgKCFjb3B5KSB7IGNvcHkgPSBtYXJrcy5zbGljZSgwLCBpKTsgfVxuICAgIH0gZWxzZSBpZiAoY29weSkge1xuICAgICAgY29weS5wdXNoKG1hcmtzW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuICFjb3B5ID8gbWFya3MgOiBjb3B5Lmxlbmd0aCA/IGNvcHkgOiBNYXJrLmVtcHR5XG59O1xuXG5Ob2RlVHlwZS5jb21waWxlID0gZnVuY3Rpb24gY29tcGlsZSAobm9kZXMsIHNjaGVtYSkge1xuICB2YXIgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSwgc3BlYykgeyByZXR1cm4gcmVzdWx0W25hbWVdID0gbmV3IE5vZGVUeXBlKG5hbWUsIHNjaGVtYSwgc3BlYyk7IH0pO1xuXG4gIHZhciB0b3BUeXBlID0gc2NoZW1hLnNwZWMudG9wTm9kZSB8fCBcImRvY1wiO1xuICBpZiAoIXJlc3VsdFt0b3BUeXBlXSkgeyB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlNjaGVtYSBpcyBtaXNzaW5nIGl0cyB0b3Agbm9kZSB0eXBlICgnXCIgKyB0b3BUeXBlICsgXCInKVwiKSB9XG4gIGlmICghcmVzdWx0LnRleHQpIHsgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJFdmVyeSBzY2hlbWEgbmVlZHMgYSAndGV4dCcgdHlwZVwiKSB9XG4gIGZvciAodmFyIF8gaW4gcmVzdWx0LnRleHQuYXR0cnMpIHsgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGUgdGV4dCBub2RlIHR5cGUgc2hvdWxkIG5vdCBoYXZlIGF0dHJpYnV0ZXNcIikgfVxuXG4gIHJldHVybiByZXN1bHRcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBOb2RlVHlwZS5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyQ1ICk7XG5cbi8vIEF0dHJpYnV0ZSBkZXNjcmlwdG9yc1xuXG52YXIgQXR0cmlidXRlID0gZnVuY3Rpb24gQXR0cmlidXRlKG9wdGlvbnMpIHtcbiAgdGhpcy5oYXNEZWZhdWx0ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsIFwiZGVmYXVsdFwiKTtcbiAgdGhpcy5kZWZhdWx0ID0gb3B0aW9ucy5kZWZhdWx0O1xufTtcblxudmFyIHByb3RvdHlwZUFjY2Vzc29ycyQxJDMgPSB7IGlzUmVxdWlyZWQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxucHJvdG90eXBlQWNjZXNzb3JzJDEkMy5pc1JlcXVpcmVkLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICF0aGlzLmhhc0RlZmF1bHRcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBBdHRyaWJ1dGUucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMkMSQzICk7XG5cbi8vIE1hcmtzXG5cbi8vIDo6LSBMaWtlIG5vZGVzLCBtYXJrcyAod2hpY2ggYXJlIGFzc29jaWF0ZWQgd2l0aCBub2RlcyB0byBzaWduaWZ5XG4vLyB0aGluZ3MgbGlrZSBlbXBoYXNpcyBvciBiZWluZyBwYXJ0IG9mIGEgbGluaykgYXJlXG4vLyBbdGFnZ2VkXSgjbW9kZWwuTWFyay50eXBlKSB3aXRoIHR5cGUgb2JqZWN0cywgd2hpY2ggYXJlXG4vLyBpbnN0YW50aWF0ZWQgb25jZSBwZXIgYFNjaGVtYWAuXG52YXIgTWFya1R5cGUgPSBmdW5jdGlvbiBNYXJrVHlwZShuYW1lLCByYW5rLCBzY2hlbWEsIHNwZWMpIHtcbiAgLy8gOjogc3RyaW5nXG4gIC8vIFRoZSBuYW1lIG9mIHRoZSBtYXJrIHR5cGUuXG4gIHRoaXMubmFtZSA9IG5hbWU7XG5cbiAgLy8gOjogU2NoZW1hXG4gIC8vIFRoZSBzY2hlbWEgdGhhdCB0aGlzIG1hcmsgdHlwZSBpbnN0YW5jZSBpcyBwYXJ0IG9mLlxuICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcblxuICAvLyA6OiBNYXJrU3BlY1xuICAvLyBUaGUgc3BlYyBvbiB3aGljaCB0aGUgdHlwZSBpcyBiYXNlZC5cbiAgdGhpcy5zcGVjID0gc3BlYztcblxuICB0aGlzLmF0dHJzID0gaW5pdEF0dHJzKHNwZWMuYXR0cnMpO1xuXG4gIHRoaXMucmFuayA9IHJhbms7XG4gIHRoaXMuZXhjbHVkZWQgPSBudWxsO1xuICB2YXIgZGVmYXVsdHMgPSBkZWZhdWx0QXR0cnModGhpcy5hdHRycyk7XG4gIHRoaXMuaW5zdGFuY2UgPSBkZWZhdWx0cyAmJiBuZXcgTWFyayh0aGlzLCBkZWZhdWx0cyk7XG59O1xuXG4vLyA6OiAoP09iamVjdCkg4oaSIE1hcmtcbi8vIENyZWF0ZSBhIG1hcmsgb2YgdGhpcyB0eXBlLiBgYXR0cnNgIG1heSBiZSBgbnVsbGAgb3IgYW4gb2JqZWN0XG4vLyBjb250YWluaW5nIG9ubHkgc29tZSBvZiB0aGUgbWFyaydzIGF0dHJpYnV0ZXMuIFRoZSBvdGhlcnMsIGlmXG4vLyB0aGV5IGhhdmUgZGVmYXVsdHMsIHdpbGwgYmUgYWRkZWQuXG5NYXJrVHlwZS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlIChhdHRycykge1xuICBpZiAoIWF0dHJzICYmIHRoaXMuaW5zdGFuY2UpIHsgcmV0dXJuIHRoaXMuaW5zdGFuY2UgfVxuICByZXR1cm4gbmV3IE1hcmsodGhpcywgY29tcHV0ZUF0dHJzKHRoaXMuYXR0cnMsIGF0dHJzKSlcbn07XG5cbk1hcmtUeXBlLmNvbXBpbGUgPSBmdW5jdGlvbiBjb21waWxlIChtYXJrcywgc2NoZW1hKSB7XG4gIHZhciByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpLCByYW5rID0gMDtcbiAgbWFya3MuZm9yRWFjaChmdW5jdGlvbiAobmFtZSwgc3BlYykgeyByZXR1cm4gcmVzdWx0W25hbWVdID0gbmV3IE1hcmtUeXBlKG5hbWUsIHJhbmsrKywgc2NoZW1hLCBzcGVjKTsgfSk7XG4gIHJldHVybiByZXN1bHRcbn07XG5cbi8vIDo6IChbTWFya10pIOKGkiBbTWFya11cbi8vIFdoZW4gdGhlcmUgaXMgYSBtYXJrIG9mIHRoaXMgdHlwZSBpbiB0aGUgZ2l2ZW4gc2V0LCBhIG5ldyBzZXRcbi8vIHdpdGhvdXQgaXQgaXMgcmV0dXJuZWQuIE90aGVyd2lzZSwgdGhlIGlucHV0IHNldCBpcyByZXR1cm5lZC5cbk1hcmtUeXBlLnByb3RvdHlwZS5yZW1vdmVGcm9tU2V0ID0gZnVuY3Rpb24gcmVtb3ZlRnJvbVNldCAoc2V0KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7IGlmIChzZXRbaV0udHlwZSA9PSB0aGlzKSB7XG4gICAgc2V0ID0gc2V0LnNsaWNlKDAsIGkpLmNvbmNhdChzZXQuc2xpY2UoaSArIDEpKTtcbiAgICBpLS07XG4gIH0gfVxuICByZXR1cm4gc2V0XG59O1xuXG4vLyA6OiAoW01hcmtdKSDihpIgP01hcmtcbi8vIFRlc3RzIHdoZXRoZXIgdGhlcmUgaXMgYSBtYXJrIG9mIHRoaXMgdHlwZSBpbiB0aGUgZ2l2ZW4gc2V0LlxuTWFya1R5cGUucHJvdG90eXBlLmlzSW5TZXQgPSBmdW5jdGlvbiBpc0luU2V0IChzZXQpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspXG4gICAgeyBpZiAoc2V0W2ldLnR5cGUgPT0gdGhpcykgeyByZXR1cm4gc2V0W2ldIH0gfVxufTtcblxuLy8gOjogKE1hcmtUeXBlKSDihpIgYm9vbFxuLy8gUXVlcmllcyB3aGV0aGVyIGEgZ2l2ZW4gbWFyayB0eXBlIGlzXG4vLyBbZXhjbHVkZWRdKCNtb2RlbC5NYXJrU3BlYy5leGNsdWRlcykgYnkgdGhpcyBvbmUuXG5NYXJrVHlwZS5wcm90b3R5cGUuZXhjbHVkZXMgPSBmdW5jdGlvbiBleGNsdWRlcyAob3RoZXIpIHtcbiAgcmV0dXJuIHRoaXMuZXhjbHVkZWQuaW5kZXhPZihvdGhlcikgPiAtMVxufTtcblxuLy8gU2NoZW1hU3BlYzo6IGludGVyZmFjZVxuLy8gQW4gb2JqZWN0IGRlc2NyaWJpbmcgYSBzY2hlbWEsIGFzIHBhc3NlZCB0byB0aGUgW2BTY2hlbWFgXSgjbW9kZWwuU2NoZW1hKVxuLy8gY29uc3RydWN0b3IuXG4vL1xuLy8gICBub2Rlczo6IHVuaW9uPE9iamVjdDxOb2RlU3BlYz4sIE9yZGVyZWRNYXA8Tm9kZVNwZWM+PlxuLy8gICBUaGUgbm9kZSB0eXBlcyBpbiB0aGlzIHNjaGVtYS4gTWFwcyBuYW1lcyB0b1xuLy8gICBbYE5vZGVTcGVjYF0oI21vZGVsLk5vZGVTcGVjKSBvYmplY3RzIHRoYXQgZGVzY3JpYmUgdGhlIG5vZGUgdHlwZVxuLy8gICBhc3NvY2lhdGVkIHdpdGggdGhhdCBuYW1lLiBUaGVpciBvcmRlciBpcyBzaWduaWZpY2FudOKAlGl0XG4vLyAgIGRldGVybWluZXMgd2hpY2ggW3BhcnNlIHJ1bGVzXSgjbW9kZWwuTm9kZVNwZWMucGFyc2VET00pIHRha2Vcbi8vICAgcHJlY2VkZW5jZSBieSBkZWZhdWx0LCBhbmQgd2hpY2ggbm9kZXMgY29tZSBmaXJzdCBpbiBhIGdpdmVuXG4vLyAgIFtncm91cF0oI21vZGVsLk5vZGVTcGVjLmdyb3VwKS5cbi8vXG4vLyAgIG1hcmtzOjogP3VuaW9uPE9iamVjdDxNYXJrU3BlYz4sIE9yZGVyZWRNYXA8TWFya1NwZWM+PlxuLy8gICBUaGUgbWFyayB0eXBlcyB0aGF0IGV4aXN0IGluIHRoaXMgc2NoZW1hLiBUaGUgb3JkZXIgaW4gd2hpY2ggdGhleVxuLy8gICBhcmUgcHJvdmlkZWQgZGV0ZXJtaW5lcyB0aGUgb3JkZXIgaW4gd2hpY2ggW21hcmtcbi8vICAgc2V0c10oI21vZGVsLk1hcmsuYWRkVG9TZXQpIGFyZSBzb3J0ZWQgYW5kIGluIHdoaWNoIFtwYXJzZVxuLy8gICBydWxlc10oI21vZGVsLk1hcmtTcGVjLnBhcnNlRE9NKSBhcmUgdHJpZWQuXG4vL1xuLy8gICB0b3BOb2RlOjogP3N0cmluZ1xuLy8gICBUaGUgbmFtZSBvZiB0aGUgZGVmYXVsdCB0b3AtbGV2ZWwgbm9kZSBmb3IgdGhlIHNjaGVtYS4gRGVmYXVsdHNcbi8vICAgdG8gYFwiZG9jXCJgLlxuXG4vLyBOb2RlU3BlYzo6IGludGVyZmFjZVxuLy9cbi8vICAgY29udGVudDo6ID9zdHJpbmdcbi8vICAgVGhlIGNvbnRlbnQgZXhwcmVzc2lvbiBmb3IgdGhpcyBub2RlLCBhcyBkZXNjcmliZWQgaW4gdGhlIFtzY2hlbWFcbi8vICAgZ3VpZGVdKC9kb2NzL2d1aWRlLyNzY2hlbWEuY29udGVudF9leHByZXNzaW9ucykuIFdoZW4gbm90IGdpdmVuLFxuLy8gICB0aGUgbm9kZSBkb2VzIG5vdCBhbGxvdyBhbnkgY29udGVudC5cbi8vXG4vLyAgIG1hcmtzOjogP3N0cmluZ1xuLy8gICBUaGUgbWFya3MgdGhhdCBhcmUgYWxsb3dlZCBpbnNpZGUgb2YgdGhpcyBub2RlLiBNYXkgYmUgYVxuLy8gICBzcGFjZS1zZXBhcmF0ZWQgc3RyaW5nIHJlZmVycmluZyB0byBtYXJrIG5hbWVzIG9yIGdyb3VwcywgYFwiX1wiYFxuLy8gICB0byBleHBsaWNpdGx5IGFsbG93IGFsbCBtYXJrcywgb3IgYFwiXCJgIHRvIGRpc2FsbG93IG1hcmtzLiBXaGVuXG4vLyAgIG5vdCBnaXZlbiwgbm9kZXMgd2l0aCBpbmxpbmUgY29udGVudCBkZWZhdWx0IHRvIGFsbG93aW5nIGFsbFxuLy8gICBtYXJrcywgb3RoZXIgbm9kZXMgZGVmYXVsdCB0byBub3QgYWxsb3dpbmcgbWFya3MuXG4vL1xuLy8gICBncm91cDo6ID9zdHJpbmdcbi8vICAgVGhlIGdyb3VwIG9yIHNwYWNlLXNlcGFyYXRlZCBncm91cHMgdG8gd2hpY2ggdGhpcyBub2RlIGJlbG9uZ3MsXG4vLyAgIHdoaWNoIGNhbiBiZSByZWZlcnJlZCB0byBpbiB0aGUgY29udGVudCBleHByZXNzaW9ucyBmb3IgdGhlXG4vLyAgIHNjaGVtYS5cbi8vXG4vLyAgIGlubGluZTo6ID9ib29sXG4vLyAgIFNob3VsZCBiZSBzZXQgdG8gdHJ1ZSBmb3IgaW5saW5lIG5vZGVzLiAoSW1wbGllZCBmb3IgdGV4dCBub2Rlcy4pXG4vL1xuLy8gICBhdG9tOjogP2Jvb2xcbi8vICAgQ2FuIGJlIHNldCB0byB0cnVlIHRvIGluZGljYXRlIHRoYXQsIHRob3VnaCB0aGlzIGlzbid0IGEgW2xlYWZcbi8vICAgbm9kZV0oI21vZGVsLk5vZGVUeXBlLmlzTGVhZiksIGl0IGRvZXNuJ3QgaGF2ZSBkaXJlY3RseSBlZGl0YWJsZVxuLy8gICBjb250ZW50IGFuZCBzaG91bGQgYmUgdHJlYXRlZCBhcyBhIHNpbmdsZSB1bml0IGluIHRoZSB2aWV3LlxuLy9cbi8vICAgYXR0cnM6OiA/T2JqZWN0PEF0dHJpYnV0ZVNwZWM+XG4vLyAgIFRoZSBhdHRyaWJ1dGVzIHRoYXQgbm9kZXMgb2YgdGhpcyB0eXBlIGdldC5cbi8vXG4vLyAgIHNlbGVjdGFibGU6OiA/Ym9vbFxuLy8gICBDb250cm9scyB3aGV0aGVyIG5vZGVzIG9mIHRoaXMgdHlwZSBjYW4gYmUgc2VsZWN0ZWQgYXMgYSBbbm9kZVxuLy8gICBzZWxlY3Rpb25dKCNzdGF0ZS5Ob2RlU2VsZWN0aW9uKS4gRGVmYXVsdHMgdG8gdHJ1ZSBmb3Igbm9uLXRleHRcbi8vICAgbm9kZXMuXG4vL1xuLy8gICBkcmFnZ2FibGU6OiA/Ym9vbFxuLy8gICBEZXRlcm1pbmVzIHdoZXRoZXIgbm9kZXMgb2YgdGhpcyB0eXBlIGNhbiBiZSBkcmFnZ2VkIHdpdGhvdXRcbi8vICAgYmVpbmcgc2VsZWN0ZWQuIERlZmF1bHRzIHRvIGZhbHNlLlxuLy9cbi8vICAgY29kZTo6ID9ib29sXG4vLyAgIENhbiBiZSB1c2VkIHRvIGluZGljYXRlIHRoYXQgdGhpcyBub2RlIGNvbnRhaW5zIGNvZGUsIHdoaWNoXG4vLyAgIGNhdXNlcyBzb21lIGNvbW1hbmRzIHRvIGJlaGF2ZSBkaWZmZXJlbnRseS5cbi8vXG4vLyAgIGRlZmluaW5nOjogP2Jvb2xcbi8vICAgRGV0ZXJtaW5lcyB3aGV0aGVyIHRoaXMgbm9kZSBpcyBjb25zaWRlcmVkIGFuIGltcG9ydGFudCBwYXJlbnRcbi8vICAgbm9kZSBkdXJpbmcgcmVwbGFjZSBvcGVyYXRpb25zIChzdWNoIGFzIHBhc3RlKS4gTm9uLWRlZmluaW5nICh0aGVcbi8vICAgZGVmYXVsdCkgbm9kZXMgZ2V0IGRyb3BwZWQgd2hlbiB0aGVpciBlbnRpcmUgY29udGVudCBpcyByZXBsYWNlZCxcbi8vICAgd2hlcmVhcyBkZWZpbmluZyBub2RlcyBwZXJzaXN0IGFuZCB3cmFwIHRoZSBpbnNlcnRlZCBjb250ZW50LlxuLy8gICBMaWtld2lzZSwgaW4gX2luc2VydGVkXyBjb250ZW50IHRoZSBkZWZpbmluZyBwYXJlbnRzIG9mIHRoZVxuLy8gICBjb250ZW50IGFyZSBwcmVzZXJ2ZWQgd2hlbiBwb3NzaWJsZS4gVHlwaWNhbGx5LFxuLy8gICBub24tZGVmYXVsdC1wYXJhZ3JhcGggdGV4dGJsb2NrIHR5cGVzLCBhbmQgcG9zc2libHkgbGlzdCBpdGVtcyxcbi8vICAgYXJlIG1hcmtlZCBhcyBkZWZpbmluZy5cbi8vXG4vLyAgIGlzb2xhdGluZzo6ID9ib29sXG4vLyAgIFdoZW4gZW5hYmxlZCAoZGVmYXVsdCBpcyBmYWxzZSksIHRoZSBzaWRlcyBvZiBub2RlcyBvZiB0aGlzIHR5cGVcbi8vICAgY291bnQgYXMgYm91bmRhcmllcyB0aGF0IHJlZ3VsYXIgZWRpdGluZyBvcGVyYXRpb25zLCBsaWtlXG4vLyAgIGJhY2tzcGFjaW5nIG9yIGxpZnRpbmcsIHdvbid0IGNyb3NzLiBBbiBleGFtcGxlIG9mIGEgbm9kZSB0aGF0XG4vLyAgIHNob3VsZCBwcm9iYWJseSBoYXZlIHRoaXMgZW5hYmxlZCBpcyBhIHRhYmxlIGNlbGwuXG4vL1xuLy8gICB0b0RPTTo6ID8obm9kZTogTm9kZSkg4oaSIERPTU91dHB1dFNwZWNcbi8vICAgRGVmaW5lcyB0aGUgZGVmYXVsdCB3YXkgYSBub2RlIG9mIHRoaXMgdHlwZSBzaG91bGQgYmUgc2VyaWFsaXplZFxuLy8gICB0byBET00vSFRNTCAoYXMgdXNlZCBieVxuLy8gICBbYERPTVNlcmlhbGl6ZXIuZnJvbVNjaGVtYWBdKCNtb2RlbC5ET01TZXJpYWxpemVyXmZyb21TY2hlbWEpKS5cbi8vICAgU2hvdWxkIHJldHVybiBhIERPTSBub2RlIG9yIGFuIFthcnJheVxuLy8gICBzdHJ1Y3R1cmVdKCNtb2RlbC5ET01PdXRwdXRTcGVjKSB0aGF0IGRlc2NyaWJlcyBvbmUsIHdpdGggYW5cbi8vICAgb3B0aW9uYWwgbnVtYmVyIHplcm8gKOKAnGhvbGXigJ0pIGluIGl0IHRvIGluZGljYXRlIHdoZXJlIHRoZSBub2RlJ3Ncbi8vICAgY29udGVudCBzaG91bGQgYmUgaW5zZXJ0ZWQuXG4vL1xuLy8gICBGb3IgdGV4dCBub2RlcywgdGhlIGRlZmF1bHQgaXMgdG8gY3JlYXRlIGEgdGV4dCBET00gbm9kZS4gVGhvdWdoXG4vLyAgIGl0IGlzIHBvc3NpYmxlIHRvIGNyZWF0ZSBhIHNlcmlhbGl6ZXIgd2hlcmUgdGV4dCBpcyByZW5kZXJlZFxuLy8gICBkaWZmZXJlbnRseSwgdGhpcyBpcyBub3Qgc3VwcG9ydGVkIGluc2lkZSB0aGUgZWRpdG9yLCBzbyB5b3Vcbi8vICAgc2hvdWxkbid0IG92ZXJyaWRlIHRoYXQgaW4geW91ciB0ZXh0IG5vZGUgc3BlYy5cbi8vXG4vLyAgIHBhcnNlRE9NOjogP1tQYXJzZVJ1bGVdXG4vLyAgIEFzc29jaWF0ZXMgRE9NIHBhcnNlciBpbmZvcm1hdGlvbiB3aXRoIHRoaXMgbm9kZSwgd2hpY2ggY2FuIGJlXG4vLyAgIHVzZWQgYnkgW2BET01QYXJzZXIuZnJvbVNjaGVtYWBdKCNtb2RlbC5ET01QYXJzZXJeZnJvbVNjaGVtYSkgdG9cbi8vICAgYXV0b21hdGljYWxseSBkZXJpdmUgYSBwYXJzZXIuIFRoZSBgbm9kZWAgZmllbGQgaW4gdGhlIHJ1bGVzIGlzXG4vLyAgIGltcGxpZWQgKHRoZSBuYW1lIG9mIHRoaXMgbm9kZSB3aWxsIGJlIGZpbGxlZCBpbiBhdXRvbWF0aWNhbGx5KS5cbi8vICAgSWYgeW91IHN1cHBseSB5b3VyIG93biBwYXJzZXIsIHlvdSBkbyBub3QgbmVlZCB0byBhbHNvIHNwZWNpZnlcbi8vICAgcGFyc2luZyBydWxlcyBpbiB5b3VyIHNjaGVtYS5cbi8vXG4vLyAgIHRvRGVidWdTdHJpbmc6OiA/KG5vZGU6IE5vZGUpIC0+IHN0cmluZ1xuLy8gICBEZWZpbmVzIHRoZSBkZWZhdWx0IHdheSBhIG5vZGUgb2YgdGhpcyB0eXBlIHNob3VsZCBiZSBzZXJpYWxpemVkXG4vLyAgIHRvIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIGZvciBkZWJ1Z2dpbmcgKGUuZy4gaW4gZXJyb3IgbWVzc2FnZXMpLlxuXG4vLyBNYXJrU3BlYzo6IGludGVyZmFjZVxuLy9cbi8vICAgYXR0cnM6OiA/T2JqZWN0PEF0dHJpYnV0ZVNwZWM+XG4vLyAgIFRoZSBhdHRyaWJ1dGVzIHRoYXQgbWFya3Mgb2YgdGhpcyB0eXBlIGdldC5cbi8vXG4vLyAgIGluY2x1c2l2ZTo6ID9ib29sXG4vLyAgIFdoZXRoZXIgdGhpcyBtYXJrIHNob3VsZCBiZSBhY3RpdmUgd2hlbiB0aGUgY3Vyc29yIGlzIHBvc2l0aW9uZWRcbi8vICAgYXQgaXRzIGVuZCAob3IgYXQgaXRzIHN0YXJ0IHdoZW4gdGhhdCBpcyBhbHNvIHRoZSBzdGFydCBvZiB0aGVcbi8vICAgcGFyZW50IG5vZGUpLiBEZWZhdWx0cyB0byB0cnVlLlxuLy9cbi8vICAgZXhjbHVkZXM6OiA/c3RyaW5nXG4vLyAgIERldGVybWluZXMgd2hpY2ggb3RoZXIgbWFya3MgdGhpcyBtYXJrIGNhbiBjb2V4aXN0IHdpdGguIFNob3VsZFxuLy8gICBiZSBhIHNwYWNlLXNlcGFyYXRlZCBzdHJpbmdzIG5hbWluZyBvdGhlciBtYXJrcyBvciBncm91cHMgb2YgbWFya3MuXG4vLyAgIFdoZW4gYSBtYXJrIGlzIFthZGRlZF0oI21vZGVsLk1hcmsuYWRkVG9TZXQpIHRvIGEgc2V0LCBhbGwgbWFya3Ncbi8vICAgdGhhdCBpdCBleGNsdWRlcyBhcmUgcmVtb3ZlZCBpbiB0aGUgcHJvY2Vzcy4gSWYgdGhlIHNldCBjb250YWluc1xuLy8gICBhbnkgbWFyayB0aGF0IGV4Y2x1ZGVzIHRoZSBuZXcgbWFyayBidXQgaXMgbm90LCBpdHNlbGYsIGV4Y2x1ZGVkXG4vLyAgIGJ5IHRoZSBuZXcgbWFyaywgdGhlIG1hcmsgY2FuIG5vdCBiZSBhZGRlZCBhbiB0aGUgc2V0LiBZb3UgY2FuXG4vLyAgIHVzZSB0aGUgdmFsdWUgYFwiX1wiYCB0byBpbmRpY2F0ZSB0aGF0IHRoZSBtYXJrIGV4Y2x1ZGVzIGFsbFxuLy8gICBtYXJrcyBpbiB0aGUgc2NoZW1hLlxuLy9cbi8vICAgRGVmYXVsdHMgdG8gb25seSBiZWluZyBleGNsdXNpdmUgd2l0aCBtYXJrcyBvZiB0aGUgc2FtZSB0eXBlLiBZb3Vcbi8vICAgY2FuIHNldCBpdCB0byBhbiBlbXB0eSBzdHJpbmcgKG9yIGFueSBzdHJpbmcgbm90IGNvbnRhaW5pbmcgdGhlXG4vLyAgIG1hcmsncyBvd24gbmFtZSkgdG8gYWxsb3cgbXVsdGlwbGUgbWFya3Mgb2YgYSBnaXZlbiB0eXBlIHRvXG4vLyAgIGNvZXhpc3QgKGFzIGxvbmcgYXMgdGhleSBoYXZlIGRpZmZlcmVudCBhdHRyaWJ1dGVzKS5cbi8vXG4vLyAgIGdyb3VwOjogP3N0cmluZ1xuLy8gICBUaGUgZ3JvdXAgb3Igc3BhY2Utc2VwYXJhdGVkIGdyb3VwcyB0byB3aGljaCB0aGlzIG1hcmsgYmVsb25ncy5cbi8vXG4vLyAgIHNwYW5uaW5nOjogP2Jvb2xcbi8vICAgRGV0ZXJtaW5lcyB3aGV0aGVyIG1hcmtzIG9mIHRoaXMgdHlwZSBjYW4gc3BhbiBtdWx0aXBsZSBhZGphY2VudFxuLy8gICBub2RlcyB3aGVuIHNlcmlhbGl6ZWQgdG8gRE9NL0hUTUwuIERlZmF1bHRzIHRvIHRydWUuXG4vL1xuLy8gICB0b0RPTTo6ID8obWFyazogTWFyaywgaW5saW5lOiBib29sKSDihpIgRE9NT3V0cHV0U3BlY1xuLy8gICBEZWZpbmVzIHRoZSBkZWZhdWx0IHdheSBtYXJrcyBvZiB0aGlzIHR5cGUgc2hvdWxkIGJlIHNlcmlhbGl6ZWRcbi8vICAgdG8gRE9NL0hUTUwuIFdoZW4gdGhlIHJlc3VsdGluZyBzcGVjIGNvbnRhaW5zIGEgaG9sZSwgdGhhdCBpc1xuLy8gICB3aGVyZSB0aGUgbWFya2VkIGNvbnRlbnQgaXMgcGxhY2VkLiBPdGhlcndpc2UsIGl0IGlzIGFwcGVuZGVkIHRvXG4vLyAgIHRoZSB0b3Agbm9kZS5cbi8vXG4vLyAgIHBhcnNlRE9NOjogP1tQYXJzZVJ1bGVdXG4vLyAgIEFzc29jaWF0ZXMgRE9NIHBhcnNlciBpbmZvcm1hdGlvbiB3aXRoIHRoaXMgbWFyayAoc2VlIHRoZVxuLy8gICBjb3JyZXNwb25kaW5nIFtub2RlIHNwZWMgZmllbGRdKCNtb2RlbC5Ob2RlU3BlYy5wYXJzZURPTSkpLiBUaGVcbi8vICAgYG1hcmtgIGZpZWxkIGluIHRoZSBydWxlcyBpcyBpbXBsaWVkLlxuXG4vLyBBdHRyaWJ1dGVTcGVjOjogaW50ZXJmYWNlXG4vL1xuLy8gVXNlZCB0byBbZGVmaW5lXSgjbW9kZWwuTm9kZVNwZWMuYXR0cnMpIGF0dHJpYnV0ZXMgb24gbm9kZXMgb3Jcbi8vIG1hcmtzLlxuLy9cbi8vICAgZGVmYXVsdDo6ID9hbnlcbi8vICAgVGhlIGRlZmF1bHQgdmFsdWUgZm9yIHRoaXMgYXR0cmlidXRlLCB0byB1c2Ugd2hlbiBubyBleHBsaWNpdFxuLy8gICB2YWx1ZSBpcyBwcm92aWRlZC4gQXR0cmlidXRlcyB0aGF0IGhhdmUgbm8gZGVmYXVsdCBtdXN0IGJlXG4vLyAgIHByb3ZpZGVkIHdoZW5ldmVyIGEgbm9kZSBvciBtYXJrIG9mIGEgdHlwZSB0aGF0IGhhcyB0aGVtIGlzXG4vLyAgIGNyZWF0ZWQuXG5cbi8vIDo6LSBBIGRvY3VtZW50IHNjaGVtYS4gSG9sZHMgW25vZGVdKCNtb2RlbC5Ob2RlVHlwZSkgYW5kIFttYXJrXG4vLyB0eXBlXSgjbW9kZWwuTWFya1R5cGUpIG9iamVjdHMgZm9yIHRoZSBub2RlcyBhbmQgbWFya3MgdGhhdCBtYXlcbi8vIG9jY3VyIGluIGNvbmZvcm1pbmcgZG9jdW1lbnRzLCBhbmQgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3Jcbi8vIGNyZWF0aW5nIGFuZCBkZXNlcmlhbGl6aW5nIHN1Y2ggZG9jdW1lbnRzLlxudmFyIFNjaGVtYSA9IGZ1bmN0aW9uIFNjaGVtYShzcGVjKSB7XG4gIC8vIDo6IFNjaGVtYVNwZWNcbiAgLy8gVGhlIFtzcGVjXSgjbW9kZWwuU2NoZW1hU3BlYykgb24gd2hpY2ggdGhlIHNjaGVtYSBpcyBiYXNlZCxcbiAgLy8gd2l0aCB0aGUgYWRkZWQgZ3VhcmFudGVlIHRoYXQgaXRzIGBub2Rlc2AgYW5kIGBtYXJrc2BcbiAgLy8gcHJvcGVydGllcyBhcmVcbiAgLy8gW2BPcmRlcmVkTWFwYF0oaHR0cHM6Ly9naXRodWIuY29tL21hcmlqbmgvb3JkZXJlZG1hcCkgaW5zdGFuY2VzXG4gIC8vIChub3QgcmF3IG9iamVjdHMpLlxuICB0aGlzLnNwZWMgPSB7fTtcbiAgZm9yICh2YXIgcHJvcCBpbiBzcGVjKSB7IHRoaXMuc3BlY1twcm9wXSA9IHNwZWNbcHJvcF07IH1cbiAgdGhpcy5zcGVjLm5vZGVzID0gT3JkZXJlZE1hcC5mcm9tKHNwZWMubm9kZXMpO1xuICB0aGlzLnNwZWMubWFya3MgPSBPcmRlcmVkTWFwLmZyb20oc3BlYy5tYXJrcyk7XG5cbiAgLy8gOjogT2JqZWN0PE5vZGVUeXBlPlxuICAvLyBBbiBvYmplY3QgbWFwcGluZyB0aGUgc2NoZW1hJ3Mgbm9kZSBuYW1lcyB0byBub2RlIHR5cGUgb2JqZWN0cy5cbiAgdGhpcy5ub2RlcyA9IE5vZGVUeXBlLmNvbXBpbGUodGhpcy5zcGVjLm5vZGVzLCB0aGlzKTtcblxuICAvLyA6OiBPYmplY3Q8TWFya1R5cGU+XG4gIC8vIEEgbWFwIGZyb20gbWFyayBuYW1lcyB0byBtYXJrIHR5cGUgb2JqZWN0cy5cbiAgdGhpcy5tYXJrcyA9IE1hcmtUeXBlLmNvbXBpbGUodGhpcy5zcGVjLm1hcmtzLCB0aGlzKTtcblxuICB2YXIgY29udGVudEV4cHJDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGZvciAodmFyIHByb3AkMSBpbiB0aGlzLm5vZGVzKSB7XG4gICAgaWYgKHByb3AkMSBpbiB0aGlzLm1hcmtzKVxuICAgICAgeyB0aHJvdyBuZXcgUmFuZ2VFcnJvcihwcm9wJDEgKyBcIiBjYW4gbm90IGJlIGJvdGggYSBub2RlIGFuZCBhIG1hcmtcIikgfVxuICAgIHZhciB0eXBlID0gdGhpcy5ub2Rlc1twcm9wJDFdLCBjb250ZW50RXhwciA9IHR5cGUuc3BlYy5jb250ZW50IHx8IFwiXCIsIG1hcmtFeHByID0gdHlwZS5zcGVjLm1hcmtzO1xuICAgIHR5cGUuY29udGVudE1hdGNoID0gY29udGVudEV4cHJDYWNoZVtjb250ZW50RXhwcl0gfHxcbiAgICAgIChjb250ZW50RXhwckNhY2hlW2NvbnRlbnRFeHByXSA9IENvbnRlbnRNYXRjaC5wYXJzZShjb250ZW50RXhwciwgdGhpcy5ub2RlcykpO1xuICAgIHR5cGUuaW5saW5lQ29udGVudCA9IHR5cGUuY29udGVudE1hdGNoLmlubGluZUNvbnRlbnQ7XG4gICAgdHlwZS5tYXJrU2V0ID0gbWFya0V4cHIgPT0gXCJfXCIgPyBudWxsIDpcbiAgICAgIG1hcmtFeHByID8gZ2F0aGVyTWFya3ModGhpcywgbWFya0V4cHIuc3BsaXQoXCIgXCIpKSA6XG4gICAgICBtYXJrRXhwciA9PSBcIlwiIHx8ICF0eXBlLmlubGluZUNvbnRlbnQgPyBbXSA6IG51bGw7XG4gIH1cbiAgZm9yICh2YXIgcHJvcCQyIGluIHRoaXMubWFya3MpIHtcbiAgICB2YXIgdHlwZSQxID0gdGhpcy5tYXJrc1twcm9wJDJdLCBleGNsID0gdHlwZSQxLnNwZWMuZXhjbHVkZXM7XG4gICAgdHlwZSQxLmV4Y2x1ZGVkID0gZXhjbCA9PSBudWxsID8gW3R5cGUkMV0gOiBleGNsID09IFwiXCIgPyBbXSA6IGdhdGhlck1hcmtzKHRoaXMsIGV4Y2wuc3BsaXQoXCIgXCIpKTtcbiAgfVxuXG4gIHRoaXMubm9kZUZyb21KU09OID0gdGhpcy5ub2RlRnJvbUpTT04uYmluZCh0aGlzKTtcbiAgdGhpcy5tYXJrRnJvbUpTT04gPSB0aGlzLm1hcmtGcm9tSlNPTi5iaW5kKHRoaXMpO1xuXG4gIC8vIDo6IE5vZGVUeXBlXG4gIC8vIFRoZSB0eXBlIG9mIHRoZSBbZGVmYXVsdCB0b3Agbm9kZV0oI21vZGVsLlNjaGVtYVNwZWMudG9wTm9kZSlcbiAgLy8gZm9yIHRoaXMgc2NoZW1hLlxuICB0aGlzLnRvcE5vZGVUeXBlID0gdGhpcy5ub2Rlc1t0aGlzLnNwZWMudG9wTm9kZSB8fCBcImRvY1wiXTtcblxuICAvLyA6OiBPYmplY3RcbiAgLy8gQW4gb2JqZWN0IGZvciBzdG9yaW5nIHdoYXRldmVyIHZhbHVlcyBtb2R1bGVzIG1heSB3YW50IHRvXG4gIC8vIGNvbXB1dGUgYW5kIGNhY2hlIHBlciBzY2hlbWEuIChJZiB5b3Ugd2FudCB0byBzdG9yZSBzb21ldGhpbmdcbiAgLy8gaW4gaXQsIHRyeSB0byB1c2UgcHJvcGVydHkgbmFtZXMgdW5saWtlbHkgdG8gY2xhc2guKVxuICB0aGlzLmNhY2hlZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHRoaXMuY2FjaGVkLndyYXBwaW5ncyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG59O1xuXG4vLyA6OiAodW5pb248c3RyaW5nLCBOb2RlVHlwZT4sID9PYmplY3QsID91bmlvbjxGcmFnbWVudCwgTm9kZSwgW05vZGVdPiwgP1tNYXJrXSkg4oaSIE5vZGVcbi8vIENyZWF0ZSBhIG5vZGUgaW4gdGhpcyBzY2hlbWEuIFRoZSBgdHlwZWAgbWF5IGJlIGEgc3RyaW5nIG9yIGFcbi8vIGBOb2RlVHlwZWAgaW5zdGFuY2UuIEF0dHJpYnV0ZXMgd2lsbCBiZSBleHRlbmRlZFxuLy8gd2l0aCBkZWZhdWx0cywgYGNvbnRlbnRgIG1heSBiZSBhIGBGcmFnbWVudGAsXG4vLyBgbnVsbGAsIGEgYE5vZGVgLCBvciBhbiBhcnJheSBvZiBub2Rlcy5cblNjaGVtYS5wcm90b3R5cGUubm9kZSA9IGZ1bmN0aW9uIG5vZGUgKHR5cGUsIGF0dHJzLCBjb250ZW50LCBtYXJrcykge1xuICBpZiAodHlwZW9mIHR5cGUgPT0gXCJzdHJpbmdcIilcbiAgICB7IHR5cGUgPSB0aGlzLm5vZGVUeXBlKHR5cGUpOyB9XG4gIGVsc2UgaWYgKCEodHlwZSBpbnN0YW5jZW9mIE5vZGVUeXBlKSlcbiAgICB7IHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBub2RlIHR5cGU6IFwiICsgdHlwZSkgfVxuICBlbHNlIGlmICh0eXBlLnNjaGVtYSAhPSB0aGlzKVxuICAgIHsgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJOb2RlIHR5cGUgZnJvbSBkaWZmZXJlbnQgc2NoZW1hIHVzZWQgKFwiICsgdHlwZS5uYW1lICsgXCIpXCIpIH1cblxuICByZXR1cm4gdHlwZS5jcmVhdGVDaGVja2VkKGF0dHJzLCBjb250ZW50LCBtYXJrcylcbn07XG5cbi8vIDo6IChzdHJpbmcsID9bTWFya10pIOKGkiBOb2RlXG4vLyBDcmVhdGUgYSB0ZXh0IG5vZGUgaW4gdGhlIHNjaGVtYS4gRW1wdHkgdGV4dCBub2RlcyBhcmUgbm90XG4vLyBhbGxvd2VkLlxuU2NoZW1hLnByb3RvdHlwZS50ZXh0ID0gZnVuY3Rpb24gdGV4dCAodGV4dCQxLCBtYXJrcykge1xuICB2YXIgdHlwZSA9IHRoaXMubm9kZXMudGV4dDtcbiAgcmV0dXJuIG5ldyBUZXh0Tm9kZSh0eXBlLCB0eXBlLmRlZmF1bHRBdHRycywgdGV4dCQxLCBNYXJrLnNldEZyb20obWFya3MpKVxufTtcblxuLy8gOjogKHVuaW9uPHN0cmluZywgTWFya1R5cGU+LCA/T2JqZWN0KSDihpIgTWFya1xuLy8gQ3JlYXRlIGEgbWFyayB3aXRoIHRoZSBnaXZlbiB0eXBlIGFuZCBhdHRyaWJ1dGVzLlxuU2NoZW1hLnByb3RvdHlwZS5tYXJrID0gZnVuY3Rpb24gbWFyayAodHlwZSwgYXR0cnMpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09IFwic3RyaW5nXCIpIHsgdHlwZSA9IHRoaXMubWFya3NbdHlwZV07IH1cbiAgcmV0dXJuIHR5cGUuY3JlYXRlKGF0dHJzKVxufTtcblxuLy8gOjogKE9iamVjdCkg4oaSIE5vZGVcbi8vIERlc2VyaWFsaXplIGEgbm9kZSBmcm9tIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uLiBUaGlzIG1ldGhvZCBpc1xuLy8gYm91bmQuXG5TY2hlbWEucHJvdG90eXBlLm5vZGVGcm9tSlNPTiA9IGZ1bmN0aW9uIG5vZGVGcm9tSlNPTiAoanNvbikge1xuICByZXR1cm4gTm9kZS5mcm9tSlNPTih0aGlzLCBqc29uKVxufTtcblxuLy8gOjogKE9iamVjdCkg4oaSIE1hcmtcbi8vIERlc2VyaWFsaXplIGEgbWFyayBmcm9tIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uLiBUaGlzIG1ldGhvZCBpc1xuLy8gYm91bmQuXG5TY2hlbWEucHJvdG90eXBlLm1hcmtGcm9tSlNPTiA9IGZ1bmN0aW9uIG1hcmtGcm9tSlNPTiAoanNvbikge1xuICByZXR1cm4gTWFyay5mcm9tSlNPTih0aGlzLCBqc29uKVxufTtcblxuU2NoZW1hLnByb3RvdHlwZS5ub2RlVHlwZSA9IGZ1bmN0aW9uIG5vZGVUeXBlIChuYW1lKSB7XG4gIHZhciBmb3VuZCA9IHRoaXMubm9kZXNbbmFtZV07XG4gIGlmICghZm91bmQpIHsgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJVbmtub3duIG5vZGUgdHlwZTogXCIgKyBuYW1lKSB9XG4gIHJldHVybiBmb3VuZFxufTtcblxuZnVuY3Rpb24gZ2F0aGVyTWFya3Moc2NoZW1hLCBtYXJrcykge1xuICB2YXIgZm91bmQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXJrcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBuYW1lID0gbWFya3NbaV0sIG1hcmsgPSBzY2hlbWEubWFya3NbbmFtZV0sIG9rID0gbWFyaztcbiAgICBpZiAobWFyaykge1xuICAgICAgZm91bmQucHVzaChtYXJrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiBzY2hlbWEubWFya3MpIHtcbiAgICAgICAgdmFyIG1hcmskMSA9IHNjaGVtYS5tYXJrc1twcm9wXTtcbiAgICAgICAgaWYgKG5hbWUgPT0gXCJfXCIgfHwgKG1hcmskMS5zcGVjLmdyb3VwICYmIG1hcmskMS5zcGVjLmdyb3VwLnNwbGl0KFwiIFwiKS5pbmRleE9mKG5hbWUpID4gLTEpKVxuICAgICAgICAgIHsgZm91bmQucHVzaChvayA9IG1hcmskMSk7IH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFvaykgeyB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJVbmtub3duIG1hcmsgdHlwZTogJ1wiICsgbWFya3NbaV0gKyBcIidcIikgfVxuICB9XG4gIHJldHVybiBmb3VuZFxufVxuXG4vLyBQYXJzZU9wdGlvbnM6OiBpbnRlcmZhY2Vcbi8vIFRoZXNlIGFyZSB0aGUgb3B0aW9ucyByZWNvZ25pemVkIGJ5IHRoZVxuLy8gW2BwYXJzZWBdKCNtb2RlbC5ET01QYXJzZXIucGFyc2UpIGFuZFxuLy8gW2BwYXJzZVNsaWNlYF0oI21vZGVsLkRPTVBhcnNlci5wYXJzZVNsaWNlKSBtZXRob2RzLlxuLy9cbi8vICAgcHJlc2VydmVXaGl0ZXNwYWNlOjogP3VuaW9uPGJvb2wsIFwiZnVsbFwiPlxuLy8gICBCeSBkZWZhdWx0LCB3aGl0ZXNwYWNlIGlzIGNvbGxhcHNlZCBhcyBwZXIgSFRNTCdzIHJ1bGVzLiBQYXNzXG4vLyAgIGB0cnVlYCB0byBwcmVzZXJ2ZSB3aGl0ZXNwYWNlLCBidXQgbm9ybWFsaXplIG5ld2xpbmVzIHRvXG4vLyAgIHNwYWNlcywgYW5kIGBcImZ1bGxcImAgdG8gcHJlc2VydmUgd2hpdGVzcGFjZSBlbnRpcmVseS5cbi8vXG4vLyAgIGZpbmRQb3NpdGlvbnM6OiA/W3tub2RlOiBkb20uTm9kZSwgb2Zmc2V0OiBudW1iZXJ9XVxuLy8gICBXaGVuIGdpdmVuLCB0aGUgcGFyc2VyIHdpbGwsIGJlc2lkZSBwYXJzaW5nIHRoZSBjb250ZW50LFxuLy8gICByZWNvcmQgdGhlIGRvY3VtZW50IHBvc2l0aW9ucyBvZiB0aGUgZ2l2ZW4gRE9NIHBvc2l0aW9ucy4gSXRcbi8vICAgd2lsbCBkbyBzbyBieSB3cml0aW5nIHRvIHRoZSBvYmplY3RzLCBhZGRpbmcgYSBgcG9zYCBwcm9wZXJ0eVxuLy8gICB0aGF0IGhvbGRzIHRoZSBkb2N1bWVudCBwb3NpdGlvbi4gRE9NIHBvc2l0aW9ucyB0aGF0IGFyZSBub3Rcbi8vICAgaW4gdGhlIHBhcnNlZCBjb250ZW50IHdpbGwgbm90IGJlIHdyaXR0ZW4gdG8uXG4vL1xuLy8gICBmcm9tOjogP251bWJlclxuLy8gICBUaGUgY2hpbGQgbm9kZSBpbmRleCB0byBzdGFydCBwYXJzaW5nIGZyb20uXG4vL1xuLy8gICB0bzo6ID9udW1iZXJcbi8vICAgVGhlIGNoaWxkIG5vZGUgaW5kZXggdG8gc3RvcCBwYXJzaW5nIGF0LlxuLy9cbi8vICAgdG9wTm9kZTo6ID9Ob2RlXG4vLyAgIEJ5IGRlZmF1bHQsIHRoZSBjb250ZW50IGlzIHBhcnNlZCBpbnRvIHRoZSBzY2hlbWEncyBkZWZhdWx0XG4vLyAgIFt0b3Agbm9kZSB0eXBlXSgjbW9kZWwuU2NoZW1hLnRvcE5vZGVUeXBlKS4gWW91IGNhbiBwYXNzIHRoaXNcbi8vICAgb3B0aW9uIHRvIHVzZSB0aGUgdHlwZSBhbmQgYXR0cmlidXRlcyBmcm9tIGEgZGlmZmVyZW50IG5vZGVcbi8vICAgYXMgdGhlIHRvcCBjb250YWluZXIuXG4vL1xuLy8gICB0b3BNYXRjaDo6ID9Db250ZW50TWF0Y2hcbi8vICAgUHJvdmlkZSB0aGUgc3RhcnRpbmcgY29udGVudCBtYXRjaCB0aGF0IGNvbnRlbnQgcGFyc2VkIGludG8gdGhlXG4vLyAgIHRvcCBub2RlIGlzIG1hdGNoZWQgYWdhaW5zdC5cbi8vXG4vLyAgIGNvbnRleHQ6OiA/UmVzb2x2ZWRQb3Ncbi8vICAgQSBzZXQgb2YgYWRkaXRpb25hbCBub2RlcyB0byBjb3VudCBhc1xuLy8gICBbY29udGV4dF0oI21vZGVsLlBhcnNlUnVsZS5jb250ZXh0KSB3aGVuIHBhcnNpbmcsIGFib3ZlIHRoZVxuLy8gICBnaXZlbiBbdG9wIG5vZGVdKCNtb2RlbC5QYXJzZU9wdGlvbnMudG9wTm9kZSkuXG5cbi8vIFBhcnNlUnVsZTo6IGludGVyZmFjZVxuLy8gQSB2YWx1ZSB0aGF0IGRlc2NyaWJlcyBob3cgdG8gcGFyc2UgYSBnaXZlbiBET00gbm9kZSBvciBpbmxpbmVcbi8vIHN0eWxlIGFzIGEgUHJvc2VNaXJyb3Igbm9kZSBvciBtYXJrLlxuLy9cbi8vICAgdGFnOjogP3N0cmluZ1xuLy8gICBBIENTUyBzZWxlY3RvciBkZXNjcmliaW5nIHRoZSBraW5kIG9mIERPTSBlbGVtZW50cyB0byBtYXRjaC4gQVxuLy8gICBzaW5nbGUgcnVsZSBzaG91bGQgaGF2ZSBfZWl0aGVyXyBhIGB0YWdgIG9yIGEgYHN0eWxlYCBwcm9wZXJ0eS5cbi8vXG4vLyAgIG5hbWVzcGFjZTo6ID9zdHJpbmdcbi8vICAgVGhlIG5hbWVzcGFjZSB0byBtYXRjaC4gVGhpcyBzaG91bGQgYmUgdXNlZCB3aXRoIGB0YWdgLlxuLy8gICBOb2RlcyBhcmUgb25seSBtYXRjaGVkIHdoZW4gdGhlIG5hbWVzcGFjZSBtYXRjaGVzIG9yIHRoaXMgcHJvcGVydHlcbi8vICAgaXMgbnVsbC5cbi8vXG4vLyAgIHN0eWxlOjogP3N0cmluZ1xuLy8gICBBIENTUyBwcm9wZXJ0eSBuYW1lIHRvIG1hdGNoLiBXaGVuIGdpdmVuLCB0aGlzIHJ1bGUgbWF0Y2hlc1xuLy8gICBpbmxpbmUgc3R5bGVzIHRoYXQgbGlzdCB0aGF0IHByb3BlcnR5LiBNYXkgYWxzbyBoYXZlIHRoZSBmb3JtXG4vLyAgIGBcInByb3BlcnR5PXZhbHVlXCJgLCBpbiB3aGljaCBjYXNlIHRoZSBydWxlIG9ubHkgbWF0Y2hlcyBpZiB0aGVcbi8vICAgcHJvcGVydHkncyB2YWx1ZSBleGFjdGx5IG1hdGNoZXMgdGhlIGdpdmVuIHZhbHVlLiAoRm9yIG1vcmVcbi8vICAgY29tcGxpY2F0ZWQgZmlsdGVycywgdXNlIFtgZ2V0QXR0cnNgXSgjbW9kZWwuUGFyc2VSdWxlLmdldEF0dHJzKVxuLy8gICBhbmQgcmV0dXJuIGZhbHNlIHRvIGluZGljYXRlIHRoYXQgdGhlIG1hdGNoIGZhaWxlZC4pIFJ1bGVzXG4vLyAgIG1hdGNoaW5nIHN0eWxlcyBtYXkgb25seSBwcm9kdWNlIFttYXJrc10oI21vZGVsLlBhcnNlUnVsZS5tYXJrKSxcbi8vICAgbm90IG5vZGVzLlxuLy9cbi8vICAgcHJpb3JpdHk6OiA/bnVtYmVyXG4vLyAgIENhbiBiZSB1c2VkIHRvIGNoYW5nZSB0aGUgb3JkZXIgaW4gd2hpY2ggdGhlIHBhcnNlIHJ1bGVzIGluIGFcbi8vICAgc2NoZW1hIGFyZSB0cmllZC4gVGhvc2Ugd2l0aCBoaWdoZXIgcHJpb3JpdHkgY29tZSBmaXJzdC4gUnVsZXNcbi8vICAgd2l0aG91dCBhIHByaW9yaXR5IGFyZSBjb3VudGVkIGFzIGhhdmluZyBwcmlvcml0eSA1MC4gVGhpc1xuLy8gICBwcm9wZXJ0eSBpcyBvbmx5IG1lYW5pbmdmdWwgaW4gYSBzY2hlbWHigJR3aGVuIGRpcmVjdGx5XG4vLyAgIGNvbnN0cnVjdGluZyBhIHBhcnNlciwgdGhlIG9yZGVyIG9mIHRoZSBydWxlIGFycmF5IGlzIHVzZWQuXG4vL1xuLy8gICBjb25zdW1pbmc6OiA/Ym9vbGVhblxuLy8gICBCeSBkZWZhdWx0LCB3aGVuIGEgcnVsZSBtYXRjaGVzIGFuIGVsZW1lbnQgb3Igc3R5bGUsIG5vIGZ1cnRoZXJcbi8vICAgcnVsZXMgZ2V0IGEgY2hhbmNlIHRvIG1hdGNoIGl0LiBCeSBzZXR0aW5nIHRoaXMgdG8gYGZhbHNlYCwgeW91XG4vLyAgIGluZGljYXRlIHRoYXQgZXZlbiB3aGVuIHRoaXMgcnVsZSBtYXRjaGVzLCBvdGhlciBydWxlcyB0aGF0IGNvbWVcbi8vICAgYWZ0ZXIgaXQgc2hvdWxkIGFsc28gcnVuLlxuLy9cbi8vICAgY29udGV4dDo6ID9zdHJpbmdcbi8vICAgV2hlbiBnaXZlbiwgcmVzdHJpY3RzIHRoaXMgcnVsZSB0byBvbmx5IG1hdGNoIHdoZW4gdGhlIGN1cnJlbnRcbi8vICAgY29udGV4dOKAlHRoZSBwYXJlbnQgbm9kZXMgaW50byB3aGljaCB0aGUgY29udGVudCBpcyBiZWluZ1xuLy8gICBwYXJzZWTigJRtYXRjaGVzIHRoaXMgZXhwcmVzc2lvbi4gU2hvdWxkIGNvbnRhaW4gb25lIG9yIG1vcmUgbm9kZVxuLy8gICBuYW1lcyBvciBub2RlIGdyb3VwIG5hbWVzIGZvbGxvd2VkIGJ5IHNpbmdsZSBvciBkb3VibGUgc2xhc2hlcy5cbi8vICAgRm9yIGV4YW1wbGUgYFwicGFyYWdyYXBoL1wiYCBtZWFucyB0aGUgcnVsZSBvbmx5IG1hdGNoZXMgd2hlbiB0aGVcbi8vICAgcGFyZW50IG5vZGUgaXMgYSBwYXJhZ3JhcGgsIGBcImJsb2NrcXVvdGUvcGFyYWdyYXBoL1wiYCByZXN0cmljdHNcbi8vICAgaXQgdG8gYmUgaW4gYSBwYXJhZ3JhcGggdGhhdCBpcyBpbnNpZGUgYSBibG9ja3F1b3RlLCBhbmRcbi8vICAgYFwic2VjdGlvbi8vXCJgIG1hdGNoZXMgYW55IHBvc2l0aW9uIGluc2lkZSBhIHNlY3Rpb27igJRhIGRvdWJsZVxuLy8gICBzbGFzaCBtYXRjaGVzIGFueSBzZXF1ZW5jZSBvZiBhbmNlc3RvciBub2Rlcy4gVG8gYWxsb3cgbXVsdGlwbGVcbi8vICAgZGlmZmVyZW50IGNvbnRleHRzLCB0aGV5IGNhbiBiZSBzZXBhcmF0ZWQgYnkgYSBwaXBlIChgfGApXG4vLyAgIGNoYXJhY3RlciwgYXMgaW4gYFwiYmxvY2txdW90ZS98bGlzdF9pdGVtL1wiYC5cbi8vXG4vLyAgIG5vZGU6OiA/c3RyaW5nXG4vLyAgIFRoZSBuYW1lIG9mIHRoZSBub2RlIHR5cGUgdG8gY3JlYXRlIHdoZW4gdGhpcyBydWxlIG1hdGNoZXMuIE9ubHlcbi8vICAgdmFsaWQgZm9yIHJ1bGVzIHdpdGggYSBgdGFnYCBwcm9wZXJ0eSwgbm90IGZvciBzdHlsZSBydWxlcy4gRWFjaFxuLy8gICBydWxlIHNob3VsZCBoYXZlIG9uZSBvZiBhIGBub2RlYCwgYG1hcmtgLCBvciBgaWdub3JlYCBwcm9wZXJ0eVxuLy8gICAoZXhjZXB0IHdoZW4gaXQgYXBwZWFycyBpbiBhIFtub2RlXSgjbW9kZWwuTm9kZVNwZWMucGFyc2VET00pIG9yXG4vLyAgIFttYXJrIHNwZWNdKCNtb2RlbC5NYXJrU3BlYy5wYXJzZURPTSksIGluIHdoaWNoIGNhc2UgdGhlIGBub2RlYFxuLy8gICBvciBgbWFya2AgcHJvcGVydHkgd2lsbCBiZSBkZXJpdmVkIGZyb20gaXRzIHBvc2l0aW9uKS5cbi8vXG4vLyAgIG1hcms6OiA/c3RyaW5nXG4vLyAgIFRoZSBuYW1lIG9mIHRoZSBtYXJrIHR5cGUgdG8gd3JhcCB0aGUgbWF0Y2hlZCBjb250ZW50IGluLlxuLy9cbi8vICAgaWdub3JlOjogP2Jvb2xcbi8vICAgV2hlbiB0cnVlLCBpZ25vcmUgY29udGVudCB0aGF0IG1hdGNoZXMgdGhpcyBydWxlLlxuLy9cbi8vICAgY2xvc2VQYXJlbnQ6OiA/Ym9vbFxuLy8gICBXaGVuIHRydWUsIGZpbmRpbmcgYW4gZWxlbWVudCB0aGF0IG1hdGNoZXMgdGhpcyBydWxlIHdpbGwgY2xvc2Vcbi8vICAgdGhlIGN1cnJlbnQgbm9kZS5cbi8vXG4vLyAgIHNraXA6OiA/Ym9vbFxuLy8gICBXaGVuIHRydWUsIGlnbm9yZSB0aGUgbm9kZSB0aGF0IG1hdGNoZXMgdGhpcyBydWxlLCBidXQgZG8gcGFyc2Vcbi8vICAgaXRzIGNvbnRlbnQuXG4vL1xuLy8gICBhdHRyczo6ID9PYmplY3Rcbi8vICAgQXR0cmlidXRlcyBmb3IgdGhlIG5vZGUgb3IgbWFyayBjcmVhdGVkIGJ5IHRoaXMgcnVsZS4gV2hlblxuLy8gICBgZ2V0QXR0cnNgIGlzIHByb3ZpZGVkLCBpdCB0YWtlcyBwcmVjZWRlbmNlLlxuLy9cbi8vICAgZ2V0QXR0cnM6OiA/KHVuaW9uPGRvbS5Ob2RlLCBzdHJpbmc+KSDihpIgP3VuaW9uPE9iamVjdCwgZmFsc2U+XG4vLyAgIEEgZnVuY3Rpb24gdXNlZCB0byBjb21wdXRlIHRoZSBhdHRyaWJ1dGVzIGZvciB0aGUgbm9kZSBvciBtYXJrXG4vLyAgIGNyZWF0ZWQgYnkgdGhpcyBydWxlLiBDYW4gYWxzbyBiZSB1c2VkIHRvIGRlc2NyaWJlIGZ1cnRoZXJcbi8vICAgY29uZGl0aW9ucyB0aGUgRE9NIGVsZW1lbnQgb3Igc3R5bGUgbXVzdCBtYXRjaC4gV2hlbiBpdCByZXR1cm5zXG4vLyAgIGBmYWxzZWAsIHRoZSBydWxlIHdvbid0IG1hdGNoLiBXaGVuIGl0IHJldHVybnMgbnVsbCBvciB1bmRlZmluZWQsXG4vLyAgIHRoYXQgaXMgaW50ZXJwcmV0ZWQgYXMgYW4gZW1wdHkvZGVmYXVsdCBzZXQgb2YgYXR0cmlidXRlcy5cbi8vXG4vLyAgIENhbGxlZCB3aXRoIGEgRE9NIEVsZW1lbnQgZm9yIGB0YWdgIHJ1bGVzLCBhbmQgd2l0aCBhIHN0cmluZyAodGhlXG4vLyAgIHN0eWxlJ3MgdmFsdWUpIGZvciBgc3R5bGVgIHJ1bGVzLlxuLy9cbi8vICAgY29udGVudEVsZW1lbnQ6OiA/dW5pb248c3RyaW5nLCAoZG9tLk5vZGUpIOKGkiBkb20uTm9kZT5cbi8vICAgRm9yIGB0YWdgIHJ1bGVzIHRoYXQgcHJvZHVjZSBub24tbGVhZiBub2RlcyBvciBtYXJrcywgYnkgZGVmYXVsdFxuLy8gICB0aGUgY29udGVudCBvZiB0aGUgRE9NIGVsZW1lbnQgaXMgcGFyc2VkIGFzIGNvbnRlbnQgb2YgdGhlIG1hcmtcbi8vICAgb3Igbm9kZS4gSWYgdGhlIGNoaWxkIG5vZGVzIGFyZSBpbiBhIGRlc2NlbmRlbnQgbm9kZSwgdGhpcyBtYXkgYmVcbi8vICAgYSBDU1Mgc2VsZWN0b3Igc3RyaW5nIHRoYXQgdGhlIHBhcnNlciBtdXN0IHVzZSB0byBmaW5kIHRoZSBhY3R1YWxcbi8vICAgY29udGVudCBlbGVtZW50LCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgYWN0dWFsIGNvbnRlbnRcbi8vICAgZWxlbWVudCB0byB0aGUgcGFyc2VyLlxuLy9cbi8vICAgZ2V0Q29udGVudDo6ID8oZG9tLk5vZGUsIHNjaGVtYTogU2NoZW1hKSDihpIgRnJhZ21lbnRcbi8vICAgQ2FuIGJlIHVzZWQgdG8gb3ZlcnJpZGUgdGhlIGNvbnRlbnQgb2YgYSBtYXRjaGVkIG5vZGUuIFdoZW5cbi8vICAgcHJlc2VudCwgaW5zdGVhZCBvZiBwYXJzaW5nIHRoZSBub2RlJ3MgY2hpbGQgbm9kZXMsIHRoZSByZXN1bHQgb2Zcbi8vICAgdGhpcyBmdW5jdGlvbiBpcyB1c2VkLlxuLy9cbi8vICAgcHJlc2VydmVXaGl0ZXNwYWNlOjogP3VuaW9uPGJvb2wsIFwiZnVsbFwiPlxuLy8gICBDb250cm9scyB3aGV0aGVyIHdoaXRlc3BhY2Ugc2hvdWxkIGJlIHByZXNlcnZlZCB3aGVuIHBhcnNpbmcgdGhlXG4vLyAgIGNvbnRlbnQgaW5zaWRlIHRoZSBtYXRjaGVkIGVsZW1lbnQuIGBmYWxzZWAgbWVhbnMgd2hpdGVzcGFjZSBtYXlcbi8vICAgYmUgY29sbGFwc2VkLCBgdHJ1ZWAgbWVhbnMgdGhhdCB3aGl0ZXNwYWNlIHNob3VsZCBiZSBwcmVzZXJ2ZWRcbi8vICAgYnV0IG5ld2xpbmVzIG5vcm1hbGl6ZWQgdG8gc3BhY2VzLCBhbmQgYFwiZnVsbFwiYCBtZWFucyB0aGF0XG4vLyAgIG5ld2xpbmVzIHNob3VsZCBhbHNvIGJlIHByZXNlcnZlZC5cblxuLy8gOjotIEEgRE9NIHBhcnNlciByZXByZXNlbnRzIGEgc3RyYXRlZ3kgZm9yIHBhcnNpbmcgRE9NIGNvbnRlbnQgaW50b1xuLy8gYSBQcm9zZU1pcnJvciBkb2N1bWVudCBjb25mb3JtaW5nIHRvIGEgZ2l2ZW4gc2NoZW1hLiBJdHMgYmVoYXZpb3Jcbi8vIGlzIGRlZmluZWQgYnkgYW4gYXJyYXkgb2YgW3J1bGVzXSgjbW9kZWwuUGFyc2VSdWxlKS5cbnZhciBET01QYXJzZXIgPSBmdW5jdGlvbiBET01QYXJzZXIoc2NoZW1hLCBydWxlcykge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAvLyA6OiBTY2hlbWFcbiAgLy8gVGhlIHNjaGVtYSBpbnRvIHdoaWNoIHRoZSBwYXJzZXIgcGFyc2VzLlxuICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgLy8gOjogW1BhcnNlUnVsZV1cbiAgLy8gVGhlIHNldCBvZiBbcGFyc2UgcnVsZXNdKCNtb2RlbC5QYXJzZVJ1bGUpIHRoYXQgdGhlIHBhcnNlclxuICAvLyB1c2VzLCBpbiBvcmRlciBvZiBwcmVjZWRlbmNlLlxuICB0aGlzLnJ1bGVzID0gcnVsZXM7XG4gIHRoaXMudGFncyA9IFtdO1xuICB0aGlzLnN0eWxlcyA9IFtdO1xuXG4gIHJ1bGVzLmZvckVhY2goZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICBpZiAocnVsZS50YWcpIHsgdGhpcyQxLnRhZ3MucHVzaChydWxlKTsgfVxuICAgIGVsc2UgaWYgKHJ1bGUuc3R5bGUpIHsgdGhpcyQxLnN0eWxlcy5wdXNoKHJ1bGUpOyB9XG4gIH0pO1xuXG4gIC8vIE9ubHkgbm9ybWFsaXplIGxpc3QgZWxlbWVudHMgd2hlbiBsaXN0cyBpbiB0aGUgc2NoZW1hIGNhbid0IGRpcmVjdGx5IGNvbnRhaW4gdGhlbXNlbHZlc1xuICB0aGlzLm5vcm1hbGl6ZUxpc3RzID0gIXRoaXMudGFncy5zb21lKGZ1bmN0aW9uIChyKSB7XG4gICAgaWYgKCEvXih1bHxvbClcXGIvLnRlc3Qoci50YWcpIHx8ICFyLm5vZGUpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICB2YXIgbm9kZSA9IHNjaGVtYS5ub2Rlc1tyLm5vZGVdO1xuICAgIHJldHVybiBub2RlLmNvbnRlbnRNYXRjaC5tYXRjaFR5cGUobm9kZSlcbiAgfSk7XG59O1xuXG4vLyA6OiAoZG9tLk5vZGUsID9QYXJzZU9wdGlvbnMpIOKGkiBOb2RlXG4vLyBQYXJzZSBhIGRvY3VtZW50IGZyb20gdGhlIGNvbnRlbnQgb2YgYSBET00gbm9kZS5cbkRPTVBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSAoZG9tLCBvcHRpb25zKSB7XG4gICAgaWYgKCBvcHRpb25zID09PSB2b2lkIDAgKSBvcHRpb25zID0ge307XG5cbiAgdmFyIGNvbnRleHQgPSBuZXcgUGFyc2VDb250ZXh0KHRoaXMsIG9wdGlvbnMsIGZhbHNlKTtcbiAgY29udGV4dC5hZGRBbGwoZG9tLCBudWxsLCBvcHRpb25zLmZyb20sIG9wdGlvbnMudG8pO1xuICByZXR1cm4gY29udGV4dC5maW5pc2goKVxufTtcblxuLy8gOjogKGRvbS5Ob2RlLCA/UGFyc2VPcHRpb25zKSDihpIgU2xpY2Vcbi8vIFBhcnNlcyB0aGUgY29udGVudCBvZiB0aGUgZ2l2ZW4gRE9NIG5vZGUsIGxpa2Vcbi8vIFtgcGFyc2VgXSgjbW9kZWwuRE9NUGFyc2VyLnBhcnNlKSwgYW5kIHRha2VzIHRoZSBzYW1lIHNldCBvZlxuLy8gb3B0aW9ucy4gQnV0IHVubGlrZSB0aGF0IG1ldGhvZCwgd2hpY2ggcHJvZHVjZXMgYSB3aG9sZSBub2RlLFxuLy8gdGhpcyBvbmUgcmV0dXJucyBhIHNsaWNlIHRoYXQgaXMgb3BlbiBhdCB0aGUgc2lkZXMsIG1lYW5pbmcgdGhhdFxuLy8gdGhlIHNjaGVtYSBjb25zdHJhaW50cyBhcmVuJ3QgYXBwbGllZCB0byB0aGUgc3RhcnQgb2Ygbm9kZXMgdG9cbi8vIHRoZSBsZWZ0IG9mIHRoZSBpbnB1dCBhbmQgdGhlIGVuZCBvZiBub2RlcyBhdCB0aGUgZW5kLlxuRE9NUGFyc2VyLnByb3RvdHlwZS5wYXJzZVNsaWNlID0gZnVuY3Rpb24gcGFyc2VTbGljZSAoZG9tLCBvcHRpb25zKSB7XG4gICAgaWYgKCBvcHRpb25zID09PSB2b2lkIDAgKSBvcHRpb25zID0ge307XG5cbiAgdmFyIGNvbnRleHQgPSBuZXcgUGFyc2VDb250ZXh0KHRoaXMsIG9wdGlvbnMsIHRydWUpO1xuICBjb250ZXh0LmFkZEFsbChkb20sIG51bGwsIG9wdGlvbnMuZnJvbSwgb3B0aW9ucy50byk7XG4gIHJldHVybiBTbGljZS5tYXhPcGVuKGNvbnRleHQuZmluaXNoKCkpXG59O1xuXG5ET01QYXJzZXIucHJvdG90eXBlLm1hdGNoVGFnID0gZnVuY3Rpb24gbWF0Y2hUYWcgKGRvbSwgY29udGV4dCwgYWZ0ZXIpIHtcbiAgZm9yICh2YXIgaSA9IGFmdGVyID8gdGhpcy50YWdzLmluZGV4T2YoYWZ0ZXIpICsgMSA6IDA7IGkgPCB0aGlzLnRhZ3MubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcnVsZSA9IHRoaXMudGFnc1tpXTtcbiAgICBpZiAobWF0Y2hlcyhkb20sIHJ1bGUudGFnKSAmJlxuICAgICAgICAocnVsZS5uYW1lc3BhY2UgPT09IHVuZGVmaW5lZCB8fCBkb20ubmFtZXNwYWNlVVJJID09IHJ1bGUubmFtZXNwYWNlKSAmJlxuICAgICAgICAoIXJ1bGUuY29udGV4dCB8fCBjb250ZXh0Lm1hdGNoZXNDb250ZXh0KHJ1bGUuY29udGV4dCkpKSB7XG4gICAgICBpZiAocnVsZS5nZXRBdHRycykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcnVsZS5nZXRBdHRycyhkb20pO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkgeyBjb250aW51ZSB9XG4gICAgICAgIHJ1bGUuYXR0cnMgPSByZXN1bHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gcnVsZVxuICAgIH1cbiAgfVxufTtcblxuRE9NUGFyc2VyLnByb3RvdHlwZS5tYXRjaFN0eWxlID0gZnVuY3Rpb24gbWF0Y2hTdHlsZSAocHJvcCwgdmFsdWUsIGNvbnRleHQsIGFmdGVyKSB7XG4gIGZvciAodmFyIGkgPSBhZnRlciA/IHRoaXMuc3R5bGVzLmluZGV4T2YoYWZ0ZXIpICsgMSA6IDA7IGkgPCB0aGlzLnN0eWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBydWxlID0gdGhpcy5zdHlsZXNbaV07XG4gICAgaWYgKHJ1bGUuc3R5bGUuaW5kZXhPZihwcm9wKSAhPSAwIHx8XG4gICAgICAgIHJ1bGUuY29udGV4dCAmJiAhY29udGV4dC5tYXRjaGVzQ29udGV4dChydWxlLmNvbnRleHQpIHx8XG4gICAgICAgIC8vIFRlc3QgdGhhdCB0aGUgc3R5bGUgc3RyaW5nIGVpdGhlciBwcmVjaXNlbHkgbWF0Y2hlcyB0aGUgcHJvcCxcbiAgICAgICAgLy8gb3IgaGFzIGFuICc9JyBzaWduIGFmdGVyIHRoZSBwcm9wLCBmb2xsb3dlZCBieSB0aGUgZ2l2ZW5cbiAgICAgICAgLy8gdmFsdWUuXG4gICAgICAgIHJ1bGUuc3R5bGUubGVuZ3RoID4gcHJvcC5sZW5ndGggJiZcbiAgICAgICAgKHJ1bGUuc3R5bGUuY2hhckNvZGVBdChwcm9wLmxlbmd0aCkgIT0gNjEgfHwgcnVsZS5zdHlsZS5zbGljZShwcm9wLmxlbmd0aCArIDEpICE9IHZhbHVlKSlcbiAgICAgIHsgY29udGludWUgfVxuICAgIGlmIChydWxlLmdldEF0dHJzKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gcnVsZS5nZXRBdHRycyh2YWx1ZSk7XG4gICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkgeyBjb250aW51ZSB9XG4gICAgICBydWxlLmF0dHJzID0gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gcnVsZVxuICB9XG59O1xuXG4vLyA6IChTY2hlbWEpIOKGkiBbUGFyc2VSdWxlXVxuRE9NUGFyc2VyLnNjaGVtYVJ1bGVzID0gZnVuY3Rpb24gc2NoZW1hUnVsZXMgKHNjaGVtYSkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZ1bmN0aW9uIGluc2VydChydWxlKSB7XG4gICAgdmFyIHByaW9yaXR5ID0gcnVsZS5wcmlvcml0eSA9PSBudWxsID8gNTAgOiBydWxlLnByaW9yaXR5LCBpID0gMDtcbiAgICBmb3IgKDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5leHQgPSByZXN1bHRbaV0sIG5leHRQcmlvcml0eSA9IG5leHQucHJpb3JpdHkgPT0gbnVsbCA/IDUwIDogbmV4dC5wcmlvcml0eTtcbiAgICAgIGlmIChuZXh0UHJpb3JpdHkgPCBwcmlvcml0eSkgeyBicmVhayB9XG4gICAgfVxuICAgIHJlc3VsdC5zcGxpY2UoaSwgMCwgcnVsZSk7XG4gIH1cblxuICB2YXIgbG9vcCA9IGZ1bmN0aW9uICggbmFtZSApIHtcbiAgICB2YXIgcnVsZXMgPSBzY2hlbWEubWFya3NbbmFtZV0uc3BlYy5wYXJzZURPTTtcbiAgICBpZiAocnVsZXMpIHsgcnVsZXMuZm9yRWFjaChmdW5jdGlvbiAocnVsZSkge1xuICAgICAgaW5zZXJ0KHJ1bGUgPSBjb3B5KHJ1bGUpKTtcbiAgICAgIHJ1bGUubWFyayA9IG5hbWU7XG4gICAgfSk7IH1cbiAgfTtcblxuICAgIGZvciAodmFyIG5hbWUgaW4gc2NoZW1hLm1hcmtzKSBsb29wKCBuYW1lICk7XG4gIHZhciBsb29wJDEgPSBmdW5jdGlvbiAoIG5hbWUgKSB7XG4gICAgdmFyIHJ1bGVzJDEgPSBzY2hlbWEubm9kZXNbbmFtZSQxXS5zcGVjLnBhcnNlRE9NO1xuICAgIGlmIChydWxlcyQxKSB7IHJ1bGVzJDEuZm9yRWFjaChmdW5jdGlvbiAocnVsZSkge1xuICAgICAgaW5zZXJ0KHJ1bGUgPSBjb3B5KHJ1bGUpKTtcbiAgICAgIHJ1bGUubm9kZSA9IG5hbWUkMTtcbiAgICB9KTsgfVxuICB9O1xuXG4gICAgZm9yICh2YXIgbmFtZSQxIGluIHNjaGVtYS5ub2RlcykgbG9vcCQxKCk7XG4gIHJldHVybiByZXN1bHRcbn07XG5cbi8vIDo6IChTY2hlbWEpIOKGkiBET01QYXJzZXJcbi8vIENvbnN0cnVjdCBhIERPTSBwYXJzZXIgdXNpbmcgdGhlIHBhcnNpbmcgcnVsZXMgbGlzdGVkIGluIGFcbi8vIHNjaGVtYSdzIFtub2RlIHNwZWNzXSgjbW9kZWwuTm9kZVNwZWMucGFyc2VET00pLCByZW9yZGVyZWQgYnlcbi8vIFtwcmlvcml0eV0oI21vZGVsLlBhcnNlUnVsZS5wcmlvcml0eSkuXG5ET01QYXJzZXIuZnJvbVNjaGVtYSA9IGZ1bmN0aW9uIGZyb21TY2hlbWEgKHNjaGVtYSkge1xuICByZXR1cm4gc2NoZW1hLmNhY2hlZC5kb21QYXJzZXIgfHxcbiAgICAoc2NoZW1hLmNhY2hlZC5kb21QYXJzZXIgPSBuZXcgRE9NUGFyc2VyKHNjaGVtYSwgRE9NUGFyc2VyLnNjaGVtYVJ1bGVzKHNjaGVtYSkpKVxufTtcblxuLy8gOiBPYmplY3Q8Ym9vbD4gVGhlIGJsb2NrLWxldmVsIHRhZ3MgaW4gSFRNTDVcbnZhciBibG9ja1RhZ3MgPSB7XG4gIGFkZHJlc3M6IHRydWUsIGFydGljbGU6IHRydWUsIGFzaWRlOiB0cnVlLCBibG9ja3F1b3RlOiB0cnVlLCBjYW52YXM6IHRydWUsXG4gIGRkOiB0cnVlLCBkaXY6IHRydWUsIGRsOiB0cnVlLCBmaWVsZHNldDogdHJ1ZSwgZmlnY2FwdGlvbjogdHJ1ZSwgZmlndXJlOiB0cnVlLFxuICBmb290ZXI6IHRydWUsIGZvcm06IHRydWUsIGgxOiB0cnVlLCBoMjogdHJ1ZSwgaDM6IHRydWUsIGg0OiB0cnVlLCBoNTogdHJ1ZSxcbiAgaDY6IHRydWUsIGhlYWRlcjogdHJ1ZSwgaGdyb3VwOiB0cnVlLCBocjogdHJ1ZSwgbGk6IHRydWUsIG5vc2NyaXB0OiB0cnVlLCBvbDogdHJ1ZSxcbiAgb3V0cHV0OiB0cnVlLCBwOiB0cnVlLCBwcmU6IHRydWUsIHNlY3Rpb246IHRydWUsIHRhYmxlOiB0cnVlLCB0Zm9vdDogdHJ1ZSwgdWw6IHRydWVcbn07XG5cbi8vIDogT2JqZWN0PGJvb2w+IFRoZSB0YWdzIHRoYXQgd2Ugbm9ybWFsbHkgaWdub3JlLlxudmFyIGlnbm9yZVRhZ3MgPSB7XG4gIGhlYWQ6IHRydWUsIG5vc2NyaXB0OiB0cnVlLCBvYmplY3Q6IHRydWUsIHNjcmlwdDogdHJ1ZSwgc3R5bGU6IHRydWUsIHRpdGxlOiB0cnVlXG59O1xuXG4vLyA6IE9iamVjdDxib29sPiBMaXN0IHRhZ3MuXG52YXIgbGlzdFRhZ3MgPSB7b2w6IHRydWUsIHVsOiB0cnVlfTtcblxuLy8gVXNpbmcgYSBiaXRmaWVsZCBmb3Igbm9kZSBjb250ZXh0IG9wdGlvbnNcbnZhciBPUFRfUFJFU0VSVkVfV1MgPSAxLCBPUFRfUFJFU0VSVkVfV1NfRlVMTCA9IDIsIE9QVF9PUEVOX0xFRlQgPSA0O1xuXG5mdW5jdGlvbiB3c09wdGlvbnNGb3IocHJlc2VydmVXaGl0ZXNwYWNlKSB7XG4gIHJldHVybiAocHJlc2VydmVXaGl0ZXNwYWNlID8gT1BUX1BSRVNFUlZFX1dTIDogMCkgfCAocHJlc2VydmVXaGl0ZXNwYWNlID09PSBcImZ1bGxcIiA/IE9QVF9QUkVTRVJWRV9XU19GVUxMIDogMClcbn1cblxudmFyIE5vZGVDb250ZXh0ID0gZnVuY3Rpb24gTm9kZUNvbnRleHQodHlwZSwgYXR0cnMsIG1hcmtzLCBwZW5kaW5nTWFya3MsIHNvbGlkLCBtYXRjaCwgb3B0aW9ucykge1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gIHRoaXMuc29saWQgPSBzb2xpZDtcbiAgdGhpcy5tYXRjaCA9IG1hdGNoIHx8IChvcHRpb25zICYgT1BUX09QRU5fTEVGVCA/IG51bGwgOiB0eXBlLmNvbnRlbnRNYXRjaCk7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIHRoaXMuY29udGVudCA9IFtdO1xuICAvLyBNYXJrcyBhcHBsaWVkIHRvIHRoaXMgbm9kZSBpdHNlbGZcbiAgdGhpcy5tYXJrcyA9IG1hcmtzO1xuICAvLyBNYXJrcyBhcHBsaWVkIHRvIGl0cyBjaGlsZHJlblxuICB0aGlzLmFjdGl2ZU1hcmtzID0gTWFyay5ub25lO1xuICAvLyBNYXJrcyB0aGF0IGNhbid0IGFwcGx5IGhlcmUsIGJ1dCB3aWxsIGJlIHVzZWQgaW4gY2hpbGRyZW4gaWYgcG9zc2libGVcbiAgdGhpcy5wZW5kaW5nTWFya3MgPSBwZW5kaW5nTWFya3M7XG4gIC8vIE5lc3RlZCBNYXJrcyB3aXRoIHNhbWUgdHlwZVxuICB0aGlzLnN0YXNoTWFya3MgPSBbXTtcbn07XG5cbk5vZGVDb250ZXh0LnByb3RvdHlwZS5maW5kV3JhcHBpbmcgPSBmdW5jdGlvbiBmaW5kV3JhcHBpbmcgKG5vZGUpIHtcbiAgaWYgKCF0aGlzLm1hdGNoKSB7XG4gICAgaWYgKCF0aGlzLnR5cGUpIHsgcmV0dXJuIFtdIH1cbiAgICB2YXIgZmlsbCA9IHRoaXMudHlwZS5jb250ZW50TWF0Y2guZmlsbEJlZm9yZShGcmFnbWVudC5mcm9tKG5vZGUpKTtcbiAgICBpZiAoZmlsbCkge1xuICAgICAgdGhpcy5tYXRjaCA9IHRoaXMudHlwZS5jb250ZW50TWF0Y2gubWF0Y2hGcmFnbWVudChmaWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0YXJ0ID0gdGhpcy50eXBlLmNvbnRlbnRNYXRjaCwgd3JhcDtcbiAgICAgIGlmICh3cmFwID0gc3RhcnQuZmluZFdyYXBwaW5nKG5vZGUudHlwZSkpIHtcbiAgICAgICAgdGhpcy5tYXRjaCA9IHN0YXJ0O1xuICAgICAgICByZXR1cm4gd3JhcFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXMubWF0Y2guZmluZFdyYXBwaW5nKG5vZGUudHlwZSlcbn07XG5cbk5vZGVDb250ZXh0LnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbiBmaW5pc2ggKG9wZW5FbmQpIHtcbiAgaWYgKCEodGhpcy5vcHRpb25zICYgT1BUX1BSRVNFUlZFX1dTKSkgeyAvLyBTdHJpcCB0cmFpbGluZyB3aGl0ZXNwYWNlXG4gICAgdmFyIGxhc3QgPSB0aGlzLmNvbnRlbnRbdGhpcy5jb250ZW50Lmxlbmd0aCAtIDFdLCBtO1xuICAgIGlmIChsYXN0ICYmIGxhc3QuaXNUZXh0ICYmIChtID0gL1sgXFx0XFxyXFxuXFx1MDAwY10rJC8uZXhlYyhsYXN0LnRleHQpKSkge1xuICAgICAgaWYgKGxhc3QudGV4dC5sZW5ndGggPT0gbVswXS5sZW5ndGgpIHsgdGhpcy5jb250ZW50LnBvcCgpOyB9XG4gICAgICBlbHNlIHsgdGhpcy5jb250ZW50W3RoaXMuY29udGVudC5sZW5ndGggLSAxXSA9IGxhc3Qud2l0aFRleHQobGFzdC50ZXh0LnNsaWNlKDAsIGxhc3QudGV4dC5sZW5ndGggLSBtWzBdLmxlbmd0aCkpOyB9XG4gICAgfVxuICB9XG4gIHZhciBjb250ZW50ID0gRnJhZ21lbnQuZnJvbSh0aGlzLmNvbnRlbnQpO1xuICBpZiAoIW9wZW5FbmQgJiYgdGhpcy5tYXRjaClcbiAgICB7IGNvbnRlbnQgPSBjb250ZW50LmFwcGVuZCh0aGlzLm1hdGNoLmZpbGxCZWZvcmUoRnJhZ21lbnQuZW1wdHksIHRydWUpKTsgfVxuICByZXR1cm4gdGhpcy50eXBlID8gdGhpcy50eXBlLmNyZWF0ZSh0aGlzLmF0dHJzLCBjb250ZW50LCB0aGlzLm1hcmtzKSA6IGNvbnRlbnRcbn07XG5cbk5vZGVDb250ZXh0LnByb3RvdHlwZS5wb3BGcm9tU3Rhc2hNYXJrID0gZnVuY3Rpb24gcG9wRnJvbVN0YXNoTWFyayAobWFyaykge1xuICBmb3IgKHZhciBpID0gdGhpcy5zdGFzaE1hcmtzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgIHsgaWYgKG1hcmsuZXEodGhpcy5zdGFzaE1hcmtzW2ldKSkgeyByZXR1cm4gdGhpcy5zdGFzaE1hcmtzLnNwbGljZShpLCAxKVswXSB9IH1cbn07XG5cbk5vZGVDb250ZXh0LnByb3RvdHlwZS5hcHBseVBlbmRpbmcgPSBmdW5jdGlvbiBhcHBseVBlbmRpbmcgKG5leHRUeXBlKSB7XG4gIGZvciAodmFyIGkgPSAwLCBwZW5kaW5nID0gdGhpcy5wZW5kaW5nTWFya3M7IGkgPCBwZW5kaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG1hcmsgPSBwZW5kaW5nW2ldO1xuICAgIGlmICgodGhpcy50eXBlID8gdGhpcy50eXBlLmFsbG93c01hcmtUeXBlKG1hcmsudHlwZSkgOiBtYXJrTWF5QXBwbHkobWFyay50eXBlLCBuZXh0VHlwZSkpICYmXG4gICAgICAgICFtYXJrLmlzSW5TZXQodGhpcy5hY3RpdmVNYXJrcykpIHtcbiAgICAgIHRoaXMuYWN0aXZlTWFya3MgPSBtYXJrLmFkZFRvU2V0KHRoaXMuYWN0aXZlTWFya3MpO1xuICAgICAgdGhpcy5wZW5kaW5nTWFya3MgPSBtYXJrLnJlbW92ZUZyb21TZXQodGhpcy5wZW5kaW5nTWFya3MpO1xuICAgIH1cbiAgfVxufTtcblxuTm9kZUNvbnRleHQucHJvdG90eXBlLmlubGluZUNvbnRleHQgPSBmdW5jdGlvbiBpbmxpbmVDb250ZXh0IChub2RlKSB7XG4gIGlmICh0aGlzLnR5cGUpIHsgcmV0dXJuIHRoaXMudHlwZS5pbmxpbmVDb250ZW50IH1cbiAgaWYgKHRoaXMuY29udGVudC5sZW5ndGgpIHsgcmV0dXJuIHRoaXMuY29udGVudFswXS5pc0lubGluZSB9XG4gIHJldHVybiBub2RlLnBhcmVudE5vZGUgJiYgIWJsb2NrVGFncy5oYXNPd25Qcm9wZXJ0eShub2RlLnBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSlcbn07XG5cbnZhciBQYXJzZUNvbnRleHQgPSBmdW5jdGlvbiBQYXJzZUNvbnRleHQocGFyc2VyLCBvcHRpb25zLCBvcGVuKSB7XG4gIC8vIDogRE9NUGFyc2VyIFRoZSBwYXJzZXIgd2UgYXJlIHVzaW5nLlxuICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgLy8gOiBPYmplY3QgVGhlIG9wdGlvbnMgcGFzc2VkIHRvIHRoaXMgcGFyc2UuXG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIHRoaXMuaXNPcGVuID0gb3BlbjtcbiAgdmFyIHRvcE5vZGUgPSBvcHRpb25zLnRvcE5vZGUsIHRvcENvbnRleHQ7XG4gIHZhciB0b3BPcHRpb25zID0gd3NPcHRpb25zRm9yKG9wdGlvbnMucHJlc2VydmVXaGl0ZXNwYWNlKSB8IChvcGVuID8gT1BUX09QRU5fTEVGVCA6IDApO1xuICBpZiAodG9wTm9kZSlcbiAgICB7IHRvcENvbnRleHQgPSBuZXcgTm9kZUNvbnRleHQodG9wTm9kZS50eXBlLCB0b3BOb2RlLmF0dHJzLCBNYXJrLm5vbmUsIE1hcmsubm9uZSwgdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMudG9wTWF0Y2ggfHwgdG9wTm9kZS50eXBlLmNvbnRlbnRNYXRjaCwgdG9wT3B0aW9ucyk7IH1cbiAgZWxzZSBpZiAob3BlbilcbiAgICB7IHRvcENvbnRleHQgPSBuZXcgTm9kZUNvbnRleHQobnVsbCwgbnVsbCwgTWFyay5ub25lLCBNYXJrLm5vbmUsIHRydWUsIG51bGwsIHRvcE9wdGlvbnMpOyB9XG4gIGVsc2VcbiAgICB7IHRvcENvbnRleHQgPSBuZXcgTm9kZUNvbnRleHQocGFyc2VyLnNjaGVtYS50b3BOb2RlVHlwZSwgbnVsbCwgTWFyay5ub25lLCBNYXJrLm5vbmUsIHRydWUsIG51bGwsIHRvcE9wdGlvbnMpOyB9XG4gIHRoaXMubm9kZXMgPSBbdG9wQ29udGV4dF07XG4gIC8vIDogW01hcmtdIFRoZSBjdXJyZW50IHNldCBvZiBtYXJrc1xuICB0aGlzLm9wZW4gPSAwO1xuICB0aGlzLmZpbmQgPSBvcHRpb25zLmZpbmRQb3NpdGlvbnM7XG4gIHRoaXMubmVlZHNCbG9jayA9IGZhbHNlO1xufTtcblxudmFyIHByb3RvdHlwZUFjY2Vzc29ycyQ2ID0geyB0b3A6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sY3VycmVudFBvczogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG5wcm90b3R5cGVBY2Nlc3NvcnMkNi50b3AuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ub2Rlc1t0aGlzLm9wZW5dXG59O1xuXG4vLyA6IChkb20uTm9kZSlcbi8vIEFkZCBhIERPTSBub2RlIHRvIHRoZSBjb250ZW50LiBUZXh0IGlzIGluc2VydGVkIGFzIHRleHQgbm9kZSxcbi8vIG90aGVyd2lzZSwgdGhlIG5vZGUgaXMgcGFzc2VkIHRvIGBhZGRFbGVtZW50YCBvciwgaWYgaXQgaGFzIGFcbi8vIGBzdHlsZWAgYXR0cmlidXRlLCBgYWRkRWxlbWVudFdpdGhTdHlsZXNgLlxuUGFyc2VDb250ZXh0LnByb3RvdHlwZS5hZGRET00gPSBmdW5jdGlvbiBhZGRET00gKGRvbSkge1xuICBpZiAoZG9tLm5vZGVUeXBlID09IDMpIHtcbiAgICB0aGlzLmFkZFRleHROb2RlKGRvbSk7XG4gIH0gZWxzZSBpZiAoZG9tLm5vZGVUeXBlID09IDEpIHtcbiAgICB2YXIgc3R5bGUgPSBkb20uZ2V0QXR0cmlidXRlKFwic3R5bGVcIik7XG4gICAgdmFyIG1hcmtzID0gc3R5bGUgPyB0aGlzLnJlYWRTdHlsZXMocGFyc2VTdHlsZXMoc3R5bGUpKSA6IG51bGwsIHRvcCA9IHRoaXMudG9wO1xuICAgIGlmIChtYXJrcyAhPSBudWxsKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgbWFya3MubGVuZ3RoOyBpKyspIHsgdGhpcy5hZGRQZW5kaW5nTWFyayhtYXJrc1tpXSk7IH0gfVxuICAgIHRoaXMuYWRkRWxlbWVudChkb20pO1xuICAgIGlmIChtYXJrcyAhPSBudWxsKSB7IGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IG1hcmtzLmxlbmd0aDsgaSQxKyspIHsgdGhpcy5yZW1vdmVQZW5kaW5nTWFyayhtYXJrc1tpJDFdLCB0b3ApOyB9IH1cbiAgfVxufTtcblxuUGFyc2VDb250ZXh0LnByb3RvdHlwZS5hZGRUZXh0Tm9kZSA9IGZ1bmN0aW9uIGFkZFRleHROb2RlIChkb20pIHtcbiAgdmFyIHZhbHVlID0gZG9tLm5vZGVWYWx1ZTtcbiAgdmFyIHRvcCA9IHRoaXMudG9wO1xuICBpZiAodG9wLm9wdGlvbnMgJiBPUFRfUFJFU0VSVkVfV1NfRlVMTCB8fFxuICAgICAgdG9wLmlubGluZUNvbnRleHQoZG9tKSB8fFxuICAgICAgL1teIFxcdFxcclxcblxcdTAwMGNdLy50ZXN0KHZhbHVlKSkge1xuICAgIGlmICghKHRvcC5vcHRpb25zICYgT1BUX1BSRVNFUlZFX1dTKSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9bIFxcdFxcclxcblxcdTAwMGNdKy9nLCBcIiBcIik7XG4gICAgICAvLyBJZiB0aGlzIHN0YXJ0cyB3aXRoIHdoaXRlc3BhY2UsIGFuZCB0aGVyZSBpcyBubyBub2RlIGJlZm9yZSBpdCwgb3JcbiAgICAgIC8vIGEgaGFyZCBicmVhaywgb3IgYSB0ZXh0IG5vZGUgdGhhdCBlbmRzIHdpdGggd2hpdGVzcGFjZSwgc3RyaXAgdGhlXG4gICAgICAvLyBsZWFkaW5nIHNwYWNlLlxuICAgICAgaWYgKC9eWyBcXHRcXHJcXG5cXHUwMDBjXS8udGVzdCh2YWx1ZSkgJiYgdGhpcy5vcGVuID09IHRoaXMubm9kZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICB2YXIgbm9kZUJlZm9yZSA9IHRvcC5jb250ZW50W3RvcC5jb250ZW50Lmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgZG9tTm9kZUJlZm9yZSA9IGRvbS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgIGlmICghbm9kZUJlZm9yZSB8fFxuICAgICAgICAgICAgKGRvbU5vZGVCZWZvcmUgJiYgZG9tTm9kZUJlZm9yZS5ub2RlTmFtZSA9PSAnQlInKSB8fFxuICAgICAgICAgICAgKG5vZGVCZWZvcmUuaXNUZXh0ICYmIC9bIFxcdFxcclxcblxcdTAwMGNdJC8udGVzdChub2RlQmVmb3JlLnRleHQpKSlcbiAgICAgICAgICB7IHZhbHVlID0gdmFsdWUuc2xpY2UoMSk7IH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEodG9wLm9wdGlvbnMgJiBPUFRfUFJFU0VSVkVfV1NfRlVMTCkpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxyP1xcbnxcXHIvZywgXCIgXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcclxcbj8vZywgXCJcXG5cIik7XG4gICAgfVxuICAgIGlmICh2YWx1ZSkgeyB0aGlzLmluc2VydE5vZGUodGhpcy5wYXJzZXIuc2NoZW1hLnRleHQodmFsdWUpKTsgfVxuICAgIHRoaXMuZmluZEluVGV4dChkb20pO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZmluZEluc2lkZShkb20pO1xuICB9XG59O1xuXG4vLyA6IChkb20uRWxlbWVudCwgP1BhcnNlUnVsZSlcbi8vIFRyeSB0byBmaW5kIGEgaGFuZGxlciBmb3IgdGhlIGdpdmVuIHRhZyBhbmQgdXNlIHRoYXQgdG8gcGFyc2UuIElmXG4vLyBub25lIGlzIGZvdW5kLCB0aGUgZWxlbWVudCdzIGNvbnRlbnQgbm9kZXMgYXJlIGFkZGVkIGRpcmVjdGx5LlxuUGFyc2VDb250ZXh0LnByb3RvdHlwZS5hZGRFbGVtZW50ID0gZnVuY3Rpb24gYWRkRWxlbWVudCAoZG9tLCBtYXRjaEFmdGVyKSB7XG4gIHZhciBuYW1lID0gZG9tLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksIHJ1bGVJRDtcbiAgaWYgKGxpc3RUYWdzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHRoaXMucGFyc2VyLm5vcm1hbGl6ZUxpc3RzKSB7IG5vcm1hbGl6ZUxpc3QoZG9tKTsgfVxuICB2YXIgcnVsZSA9ICh0aGlzLm9wdGlvbnMucnVsZUZyb21Ob2RlICYmIHRoaXMub3B0aW9ucy5ydWxlRnJvbU5vZGUoZG9tKSkgfHxcbiAgICAgIChydWxlSUQgPSB0aGlzLnBhcnNlci5tYXRjaFRhZyhkb20sIHRoaXMsIG1hdGNoQWZ0ZXIpKTtcbiAgaWYgKHJ1bGUgPyBydWxlLmlnbm9yZSA6IGlnbm9yZVRhZ3MuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICB0aGlzLmZpbmRJbnNpZGUoZG9tKTtcbiAgICB0aGlzLmlnbm9yZUZhbGxiYWNrKGRvbSk7XG4gIH0gZWxzZSBpZiAoIXJ1bGUgfHwgcnVsZS5za2lwIHx8IHJ1bGUuY2xvc2VQYXJlbnQpIHtcbiAgICBpZiAocnVsZSAmJiBydWxlLmNsb3NlUGFyZW50KSB7IHRoaXMub3BlbiA9IE1hdGgubWF4KDAsIHRoaXMub3BlbiAtIDEpOyB9XG4gICAgZWxzZSBpZiAocnVsZSAmJiBydWxlLnNraXAubm9kZVR5cGUpIHsgZG9tID0gcnVsZS5za2lwOyB9XG4gICAgdmFyIHN5bmMsIHRvcCA9IHRoaXMudG9wLCBvbGROZWVkc0Jsb2NrID0gdGhpcy5uZWVkc0Jsb2NrO1xuICAgIGlmIChibG9ja1RhZ3MuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIHN5bmMgPSB0cnVlO1xuICAgICAgaWYgKCF0b3AudHlwZSkgeyB0aGlzLm5lZWRzQmxvY2sgPSB0cnVlOyB9XG4gICAgfSBlbHNlIGlmICghZG9tLmZpcnN0Q2hpbGQpIHtcbiAgICAgIHRoaXMubGVhZkZhbGxiYWNrKGRvbSk7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdGhpcy5hZGRBbGwoZG9tKTtcbiAgICBpZiAoc3luYykgeyB0aGlzLnN5bmModG9wKTsgfVxuICAgIHRoaXMubmVlZHNCbG9jayA9IG9sZE5lZWRzQmxvY2s7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5hZGRFbGVtZW50QnlSdWxlKGRvbSwgcnVsZSwgcnVsZS5jb25zdW1pbmcgPT09IGZhbHNlID8gcnVsZUlEIDogbnVsbCk7XG4gIH1cbn07XG5cbi8vIENhbGxlZCBmb3IgbGVhZiBET00gbm9kZXMgdGhhdCB3b3VsZCBvdGhlcndpc2UgYmUgaWdub3JlZFxuUGFyc2VDb250ZXh0LnByb3RvdHlwZS5sZWFmRmFsbGJhY2sgPSBmdW5jdGlvbiBsZWFmRmFsbGJhY2sgKGRvbSkge1xuICBpZiAoZG9tLm5vZGVOYW1lID09IFwiQlJcIiAmJiB0aGlzLnRvcC50eXBlICYmIHRoaXMudG9wLnR5cGUuaW5saW5lQ29udGVudClcbiAgICB7IHRoaXMuYWRkVGV4dE5vZGUoZG9tLm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG5cIikpOyB9XG59O1xuXG4vLyBDYWxsZWQgZm9yIGlnbm9yZWQgbm9kZXNcblBhcnNlQ29udGV4dC5wcm90b3R5cGUuaWdub3JlRmFsbGJhY2sgPSBmdW5jdGlvbiBpZ25vcmVGYWxsYmFjayAoZG9tKSB7XG4gIC8vIElnbm9yZWQgQlIgbm9kZXMgc2hvdWxkIGF0IGxlYXN0IGNyZWF0ZSBhbiBpbmxpbmUgY29udGV4dFxuICBpZiAoZG9tLm5vZGVOYW1lID09IFwiQlJcIiAmJiAoIXRoaXMudG9wLnR5cGUgfHwgIXRoaXMudG9wLnR5cGUuaW5saW5lQ29udGVudCkpXG4gICAgeyB0aGlzLmZpbmRQbGFjZSh0aGlzLnBhcnNlci5zY2hlbWEudGV4dChcIi1cIikpOyB9XG59O1xuXG4vLyBSdW4gYW55IHN0eWxlIHBhcnNlciBhc3NvY2lhdGVkIHdpdGggdGhlIG5vZGUncyBzdHlsZXMuIEVpdGhlclxuLy8gcmV0dXJuIGFuIGFycmF5IG9mIG1hcmtzLCBvciBudWxsIHRvIGluZGljYXRlIHNvbWUgb2YgdGhlIHN0eWxlc1xuLy8gaGFkIGEgcnVsZSB3aXRoIGBpZ25vcmVgIHNldC5cblBhcnNlQ29udGV4dC5wcm90b3R5cGUucmVhZFN0eWxlcyA9IGZ1bmN0aW9uIHJlYWRTdHlsZXMgKHN0eWxlcykge1xuICB2YXIgbWFya3MgPSBNYXJrLm5vbmU7XG4gIHN0eWxlOiBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIGZvciAodmFyIGFmdGVyID0gbnVsbDs7KSB7XG4gICAgICB2YXIgcnVsZSA9IHRoaXMucGFyc2VyLm1hdGNoU3R5bGUoc3R5bGVzW2ldLCBzdHlsZXNbaSArIDFdLCB0aGlzLCBhZnRlcik7XG4gICAgICBpZiAoIXJ1bGUpIHsgY29udGludWUgc3R5bGUgfVxuICAgICAgaWYgKHJ1bGUuaWdub3JlKSB7IHJldHVybiBudWxsIH1cbiAgICAgIG1hcmtzID0gdGhpcy5wYXJzZXIuc2NoZW1hLm1hcmtzW3J1bGUubWFya10uY3JlYXRlKHJ1bGUuYXR0cnMpLmFkZFRvU2V0KG1hcmtzKTtcbiAgICAgIGlmIChydWxlLmNvbnN1bWluZyA9PT0gZmFsc2UpIHsgYWZ0ZXIgPSBydWxlOyB9XG4gICAgICBlbHNlIHsgYnJlYWsgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbWFya3Ncbn07XG5cbi8vIDogKGRvbS5FbGVtZW50LCBQYXJzZVJ1bGUpIOKGkiBib29sXG4vLyBMb29rIHVwIGEgaGFuZGxlciBmb3IgdGhlIGdpdmVuIG5vZGUuIElmIG5vbmUgYXJlIGZvdW5kLCByZXR1cm5cbi8vIGZhbHNlLiBPdGhlcndpc2UsIGFwcGx5IGl0LCB1c2UgaXRzIHJldHVybiB2YWx1ZSB0byBkcml2ZSB0aGUgd2F5XG4vLyB0aGUgbm9kZSdzIGNvbnRlbnQgaXMgd3JhcHBlZCwgYW5kIHJldHVybiB0cnVlLlxuUGFyc2VDb250ZXh0LnByb3RvdHlwZS5hZGRFbGVtZW50QnlSdWxlID0gZnVuY3Rpb24gYWRkRWxlbWVudEJ5UnVsZSAoZG9tLCBydWxlLCBjb250aW51ZUFmdGVyKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIHN5bmMsIG5vZGVUeXBlLCBtYXJrVHlwZSwgbWFyaztcbiAgaWYgKHJ1bGUubm9kZSkge1xuICAgIG5vZGVUeXBlID0gdGhpcy5wYXJzZXIuc2NoZW1hLm5vZGVzW3J1bGUubm9kZV07XG4gICAgaWYgKCFub2RlVHlwZS5pc0xlYWYpIHtcbiAgICAgIHN5bmMgPSB0aGlzLmVudGVyKG5vZGVUeXBlLCBydWxlLmF0dHJzLCBydWxlLnByZXNlcnZlV2hpdGVzcGFjZSk7XG4gICAgfSBlbHNlIGlmICghdGhpcy5pbnNlcnROb2RlKG5vZGVUeXBlLmNyZWF0ZShydWxlLmF0dHJzKSkpIHtcbiAgICAgIHRoaXMubGVhZkZhbGxiYWNrKGRvbSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG1hcmtUeXBlID0gdGhpcy5wYXJzZXIuc2NoZW1hLm1hcmtzW3J1bGUubWFya107XG4gICAgbWFyayA9IG1hcmtUeXBlLmNyZWF0ZShydWxlLmF0dHJzKTtcbiAgICB0aGlzLmFkZFBlbmRpbmdNYXJrKG1hcmspO1xuICB9XG4gIHZhciBzdGFydEluID0gdGhpcy50b3A7XG5cbiAgaWYgKG5vZGVUeXBlICYmIG5vZGVUeXBlLmlzTGVhZikge1xuICAgIHRoaXMuZmluZEluc2lkZShkb20pO1xuICB9IGVsc2UgaWYgKGNvbnRpbnVlQWZ0ZXIpIHtcbiAgICB0aGlzLmFkZEVsZW1lbnQoZG9tLCBjb250aW51ZUFmdGVyKTtcbiAgfSBlbHNlIGlmIChydWxlLmdldENvbnRlbnQpIHtcbiAgICB0aGlzLmZpbmRJbnNpZGUoZG9tKTtcbiAgICBydWxlLmdldENvbnRlbnQoZG9tLCB0aGlzLnBhcnNlci5zY2hlbWEpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIHRoaXMkMS5pbnNlcnROb2RlKG5vZGUpOyB9KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29udGVudERPTSA9IHJ1bGUuY29udGVudEVsZW1lbnQ7XG4gICAgaWYgKHR5cGVvZiBjb250ZW50RE9NID09IFwic3RyaW5nXCIpIHsgY29udGVudERPTSA9IGRvbS5xdWVyeVNlbGVjdG9yKGNvbnRlbnRET00pOyB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGNvbnRlbnRET00gPT0gXCJmdW5jdGlvblwiKSB7IGNvbnRlbnRET00gPSBjb250ZW50RE9NKGRvbSk7IH1cbiAgICBpZiAoIWNvbnRlbnRET00pIHsgY29udGVudERPTSA9IGRvbTsgfVxuICAgIHRoaXMuZmluZEFyb3VuZChkb20sIGNvbnRlbnRET00sIHRydWUpO1xuICAgIHRoaXMuYWRkQWxsKGNvbnRlbnRET00sIHN5bmMpO1xuICB9XG4gIGlmIChzeW5jKSB7IHRoaXMuc3luYyhzdGFydEluKTsgdGhpcy5vcGVuLS07IH1cbiAgaWYgKG1hcmspIHsgdGhpcy5yZW1vdmVQZW5kaW5nTWFyayhtYXJrLCBzdGFydEluKTsgfVxufTtcblxuLy8gOiAoZG9tLk5vZGUsID9Ob2RlQnVpbGRlciwgP251bWJlciwgP251bWJlcilcbi8vIEFkZCBhbGwgY2hpbGQgbm9kZXMgYmV0d2VlbiBgc3RhcnRJbmRleGAgYW5kIGBlbmRJbmRleGAgKG9yIHRoZVxuLy8gd2hvbGUgbm9kZSwgaWYgbm90IGdpdmVuKS4gSWYgYHN5bmNgIGlzIHBhc3NlZCwgdXNlIGl0IHRvXG4vLyBzeW5jaHJvbml6ZSBhZnRlciBldmVyeSBibG9jayBlbGVtZW50LlxuUGFyc2VDb250ZXh0LnByb3RvdHlwZS5hZGRBbGwgPSBmdW5jdGlvbiBhZGRBbGwgKHBhcmVudCwgc3luYywgc3RhcnRJbmRleCwgZW5kSW5kZXgpIHtcbiAgdmFyIGluZGV4ID0gc3RhcnRJbmRleCB8fCAwO1xuICBmb3IgKHZhciBkb20gPSBzdGFydEluZGV4ID8gcGFyZW50LmNoaWxkTm9kZXNbc3RhcnRJbmRleF0gOiBwYXJlbnQuZmlyc3RDaGlsZCxcbiAgICAgICAgICAgZW5kID0gZW5kSW5kZXggPT0gbnVsbCA/IG51bGwgOiBwYXJlbnQuY2hpbGROb2Rlc1tlbmRJbmRleF07XG4gICAgICAgZG9tICE9IGVuZDsgZG9tID0gZG9tLm5leHRTaWJsaW5nLCArK2luZGV4KSB7XG4gICAgdGhpcy5maW5kQXRQb2ludChwYXJlbnQsIGluZGV4KTtcbiAgICB0aGlzLmFkZERPTShkb20pO1xuICAgIGlmIChzeW5jICYmIGJsb2NrVGFncy5oYXNPd25Qcm9wZXJ0eShkb20ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkpXG4gICAgICB7IHRoaXMuc3luYyhzeW5jKTsgfVxuICB9XG4gIHRoaXMuZmluZEF0UG9pbnQocGFyZW50LCBpbmRleCk7XG59O1xuXG4vLyBUcnkgdG8gZmluZCBhIHdheSB0byBmaXQgdGhlIGdpdmVuIG5vZGUgdHlwZSBpbnRvIHRoZSBjdXJyZW50XG4vLyBjb250ZXh0LiBNYXkgYWRkIGludGVybWVkaWF0ZSB3cmFwcGVycyBhbmQvb3IgbGVhdmUgbm9uLXNvbGlkXG4vLyBub2RlcyB0aGF0IHdlJ3JlIGluLlxuUGFyc2VDb250ZXh0LnByb3RvdHlwZS5maW5kUGxhY2UgPSBmdW5jdGlvbiBmaW5kUGxhY2UgKG5vZGUpIHtcbiAgdmFyIHJvdXRlLCBzeW5jO1xuICBmb3IgKHZhciBkZXB0aCA9IHRoaXMub3BlbjsgZGVwdGggPj0gMDsgZGVwdGgtLSkge1xuICAgIHZhciBjeCA9IHRoaXMubm9kZXNbZGVwdGhdO1xuICAgIHZhciBmb3VuZCA9IGN4LmZpbmRXcmFwcGluZyhub2RlKTtcbiAgICBpZiAoZm91bmQgJiYgKCFyb3V0ZSB8fCByb3V0ZS5sZW5ndGggPiBmb3VuZC5sZW5ndGgpKSB7XG4gICAgICByb3V0ZSA9IGZvdW5kO1xuICAgICAgc3luYyA9IGN4O1xuICAgICAgaWYgKCFmb3VuZC5sZW5ndGgpIHsgYnJlYWsgfVxuICAgIH1cbiAgICBpZiAoY3guc29saWQpIHsgYnJlYWsgfVxuICB9XG4gIGlmICghcm91dGUpIHsgcmV0dXJuIGZhbHNlIH1cbiAgdGhpcy5zeW5jKHN5bmMpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJvdXRlLmxlbmd0aDsgaSsrKVxuICAgIHsgdGhpcy5lbnRlcklubmVyKHJvdXRlW2ldLCBudWxsLCBmYWxzZSk7IH1cbiAgcmV0dXJuIHRydWVcbn07XG5cbi8vIDogKE5vZGUpIOKGkiA/Tm9kZVxuLy8gVHJ5IHRvIGluc2VydCB0aGUgZ2l2ZW4gbm9kZSwgYWRqdXN0aW5nIHRoZSBjb250ZXh0IHdoZW4gbmVlZGVkLlxuUGFyc2VDb250ZXh0LnByb3RvdHlwZS5pbnNlcnROb2RlID0gZnVuY3Rpb24gaW5zZXJ0Tm9kZSAobm9kZSkge1xuICBpZiAobm9kZS5pc0lubGluZSAmJiB0aGlzLm5lZWRzQmxvY2sgJiYgIXRoaXMudG9wLnR5cGUpIHtcbiAgICB2YXIgYmxvY2sgPSB0aGlzLnRleHRibG9ja0Zyb21Db250ZXh0KCk7XG4gICAgaWYgKGJsb2NrKSB7IHRoaXMuZW50ZXJJbm5lcihibG9jayk7IH1cbiAgfVxuICBpZiAodGhpcy5maW5kUGxhY2Uobm9kZSkpIHtcbiAgICB0aGlzLmNsb3NlRXh0cmEoKTtcbiAgICB2YXIgdG9wID0gdGhpcy50b3A7XG4gICAgdG9wLmFwcGx5UGVuZGluZyhub2RlLnR5cGUpO1xuICAgIGlmICh0b3AubWF0Y2gpIHsgdG9wLm1hdGNoID0gdG9wLm1hdGNoLm1hdGNoVHlwZShub2RlLnR5cGUpOyB9XG4gICAgdmFyIG1hcmtzID0gdG9wLmFjdGl2ZU1hcmtzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5tYXJrcy5sZW5ndGg7IGkrKylcbiAgICAgIHsgaWYgKCF0b3AudHlwZSB8fCB0b3AudHlwZS5hbGxvd3NNYXJrVHlwZShub2RlLm1hcmtzW2ldLnR5cGUpKVxuICAgICAgICB7IG1hcmtzID0gbm9kZS5tYXJrc1tpXS5hZGRUb1NldChtYXJrcyk7IH0gfVxuICAgIHRvcC5jb250ZW50LnB1c2gobm9kZS5tYXJrKG1hcmtzKSk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIDogKE5vZGVUeXBlLCA/T2JqZWN0KSDihpIgYm9vbFxuLy8gVHJ5IHRvIHN0YXJ0IGEgbm9kZSBvZiB0aGUgZ2l2ZW4gdHlwZSwgYWRqdXN0aW5nIHRoZSBjb250ZXh0IHdoZW5cbi8vIG5lY2Vzc2FyeS5cblBhcnNlQ29udGV4dC5wcm90b3R5cGUuZW50ZXIgPSBmdW5jdGlvbiBlbnRlciAodHlwZSwgYXR0cnMsIHByZXNlcnZlV1MpIHtcbiAgdmFyIG9rID0gdGhpcy5maW5kUGxhY2UodHlwZS5jcmVhdGUoYXR0cnMpKTtcbiAgaWYgKG9rKSB7IHRoaXMuZW50ZXJJbm5lcih0eXBlLCBhdHRycywgdHJ1ZSwgcHJlc2VydmVXUyk7IH1cbiAgcmV0dXJuIG9rXG59O1xuXG4vLyBPcGVuIGEgbm9kZSBvZiB0aGUgZ2l2ZW4gdHlwZVxuUGFyc2VDb250ZXh0LnByb3RvdHlwZS5lbnRlcklubmVyID0gZnVuY3Rpb24gZW50ZXJJbm5lciAodHlwZSwgYXR0cnMsIHNvbGlkLCBwcmVzZXJ2ZVdTKSB7XG4gIHRoaXMuY2xvc2VFeHRyYSgpO1xuICB2YXIgdG9wID0gdGhpcy50b3A7XG4gIHRvcC5hcHBseVBlbmRpbmcodHlwZSk7XG4gIHRvcC5tYXRjaCA9IHRvcC5tYXRjaCAmJiB0b3AubWF0Y2gubWF0Y2hUeXBlKHR5cGUsIGF0dHJzKTtcbiAgdmFyIG9wdGlvbnMgPSBwcmVzZXJ2ZVdTID09IG51bGwgPyB0b3Aub3B0aW9ucyAmIH5PUFRfT1BFTl9MRUZUIDogd3NPcHRpb25zRm9yKHByZXNlcnZlV1MpO1xuICBpZiAoKHRvcC5vcHRpb25zICYgT1BUX09QRU5fTEVGVCkgJiYgdG9wLmNvbnRlbnQubGVuZ3RoID09IDApIHsgb3B0aW9ucyB8PSBPUFRfT1BFTl9MRUZUOyB9XG4gIHRoaXMubm9kZXMucHVzaChuZXcgTm9kZUNvbnRleHQodHlwZSwgYXR0cnMsIHRvcC5hY3RpdmVNYXJrcywgdG9wLnBlbmRpbmdNYXJrcywgc29saWQsIG51bGwsIG9wdGlvbnMpKTtcbiAgdGhpcy5vcGVuKys7XG59O1xuXG4vLyBNYWtlIHN1cmUgYWxsIG5vZGVzIGFib3ZlIHRoaXMub3BlbiBhcmUgZmluaXNoZWQgYW5kIGFkZGVkIHRvXG4vLyB0aGVpciBwYXJlbnRzXG5QYXJzZUNvbnRleHQucHJvdG90eXBlLmNsb3NlRXh0cmEgPSBmdW5jdGlvbiBjbG9zZUV4dHJhIChvcGVuRW5kKSB7XG4gIHZhciBpID0gdGhpcy5ub2Rlcy5sZW5ndGggLSAxO1xuICBpZiAoaSA+IHRoaXMub3Blbikge1xuICAgIGZvciAoOyBpID4gdGhpcy5vcGVuOyBpLS0pIHsgdGhpcy5ub2Rlc1tpIC0gMV0uY29udGVudC5wdXNoKHRoaXMubm9kZXNbaV0uZmluaXNoKG9wZW5FbmQpKTsgfVxuICAgIHRoaXMubm9kZXMubGVuZ3RoID0gdGhpcy5vcGVuICsgMTtcbiAgfVxufTtcblxuUGFyc2VDb250ZXh0LnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbiBmaW5pc2ggKCkge1xuICB0aGlzLm9wZW4gPSAwO1xuICB0aGlzLmNsb3NlRXh0cmEodGhpcy5pc09wZW4pO1xuICByZXR1cm4gdGhpcy5ub2Rlc1swXS5maW5pc2godGhpcy5pc09wZW4gfHwgdGhpcy5vcHRpb25zLnRvcE9wZW4pXG59O1xuXG5QYXJzZUNvbnRleHQucHJvdG90eXBlLnN5bmMgPSBmdW5jdGlvbiBzeW5jICh0bykge1xuICBmb3IgKHZhciBpID0gdGhpcy5vcGVuOyBpID49IDA7IGktLSkgeyBpZiAodGhpcy5ub2Rlc1tpXSA9PSB0bykge1xuICAgIHRoaXMub3BlbiA9IGk7XG4gICAgcmV0dXJuXG4gIH0gfVxufTtcblxucHJvdG90eXBlQWNjZXNzb3JzJDYuY3VycmVudFBvcy5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuY2xvc2VFeHRyYSgpO1xuICB2YXIgcG9zID0gMDtcbiAgZm9yICh2YXIgaSA9IHRoaXMub3BlbjsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgY29udGVudCA9IHRoaXMubm9kZXNbaV0uY29udGVudDtcbiAgICBmb3IgKHZhciBqID0gY29udGVudC5sZW5ndGggLSAxOyBqID49IDA7IGotLSlcbiAgICAgIHsgcG9zICs9IGNvbnRlbnRbal0ubm9kZVNpemU7IH1cbiAgICBpZiAoaSkgeyBwb3MrKzsgfVxuICB9XG4gIHJldHVybiBwb3Ncbn07XG5cblBhcnNlQ29udGV4dC5wcm90b3R5cGUuZmluZEF0UG9pbnQgPSBmdW5jdGlvbiBmaW5kQXRQb2ludCAocGFyZW50LCBvZmZzZXQpIHtcbiAgaWYgKHRoaXMuZmluZCkgeyBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZmluZC5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0aGlzLmZpbmRbaV0ubm9kZSA9PSBwYXJlbnQgJiYgdGhpcy5maW5kW2ldLm9mZnNldCA9PSBvZmZzZXQpXG4gICAgICB7IHRoaXMuZmluZFtpXS5wb3MgPSB0aGlzLmN1cnJlbnRQb3M7IH1cbiAgfSB9XG59O1xuXG5QYXJzZUNvbnRleHQucHJvdG90eXBlLmZpbmRJbnNpZGUgPSBmdW5jdGlvbiBmaW5kSW5zaWRlIChwYXJlbnQpIHtcbiAgaWYgKHRoaXMuZmluZCkgeyBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZmluZC5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0aGlzLmZpbmRbaV0ucG9zID09IG51bGwgJiYgcGFyZW50Lm5vZGVUeXBlID09IDEgJiYgcGFyZW50LmNvbnRhaW5zKHRoaXMuZmluZFtpXS5ub2RlKSlcbiAgICAgIHsgdGhpcy5maW5kW2ldLnBvcyA9IHRoaXMuY3VycmVudFBvczsgfVxuICB9IH1cbn07XG5cblBhcnNlQ29udGV4dC5wcm90b3R5cGUuZmluZEFyb3VuZCA9IGZ1bmN0aW9uIGZpbmRBcm91bmQgKHBhcmVudCwgY29udGVudCwgYmVmb3JlKSB7XG4gIGlmIChwYXJlbnQgIT0gY29udGVudCAmJiB0aGlzLmZpbmQpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmZpbmQubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodGhpcy5maW5kW2ldLnBvcyA9PSBudWxsICYmIHBhcmVudC5ub2RlVHlwZSA9PSAxICYmIHBhcmVudC5jb250YWlucyh0aGlzLmZpbmRbaV0ubm9kZSkpIHtcbiAgICAgIHZhciBwb3MgPSBjb250ZW50LmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKHRoaXMuZmluZFtpXS5ub2RlKTtcbiAgICAgIGlmIChwb3MgJiAoYmVmb3JlID8gMiA6IDQpKVxuICAgICAgICB7IHRoaXMuZmluZFtpXS5wb3MgPSB0aGlzLmN1cnJlbnRQb3M7IH1cbiAgICB9XG4gIH0gfVxufTtcblxuUGFyc2VDb250ZXh0LnByb3RvdHlwZS5maW5kSW5UZXh0ID0gZnVuY3Rpb24gZmluZEluVGV4dCAodGV4dE5vZGUpIHtcbiAgaWYgKHRoaXMuZmluZCkgeyBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZmluZC5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0aGlzLmZpbmRbaV0ubm9kZSA9PSB0ZXh0Tm9kZSlcbiAgICAgIHsgdGhpcy5maW5kW2ldLnBvcyA9IHRoaXMuY3VycmVudFBvcyAtICh0ZXh0Tm9kZS5ub2RlVmFsdWUubGVuZ3RoIC0gdGhpcy5maW5kW2ldLm9mZnNldCk7IH1cbiAgfSB9XG59O1xuXG4vLyA6IChzdHJpbmcpIOKGkiBib29sXG4vLyBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGdpdmVuIFtjb250ZXh0XG4vLyBzdHJpbmddKCNQYXJzZVJ1bGUuY29udGV4dCkgbWF0Y2hlcyB0aGlzIGNvbnRleHQuXG5QYXJzZUNvbnRleHQucHJvdG90eXBlLm1hdGNoZXNDb250ZXh0ID0gZnVuY3Rpb24gbWF0Y2hlc0NvbnRleHQgKGNvbnRleHQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAoY29udGV4dC5pbmRleE9mKFwifFwiKSA+IC0xKVxuICAgIHsgcmV0dXJuIGNvbnRleHQuc3BsaXQoL1xccypcXHxcXHMqLykuc29tZSh0aGlzLm1hdGNoZXNDb250ZXh0LCB0aGlzKSB9XG5cbiAgdmFyIHBhcnRzID0gY29udGV4dC5zcGxpdChcIi9cIik7XG4gIHZhciBvcHRpb24gPSB0aGlzLm9wdGlvbnMuY29udGV4dDtcbiAgdmFyIHVzZVJvb3QgPSAhdGhpcy5pc09wZW4gJiYgKCFvcHRpb24gfHwgb3B0aW9uLnBhcmVudC50eXBlID09IHRoaXMubm9kZXNbMF0udHlwZSk7XG4gIHZhciBtaW5EZXB0aCA9IC0ob3B0aW9uID8gb3B0aW9uLmRlcHRoICsgMSA6IDApICsgKHVzZVJvb3QgPyAwIDogMSk7XG4gIHZhciBtYXRjaCA9IGZ1bmN0aW9uIChpLCBkZXB0aCkge1xuICAgIGZvciAoOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIHBhcnQgPSBwYXJ0c1tpXTtcbiAgICAgIGlmIChwYXJ0ID09IFwiXCIpIHtcbiAgICAgICAgaWYgKGkgPT0gcGFydHMubGVuZ3RoIC0gMSB8fCBpID09IDApIHsgY29udGludWUgfVxuICAgICAgICBmb3IgKDsgZGVwdGggPj0gbWluRGVwdGg7IGRlcHRoLS0pXG4gICAgICAgICAgeyBpZiAobWF0Y2goaSAtIDEsIGRlcHRoKSkgeyByZXR1cm4gdHJ1ZSB9IH1cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbmV4dCA9IGRlcHRoID4gMCB8fCAoZGVwdGggPT0gMCAmJiB1c2VSb290KSA/IHRoaXMkMS5ub2Rlc1tkZXB0aF0udHlwZVxuICAgICAgICAgICAgOiBvcHRpb24gJiYgZGVwdGggPj0gbWluRGVwdGggPyBvcHRpb24ubm9kZShkZXB0aCAtIG1pbkRlcHRoKS50eXBlXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIGlmICghbmV4dCB8fCAobmV4dC5uYW1lICE9IHBhcnQgJiYgbmV4dC5ncm91cHMuaW5kZXhPZihwYXJ0KSA9PSAtMSkpXG4gICAgICAgICAgeyByZXR1cm4gZmFsc2UgfVxuICAgICAgICBkZXB0aC0tO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9O1xuICByZXR1cm4gbWF0Y2gocGFydHMubGVuZ3RoIC0gMSwgdGhpcy5vcGVuKVxufTtcblxuUGFyc2VDb250ZXh0LnByb3RvdHlwZS50ZXh0YmxvY2tGcm9tQ29udGV4dCA9IGZ1bmN0aW9uIHRleHRibG9ja0Zyb21Db250ZXh0ICgpIHtcbiAgdmFyICRjb250ZXh0ID0gdGhpcy5vcHRpb25zLmNvbnRleHQ7XG4gIGlmICgkY29udGV4dCkgeyBmb3IgKHZhciBkID0gJGNvbnRleHQuZGVwdGg7IGQgPj0gMDsgZC0tKSB7XG4gICAgdmFyIGRlZmx0ID0gJGNvbnRleHQubm9kZShkKS5jb250ZW50TWF0Y2hBdCgkY29udGV4dC5pbmRleEFmdGVyKGQpKS5kZWZhdWx0VHlwZTtcbiAgICBpZiAoZGVmbHQgJiYgZGVmbHQuaXNUZXh0YmxvY2sgJiYgZGVmbHQuZGVmYXVsdEF0dHJzKSB7IHJldHVybiBkZWZsdCB9XG4gIH0gfVxuICBmb3IgKHZhciBuYW1lIGluIHRoaXMucGFyc2VyLnNjaGVtYS5ub2Rlcykge1xuICAgIHZhciB0eXBlID0gdGhpcy5wYXJzZXIuc2NoZW1hLm5vZGVzW25hbWVdO1xuICAgIGlmICh0eXBlLmlzVGV4dGJsb2NrICYmIHR5cGUuZGVmYXVsdEF0dHJzKSB7IHJldHVybiB0eXBlIH1cbiAgfVxufTtcblxuUGFyc2VDb250ZXh0LnByb3RvdHlwZS5hZGRQZW5kaW5nTWFyayA9IGZ1bmN0aW9uIGFkZFBlbmRpbmdNYXJrIChtYXJrKSB7XG4gIHZhciBmb3VuZCA9IGZpbmRTYW1lTWFya0luU2V0KG1hcmssIHRoaXMudG9wLnBlbmRpbmdNYXJrcyk7XG4gIGlmIChmb3VuZCkgeyB0aGlzLnRvcC5zdGFzaE1hcmtzLnB1c2goZm91bmQpOyB9XG4gIHRoaXMudG9wLnBlbmRpbmdNYXJrcyA9IG1hcmsuYWRkVG9TZXQodGhpcy50b3AucGVuZGluZ01hcmtzKTtcbn07XG5cblBhcnNlQ29udGV4dC5wcm90b3R5cGUucmVtb3ZlUGVuZGluZ01hcmsgPSBmdW5jdGlvbiByZW1vdmVQZW5kaW5nTWFyayAobWFyaywgdXB0bykge1xuICBmb3IgKHZhciBkZXB0aCA9IHRoaXMub3BlbjsgZGVwdGggPj0gMDsgZGVwdGgtLSkge1xuICAgIHZhciBsZXZlbCA9IHRoaXMubm9kZXNbZGVwdGhdO1xuICAgIHZhciBmb3VuZCA9IGxldmVsLnBlbmRpbmdNYXJrcy5sYXN0SW5kZXhPZihtYXJrKTtcbiAgICBpZiAoZm91bmQgPiAtMSkge1xuICAgICAgbGV2ZWwucGVuZGluZ01hcmtzID0gbWFyay5yZW1vdmVGcm9tU2V0KGxldmVsLnBlbmRpbmdNYXJrcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldmVsLmFjdGl2ZU1hcmtzID0gbWFyay5yZW1vdmVGcm9tU2V0KGxldmVsLmFjdGl2ZU1hcmtzKTtcbiAgICAgIHZhciBzdGFzaE1hcmsgPSBsZXZlbC5wb3BGcm9tU3Rhc2hNYXJrKG1hcmspO1xuICAgICAgaWYgKHN0YXNoTWFyayAmJiBsZXZlbC50eXBlICYmIGxldmVsLnR5cGUuYWxsb3dzTWFya1R5cGUoc3Rhc2hNYXJrLnR5cGUpKVxuICAgICAgICB7IGxldmVsLmFjdGl2ZU1hcmtzID0gc3Rhc2hNYXJrLmFkZFRvU2V0KGxldmVsLmFjdGl2ZU1hcmtzKTsgfVxuICAgIH1cbiAgICBpZiAobGV2ZWwgPT0gdXB0bykgeyBicmVhayB9XG4gIH1cbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBQYXJzZUNvbnRleHQucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMkNiApO1xuXG4vLyBLbHVkZ2UgdG8gd29yayBhcm91bmQgZGlyZWN0bHkgbmVzdGVkIGxpc3Qgbm9kZXMgcHJvZHVjZWQgYnkgc29tZVxuLy8gdG9vbHMgYW5kIGFsbG93ZWQgYnkgYnJvd3NlcnMgdG8gbWVhbiB0aGF0IHRoZSBuZXN0ZWQgbGlzdCBpc1xuLy8gYWN0dWFsbHkgcGFydCBvZiB0aGUgbGlzdCBpdGVtIGFib3ZlIGl0LlxuZnVuY3Rpb24gbm9ybWFsaXplTGlzdChkb20pIHtcbiAgZm9yICh2YXIgY2hpbGQgPSBkb20uZmlyc3RDaGlsZCwgcHJldkl0ZW0gPSBudWxsOyBjaGlsZDsgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZykge1xuICAgIHZhciBuYW1lID0gY2hpbGQubm9kZVR5cGUgPT0gMSA/IGNoaWxkLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgOiBudWxsO1xuICAgIGlmIChuYW1lICYmIGxpc3RUYWdzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHByZXZJdGVtKSB7XG4gICAgICBwcmV2SXRlbS5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICBjaGlsZCA9IHByZXZJdGVtO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PSBcImxpXCIpIHtcbiAgICAgIHByZXZJdGVtID0gY2hpbGQ7XG4gICAgfSBlbHNlIGlmIChuYW1lKSB7XG4gICAgICBwcmV2SXRlbSA9IG51bGw7XG4gICAgfVxuICB9XG59XG5cbi8vIEFwcGx5IGEgQ1NTIHNlbGVjdG9yLlxuZnVuY3Rpb24gbWF0Y2hlcyhkb20sIHNlbGVjdG9yKSB7XG4gIHJldHVybiAoZG9tLm1hdGNoZXMgfHwgZG9tLm1zTWF0Y2hlc1NlbGVjdG9yIHx8IGRvbS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHwgZG9tLm1vek1hdGNoZXNTZWxlY3RvcikuY2FsbChkb20sIHNlbGVjdG9yKVxufVxuXG4vLyA6IChzdHJpbmcpIOKGkiBbc3RyaW5nXVxuLy8gVG9rZW5pemUgYSBzdHlsZSBhdHRyaWJ1dGUgaW50byBwcm9wZXJ0eS92YWx1ZSBwYWlycy5cbmZ1bmN0aW9uIHBhcnNlU3R5bGVzKHN0eWxlKSB7XG4gIHZhciByZSA9IC9cXHMqKFtcXHctXSspXFxzKjpcXHMqKFteO10rKS9nLCBtLCByZXN1bHQgPSBbXTtcbiAgd2hpbGUgKG0gPSByZS5leGVjKHN0eWxlKSkgeyByZXN1bHQucHVzaChtWzFdLCBtWzJdLnRyaW0oKSk7IH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiBjb3B5KG9iaikge1xuICB2YXIgY29weSA9IHt9O1xuICBmb3IgKHZhciBwcm9wIGluIG9iaikgeyBjb3B5W3Byb3BdID0gb2JqW3Byb3BdOyB9XG4gIHJldHVybiBjb3B5XG59XG5cbi8vIFVzZWQgd2hlbiBmaW5kaW5nIGEgbWFyayBhdCB0aGUgdG9wIGxldmVsIG9mIGEgZnJhZ21lbnQgcGFyc2UuXG4vLyBDaGVja3Mgd2hldGhlciBpdCB3b3VsZCBiZSByZWFzb25hYmxlIHRvIGFwcGx5IGEgZ2l2ZW4gbWFyayB0eXBlIHRvXG4vLyBhIGdpdmVuIG5vZGUsIGJ5IGxvb2tpbmcgYXQgdGhlIHdheSB0aGUgbWFyayBvY2N1cnMgaW4gdGhlIHNjaGVtYS5cbmZ1bmN0aW9uIG1hcmtNYXlBcHBseShtYXJrVHlwZSwgbm9kZVR5cGUpIHtcbiAgdmFyIG5vZGVzID0gbm9kZVR5cGUuc2NoZW1hLm5vZGVzO1xuICB2YXIgbG9vcCA9IGZ1bmN0aW9uICggbmFtZSApIHtcbiAgICB2YXIgcGFyZW50ID0gbm9kZXNbbmFtZV07XG4gICAgaWYgKCFwYXJlbnQuYWxsb3dzTWFya1R5cGUobWFya1R5cGUpKSB7IHJldHVybiB9XG4gICAgdmFyIHNlZW4gPSBbXSwgc2NhbiA9IGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgc2Vlbi5wdXNoKG1hdGNoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF0Y2guZWRnZUNvdW50OyBpKyspIHtcbiAgICAgICAgdmFyIHJlZiA9IG1hdGNoLmVkZ2UoaSk7XG4gICAgICAgIHZhciB0eXBlID0gcmVmLnR5cGU7XG4gICAgICAgIHZhciBuZXh0ID0gcmVmLm5leHQ7XG4gICAgICAgIGlmICh0eXBlID09IG5vZGVUeXBlKSB7IHJldHVybiB0cnVlIH1cbiAgICAgICAgaWYgKHNlZW4uaW5kZXhPZihuZXh0KSA8IDAgJiYgc2NhbihuZXh0KSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoc2NhbihwYXJlbnQuY29udGVudE1hdGNoKSkgeyByZXR1cm4geyB2OiB0cnVlIH0gfVxuICB9O1xuXG4gIGZvciAodmFyIG5hbWUgaW4gbm9kZXMpIHtcbiAgICB2YXIgcmV0dXJuZWQgPSBsb29wKCBuYW1lICk7XG5cbiAgICBpZiAoIHJldHVybmVkICkgcmV0dXJuIHJldHVybmVkLnY7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZFNhbWVNYXJrSW5TZXQobWFyaywgc2V0KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG1hcmsuZXEoc2V0W2ldKSkgeyByZXR1cm4gc2V0W2ldIH1cbiAgfVxufVxuXG4vLyBET01PdXRwdXRTcGVjOjogaW50ZXJmYWNlXG4vLyBBIGRlc2NyaXB0aW9uIG9mIGEgRE9NIHN0cnVjdHVyZS4gQ2FuIGJlIGVpdGhlciBhIHN0cmluZywgd2hpY2ggaXNcbi8vIGludGVycHJldGVkIGFzIGEgdGV4dCBub2RlLCBhIERPTSBub2RlLCB3aGljaCBpcyBpbnRlcnByZXRlZCBhc1xuLy8gaXRzZWxmLCBhIGB7ZG9tOiBOb2RlLCBjb250ZW50RE9NOiA/Tm9kZX1gIG9iamVjdCwgb3IgYW4gYXJyYXkuXG4vL1xuLy8gQW4gYXJyYXkgZGVzY3JpYmVzIGEgRE9NIGVsZW1lbnQuIFRoZSBmaXJzdCB2YWx1ZSBpbiB0aGUgYXJyYXlcbi8vIHNob3VsZCBiZSBhIHN0cmluZ+KAlHRoZSBuYW1lIG9mIHRoZSBET00gZWxlbWVudCwgb3B0aW9uYWxseSBwcmVmaXhlZFxuLy8gYnkgYSBuYW1lc3BhY2UgVVJMIGFuZCBhIHNwYWNlLiBJZiB0aGUgc2Vjb25kIGVsZW1lbnQgaXMgcGxhaW5cbi8vIG9iamVjdCwgaXQgaXMgaW50ZXJwcmV0ZWQgYXMgYSBzZXQgb2YgYXR0cmlidXRlcyBmb3IgdGhlIGVsZW1lbnQuXG4vLyBBbnkgZWxlbWVudHMgYWZ0ZXIgdGhhdCAoaW5jbHVkaW5nIHRoZSAybmQgaWYgaXQncyBub3QgYW4gYXR0cmlidXRlXG4vLyBvYmplY3QpIGFyZSBpbnRlcnByZXRlZCBhcyBjaGlsZHJlbiBvZiB0aGUgRE9NIGVsZW1lbnRzLCBhbmQgbXVzdFxuLy8gZWl0aGVyIGJlIHZhbGlkIGBET01PdXRwdXRTcGVjYCB2YWx1ZXMsIG9yIHRoZSBudW1iZXIgemVyby5cbi8vXG4vLyBUaGUgbnVtYmVyIHplcm8gKHByb25vdW5jZWQg4oCcaG9sZeKAnSkgaXMgdXNlZCB0byBpbmRpY2F0ZSB0aGUgcGxhY2Vcbi8vIHdoZXJlIGEgbm9kZSdzIGNoaWxkIG5vZGVzIHNob3VsZCBiZSBpbnNlcnRlZC4gSWYgaXQgb2NjdXJzIGluIGFuXG4vLyBvdXRwdXQgc3BlYywgaXQgc2hvdWxkIGJlIHRoZSBvbmx5IGNoaWxkIGVsZW1lbnQgaW4gaXRzIHBhcmVudFxuLy8gbm9kZS5cblxuLy8gOjotIEEgRE9NIHNlcmlhbGl6ZXIga25vd3MgaG93IHRvIGNvbnZlcnQgUHJvc2VNaXJyb3Igbm9kZXMgYW5kXG4vLyBtYXJrcyBvZiB2YXJpb3VzIHR5cGVzIHRvIERPTSBub2Rlcy5cbnZhciBET01TZXJpYWxpemVyID0gZnVuY3Rpb24gRE9NU2VyaWFsaXplcihub2RlcywgbWFya3MpIHtcbiAgLy8gOjogT2JqZWN0PChub2RlOiBOb2RlKSDihpIgRE9NT3V0cHV0U3BlYz5cbiAgLy8gVGhlIG5vZGUgc2VyaWFsaXphdGlvbiBmdW5jdGlvbnMuXG4gIHRoaXMubm9kZXMgPSBub2RlcyB8fCB7fTtcbiAgLy8gOjogT2JqZWN0PD8obWFyazogTWFyaywgaW5saW5lOiBib29sKSDihpIgRE9NT3V0cHV0U3BlYz5cbiAgLy8gVGhlIG1hcmsgc2VyaWFsaXphdGlvbiBmdW5jdGlvbnMuXG4gIHRoaXMubWFya3MgPSBtYXJrcyB8fCB7fTtcbn07XG5cbi8vIDo6IChGcmFnbWVudCwgP09iamVjdCkg4oaSIGRvbS5Eb2N1bWVudEZyYWdtZW50XG4vLyBTZXJpYWxpemUgdGhlIGNvbnRlbnQgb2YgdGhpcyBmcmFnbWVudCB0byBhIERPTSBmcmFnbWVudC4gV2hlblxuLy8gbm90IGluIHRoZSBicm93c2VyLCB0aGUgYGRvY3VtZW50YCBvcHRpb24sIGNvbnRhaW5pbmcgYSBET01cbi8vIGRvY3VtZW50LCBzaG91bGQgYmUgcGFzc2VkIHNvIHRoYXQgdGhlIHNlcmlhbGl6ZXIgY2FuIGNyZWF0ZVxuLy8gbm9kZXMuXG5ET01TZXJpYWxpemVyLnByb3RvdHlwZS5zZXJpYWxpemVGcmFnbWVudCA9IGZ1bmN0aW9uIHNlcmlhbGl6ZUZyYWdtZW50IChmcmFnbWVudCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG4gICAgaWYgKCBvcHRpb25zID09PSB2b2lkIDAgKSBvcHRpb25zID0ge307XG5cbiAgaWYgKCF0YXJnZXQpIHsgdGFyZ2V0ID0gZG9jKG9wdGlvbnMpLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTsgfVxuXG4gIHZhciB0b3AgPSB0YXJnZXQsIGFjdGl2ZSA9IG51bGw7XG4gIGZyYWdtZW50LmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBpZiAoYWN0aXZlIHx8IG5vZGUubWFya3MubGVuZ3RoKSB7XG4gICAgICBpZiAoIWFjdGl2ZSkgeyBhY3RpdmUgPSBbXTsgfVxuICAgICAgdmFyIGtlZXAgPSAwLCByZW5kZXJlZCA9IDA7XG4gICAgICB3aGlsZSAoa2VlcCA8IGFjdGl2ZS5sZW5ndGggJiYgcmVuZGVyZWQgPCBub2RlLm1hcmtzLmxlbmd0aCkge1xuICAgICAgICB2YXIgbmV4dCA9IG5vZGUubWFya3NbcmVuZGVyZWRdO1xuICAgICAgICBpZiAoIXRoaXMkMS5tYXJrc1tuZXh0LnR5cGUubmFtZV0pIHsgcmVuZGVyZWQrKzsgY29udGludWUgfVxuICAgICAgICBpZiAoIW5leHQuZXEoYWN0aXZlW2tlZXBdKSB8fCBuZXh0LnR5cGUuc3BlYy5zcGFubmluZyA9PT0gZmFsc2UpIHsgYnJlYWsgfVxuICAgICAgICBrZWVwICs9IDI7IHJlbmRlcmVkKys7XG4gICAgICB9XG4gICAgICB3aGlsZSAoa2VlcCA8IGFjdGl2ZS5sZW5ndGgpIHtcbiAgICAgICAgdG9wID0gYWN0aXZlLnBvcCgpO1xuICAgICAgICBhY3RpdmUucG9wKCk7XG4gICAgICB9XG4gICAgICB3aGlsZSAocmVuZGVyZWQgPCBub2RlLm1hcmtzLmxlbmd0aCkge1xuICAgICAgICB2YXIgYWRkID0gbm9kZS5tYXJrc1tyZW5kZXJlZCsrXTtcbiAgICAgICAgdmFyIG1hcmtET00gPSB0aGlzJDEuc2VyaWFsaXplTWFyayhhZGQsIG5vZGUuaXNJbmxpbmUsIG9wdGlvbnMpO1xuICAgICAgICBpZiAobWFya0RPTSkge1xuICAgICAgICAgIGFjdGl2ZS5wdXNoKGFkZCwgdG9wKTtcbiAgICAgICAgICB0b3AuYXBwZW5kQ2hpbGQobWFya0RPTS5kb20pO1xuICAgICAgICAgIHRvcCA9IG1hcmtET00uY29udGVudERPTSB8fCBtYXJrRE9NLmRvbTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0b3AuYXBwZW5kQ2hpbGQodGhpcyQxLnNlcmlhbGl6ZU5vZGVJbm5lcihub2RlLCBvcHRpb25zKSk7XG4gIH0pO1xuXG4gIHJldHVybiB0YXJnZXRcbn07XG5cbkRPTVNlcmlhbGl6ZXIucHJvdG90eXBlLnNlcmlhbGl6ZU5vZGVJbm5lciA9IGZ1bmN0aW9uIHNlcmlhbGl6ZU5vZGVJbm5lciAobm9kZSwgb3B0aW9ucykge1xuICAgIGlmICggb3B0aW9ucyA9PT0gdm9pZCAwICkgb3B0aW9ucyA9IHt9O1xuXG4gIHZhciByZWYgPVxuICAgICAgRE9NU2VyaWFsaXplci5yZW5kZXJTcGVjKGRvYyhvcHRpb25zKSwgdGhpcy5ub2Rlc1tub2RlLnR5cGUubmFtZV0obm9kZSkpO1xuICAgIHZhciBkb20gPSByZWYuZG9tO1xuICAgIHZhciBjb250ZW50RE9NID0gcmVmLmNvbnRlbnRET007XG4gIGlmIChjb250ZW50RE9NKSB7XG4gICAgaWYgKG5vZGUuaXNMZWFmKVxuICAgICAgeyB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkNvbnRlbnQgaG9sZSBub3QgYWxsb3dlZCBpbiBhIGxlYWYgbm9kZSBzcGVjXCIpIH1cbiAgICBpZiAob3B0aW9ucy5vbkNvbnRlbnQpXG4gICAgICB7IG9wdGlvbnMub25Db250ZW50KG5vZGUsIGNvbnRlbnRET00sIG9wdGlvbnMpOyB9XG4gICAgZWxzZVxuICAgICAgeyB0aGlzLnNlcmlhbGl6ZUZyYWdtZW50KG5vZGUuY29udGVudCwgb3B0aW9ucywgY29udGVudERPTSk7IH1cbiAgfVxuICByZXR1cm4gZG9tXG59O1xuXG4vLyA6OiAoTm9kZSwgP09iamVjdCkg4oaSIGRvbS5Ob2RlXG4vLyBTZXJpYWxpemUgdGhpcyBub2RlIHRvIGEgRE9NIG5vZGUuIFRoaXMgY2FuIGJlIHVzZWZ1bCB3aGVuIHlvdVxuLy8gbmVlZCB0byBzZXJpYWxpemUgYSBwYXJ0IG9mIGEgZG9jdW1lbnQsIGFzIG9wcG9zZWQgdG8gdGhlIHdob2xlXG4vLyBkb2N1bWVudC4gVG8gc2VyaWFsaXplIGEgd2hvbGUgZG9jdW1lbnQsIHVzZVxuLy8gW2BzZXJpYWxpemVGcmFnbWVudGBdKCNtb2RlbC5ET01TZXJpYWxpemVyLnNlcmlhbGl6ZUZyYWdtZW50KSBvblxuLy8gaXRzIFtjb250ZW50XSgjbW9kZWwuTm9kZS5jb250ZW50KS5cbkRPTVNlcmlhbGl6ZXIucHJvdG90eXBlLnNlcmlhbGl6ZU5vZGUgPSBmdW5jdGlvbiBzZXJpYWxpemVOb2RlIChub2RlLCBvcHRpb25zKSB7XG4gICAgaWYgKCBvcHRpb25zID09PSB2b2lkIDAgKSBvcHRpb25zID0ge307XG5cbiAgdmFyIGRvbSA9IHRoaXMuc2VyaWFsaXplTm9kZUlubmVyKG5vZGUsIG9wdGlvbnMpO1xuICBmb3IgKHZhciBpID0gbm9kZS5tYXJrcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciB3cmFwID0gdGhpcy5zZXJpYWxpemVNYXJrKG5vZGUubWFya3NbaV0sIG5vZGUuaXNJbmxpbmUsIG9wdGlvbnMpO1xuICAgIGlmICh3cmFwKSB7XG4od3JhcC5jb250ZW50RE9NIHx8IHdyYXAuZG9tKS5hcHBlbmRDaGlsZChkb20pO1xuICAgICAgZG9tID0gd3JhcC5kb207XG4gICAgfVxuICB9XG4gIHJldHVybiBkb21cbn07XG5cbkRPTVNlcmlhbGl6ZXIucHJvdG90eXBlLnNlcmlhbGl6ZU1hcmsgPSBmdW5jdGlvbiBzZXJpYWxpemVNYXJrIChtYXJrLCBpbmxpbmUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxuICB2YXIgdG9ET00gPSB0aGlzLm1hcmtzW21hcmsudHlwZS5uYW1lXTtcbiAgcmV0dXJuIHRvRE9NICYmIERPTVNlcmlhbGl6ZXIucmVuZGVyU3BlYyhkb2Mob3B0aW9ucyksIHRvRE9NKG1hcmssIGlubGluZSkpXG59O1xuXG4vLyA6OiAoZG9tLkRvY3VtZW50LCBET01PdXRwdXRTcGVjKSDihpIge2RvbTogZG9tLk5vZGUsIGNvbnRlbnRET006ID9kb20uTm9kZX1cbi8vIFJlbmRlciBhbiBbb3V0cHV0IHNwZWNdKCNtb2RlbC5ET01PdXRwdXRTcGVjKSB0byBhIERPTSBub2RlLiBJZlxuLy8gdGhlIHNwZWMgaGFzIGEgaG9sZSAoemVybykgaW4gaXQsIGBjb250ZW50RE9NYCB3aWxsIHBvaW50IGF0IHRoZVxuLy8gbm9kZSB3aXRoIHRoZSBob2xlLlxuRE9NU2VyaWFsaXplci5yZW5kZXJTcGVjID0gZnVuY3Rpb24gcmVuZGVyU3BlYyAoZG9jLCBzdHJ1Y3R1cmUsIHhtbE5TKSB7XG4gICAgaWYgKCB4bWxOUyA9PT0gdm9pZCAwICkgeG1sTlMgPSBudWxsO1xuXG4gIGlmICh0eXBlb2Ygc3RydWN0dXJlID09IFwic3RyaW5nXCIpXG4gICAgeyByZXR1cm4ge2RvbTogZG9jLmNyZWF0ZVRleHROb2RlKHN0cnVjdHVyZSl9IH1cbiAgaWYgKHN0cnVjdHVyZS5ub2RlVHlwZSAhPSBudWxsKVxuICAgIHsgcmV0dXJuIHtkb206IHN0cnVjdHVyZX0gfVxuICBpZiAoc3RydWN0dXJlLmRvbSAmJiBzdHJ1Y3R1cmUuZG9tLm5vZGVUeXBlICE9IG51bGwpXG4gICAgeyByZXR1cm4gc3RydWN0dXJlIH1cbiAgdmFyIHRhZ05hbWUgPSBzdHJ1Y3R1cmVbMF0sIHNwYWNlID0gdGFnTmFtZS5pbmRleE9mKFwiIFwiKTtcbiAgaWYgKHNwYWNlID4gMCkge1xuICAgIHhtbE5TID0gdGFnTmFtZS5zbGljZSgwLCBzcGFjZSk7XG4gICAgdGFnTmFtZSA9IHRhZ05hbWUuc2xpY2Uoc3BhY2UgKyAxKTtcbiAgfVxuICB2YXIgY29udGVudERPTSA9IG51bGwsIGRvbSA9IHhtbE5TID8gZG9jLmNyZWF0ZUVsZW1lbnROUyh4bWxOUywgdGFnTmFtZSkgOiBkb2MuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgdmFyIGF0dHJzID0gc3RydWN0dXJlWzFdLCBzdGFydCA9IDE7XG4gIGlmIChhdHRycyAmJiB0eXBlb2YgYXR0cnMgPT0gXCJvYmplY3RcIiAmJiBhdHRycy5ub2RlVHlwZSA9PSBudWxsICYmICFBcnJheS5pc0FycmF5KGF0dHJzKSkge1xuICAgIHN0YXJ0ID0gMjtcbiAgICBmb3IgKHZhciBuYW1lIGluIGF0dHJzKSB7IGlmIChhdHRyc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICB2YXIgc3BhY2UkMSA9IG5hbWUuaW5kZXhPZihcIiBcIik7XG4gICAgICBpZiAoc3BhY2UkMSA+IDApIHsgZG9tLnNldEF0dHJpYnV0ZU5TKG5hbWUuc2xpY2UoMCwgc3BhY2UkMSksIG5hbWUuc2xpY2Uoc3BhY2UkMSArIDEpLCBhdHRyc1tuYW1lXSk7IH1cbiAgICAgIGVsc2UgeyBkb20uc2V0QXR0cmlidXRlKG5hbWUsIGF0dHJzW25hbWVdKTsgfVxuICAgIH0gfVxuICB9XG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IHN0cnVjdHVyZS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjaGlsZCA9IHN0cnVjdHVyZVtpXTtcbiAgICBpZiAoY2hpbGQgPT09IDApIHtcbiAgICAgIGlmIChpIDwgc3RydWN0dXJlLmxlbmd0aCAtIDEgfHwgaSA+IHN0YXJ0KVxuICAgICAgICB7IHRocm93IG5ldyBSYW5nZUVycm9yKFwiQ29udGVudCBob2xlIG11c3QgYmUgdGhlIG9ubHkgY2hpbGQgb2YgaXRzIHBhcmVudCBub2RlXCIpIH1cbiAgICAgIHJldHVybiB7ZG9tOiBkb20sIGNvbnRlbnRET006IGRvbX1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHJlZiA9IERPTVNlcmlhbGl6ZXIucmVuZGVyU3BlYyhkb2MsIGNoaWxkLCB4bWxOUyk7XG4gICAgICAgIHZhciBpbm5lciA9IHJlZi5kb207XG4gICAgICAgIHZhciBpbm5lckNvbnRlbnQgPSByZWYuY29udGVudERPTTtcbiAgICAgIGRvbS5hcHBlbmRDaGlsZChpbm5lcik7XG4gICAgICBpZiAoaW5uZXJDb250ZW50KSB7XG4gICAgICAgIGlmIChjb250ZW50RE9NKSB7IHRocm93IG5ldyBSYW5nZUVycm9yKFwiTXVsdGlwbGUgY29udGVudCBob2xlc1wiKSB9XG4gICAgICAgIGNvbnRlbnRET00gPSBpbm5lckNvbnRlbnQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB7ZG9tOiBkb20sIGNvbnRlbnRET006IGNvbnRlbnRET019XG59O1xuXG4vLyA6OiAoU2NoZW1hKSDihpIgRE9NU2VyaWFsaXplclxuLy8gQnVpbGQgYSBzZXJpYWxpemVyIHVzaW5nIHRoZSBbYHRvRE9NYF0oI21vZGVsLk5vZGVTcGVjLnRvRE9NKVxuLy8gcHJvcGVydGllcyBpbiBhIHNjaGVtYSdzIG5vZGUgYW5kIG1hcmsgc3BlY3MuXG5ET01TZXJpYWxpemVyLmZyb21TY2hlbWEgPSBmdW5jdGlvbiBmcm9tU2NoZW1hIChzY2hlbWEpIHtcbiAgcmV0dXJuIHNjaGVtYS5jYWNoZWQuZG9tU2VyaWFsaXplciB8fFxuICAgIChzY2hlbWEuY2FjaGVkLmRvbVNlcmlhbGl6ZXIgPSBuZXcgRE9NU2VyaWFsaXplcih0aGlzLm5vZGVzRnJvbVNjaGVtYShzY2hlbWEpLCB0aGlzLm1hcmtzRnJvbVNjaGVtYShzY2hlbWEpKSlcbn07XG5cbi8vIDogKFNjaGVtYSkg4oaSIE9iamVjdDwobm9kZTogTm9kZSkg4oaSIERPTU91dHB1dFNwZWM+XG4vLyBHYXRoZXIgdGhlIHNlcmlhbGl6ZXJzIGluIGEgc2NoZW1hJ3Mgbm9kZSBzcGVjcyBpbnRvIGFuIG9iamVjdC5cbi8vIFRoaXMgY2FuIGJlIHVzZWZ1bCBhcyBhIGJhc2UgdG8gYnVpbGQgYSBjdXN0b20gc2VyaWFsaXplciBmcm9tLlxuRE9NU2VyaWFsaXplci5ub2Rlc0Zyb21TY2hlbWEgPSBmdW5jdGlvbiBub2Rlc0Zyb21TY2hlbWEgKHNjaGVtYSkge1xuICB2YXIgcmVzdWx0ID0gZ2F0aGVyVG9ET00oc2NoZW1hLm5vZGVzKTtcbiAgaWYgKCFyZXN1bHQudGV4dCkgeyByZXN1bHQudGV4dCA9IGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnRleHQ7IH07IH1cbiAgcmV0dXJuIHJlc3VsdFxufTtcblxuLy8gOiAoU2NoZW1hKSDihpIgT2JqZWN0PChtYXJrOiBNYXJrKSDihpIgRE9NT3V0cHV0U3BlYz5cbi8vIEdhdGhlciB0aGUgc2VyaWFsaXplcnMgaW4gYSBzY2hlbWEncyBtYXJrIHNwZWNzIGludG8gYW4gb2JqZWN0LlxuRE9NU2VyaWFsaXplci5tYXJrc0Zyb21TY2hlbWEgPSBmdW5jdGlvbiBtYXJrc0Zyb21TY2hlbWEgKHNjaGVtYSkge1xuICByZXR1cm4gZ2F0aGVyVG9ET00oc2NoZW1hLm1hcmtzKVxufTtcblxuZnVuY3Rpb24gZ2F0aGVyVG9ET00ob2JqKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgZm9yICh2YXIgbmFtZSBpbiBvYmopIHtcbiAgICB2YXIgdG9ET00gPSBvYmpbbmFtZV0uc3BlYy50b0RPTTtcbiAgICBpZiAodG9ET00pIHsgcmVzdWx0W25hbWVdID0gdG9ET007IH1cbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIGRvYyhvcHRpb25zKSB7XG4gIC8vIGRlY2xhcmUgZ2xvYmFsOiB3aW5kb3dcbiAgcmV0dXJuIG9wdGlvbnMuZG9jdW1lbnQgfHwgd2luZG93LmRvY3VtZW50XG59XG5cbmV4cG9ydCB7IENvbnRlbnRNYXRjaCwgRE9NUGFyc2VyLCBET01TZXJpYWxpemVyLCBGcmFnbWVudCwgTWFyaywgTWFya1R5cGUsIE5vZGUsIE5vZGVSYW5nZSwgTm9kZVR5cGUsIFJlcGxhY2VFcnJvciwgUmVzb2x2ZWRQb3MsIFNjaGVtYSwgU2xpY2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzLmpzLm1hcFxuIiwiaW1wb3J0IHsgU2NoZW1hIH0gZnJvbSAncHJvc2VtaXJyb3ItbW9kZWwnO1xuXG52YXIgcERPTSA9IFtcInBcIiwgMF0sIGJsb2NrcXVvdGVET00gPSBbXCJibG9ja3F1b3RlXCIsIDBdLCBockRPTSA9IFtcImhyXCJdLFxuICAgICAgcHJlRE9NID0gW1wicHJlXCIsIFtcImNvZGVcIiwgMF1dLCBickRPTSA9IFtcImJyXCJdO1xuXG4vLyA6OiBPYmplY3Rcbi8vIFtTcGVjc10oI21vZGVsLk5vZGVTcGVjKSBmb3IgdGhlIG5vZGVzIGRlZmluZWQgaW4gdGhpcyBzY2hlbWEuXG52YXIgbm9kZXMgPSB7XG4gIC8vIDo6IE5vZGVTcGVjIFRoZSB0b3AgbGV2ZWwgZG9jdW1lbnQgbm9kZS5cbiAgZG9jOiB7XG4gICAgY29udGVudDogXCJibG9jaytcIlxuICB9LFxuXG4gIC8vIDo6IE5vZGVTcGVjIEEgcGxhaW4gcGFyYWdyYXBoIHRleHRibG9jay4gUmVwcmVzZW50ZWQgaW4gdGhlIERPTVxuICAvLyBhcyBhIGA8cD5gIGVsZW1lbnQuXG4gIHBhcmFncmFwaDoge1xuICAgIGNvbnRlbnQ6IFwiaW5saW5lKlwiLFxuICAgIGdyb3VwOiBcImJsb2NrXCIsXG4gICAgcGFyc2VET006IFt7dGFnOiBcInBcIn1dLFxuICAgIHRvRE9NOiBmdW5jdGlvbiB0b0RPTSgpIHsgcmV0dXJuIHBET00gfVxuICB9LFxuXG4gIC8vIDo6IE5vZGVTcGVjIEEgYmxvY2txdW90ZSAoYDxibG9ja3F1b3RlPmApIHdyYXBwaW5nIG9uZSBvciBtb3JlIGJsb2Nrcy5cbiAgYmxvY2txdW90ZToge1xuICAgIGNvbnRlbnQ6IFwiYmxvY2srXCIsXG4gICAgZ3JvdXA6IFwiYmxvY2tcIixcbiAgICBkZWZpbmluZzogdHJ1ZSxcbiAgICBwYXJzZURPTTogW3t0YWc6IFwiYmxvY2txdW90ZVwifV0sXG4gICAgdG9ET006IGZ1bmN0aW9uIHRvRE9NKCkgeyByZXR1cm4gYmxvY2txdW90ZURPTSB9XG4gIH0sXG5cbiAgLy8gOjogTm9kZVNwZWMgQSBob3Jpem9udGFsIHJ1bGUgKGA8aHI+YCkuXG4gIGhvcml6b250YWxfcnVsZToge1xuICAgIGdyb3VwOiBcImJsb2NrXCIsXG4gICAgcGFyc2VET006IFt7dGFnOiBcImhyXCJ9XSxcbiAgICB0b0RPTTogZnVuY3Rpb24gdG9ET00oKSB7IHJldHVybiBockRPTSB9XG4gIH0sXG5cbiAgLy8gOjogTm9kZVNwZWMgQSBoZWFkaW5nIHRleHRibG9jaywgd2l0aCBhIGBsZXZlbGAgYXR0cmlidXRlIHRoYXRcbiAgLy8gc2hvdWxkIGhvbGQgdGhlIG51bWJlciAxIHRvIDYuIFBhcnNlZCBhbmQgc2VyaWFsaXplZCBhcyBgPGgxPmAgdG9cbiAgLy8gYDxoNj5gIGVsZW1lbnRzLlxuICBoZWFkaW5nOiB7XG4gICAgYXR0cnM6IHtsZXZlbDoge2RlZmF1bHQ6IDF9fSxcbiAgICBjb250ZW50OiBcImlubGluZSpcIixcbiAgICBncm91cDogXCJibG9ja1wiLFxuICAgIGRlZmluaW5nOiB0cnVlLFxuICAgIHBhcnNlRE9NOiBbe3RhZzogXCJoMVwiLCBhdHRyczoge2xldmVsOiAxfX0sXG4gICAgICAgICAgICAgICB7dGFnOiBcImgyXCIsIGF0dHJzOiB7bGV2ZWw6IDJ9fSxcbiAgICAgICAgICAgICAgIHt0YWc6IFwiaDNcIiwgYXR0cnM6IHtsZXZlbDogM319LFxuICAgICAgICAgICAgICAge3RhZzogXCJoNFwiLCBhdHRyczoge2xldmVsOiA0fX0sXG4gICAgICAgICAgICAgICB7dGFnOiBcImg1XCIsIGF0dHJzOiB7bGV2ZWw6IDV9fSxcbiAgICAgICAgICAgICAgIHt0YWc6IFwiaDZcIiwgYXR0cnM6IHtsZXZlbDogNn19XSxcbiAgICB0b0RPTTogZnVuY3Rpb24gdG9ET00obm9kZSkgeyByZXR1cm4gW1wiaFwiICsgbm9kZS5hdHRycy5sZXZlbCwgMF0gfVxuICB9LFxuXG4gIC8vIDo6IE5vZGVTcGVjIEEgY29kZSBsaXN0aW5nLiBEaXNhbGxvd3MgbWFya3Mgb3Igbm9uLXRleHQgaW5saW5lXG4gIC8vIG5vZGVzIGJ5IGRlZmF1bHQuIFJlcHJlc2VudGVkIGFzIGEgYDxwcmU+YCBlbGVtZW50IHdpdGggYVxuICAvLyBgPGNvZGU+YCBlbGVtZW50IGluc2lkZSBvZiBpdC5cbiAgY29kZV9ibG9jazoge1xuICAgIGNvbnRlbnQ6IFwidGV4dCpcIixcbiAgICBtYXJrczogXCJcIixcbiAgICBncm91cDogXCJibG9ja1wiLFxuICAgIGNvZGU6IHRydWUsXG4gICAgZGVmaW5pbmc6IHRydWUsXG4gICAgcGFyc2VET006IFt7dGFnOiBcInByZVwiLCBwcmVzZXJ2ZVdoaXRlc3BhY2U6IFwiZnVsbFwifV0sXG4gICAgdG9ET006IGZ1bmN0aW9uIHRvRE9NKCkgeyByZXR1cm4gcHJlRE9NIH1cbiAgfSxcblxuICAvLyA6OiBOb2RlU3BlYyBUaGUgdGV4dCBub2RlLlxuICB0ZXh0OiB7XG4gICAgZ3JvdXA6IFwiaW5saW5lXCJcbiAgfSxcblxuICAvLyA6OiBOb2RlU3BlYyBBbiBpbmxpbmUgaW1hZ2UgKGA8aW1nPmApIG5vZGUuIFN1cHBvcnRzIGBzcmNgLFxuICAvLyBgYWx0YCwgYW5kIGBocmVmYCBhdHRyaWJ1dGVzLiBUaGUgbGF0dGVyIHR3byBkZWZhdWx0IHRvIHRoZSBlbXB0eVxuICAvLyBzdHJpbmcuXG4gIGltYWdlOiB7XG4gICAgaW5saW5lOiB0cnVlLFxuICAgIGF0dHJzOiB7XG4gICAgICBzcmM6IHt9LFxuICAgICAgYWx0OiB7ZGVmYXVsdDogbnVsbH0sXG4gICAgICB0aXRsZToge2RlZmF1bHQ6IG51bGx9XG4gICAgfSxcbiAgICBncm91cDogXCJpbmxpbmVcIixcbiAgICBkcmFnZ2FibGU6IHRydWUsXG4gICAgcGFyc2VET006IFt7dGFnOiBcImltZ1tzcmNdXCIsIGdldEF0dHJzOiBmdW5jdGlvbiBnZXRBdHRycyhkb20pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNyYzogZG9tLmdldEF0dHJpYnV0ZShcInNyY1wiKSxcbiAgICAgICAgdGl0bGU6IGRvbS5nZXRBdHRyaWJ1dGUoXCJ0aXRsZVwiKSxcbiAgICAgICAgYWx0OiBkb20uZ2V0QXR0cmlidXRlKFwiYWx0XCIpXG4gICAgICB9XG4gICAgfX1dLFxuICAgIHRvRE9NOiBmdW5jdGlvbiB0b0RPTShub2RlKSB7IHZhciByZWYgPSBub2RlLmF0dHJzO1xuICAgIHZhciBzcmMgPSByZWYuc3JjO1xuICAgIHZhciBhbHQgPSByZWYuYWx0O1xuICAgIHZhciB0aXRsZSA9IHJlZi50aXRsZTsgcmV0dXJuIFtcImltZ1wiLCB7c3JjOiBzcmMsIGFsdDogYWx0LCB0aXRsZTogdGl0bGV9XSB9XG4gIH0sXG5cbiAgLy8gOjogTm9kZVNwZWMgQSBoYXJkIGxpbmUgYnJlYWssIHJlcHJlc2VudGVkIGluIHRoZSBET00gYXMgYDxicj5gLlxuICBoYXJkX2JyZWFrOiB7XG4gICAgaW5saW5lOiB0cnVlLFxuICAgIGdyb3VwOiBcImlubGluZVwiLFxuICAgIHNlbGVjdGFibGU6IGZhbHNlLFxuICAgIHBhcnNlRE9NOiBbe3RhZzogXCJiclwifV0sXG4gICAgdG9ET006IGZ1bmN0aW9uIHRvRE9NKCkgeyByZXR1cm4gYnJET00gfVxuICB9XG59O1xuXG52YXIgZW1ET00gPSBbXCJlbVwiLCAwXSwgc3Ryb25nRE9NID0gW1wic3Ryb25nXCIsIDBdLCBjb2RlRE9NID0gW1wiY29kZVwiLCAwXTtcblxuLy8gOjogT2JqZWN0IFtTcGVjc10oI21vZGVsLk1hcmtTcGVjKSBmb3IgdGhlIG1hcmtzIGluIHRoZSBzY2hlbWEuXG52YXIgbWFya3MgPSB7XG4gIC8vIDo6IE1hcmtTcGVjIEEgbGluay4gSGFzIGBocmVmYCBhbmQgYHRpdGxlYCBhdHRyaWJ1dGVzLiBgdGl0bGVgXG4gIC8vIGRlZmF1bHRzIHRvIHRoZSBlbXB0eSBzdHJpbmcuIFJlbmRlcmVkIGFuZCBwYXJzZWQgYXMgYW4gYDxhPmBcbiAgLy8gZWxlbWVudC5cbiAgbGluazoge1xuICAgIGF0dHJzOiB7XG4gICAgICBocmVmOiB7fSxcbiAgICAgIHRpdGxlOiB7ZGVmYXVsdDogbnVsbH1cbiAgICB9LFxuICAgIGluY2x1c2l2ZTogZmFsc2UsXG4gICAgcGFyc2VET006IFt7dGFnOiBcImFbaHJlZl1cIiwgZ2V0QXR0cnM6IGZ1bmN0aW9uIGdldEF0dHJzKGRvbSkge1xuICAgICAgcmV0dXJuIHtocmVmOiBkb20uZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSwgdGl0bGU6IGRvbS5nZXRBdHRyaWJ1dGUoXCJ0aXRsZVwiKX1cbiAgICB9fV0sXG4gICAgdG9ET006IGZ1bmN0aW9uIHRvRE9NKG5vZGUpIHsgdmFyIHJlZiA9IG5vZGUuYXR0cnM7XG4gICAgdmFyIGhyZWYgPSByZWYuaHJlZjtcbiAgICB2YXIgdGl0bGUgPSByZWYudGl0bGU7IHJldHVybiBbXCJhXCIsIHtocmVmOiBocmVmLCB0aXRsZTogdGl0bGV9LCAwXSB9XG4gIH0sXG5cbiAgLy8gOjogTWFya1NwZWMgQW4gZW1waGFzaXMgbWFyay4gUmVuZGVyZWQgYXMgYW4gYDxlbT5gIGVsZW1lbnQuXG4gIC8vIEhhcyBwYXJzZSBydWxlcyB0aGF0IGFsc28gbWF0Y2ggYDxpPmAgYW5kIGBmb250LXN0eWxlOiBpdGFsaWNgLlxuICBlbToge1xuICAgIHBhcnNlRE9NOiBbe3RhZzogXCJpXCJ9LCB7dGFnOiBcImVtXCJ9LCB7c3R5bGU6IFwiZm9udC1zdHlsZT1pdGFsaWNcIn1dLFxuICAgIHRvRE9NOiBmdW5jdGlvbiB0b0RPTSgpIHsgcmV0dXJuIGVtRE9NIH1cbiAgfSxcblxuICAvLyA6OiBNYXJrU3BlYyBBIHN0cm9uZyBtYXJrLiBSZW5kZXJlZCBhcyBgPHN0cm9uZz5gLCBwYXJzZSBydWxlc1xuICAvLyBhbHNvIG1hdGNoIGA8Yj5gIGFuZCBgZm9udC13ZWlnaHQ6IGJvbGRgLlxuICBzdHJvbmc6IHtcbiAgICBwYXJzZURPTTogW3t0YWc6IFwic3Ryb25nXCJ9LFxuICAgICAgICAgICAgICAgLy8gVGhpcyB3b3JrcyBhcm91bmQgYSBHb29nbGUgRG9jcyBtaXNiZWhhdmlvciB3aGVyZVxuICAgICAgICAgICAgICAgLy8gcGFzdGVkIGNvbnRlbnQgd2lsbCBiZSBpbmV4cGxpY2FibHkgd3JhcHBlZCBpbiBgPGI+YFxuICAgICAgICAgICAgICAgLy8gdGFncyB3aXRoIGEgZm9udC13ZWlnaHQgbm9ybWFsLlxuICAgICAgICAgICAgICAge3RhZzogXCJiXCIsIGdldEF0dHJzOiBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS5zdHlsZS5mb250V2VpZ2h0ICE9IFwibm9ybWFsXCIgJiYgbnVsbDsgfX0sXG4gICAgICAgICAgICAgICB7c3R5bGU6IFwiZm9udC13ZWlnaHRcIiwgZ2V0QXR0cnM6IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gL14oYm9sZChlcik/fFs1LTldXFxkezIsfSkkLy50ZXN0KHZhbHVlKSAmJiBudWxsOyB9fV0sXG4gICAgdG9ET006IGZ1bmN0aW9uIHRvRE9NKCkgeyByZXR1cm4gc3Ryb25nRE9NIH1cbiAgfSxcblxuICAvLyA6OiBNYXJrU3BlYyBDb2RlIGZvbnQgbWFyay4gUmVwcmVzZW50ZWQgYXMgYSBgPGNvZGU+YCBlbGVtZW50LlxuICBjb2RlOiB7XG4gICAgcGFyc2VET006IFt7dGFnOiBcImNvZGVcIn1dLFxuICAgIHRvRE9NOiBmdW5jdGlvbiB0b0RPTSgpIHsgcmV0dXJuIGNvZGVET00gfVxuICB9XG59O1xuXG4vLyA6OiBTY2hlbWFcbi8vIFRoaXMgc2NoZW1hIHJvdWdobHkgY29ycmVzcG9uZHMgdG8gdGhlIGRvY3VtZW50IHNjaGVtYSB1c2VkIGJ5XG4vLyBbQ29tbW9uTWFya10oaHR0cDovL2NvbW1vbm1hcmsub3JnLyksIG1pbnVzIHRoZSBsaXN0IGVsZW1lbnRzLFxuLy8gd2hpY2ggYXJlIGRlZmluZWQgaW4gdGhlIFtgcHJvc2VtaXJyb3Itc2NoZW1hLWxpc3RgXSgjc2NoZW1hLWxpc3QpXG4vLyBtb2R1bGUuXG4vL1xuLy8gVG8gcmV1c2UgZWxlbWVudHMgZnJvbSB0aGlzIHNjaGVtYSwgZXh0ZW5kIG9yIHJlYWQgZnJvbSBpdHNcbi8vIGBzcGVjLm5vZGVzYCBhbmQgYHNwZWMubWFya3NgIFtwcm9wZXJ0aWVzXSgjbW9kZWwuU2NoZW1hLnNwZWMpLlxudmFyIHNjaGVtYSA9IG5ldyBTY2hlbWEoe25vZGVzOiBub2RlcywgbWFya3M6IG1hcmtzfSk7XG5cbmV4cG9ydCB7IG1hcmtzLCBub2Rlcywgc2NoZW1hIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lcy5qcy5tYXBcbiIsImltcG9ydCB7IGZpbmRXcmFwcGluZywgUmVwbGFjZUFyb3VuZFN0ZXAsIGNhblNwbGl0LCBsaWZ0VGFyZ2V0IH0gZnJvbSAncHJvc2VtaXJyb3ItdHJhbnNmb3JtJztcbmltcG9ydCB7IE5vZGVSYW5nZSwgRnJhZ21lbnQsIFNsaWNlIH0gZnJvbSAncHJvc2VtaXJyb3ItbW9kZWwnO1xuXG52YXIgb2xET00gPSBbXCJvbFwiLCAwXSwgdWxET00gPSBbXCJ1bFwiLCAwXSwgbGlET00gPSBbXCJsaVwiLCAwXTtcblxuLy8gOjogTm9kZVNwZWNcbi8vIEFuIG9yZGVyZWQgbGlzdCBbbm9kZSBzcGVjXSgjbW9kZWwuTm9kZVNwZWMpLiBIYXMgYSBzaW5nbGVcbi8vIGF0dHJpYnV0ZSwgYG9yZGVyYCwgd2hpY2ggZGV0ZXJtaW5lcyB0aGUgbnVtYmVyIGF0IHdoaWNoIHRoZSBsaXN0XG4vLyBzdGFydHMgY291bnRpbmcsIGFuZCBkZWZhdWx0cyB0byAxLiBSZXByZXNlbnRlZCBhcyBhbiBgPG9sPmBcbi8vIGVsZW1lbnQuXG52YXIgb3JkZXJlZExpc3QgPSB7XG4gIGF0dHJzOiB7b3JkZXI6IHtkZWZhdWx0OiAxfX0sXG4gIHBhcnNlRE9NOiBbe3RhZzogXCJvbFwiLCBnZXRBdHRyczogZnVuY3Rpb24gZ2V0QXR0cnMoZG9tKSB7XG4gICAgcmV0dXJuIHtvcmRlcjogZG9tLmhhc0F0dHJpYnV0ZShcInN0YXJ0XCIpID8gK2RvbS5nZXRBdHRyaWJ1dGUoXCJzdGFydFwiKSA6IDF9XG4gIH19XSxcbiAgdG9ET006IGZ1bmN0aW9uIHRvRE9NKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5hdHRycy5vcmRlciA9PSAxID8gb2xET00gOiBbXCJvbFwiLCB7c3RhcnQ6IG5vZGUuYXR0cnMub3JkZXJ9LCAwXVxuICB9XG59O1xuXG4vLyA6OiBOb2RlU3BlY1xuLy8gQSBidWxsZXQgbGlzdCBub2RlIHNwZWMsIHJlcHJlc2VudGVkIGluIHRoZSBET00gYXMgYDx1bD5gLlxudmFyIGJ1bGxldExpc3QgPSB7XG4gIHBhcnNlRE9NOiBbe3RhZzogXCJ1bFwifV0sXG4gIHRvRE9NOiBmdW5jdGlvbiB0b0RPTSgpIHsgcmV0dXJuIHVsRE9NIH1cbn07XG5cbi8vIDo6IE5vZGVTcGVjXG4vLyBBIGxpc3QgaXRlbSAoYDxsaT5gKSBzcGVjLlxudmFyIGxpc3RJdGVtID0ge1xuICBwYXJzZURPTTogW3t0YWc6IFwibGlcIn1dLFxuICB0b0RPTTogZnVuY3Rpb24gdG9ET00oKSB7IHJldHVybiBsaURPTSB9LFxuICBkZWZpbmluZzogdHJ1ZVxufTtcblxuZnVuY3Rpb24gYWRkKG9iaiwgcHJvcHMpIHtcbiAgdmFyIGNvcHkgPSB7fTtcbiAgZm9yICh2YXIgcHJvcCBpbiBvYmopIHsgY29weVtwcm9wXSA9IG9ialtwcm9wXTsgfVxuICBmb3IgKHZhciBwcm9wJDEgaW4gcHJvcHMpIHsgY29weVtwcm9wJDFdID0gcHJvcHNbcHJvcCQxXTsgfVxuICByZXR1cm4gY29weVxufVxuXG4vLyA6OiAoT3JkZXJlZE1hcDxOb2RlU3BlYz4sIHN0cmluZywgP3N0cmluZykg4oaSIE9yZGVyZWRNYXA8Tm9kZVNwZWM+XG4vLyBDb252ZW5pZW5jZSBmdW5jdGlvbiBmb3IgYWRkaW5nIGxpc3QtcmVsYXRlZCBub2RlIHR5cGVzIHRvIGEgbWFwXG4vLyBzcGVjaWZ5aW5nIHRoZSBub2RlcyBmb3IgYSBzY2hlbWEuIEFkZHNcbi8vIFtgb3JkZXJlZExpc3RgXSgjc2NoZW1hLWxpc3Qub3JkZXJlZExpc3QpIGFzIGBcIm9yZGVyZWRfbGlzdFwiYCxcbi8vIFtgYnVsbGV0TGlzdGBdKCNzY2hlbWEtbGlzdC5idWxsZXRMaXN0KSBhcyBgXCJidWxsZXRfbGlzdFwiYCwgYW5kXG4vLyBbYGxpc3RJdGVtYF0oI3NjaGVtYS1saXN0Lmxpc3RJdGVtKSBhcyBgXCJsaXN0X2l0ZW1cImAuXG4vL1xuLy8gYGl0ZW1Db250ZW50YCBkZXRlcm1pbmVzIHRoZSBjb250ZW50IGV4cHJlc3Npb24gZm9yIHRoZSBsaXN0IGl0ZW1zLlxuLy8gSWYgeW91IHdhbnQgdGhlIGNvbW1hbmRzIGRlZmluZWQgaW4gdGhpcyBtb2R1bGUgdG8gYXBwbHkgdG8geW91clxuLy8gbGlzdCBzdHJ1Y3R1cmUsIGl0IHNob3VsZCBoYXZlIGEgc2hhcGUgbGlrZSBgXCJwYXJhZ3JhcGggYmxvY2sqXCJgIG9yXG4vLyBgXCJwYXJhZ3JhcGggKG9yZGVyZWRfbGlzdCB8IGJ1bGxldF9saXN0KSpcImAuIGBsaXN0R3JvdXBgIGNhbiBiZVxuLy8gZ2l2ZW4gdG8gYXNzaWduIGEgZ3JvdXAgbmFtZSB0byB0aGUgbGlzdCBub2RlIHR5cGVzLCBmb3IgZXhhbXBsZVxuLy8gYFwiYmxvY2tcImAuXG5mdW5jdGlvbiBhZGRMaXN0Tm9kZXMobm9kZXMsIGl0ZW1Db250ZW50LCBsaXN0R3JvdXApIHtcbiAgcmV0dXJuIG5vZGVzLmFwcGVuZCh7XG4gICAgb3JkZXJlZF9saXN0OiBhZGQob3JkZXJlZExpc3QsIHtjb250ZW50OiBcImxpc3RfaXRlbStcIiwgZ3JvdXA6IGxpc3RHcm91cH0pLFxuICAgIGJ1bGxldF9saXN0OiBhZGQoYnVsbGV0TGlzdCwge2NvbnRlbnQ6IFwibGlzdF9pdGVtK1wiLCBncm91cDogbGlzdEdyb3VwfSksXG4gICAgbGlzdF9pdGVtOiBhZGQobGlzdEl0ZW0sIHtjb250ZW50OiBpdGVtQ29udGVudH0pXG4gIH0pXG59XG5cbi8vIDo6IChOb2RlVHlwZSwgP09iamVjdCkg4oaSIChzdGF0ZTogRWRpdG9yU3RhdGUsIGRpc3BhdGNoOiA/KHRyOiBUcmFuc2FjdGlvbikpIOKGkiBib29sXG4vLyBSZXR1cm5zIGEgY29tbWFuZCBmdW5jdGlvbiB0aGF0IHdyYXBzIHRoZSBzZWxlY3Rpb24gaW4gYSBsaXN0IHdpdGhcbi8vIHRoZSBnaXZlbiB0eXBlIGFuIGF0dHJpYnV0ZXMuIElmIGBkaXNwYXRjaGAgaXMgbnVsbCwgb25seSByZXR1cm4gYVxuLy8gdmFsdWUgdG8gaW5kaWNhdGUgd2hldGhlciB0aGlzIGlzIHBvc3NpYmxlLCBidXQgZG9uJ3QgYWN0dWFsbHlcbi8vIHBlcmZvcm0gdGhlIGNoYW5nZS5cbmZ1bmN0aW9uIHdyYXBJbkxpc3QobGlzdFR5cGUsIGF0dHJzKSB7XG4gIHJldHVybiBmdW5jdGlvbihzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICB2YXIgcmVmID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIHZhciAkZnJvbSA9IHJlZi4kZnJvbTtcbiAgICB2YXIgJHRvID0gcmVmLiR0bztcbiAgICB2YXIgcmFuZ2UgPSAkZnJvbS5ibG9ja1JhbmdlKCR0byksIGRvSm9pbiA9IGZhbHNlLCBvdXRlclJhbmdlID0gcmFuZ2U7XG4gICAgaWYgKCFyYW5nZSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIC8vIFRoaXMgaXMgYXQgdGhlIHRvcCBvZiBhbiBleGlzdGluZyBsaXN0IGl0ZW1cbiAgICBpZiAocmFuZ2UuZGVwdGggPj0gMiAmJiAkZnJvbS5ub2RlKHJhbmdlLmRlcHRoIC0gMSkudHlwZS5jb21wYXRpYmxlQ29udGVudChsaXN0VHlwZSkgJiYgcmFuZ2Uuc3RhcnRJbmRleCA9PSAwKSB7XG4gICAgICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiB0aGlzIGlzIHRoZSB0b3Agb2YgdGhlIGxpc3RcbiAgICAgIGlmICgkZnJvbS5pbmRleChyYW5nZS5kZXB0aCAtIDEpID09IDApIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAgIHZhciAkaW5zZXJ0ID0gc3RhdGUuZG9jLnJlc29sdmUocmFuZ2Uuc3RhcnQgLSAyKTtcbiAgICAgIG91dGVyUmFuZ2UgPSBuZXcgTm9kZVJhbmdlKCRpbnNlcnQsICRpbnNlcnQsIHJhbmdlLmRlcHRoKTtcbiAgICAgIGlmIChyYW5nZS5lbmRJbmRleCA8IHJhbmdlLnBhcmVudC5jaGlsZENvdW50KVxuICAgICAgICB7IHJhbmdlID0gbmV3IE5vZGVSYW5nZSgkZnJvbSwgc3RhdGUuZG9jLnJlc29sdmUoJHRvLmVuZChyYW5nZS5kZXB0aCkpLCByYW5nZS5kZXB0aCk7IH1cbiAgICAgIGRvSm9pbiA9IHRydWU7XG4gICAgfVxuICAgIHZhciB3cmFwID0gZmluZFdyYXBwaW5nKG91dGVyUmFuZ2UsIGxpc3RUeXBlLCBhdHRycywgcmFuZ2UpO1xuICAgIGlmICghd3JhcCkgeyByZXR1cm4gZmFsc2UgfVxuICAgIGlmIChkaXNwYXRjaCkgeyBkaXNwYXRjaChkb1dyYXBJbkxpc3Qoc3RhdGUudHIsIHJhbmdlLCB3cmFwLCBkb0pvaW4sIGxpc3RUeXBlKS5zY3JvbGxJbnRvVmlldygpKTsgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cbn1cblxuZnVuY3Rpb24gZG9XcmFwSW5MaXN0KHRyLCByYW5nZSwgd3JhcHBlcnMsIGpvaW5CZWZvcmUsIGxpc3RUeXBlKSB7XG4gIHZhciBjb250ZW50ID0gRnJhZ21lbnQuZW1wdHk7XG4gIGZvciAodmFyIGkgPSB3cmFwcGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICB7IGNvbnRlbnQgPSBGcmFnbWVudC5mcm9tKHdyYXBwZXJzW2ldLnR5cGUuY3JlYXRlKHdyYXBwZXJzW2ldLmF0dHJzLCBjb250ZW50KSk7IH1cblxuICB0ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcChyYW5nZS5zdGFydCAtIChqb2luQmVmb3JlID8gMiA6IDApLCByYW5nZS5lbmQsIHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBTbGljZShjb250ZW50LCAwLCAwKSwgd3JhcHBlcnMubGVuZ3RoLCB0cnVlKSk7XG5cbiAgdmFyIGZvdW5kID0gMDtcbiAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgd3JhcHBlcnMubGVuZ3RoOyBpJDErKykgeyBpZiAod3JhcHBlcnNbaSQxXS50eXBlID09IGxpc3RUeXBlKSB7IGZvdW5kID0gaSQxICsgMTsgfSB9XG4gIHZhciBzcGxpdERlcHRoID0gd3JhcHBlcnMubGVuZ3RoIC0gZm91bmQ7XG5cbiAgdmFyIHNwbGl0UG9zID0gcmFuZ2Uuc3RhcnQgKyB3cmFwcGVycy5sZW5ndGggLSAoam9pbkJlZm9yZSA/IDIgOiAwKSwgcGFyZW50ID0gcmFuZ2UucGFyZW50O1xuICBmb3IgKHZhciBpJDIgPSByYW5nZS5zdGFydEluZGV4LCBlID0gcmFuZ2UuZW5kSW5kZXgsIGZpcnN0ID0gdHJ1ZTsgaSQyIDwgZTsgaSQyKyssIGZpcnN0ID0gZmFsc2UpIHtcbiAgICBpZiAoIWZpcnN0ICYmIGNhblNwbGl0KHRyLmRvYywgc3BsaXRQb3MsIHNwbGl0RGVwdGgpKSB7XG4gICAgICB0ci5zcGxpdChzcGxpdFBvcywgc3BsaXREZXB0aCk7XG4gICAgICBzcGxpdFBvcyArPSAyICogc3BsaXREZXB0aDtcbiAgICB9XG4gICAgc3BsaXRQb3MgKz0gcGFyZW50LmNoaWxkKGkkMikubm9kZVNpemU7XG4gIH1cbiAgcmV0dXJuIHRyXG59XG5cbi8vIDo6IChOb2RlVHlwZSkg4oaSIChzdGF0ZTogRWRpdG9yU3RhdGUsIGRpc3BhdGNoOiA/KHRyOiBUcmFuc2FjdGlvbikpIOKGkiBib29sXG4vLyBCdWlsZCBhIGNvbW1hbmQgdGhhdCBzcGxpdHMgYSBub24tZW1wdHkgdGV4dGJsb2NrIGF0IHRoZSB0b3AgbGV2ZWxcbi8vIG9mIGEgbGlzdCBpdGVtIGJ5IGFsc28gc3BsaXR0aW5nIHRoYXQgbGlzdCBpdGVtLlxuZnVuY3Rpb24gc3BsaXRMaXN0SXRlbShpdGVtVHlwZSkge1xuICByZXR1cm4gZnVuY3Rpb24oc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgdmFyIHJlZiA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICB2YXIgJGZyb20gPSByZWYuJGZyb207XG4gICAgdmFyICR0byA9IHJlZi4kdG87XG4gICAgdmFyIG5vZGUgPSByZWYubm9kZTtcbiAgICBpZiAoKG5vZGUgJiYgbm9kZS5pc0Jsb2NrKSB8fCAkZnJvbS5kZXB0aCA8IDIgfHwgISRmcm9tLnNhbWVQYXJlbnQoJHRvKSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIHZhciBncmFuZFBhcmVudCA9ICRmcm9tLm5vZGUoLTEpO1xuICAgIGlmIChncmFuZFBhcmVudC50eXBlICE9IGl0ZW1UeXBlKSB7IHJldHVybiBmYWxzZSB9XG4gICAgaWYgKCRmcm9tLnBhcmVudC5jb250ZW50LnNpemUgPT0gMCAmJiAkZnJvbS5ub2RlKC0xKS5jaGlsZENvdW50ID09ICRmcm9tLmluZGV4QWZ0ZXIoLTEpKSB7XG4gICAgICAvLyBJbiBhbiBlbXB0eSBibG9jay4gSWYgdGhpcyBpcyBhIG5lc3RlZCBsaXN0LCB0aGUgd3JhcHBpbmdcbiAgICAgIC8vIGxpc3QgaXRlbSBzaG91bGQgYmUgc3BsaXQuIE90aGVyd2lzZSwgYmFpbCBvdXQgYW5kIGxldCBuZXh0XG4gICAgICAvLyBjb21tYW5kIGhhbmRsZSBsaWZ0aW5nLlxuICAgICAgaWYgKCRmcm9tLmRlcHRoID09IDIgfHwgJGZyb20ubm9kZSgtMykudHlwZSAhPSBpdGVtVHlwZSB8fFxuICAgICAgICAgICRmcm9tLmluZGV4KC0yKSAhPSAkZnJvbS5ub2RlKC0yKS5jaGlsZENvdW50IC0gMSkgeyByZXR1cm4gZmFsc2UgfVxuICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgIHZhciB3cmFwID0gRnJhZ21lbnQuZW1wdHk7XG4gICAgICAgIHZhciBkZXB0aEJlZm9yZSA9ICRmcm9tLmluZGV4KC0xKSA/IDEgOiAkZnJvbS5pbmRleCgtMikgPyAyIDogMztcbiAgICAgICAgLy8gQnVpbGQgYSBmcmFnbWVudCBjb250YWluaW5nIGVtcHR5IHZlcnNpb25zIG9mIHRoZSBzdHJ1Y3R1cmVcbiAgICAgICAgLy8gZnJvbSB0aGUgb3V0ZXIgbGlzdCBpdGVtIHRvIHRoZSBwYXJlbnQgbm9kZSBvZiB0aGUgY3Vyc29yXG4gICAgICAgIGZvciAodmFyIGQgPSAkZnJvbS5kZXB0aCAtIGRlcHRoQmVmb3JlOyBkID49ICRmcm9tLmRlcHRoIC0gMzsgZC0tKVxuICAgICAgICAgIHsgd3JhcCA9IEZyYWdtZW50LmZyb20oJGZyb20ubm9kZShkKS5jb3B5KHdyYXApKTsgfVxuICAgICAgICB2YXIgZGVwdGhBZnRlciA9ICRmcm9tLmluZGV4QWZ0ZXIoLTEpIDwgJGZyb20ubm9kZSgtMikuY2hpbGRDb3VudCA/IDFcbiAgICAgICAgICAgIDogJGZyb20uaW5kZXhBZnRlcigtMikgPCAkZnJvbS5ub2RlKC0zKS5jaGlsZENvdW50ID8gMiA6IDM7XG4gICAgICAgIC8vIEFkZCBhIHNlY29uZCBsaXN0IGl0ZW0gd2l0aCBhbiBlbXB0eSBkZWZhdWx0IHN0YXJ0IG5vZGVcbiAgICAgICAgd3JhcCA9IHdyYXAuYXBwZW5kKEZyYWdtZW50LmZyb20oaXRlbVR5cGUuY3JlYXRlQW5kRmlsbCgpKSk7XG4gICAgICAgIHZhciBzdGFydCA9ICRmcm9tLmJlZm9yZSgkZnJvbS5kZXB0aCAtIChkZXB0aEJlZm9yZSAtIDEpKTtcbiAgICAgICAgdmFyIHRyJDEgPSBzdGF0ZS50ci5yZXBsYWNlKHN0YXJ0LCAkZnJvbS5hZnRlcigtZGVwdGhBZnRlciksIG5ldyBTbGljZSh3cmFwLCA0IC0gZGVwdGhCZWZvcmUsIDApKTtcbiAgICAgICAgdmFyIHNlbCA9IC0xO1xuICAgICAgICB0ciQxLmRvYy5ub2Rlc0JldHdlZW4oc3RhcnQsIHRyJDEuZG9jLmNvbnRlbnQuc2l6ZSwgZnVuY3Rpb24gKG5vZGUsIHBvcykge1xuICAgICAgICAgIGlmIChzZWwgPiAtMSkgeyByZXR1cm4gZmFsc2UgfVxuICAgICAgICAgIGlmIChub2RlLmlzVGV4dGJsb2NrICYmIG5vZGUuY29udGVudC5zaXplID09IDApIHsgc2VsID0gcG9zICsgMTsgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHNlbCA+IC0xKSB7IHRyJDEuc2V0U2VsZWN0aW9uKHN0YXRlLnNlbGVjdGlvbi5jb25zdHJ1Y3Rvci5uZWFyKHRyJDEuZG9jLnJlc29sdmUoc2VsKSkpOyB9XG4gICAgICAgIGRpc3BhdGNoKHRyJDEuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICB2YXIgbmV4dFR5cGUgPSAkdG8ucG9zID09ICRmcm9tLmVuZCgpID8gZ3JhbmRQYXJlbnQuY29udGVudE1hdGNoQXQoMCkuZGVmYXVsdFR5cGUgOiBudWxsO1xuICAgIHZhciB0ciA9IHN0YXRlLnRyLmRlbGV0ZSgkZnJvbS5wb3MsICR0by5wb3MpO1xuICAgIHZhciB0eXBlcyA9IG5leHRUeXBlICYmIFtudWxsLCB7dHlwZTogbmV4dFR5cGV9XTtcbiAgICBpZiAoIWNhblNwbGl0KHRyLmRvYywgJGZyb20ucG9zLCAyLCB0eXBlcykpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBpZiAoZGlzcGF0Y2gpIHsgZGlzcGF0Y2godHIuc3BsaXQoJGZyb20ucG9zLCAyLCB0eXBlcykuc2Nyb2xsSW50b1ZpZXcoKSk7IH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG59XG5cbi8vIDo6IChOb2RlVHlwZSkg4oaSIChzdGF0ZTogRWRpdG9yU3RhdGUsIGRpc3BhdGNoOiA/KHRyOiBUcmFuc2FjdGlvbikpIOKGkiBib29sXG4vLyBDcmVhdGUgYSBjb21tYW5kIHRvIGxpZnQgdGhlIGxpc3QgaXRlbSBhcm91bmQgdGhlIHNlbGVjdGlvbiB1cCBpbnRvXG4vLyBhIHdyYXBwaW5nIGxpc3QuXG5mdW5jdGlvbiBsaWZ0TGlzdEl0ZW0oaXRlbVR5cGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgIHZhciByZWYgPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgdmFyICRmcm9tID0gcmVmLiRmcm9tO1xuICAgIHZhciAkdG8gPSByZWYuJHRvO1xuICAgIHZhciByYW5nZSA9ICRmcm9tLmJsb2NrUmFuZ2UoJHRvLCBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS5jaGlsZENvdW50ICYmIG5vZGUuZmlyc3RDaGlsZC50eXBlID09IGl0ZW1UeXBlOyB9KTtcbiAgICBpZiAoIXJhbmdlKSB7IHJldHVybiBmYWxzZSB9XG4gICAgaWYgKCFkaXNwYXRjaCkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgaWYgKCRmcm9tLm5vZGUocmFuZ2UuZGVwdGggLSAxKS50eXBlID09IGl0ZW1UeXBlKSAvLyBJbnNpZGUgYSBwYXJlbnQgbGlzdFxuICAgICAgeyByZXR1cm4gbGlmdFRvT3V0ZXJMaXN0KHN0YXRlLCBkaXNwYXRjaCwgaXRlbVR5cGUsIHJhbmdlKSB9XG4gICAgZWxzZSAvLyBPdXRlciBsaXN0IG5vZGVcbiAgICAgIHsgcmV0dXJuIGxpZnRPdXRPZkxpc3Qoc3RhdGUsIGRpc3BhdGNoLCByYW5nZSkgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGxpZnRUb091dGVyTGlzdChzdGF0ZSwgZGlzcGF0Y2gsIGl0ZW1UeXBlLCByYW5nZSkge1xuICB2YXIgdHIgPSBzdGF0ZS50ciwgZW5kID0gcmFuZ2UuZW5kLCBlbmRPZkxpc3QgPSByYW5nZS4kdG8uZW5kKHJhbmdlLmRlcHRoKTtcbiAgaWYgKGVuZCA8IGVuZE9mTGlzdCkge1xuICAgIC8vIFRoZXJlIGFyZSBzaWJsaW5ncyBhZnRlciB0aGUgbGlmdGVkIGl0ZW1zLCB3aGljaCBtdXN0IGJlY29tZVxuICAgIC8vIGNoaWxkcmVuIG9mIHRoZSBsYXN0IGl0ZW1cbiAgICB0ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcChlbmQgLSAxLCBlbmRPZkxpc3QsIGVuZCwgZW5kT2ZMaXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBTbGljZShGcmFnbWVudC5mcm9tKGl0ZW1UeXBlLmNyZWF0ZShudWxsLCByYW5nZS5wYXJlbnQuY29weSgpKSksIDEsIDApLCAxLCB0cnVlKSk7XG4gICAgcmFuZ2UgPSBuZXcgTm9kZVJhbmdlKHRyLmRvYy5yZXNvbHZlKHJhbmdlLiRmcm9tLnBvcyksIHRyLmRvYy5yZXNvbHZlKGVuZE9mTGlzdCksIHJhbmdlLmRlcHRoKTtcbiAgfVxuICBkaXNwYXRjaCh0ci5saWZ0KHJhbmdlLCBsaWZ0VGFyZ2V0KHJhbmdlKSkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIGxpZnRPdXRPZkxpc3Qoc3RhdGUsIGRpc3BhdGNoLCByYW5nZSkge1xuICB2YXIgdHIgPSBzdGF0ZS50ciwgbGlzdCA9IHJhbmdlLnBhcmVudDtcbiAgLy8gTWVyZ2UgdGhlIGxpc3QgaXRlbXMgaW50byBhIHNpbmdsZSBiaWcgaXRlbVxuICBmb3IgKHZhciBwb3MgPSByYW5nZS5lbmQsIGkgPSByYW5nZS5lbmRJbmRleCAtIDEsIGUgPSByYW5nZS5zdGFydEluZGV4OyBpID4gZTsgaS0tKSB7XG4gICAgcG9zIC09IGxpc3QuY2hpbGQoaSkubm9kZVNpemU7XG4gICAgdHIuZGVsZXRlKHBvcyAtIDEsIHBvcyArIDEpO1xuICB9XG4gIHZhciAkc3RhcnQgPSB0ci5kb2MucmVzb2x2ZShyYW5nZS5zdGFydCksIGl0ZW0gPSAkc3RhcnQubm9kZUFmdGVyO1xuICBpZiAodHIubWFwcGluZy5tYXAocmFuZ2UuZW5kKSAhPSByYW5nZS5zdGFydCArICRzdGFydC5ub2RlQWZ0ZXIubm9kZVNpemUpIHsgcmV0dXJuIGZhbHNlIH1cbiAgdmFyIGF0U3RhcnQgPSByYW5nZS5zdGFydEluZGV4ID09IDAsIGF0RW5kID0gcmFuZ2UuZW5kSW5kZXggPT0gbGlzdC5jaGlsZENvdW50O1xuICB2YXIgcGFyZW50ID0gJHN0YXJ0Lm5vZGUoLTEpLCBpbmRleEJlZm9yZSA9ICRzdGFydC5pbmRleCgtMSk7XG4gIGlmICghcGFyZW50LmNhblJlcGxhY2UoaW5kZXhCZWZvcmUgKyAoYXRTdGFydCA/IDAgOiAxKSwgaW5kZXhCZWZvcmUgKyAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uY29udGVudC5hcHBlbmQoYXRFbmQgPyBGcmFnbWVudC5lbXB0eSA6IEZyYWdtZW50LmZyb20obGlzdCkpKSlcbiAgICB7IHJldHVybiBmYWxzZSB9XG4gIHZhciBzdGFydCA9ICRzdGFydC5wb3MsIGVuZCA9IHN0YXJ0ICsgaXRlbS5ub2RlU2l6ZTtcbiAgLy8gU3RyaXAgb2ZmIHRoZSBzdXJyb3VuZGluZyBsaXN0LiBBdCB0aGUgc2lkZXMgd2hlcmUgd2UncmUgbm90IGF0XG4gIC8vIHRoZSBlbmQgb2YgdGhlIGxpc3QsIHRoZSBleGlzdGluZyBsaXN0IGlzIGNsb3NlZC4gQXQgc2lkZXMgd2hlcmVcbiAgLy8gdGhpcyBpcyB0aGUgZW5kLCBpdCBpcyBvdmVyd3JpdHRlbiB0byBpdHMgZW5kLlxuICB0ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcChzdGFydCAtIChhdFN0YXJ0ID8gMSA6IDApLCBlbmQgKyAoYXRFbmQgPyAxIDogMCksIHN0YXJ0ICsgMSwgZW5kIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFNsaWNlKChhdFN0YXJ0ID8gRnJhZ21lbnQuZW1wdHkgOiBGcmFnbWVudC5mcm9tKGxpc3QuY29weShGcmFnbWVudC5lbXB0eSkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChhdEVuZCA/IEZyYWdtZW50LmVtcHR5IDogRnJhZ21lbnQuZnJvbShsaXN0LmNvcHkoRnJhZ21lbnQuZW1wdHkpKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdFN0YXJ0ID8gMCA6IDEsIGF0RW5kID8gMCA6IDEpLCBhdFN0YXJ0ID8gMCA6IDEpKTtcbiAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gIHJldHVybiB0cnVlXG59XG5cbi8vIDo6IChOb2RlVHlwZSkg4oaSIChzdGF0ZTogRWRpdG9yU3RhdGUsIGRpc3BhdGNoOiA/KHRyOiBUcmFuc2FjdGlvbikpIOKGkiBib29sXG4vLyBDcmVhdGUgYSBjb21tYW5kIHRvIHNpbmsgdGhlIGxpc3QgaXRlbSBhcm91bmQgdGhlIHNlbGVjdGlvbiBkb3duXG4vLyBpbnRvIGFuIGlubmVyIGxpc3QuXG5mdW5jdGlvbiBzaW5rTGlzdEl0ZW0oaXRlbVR5cGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgIHZhciByZWYgPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgdmFyICRmcm9tID0gcmVmLiRmcm9tO1xuICAgIHZhciAkdG8gPSByZWYuJHRvO1xuICAgIHZhciByYW5nZSA9ICRmcm9tLmJsb2NrUmFuZ2UoJHRvLCBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS5jaGlsZENvdW50ICYmIG5vZGUuZmlyc3RDaGlsZC50eXBlID09IGl0ZW1UeXBlOyB9KTtcbiAgICBpZiAoIXJhbmdlKSB7IHJldHVybiBmYWxzZSB9XG4gICAgdmFyIHN0YXJ0SW5kZXggPSByYW5nZS5zdGFydEluZGV4O1xuICAgIGlmIChzdGFydEluZGV4ID09IDApIHsgcmV0dXJuIGZhbHNlIH1cbiAgICB2YXIgcGFyZW50ID0gcmFuZ2UucGFyZW50LCBub2RlQmVmb3JlID0gcGFyZW50LmNoaWxkKHN0YXJ0SW5kZXggLSAxKTtcbiAgICBpZiAobm9kZUJlZm9yZS50eXBlICE9IGl0ZW1UeXBlKSB7IHJldHVybiBmYWxzZSB9XG5cbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgIHZhciBuZXN0ZWRCZWZvcmUgPSBub2RlQmVmb3JlLmxhc3RDaGlsZCAmJiBub2RlQmVmb3JlLmxhc3RDaGlsZC50eXBlID09IHBhcmVudC50eXBlO1xuICAgICAgdmFyIGlubmVyID0gRnJhZ21lbnQuZnJvbShuZXN0ZWRCZWZvcmUgPyBpdGVtVHlwZS5jcmVhdGUoKSA6IG51bGwpO1xuICAgICAgdmFyIHNsaWNlID0gbmV3IFNsaWNlKEZyYWdtZW50LmZyb20oaXRlbVR5cGUuY3JlYXRlKG51bGwsIEZyYWdtZW50LmZyb20ocGFyZW50LnR5cGUuY3JlYXRlKG51bGwsIGlubmVyKSkpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXN0ZWRCZWZvcmUgPyAzIDogMSwgMCk7XG4gICAgICB2YXIgYmVmb3JlID0gcmFuZ2Uuc3RhcnQsIGFmdGVyID0gcmFuZ2UuZW5kO1xuICAgICAgZGlzcGF0Y2goc3RhdGUudHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoYmVmb3JlIC0gKG5lc3RlZEJlZm9yZSA/IDMgOiAxKSwgYWZ0ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZWZvcmUsIGFmdGVyLCBzbGljZSwgMSwgdHJ1ZSkpXG4gICAgICAgICAgICAgICAuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cbn1cblxuZXhwb3J0IHsgYWRkTGlzdE5vZGVzLCBidWxsZXRMaXN0LCBsaWZ0TGlzdEl0ZW0sIGxpc3RJdGVtLCBvcmRlcmVkTGlzdCwgc2lua0xpc3RJdGVtLCBzcGxpdExpc3RJdGVtLCB3cmFwSW5MaXN0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lcy5qcy5tYXBcbiIsImltcG9ydCB7IFNsaWNlLCBGcmFnbWVudCwgTWFyaywgTm9kZSB9IGZyb20gJ3Byb3NlbWlycm9yLW1vZGVsJztcbmltcG9ydCB7IFJlcGxhY2VTdGVwLCBSZXBsYWNlQXJvdW5kU3RlcCwgVHJhbnNmb3JtIH0gZnJvbSAncHJvc2VtaXJyb3ItdHJhbnNmb3JtJztcblxudmFyIGNsYXNzZXNCeUlkID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuLy8gOjotIFN1cGVyY2xhc3MgZm9yIGVkaXRvciBzZWxlY3Rpb25zLiBFdmVyeSBzZWxlY3Rpb24gdHlwZSBzaG91bGRcbi8vIGV4dGVuZCB0aGlzLiBTaG91bGQgbm90IGJlIGluc3RhbnRpYXRlZCBkaXJlY3RseS5cbnZhciBTZWxlY3Rpb24gPSBmdW5jdGlvbiBTZWxlY3Rpb24oJGFuY2hvciwgJGhlYWQsIHJhbmdlcykge1xuICAvLyA6OiBbU2VsZWN0aW9uUmFuZ2VdXG4gIC8vIFRoZSByYW5nZXMgY292ZXJlZCBieSB0aGUgc2VsZWN0aW9uLlxuICB0aGlzLnJhbmdlcyA9IHJhbmdlcyB8fCBbbmV3IFNlbGVjdGlvblJhbmdlKCRhbmNob3IubWluKCRoZWFkKSwgJGFuY2hvci5tYXgoJGhlYWQpKV07XG4gIC8vIDo6IFJlc29sdmVkUG9zXG4gIC8vIFRoZSByZXNvbHZlZCBhbmNob3Igb2YgdGhlIHNlbGVjdGlvbiAodGhlIHNpZGUgdGhhdCBzdGF5cyBpblxuICAvLyBwbGFjZSB3aGVuIHRoZSBzZWxlY3Rpb24gaXMgbW9kaWZpZWQpLlxuICB0aGlzLiRhbmNob3IgPSAkYW5jaG9yO1xuICAvLyA6OiBSZXNvbHZlZFBvc1xuICAvLyBUaGUgcmVzb2x2ZWQgaGVhZCBvZiB0aGUgc2VsZWN0aW9uICh0aGUgc2lkZSB0aGF0IG1vdmVzIHdoZW5cbiAgLy8gdGhlIHNlbGVjdGlvbiBpcyBtb2RpZmllZCkuXG4gIHRoaXMuJGhlYWQgPSAkaGVhZDtcbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMgPSB7IGFuY2hvcjogeyBjb25maWd1cmFibGU6IHRydWUgfSxoZWFkOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGZyb206IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sdG86IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sJGZyb206IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sJHRvOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGVtcHR5OiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbi8vIDo6IG51bWJlclxuLy8gVGhlIHNlbGVjdGlvbidzIGFuY2hvciwgYXMgYW4gdW5yZXNvbHZlZCBwb3NpdGlvbi5cbnByb3RvdHlwZUFjY2Vzc29ycy5hbmNob3IuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy4kYW5jaG9yLnBvcyB9O1xuXG4vLyA6OiBudW1iZXJcbi8vIFRoZSBzZWxlY3Rpb24ncyBoZWFkLlxucHJvdG90eXBlQWNjZXNzb3JzLmhlYWQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy4kaGVhZC5wb3MgfTtcblxuLy8gOjogbnVtYmVyXG4vLyBUaGUgbG93ZXIgYm91bmQgb2YgdGhlIHNlbGVjdGlvbidzIG1haW4gcmFuZ2UuXG5wcm90b3R5cGVBY2Nlc3NvcnMuZnJvbS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLiRmcm9tLnBvcyB9O1xuXG4vLyA6OiBudW1iZXJcbi8vIFRoZSB1cHBlciBib3VuZCBvZiB0aGUgc2VsZWN0aW9uJ3MgbWFpbiByYW5nZS5cbnByb3RvdHlwZUFjY2Vzc29ycy50by5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLiR0by5wb3MgfTtcblxuLy8gOjogUmVzb2x2ZWRQb3Ncbi8vIFRoZSByZXNvbHZlZCBsb3dlcmJvdW5kIG9mIHRoZSBzZWxlY3Rpb24ncyBtYWluIHJhbmdlLlxucHJvdG90eXBlQWNjZXNzb3JzLiRmcm9tLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucmFuZ2VzWzBdLiRmcm9tXG59O1xuXG4vLyA6OiBSZXNvbHZlZFBvc1xuLy8gVGhlIHJlc29sdmVkIHVwcGVyIGJvdW5kIG9mIHRoZSBzZWxlY3Rpb24ncyBtYWluIHJhbmdlLlxucHJvdG90eXBlQWNjZXNzb3JzLiR0by5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnJhbmdlc1swXS4kdG9cbn07XG5cbi8vIDo6IGJvb2xcbi8vIEluZGljYXRlcyB3aGV0aGVyIHRoZSBzZWxlY3Rpb24gY29udGFpbnMgYW55IGNvbnRlbnQuXG5wcm90b3R5cGVBY2Nlc3NvcnMuZW1wdHkuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcmFuZ2VzID0gdGhpcy5yYW5nZXM7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKVxuICAgIHsgaWYgKHJhbmdlc1tpXS4kZnJvbS5wb3MgIT0gcmFuZ2VzW2ldLiR0by5wb3MpIHsgcmV0dXJuIGZhbHNlIH0gfVxuICByZXR1cm4gdHJ1ZVxufTtcblxuLy8gZXE6OiAoU2VsZWN0aW9uKSDihpIgYm9vbFxuLy8gVGVzdCB3aGV0aGVyIHRoZSBzZWxlY3Rpb24gaXMgdGhlIHNhbWUgYXMgYW5vdGhlciBzZWxlY3Rpb24uXG5cbi8vIG1hcDo6IChkb2M6IE5vZGUsIG1hcHBpbmc6IE1hcHBhYmxlKSDihpIgU2VsZWN0aW9uXG4vLyBNYXAgdGhpcyBzZWxlY3Rpb24gdGhyb3VnaCBhIFttYXBwYWJsZV0oI3RyYW5zZm9ybS5NYXBwYWJsZSkgdGhpbmcuIGBkb2NgXG4vLyBzaG91bGQgYmUgdGhlIG5ldyBkb2N1bWVudCB0byB3aGljaCB3ZSBhcmUgbWFwcGluZy5cblxuLy8gOjogKCkg4oaSIFNsaWNlXG4vLyBHZXQgdGhlIGNvbnRlbnQgb2YgdGhpcyBzZWxlY3Rpb24gYXMgYSBzbGljZS5cblNlbGVjdGlvbi5wcm90b3R5cGUuY29udGVudCA9IGZ1bmN0aW9uIGNvbnRlbnQgKCkge1xuICByZXR1cm4gdGhpcy4kZnJvbS5ub2RlKDApLnNsaWNlKHRoaXMuZnJvbSwgdGhpcy50bywgdHJ1ZSlcbn07XG5cbi8vIDo6IChUcmFuc2FjdGlvbiwgP1NsaWNlKVxuLy8gUmVwbGFjZSB0aGUgc2VsZWN0aW9uIHdpdGggYSBzbGljZSBvciwgaWYgbm8gc2xpY2UgaXMgZ2l2ZW4sXG4vLyBkZWxldGUgdGhlIHNlbGVjdGlvbi4gV2lsbCBhcHBlbmQgdG8gdGhlIGdpdmVuIHRyYW5zYWN0aW9uLlxuU2VsZWN0aW9uLnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZSAodHIsIGNvbnRlbnQpIHtcbiAgICBpZiAoIGNvbnRlbnQgPT09IHZvaWQgMCApIGNvbnRlbnQgPSBTbGljZS5lbXB0eTtcblxuICAvLyBQdXQgdGhlIG5ldyBzZWxlY3Rpb24gYXQgdGhlIHBvc2l0aW9uIGFmdGVyIHRoZSBpbnNlcnRlZFxuICAvLyBjb250ZW50LiBXaGVuIHRoYXQgZW5kZWQgaW4gYW4gaW5saW5lIG5vZGUsIHNlYXJjaCBiYWNrd2FyZHMsXG4gIC8vIHRvIGdldCB0aGUgcG9zaXRpb24gYWZ0ZXIgdGhhdCBub2RlLiBJZiBub3QsIHNlYXJjaCBmb3J3YXJkLlxuICB2YXIgbGFzdE5vZGUgPSBjb250ZW50LmNvbnRlbnQubGFzdENoaWxkLCBsYXN0UGFyZW50ID0gbnVsbDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250ZW50Lm9wZW5FbmQ7IGkrKykge1xuICAgIGxhc3RQYXJlbnQgPSBsYXN0Tm9kZTtcbiAgICBsYXN0Tm9kZSA9IGxhc3ROb2RlLmxhc3RDaGlsZDtcbiAgfVxuXG4gIHZhciBtYXBGcm9tID0gdHIuc3RlcHMubGVuZ3RoLCByYW5nZXMgPSB0aGlzLnJhbmdlcztcbiAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgcmFuZ2VzLmxlbmd0aDsgaSQxKyspIHtcbiAgICB2YXIgcmVmID0gcmFuZ2VzW2kkMV07XG4gICAgICB2YXIgJGZyb20gPSByZWYuJGZyb207XG4gICAgICB2YXIgJHRvID0gcmVmLiR0bztcbiAgICAgIHZhciBtYXBwaW5nID0gdHIubWFwcGluZy5zbGljZShtYXBGcm9tKTtcbiAgICB0ci5yZXBsYWNlUmFuZ2UobWFwcGluZy5tYXAoJGZyb20ucG9zKSwgbWFwcGluZy5tYXAoJHRvLnBvcyksIGkkMSA/IFNsaWNlLmVtcHR5IDogY29udGVudCk7XG4gICAgaWYgKGkkMSA9PSAwKVxuICAgICAgeyBzZWxlY3Rpb25Ub0luc2VydGlvbkVuZCh0ciwgbWFwRnJvbSwgKGxhc3ROb2RlID8gbGFzdE5vZGUuaXNJbmxpbmUgOiBsYXN0UGFyZW50ICYmIGxhc3RQYXJlbnQuaXNUZXh0YmxvY2spID8gLTEgOiAxKTsgfVxuICB9XG59O1xuXG4vLyA6OiAoVHJhbnNhY3Rpb24sIE5vZGUpXG4vLyBSZXBsYWNlIHRoZSBzZWxlY3Rpb24gd2l0aCB0aGUgZ2l2ZW4gbm9kZSwgYXBwZW5kaW5nIHRoZSBjaGFuZ2VzXG4vLyB0byB0aGUgZ2l2ZW4gdHJhbnNhY3Rpb24uXG5TZWxlY3Rpb24ucHJvdG90eXBlLnJlcGxhY2VXaXRoID0gZnVuY3Rpb24gcmVwbGFjZVdpdGggKHRyLCBub2RlKSB7XG4gIHZhciBtYXBGcm9tID0gdHIuc3RlcHMubGVuZ3RoLCByYW5nZXMgPSB0aGlzLnJhbmdlcztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcmVmID0gcmFuZ2VzW2ldO1xuICAgICAgdmFyICRmcm9tID0gcmVmLiRmcm9tO1xuICAgICAgdmFyICR0byA9IHJlZi4kdG87XG4gICAgICB2YXIgbWFwcGluZyA9IHRyLm1hcHBpbmcuc2xpY2UobWFwRnJvbSk7XG4gICAgdmFyIGZyb20gPSBtYXBwaW5nLm1hcCgkZnJvbS5wb3MpLCB0byA9IG1hcHBpbmcubWFwKCR0by5wb3MpO1xuICAgIGlmIChpKSB7XG4gICAgICB0ci5kZWxldGVSYW5nZShmcm9tLCB0byk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyLnJlcGxhY2VSYW5nZVdpdGgoZnJvbSwgdG8sIG5vZGUpO1xuICAgICAgc2VsZWN0aW9uVG9JbnNlcnRpb25FbmQodHIsIG1hcEZyb20sIG5vZGUuaXNJbmxpbmUgPyAtMSA6IDEpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gdG9KU09OOjogKCkg4oaSIE9iamVjdFxuLy8gQ29udmVydCB0aGUgc2VsZWN0aW9uIHRvIGEgSlNPTiByZXByZXNlbnRhdGlvbi4gV2hlbiBpbXBsZW1lbnRpbmdcbi8vIHRoaXMgZm9yIGEgY3VzdG9tIHNlbGVjdGlvbiBjbGFzcywgbWFrZSBzdXJlIHRvIGdpdmUgdGhlIG9iamVjdCBhXG4vLyBgdHlwZWAgcHJvcGVydHkgd2hvc2UgdmFsdWUgbWF0Y2hlcyB0aGUgSUQgdW5kZXIgd2hpY2ggeW91XG4vLyBbcmVnaXN0ZXJlZF0oI3N0YXRlLlNlbGVjdGlvbl5qc29uSUQpIHlvdXIgY2xhc3MuXG5cbi8vIDo6IChSZXNvbHZlZFBvcywgbnVtYmVyLCA/Ym9vbCkg4oaSID9TZWxlY3Rpb25cbi8vIEZpbmQgYSB2YWxpZCBjdXJzb3Igb3IgbGVhZiBub2RlIHNlbGVjdGlvbiBzdGFydGluZyBhdCB0aGUgZ2l2ZW5cbi8vIHBvc2l0aW9uIGFuZCBzZWFyY2hpbmcgYmFjayBpZiBgZGlyYCBpcyBuZWdhdGl2ZSwgYW5kIGZvcndhcmQgaWZcbi8vIHBvc2l0aXZlLiBXaGVuIGB0ZXh0T25seWAgaXMgdHJ1ZSwgb25seSBjb25zaWRlciBjdXJzb3Jcbi8vIHNlbGVjdGlvbnMuIFdpbGwgcmV0dXJuIG51bGwgd2hlbiBubyB2YWxpZCBzZWxlY3Rpb24gcG9zaXRpb24gaXNcbi8vIGZvdW5kLlxuU2VsZWN0aW9uLmZpbmRGcm9tID0gZnVuY3Rpb24gZmluZEZyb20gKCRwb3MsIGRpciwgdGV4dE9ubHkpIHtcbiAgdmFyIGlubmVyID0gJHBvcy5wYXJlbnQuaW5saW5lQ29udGVudCA/IG5ldyBUZXh0U2VsZWN0aW9uKCRwb3MpXG4gICAgICA6IGZpbmRTZWxlY3Rpb25JbigkcG9zLm5vZGUoMCksICRwb3MucGFyZW50LCAkcG9zLnBvcywgJHBvcy5pbmRleCgpLCBkaXIsIHRleHRPbmx5KTtcbiAgaWYgKGlubmVyKSB7IHJldHVybiBpbm5lciB9XG5cbiAgZm9yICh2YXIgZGVwdGggPSAkcG9zLmRlcHRoIC0gMTsgZGVwdGggPj0gMDsgZGVwdGgtLSkge1xuICAgIHZhciBmb3VuZCA9IGRpciA8IDBcbiAgICAgICAgPyBmaW5kU2VsZWN0aW9uSW4oJHBvcy5ub2RlKDApLCAkcG9zLm5vZGUoZGVwdGgpLCAkcG9zLmJlZm9yZShkZXB0aCArIDEpLCAkcG9zLmluZGV4KGRlcHRoKSwgZGlyLCB0ZXh0T25seSlcbiAgICAgICAgOiBmaW5kU2VsZWN0aW9uSW4oJHBvcy5ub2RlKDApLCAkcG9zLm5vZGUoZGVwdGgpLCAkcG9zLmFmdGVyKGRlcHRoICsgMSksICRwb3MuaW5kZXgoZGVwdGgpICsgMSwgZGlyLCB0ZXh0T25seSk7XG4gICAgaWYgKGZvdW5kKSB7IHJldHVybiBmb3VuZCB9XG4gIH1cbn07XG5cbi8vIDo6IChSZXNvbHZlZFBvcywgP251bWJlcikg4oaSIFNlbGVjdGlvblxuLy8gRmluZCBhIHZhbGlkIGN1cnNvciBvciBsZWFmIG5vZGUgc2VsZWN0aW9uIG5lYXIgdGhlIGdpdmVuXG4vLyBwb3NpdGlvbi4gU2VhcmNoZXMgZm9yd2FyZCBmaXJzdCBieSBkZWZhdWx0LCBidXQgaWYgYGJpYXNgIGlzXG4vLyBuZWdhdGl2ZSwgaXQgd2lsbCBzZWFyY2ggYmFja3dhcmRzIGZpcnN0LlxuU2VsZWN0aW9uLm5lYXIgPSBmdW5jdGlvbiBuZWFyICgkcG9zLCBiaWFzKSB7XG4gICAgaWYgKCBiaWFzID09PSB2b2lkIDAgKSBiaWFzID0gMTtcblxuICByZXR1cm4gdGhpcy5maW5kRnJvbSgkcG9zLCBiaWFzKSB8fCB0aGlzLmZpbmRGcm9tKCRwb3MsIC1iaWFzKSB8fCBuZXcgQWxsU2VsZWN0aW9uKCRwb3Mubm9kZSgwKSlcbn07XG5cbi8vIDo6IChOb2RlKSDihpIgU2VsZWN0aW9uXG4vLyBGaW5kIHRoZSBjdXJzb3Igb3IgbGVhZiBub2RlIHNlbGVjdGlvbiBjbG9zZXN0IHRvIHRoZSBzdGFydCBvZlxuLy8gdGhlIGdpdmVuIGRvY3VtZW50LiBXaWxsIHJldHVybiBhblxuLy8gW2BBbGxTZWxlY3Rpb25gXSgjc3RhdGUuQWxsU2VsZWN0aW9uKSBpZiBubyB2YWxpZCBwb3NpdGlvblxuLy8gZXhpc3RzLlxuU2VsZWN0aW9uLmF0U3RhcnQgPSBmdW5jdGlvbiBhdFN0YXJ0IChkb2MpIHtcbiAgcmV0dXJuIGZpbmRTZWxlY3Rpb25Jbihkb2MsIGRvYywgMCwgMCwgMSkgfHwgbmV3IEFsbFNlbGVjdGlvbihkb2MpXG59O1xuXG4vLyA6OiAoTm9kZSkg4oaSIFNlbGVjdGlvblxuLy8gRmluZCB0aGUgY3Vyc29yIG9yIGxlYWYgbm9kZSBzZWxlY3Rpb24gY2xvc2VzdCB0byB0aGUgZW5kIG9mIHRoZVxuLy8gZ2l2ZW4gZG9jdW1lbnQuXG5TZWxlY3Rpb24uYXRFbmQgPSBmdW5jdGlvbiBhdEVuZCAoZG9jKSB7XG4gIHJldHVybiBmaW5kU2VsZWN0aW9uSW4oZG9jLCBkb2MsIGRvYy5jb250ZW50LnNpemUsIGRvYy5jaGlsZENvdW50LCAtMSkgfHwgbmV3IEFsbFNlbGVjdGlvbihkb2MpXG59O1xuXG4vLyA6OiAoTm9kZSwgT2JqZWN0KSDihpIgU2VsZWN0aW9uXG4vLyBEZXNlcmlhbGl6ZSB0aGUgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBhIHNlbGVjdGlvbi4gTXVzdCBiZVxuLy8gaW1wbGVtZW50ZWQgZm9yIGN1c3RvbSBjbGFzc2VzIChhcyBhIHN0YXRpYyBjbGFzcyBtZXRob2QpLlxuU2VsZWN0aW9uLmZyb21KU09OID0gZnVuY3Rpb24gZnJvbUpTT04gKGRvYywganNvbikge1xuICBpZiAoIWpzb24gfHwgIWpzb24udHlwZSkgeyB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIFNlbGVjdGlvbi5mcm9tSlNPTlwiKSB9XG4gIHZhciBjbHMgPSBjbGFzc2VzQnlJZFtqc29uLnR5cGVdO1xuICBpZiAoIWNscykgeyB0aHJvdyBuZXcgUmFuZ2VFcnJvcigoXCJObyBzZWxlY3Rpb24gdHlwZSBcIiArIChqc29uLnR5cGUpICsgXCIgZGVmaW5lZFwiKSkgfVxuICByZXR1cm4gY2xzLmZyb21KU09OKGRvYywganNvbilcbn07XG5cbi8vIDo6IChzdHJpbmcsIGNvbnN0cnVjdG9yPFNlbGVjdGlvbj4pXG4vLyBUbyBiZSBhYmxlIHRvIGRlc2VyaWFsaXplIHNlbGVjdGlvbnMgZnJvbSBKU09OLCBjdXN0b20gc2VsZWN0aW9uXG4vLyBjbGFzc2VzIG11c3QgcmVnaXN0ZXIgdGhlbXNlbHZlcyB3aXRoIGFuIElEIHN0cmluZywgc28gdGhhdCB0aGV5XG4vLyBjYW4gYmUgZGlzYW1iaWd1YXRlZC4gVHJ5IHRvIHBpY2sgc29tZXRoaW5nIHRoYXQncyB1bmxpa2VseSB0b1xuLy8gY2xhc2ggd2l0aCBjbGFzc2VzIGZyb20gb3RoZXIgbW9kdWxlcy5cblNlbGVjdGlvbi5qc29uSUQgPSBmdW5jdGlvbiBqc29uSUQgKGlkLCBzZWxlY3Rpb25DbGFzcykge1xuICBpZiAoaWQgaW4gY2xhc3Nlc0J5SWQpIHsgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJEdXBsaWNhdGUgdXNlIG9mIHNlbGVjdGlvbiBKU09OIElEIFwiICsgaWQpIH1cbiAgY2xhc3Nlc0J5SWRbaWRdID0gc2VsZWN0aW9uQ2xhc3M7XG4gIHNlbGVjdGlvbkNsYXNzLnByb3RvdHlwZS5qc29uSUQgPSBpZDtcbiAgcmV0dXJuIHNlbGVjdGlvbkNsYXNzXG59O1xuXG4vLyA6OiAoKSDihpIgU2VsZWN0aW9uQm9va21hcmtcbi8vIEdldCBhIFtib29rbWFya10oI3N0YXRlLlNlbGVjdGlvbkJvb2ttYXJrKSBmb3IgdGhpcyBzZWxlY3Rpb24sXG4vLyB3aGljaCBpcyBhIHZhbHVlIHRoYXQgY2FuIGJlIG1hcHBlZCB3aXRob3V0IGhhdmluZyBhY2Nlc3MgdG8gYVxuLy8gY3VycmVudCBkb2N1bWVudCwgYW5kIGxhdGVyIHJlc29sdmVkIHRvIGEgcmVhbCBzZWxlY3Rpb24gZm9yIGFcbi8vIGdpdmVuIGRvY3VtZW50IGFnYWluLiAoVGhpcyBpcyB1c2VkIG1vc3RseSBieSB0aGUgaGlzdG9yeSB0b1xuLy8gdHJhY2sgYW5kIHJlc3RvcmUgb2xkIHNlbGVjdGlvbnMuKSBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZlxuLy8gdGhpcyBtZXRob2QganVzdCBjb252ZXJ0cyB0aGUgc2VsZWN0aW9uIHRvIGEgdGV4dCBzZWxlY3Rpb24gYW5kXG4vLyByZXR1cm5zIHRoZSBib29rbWFyayBmb3IgdGhhdC5cblNlbGVjdGlvbi5wcm90b3R5cGUuZ2V0Qm9va21hcmsgPSBmdW5jdGlvbiBnZXRCb29rbWFyayAoKSB7XG4gIHJldHVybiBUZXh0U2VsZWN0aW9uLmJldHdlZW4odGhpcy4kYW5jaG9yLCB0aGlzLiRoZWFkKS5nZXRCb29rbWFyaygpXG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggU2VsZWN0aW9uLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzICk7XG5cbi8vIDo6IGJvb2xcbi8vIENvbnRyb2xzIHdoZXRoZXIsIHdoZW4gYSBzZWxlY3Rpb24gb2YgdGhpcyB0eXBlIGlzIGFjdGl2ZSBpbiB0aGVcbi8vIGJyb3dzZXIsIHRoZSBzZWxlY3RlZCByYW5nZSBzaG91bGQgYmUgdmlzaWJsZSB0byB0aGUgdXNlci4gRGVmYXVsdHNcbi8vIHRvIGB0cnVlYC5cblNlbGVjdGlvbi5wcm90b3R5cGUudmlzaWJsZSA9IHRydWU7XG5cbi8vIFNlbGVjdGlvbkJvb2ttYXJrOjogaW50ZXJmYWNlXG4vLyBBIGxpZ2h0d2VpZ2h0LCBkb2N1bWVudC1pbmRlcGVuZGVudCByZXByZXNlbnRhdGlvbiBvZiBhIHNlbGVjdGlvbi5cbi8vIFlvdSBjYW4gZGVmaW5lIGEgY3VzdG9tIGJvb2ttYXJrIHR5cGUgZm9yIGEgY3VzdG9tIHNlbGVjdGlvbiBjbGFzc1xuLy8gdG8gbWFrZSB0aGUgaGlzdG9yeSBoYW5kbGUgaXQgd2VsbC5cbi8vXG4vLyAgIG1hcDo6IChtYXBwaW5nOiBNYXBwaW5nKSDihpIgU2VsZWN0aW9uQm9va21hcmtcbi8vICAgTWFwIHRoZSBib29rbWFyayB0aHJvdWdoIGEgc2V0IG9mIGNoYW5nZXMuXG4vL1xuLy8gICByZXNvbHZlOjogKGRvYzogTm9kZSkg4oaSIFNlbGVjdGlvblxuLy8gICBSZXNvbHZlIHRoZSBib29rbWFyayB0byBhIHJlYWwgc2VsZWN0aW9uIGFnYWluLiBUaGlzIG1heSBuZWVkIHRvXG4vLyAgIGRvIHNvbWUgZXJyb3IgY2hlY2tpbmcgYW5kIG1heSBmYWxsIGJhY2sgdG8gYSBkZWZhdWx0ICh1c3VhbGx5XG4vLyAgIFtgVGV4dFNlbGVjdGlvbi5iZXR3ZWVuYF0oI3N0YXRlLlRleHRTZWxlY3Rpb25eYmV0d2VlbikpIGlmXG4vLyAgIG1hcHBpbmcgbWFkZSB0aGUgYm9va21hcmsgaW52YWxpZC5cblxuLy8gOjotIFJlcHJlc2VudHMgYSBzZWxlY3RlZCByYW5nZSBpbiBhIGRvY3VtZW50LlxudmFyIFNlbGVjdGlvblJhbmdlID0gZnVuY3Rpb24gU2VsZWN0aW9uUmFuZ2UoJGZyb20sICR0bykge1xuICAvLyA6OiBSZXNvbHZlZFBvc1xuICAvLyBUaGUgbG93ZXIgYm91bmQgb2YgdGhlIHJhbmdlLlxuICB0aGlzLiRmcm9tID0gJGZyb207XG4gIC8vIDo6IFJlc29sdmVkUG9zXG4gIC8vIFRoZSB1cHBlciBib3VuZCBvZiB0aGUgcmFuZ2UuXG4gIHRoaXMuJHRvID0gJHRvO1xufTtcblxuLy8gOjotIEEgdGV4dCBzZWxlY3Rpb24gcmVwcmVzZW50cyBhIGNsYXNzaWNhbCBlZGl0b3Igc2VsZWN0aW9uLCB3aXRoXG4vLyBhIGhlYWQgKHRoZSBtb3Zpbmcgc2lkZSkgYW5kIGFuY2hvciAoaW1tb2JpbGUgc2lkZSksIGJvdGggb2Ygd2hpY2hcbi8vIHBvaW50IGludG8gdGV4dGJsb2NrIG5vZGVzLiBJdCBjYW4gYmUgZW1wdHkgKGEgcmVndWxhciBjdXJzb3Jcbi8vIHBvc2l0aW9uKS5cbnZhciBUZXh0U2VsZWN0aW9uID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoU2VsZWN0aW9uKSB7XG4gIGZ1bmN0aW9uIFRleHRTZWxlY3Rpb24oJGFuY2hvciwgJGhlYWQpIHtcbiAgICBpZiAoICRoZWFkID09PSB2b2lkIDAgKSAkaGVhZCA9ICRhbmNob3I7XG5cbiAgICBTZWxlY3Rpb24uY2FsbCh0aGlzLCAkYW5jaG9yLCAkaGVhZCk7XG4gIH1cblxuICBpZiAoIFNlbGVjdGlvbiApIFRleHRTZWxlY3Rpb24uX19wcm90b19fID0gU2VsZWN0aW9uO1xuICBUZXh0U2VsZWN0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFNlbGVjdGlvbiAmJiBTZWxlY3Rpb24ucHJvdG90eXBlICk7XG4gIFRleHRTZWxlY3Rpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVGV4dFNlbGVjdGlvbjtcblxuICB2YXIgcHJvdG90eXBlQWNjZXNzb3JzJDEgPSB7ICRjdXJzb3I6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxuICAvLyA6OiA/UmVzb2x2ZWRQb3NcbiAgLy8gUmV0dXJucyBhIHJlc29sdmVkIHBvc2l0aW9uIGlmIHRoaXMgaXMgYSBjdXJzb3Igc2VsZWN0aW9uIChhblxuICAvLyBlbXB0eSB0ZXh0IHNlbGVjdGlvbiksIGFuZCBudWxsIG90aGVyd2lzZS5cbiAgcHJvdG90eXBlQWNjZXNzb3JzJDEuJGN1cnNvci5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLiRhbmNob3IucG9zID09IHRoaXMuJGhlYWQucG9zID8gdGhpcy4kaGVhZCA6IG51bGwgfTtcblxuICBUZXh0U2VsZWN0aW9uLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiBtYXAgKGRvYywgbWFwcGluZykge1xuICAgIHZhciAkaGVhZCA9IGRvYy5yZXNvbHZlKG1hcHBpbmcubWFwKHRoaXMuaGVhZCkpO1xuICAgIGlmICghJGhlYWQucGFyZW50LmlubGluZUNvbnRlbnQpIHsgcmV0dXJuIFNlbGVjdGlvbi5uZWFyKCRoZWFkKSB9XG4gICAgdmFyICRhbmNob3IgPSBkb2MucmVzb2x2ZShtYXBwaW5nLm1hcCh0aGlzLmFuY2hvcikpO1xuICAgIHJldHVybiBuZXcgVGV4dFNlbGVjdGlvbigkYW5jaG9yLnBhcmVudC5pbmxpbmVDb250ZW50ID8gJGFuY2hvciA6ICRoZWFkLCAkaGVhZClcbiAgfTtcblxuICBUZXh0U2VsZWN0aW9uLnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZSAodHIsIGNvbnRlbnQpIHtcbiAgICBpZiAoIGNvbnRlbnQgPT09IHZvaWQgMCApIGNvbnRlbnQgPSBTbGljZS5lbXB0eTtcblxuICAgIFNlbGVjdGlvbi5wcm90b3R5cGUucmVwbGFjZS5jYWxsKHRoaXMsIHRyLCBjb250ZW50KTtcbiAgICBpZiAoY29udGVudCA9PSBTbGljZS5lbXB0eSkge1xuICAgICAgdmFyIG1hcmtzID0gdGhpcy4kZnJvbS5tYXJrc0Fjcm9zcyh0aGlzLiR0byk7XG4gICAgICBpZiAobWFya3MpIHsgdHIuZW5zdXJlTWFya3MobWFya3MpOyB9XG4gICAgfVxuICB9O1xuXG4gIFRleHRTZWxlY3Rpb24ucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gZXEgKG90aGVyKSB7XG4gICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbiAmJiBvdGhlci5hbmNob3IgPT0gdGhpcy5hbmNob3IgJiYgb3RoZXIuaGVhZCA9PSB0aGlzLmhlYWRcbiAgfTtcblxuICBUZXh0U2VsZWN0aW9uLnByb3RvdHlwZS5nZXRCb29rbWFyayA9IGZ1bmN0aW9uIGdldEJvb2ttYXJrICgpIHtcbiAgICByZXR1cm4gbmV3IFRleHRCb29rbWFyayh0aGlzLmFuY2hvciwgdGhpcy5oZWFkKVxuICB9O1xuXG4gIFRleHRTZWxlY3Rpb24ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gICAgcmV0dXJuIHt0eXBlOiBcInRleHRcIiwgYW5jaG9yOiB0aGlzLmFuY2hvciwgaGVhZDogdGhpcy5oZWFkfVxuICB9O1xuXG4gIFRleHRTZWxlY3Rpb24uZnJvbUpTT04gPSBmdW5jdGlvbiBmcm9tSlNPTiAoZG9jLCBqc29uKSB7XG4gICAgaWYgKHR5cGVvZiBqc29uLmFuY2hvciAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiBqc29uLmhlYWQgIT0gXCJudW1iZXJcIilcbiAgICAgIHsgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBUZXh0U2VsZWN0aW9uLmZyb21KU09OXCIpIH1cbiAgICByZXR1cm4gbmV3IFRleHRTZWxlY3Rpb24oZG9jLnJlc29sdmUoanNvbi5hbmNob3IpLCBkb2MucmVzb2x2ZShqc29uLmhlYWQpKVxuICB9O1xuXG4gIC8vIDo6IChOb2RlLCBudW1iZXIsID9udW1iZXIpIOKGkiBUZXh0U2VsZWN0aW9uXG4gIC8vIENyZWF0ZSBhIHRleHQgc2VsZWN0aW9uIGZyb20gbm9uLXJlc29sdmVkIHBvc2l0aW9ucy5cbiAgVGV4dFNlbGVjdGlvbi5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUgKGRvYywgYW5jaG9yLCBoZWFkKSB7XG4gICAgaWYgKCBoZWFkID09PSB2b2lkIDAgKSBoZWFkID0gYW5jaG9yO1xuXG4gICAgdmFyICRhbmNob3IgPSBkb2MucmVzb2x2ZShhbmNob3IpO1xuICAgIHJldHVybiBuZXcgdGhpcygkYW5jaG9yLCBoZWFkID09IGFuY2hvciA/ICRhbmNob3IgOiBkb2MucmVzb2x2ZShoZWFkKSlcbiAgfTtcblxuICAvLyA6OiAoUmVzb2x2ZWRQb3MsIFJlc29sdmVkUG9zLCA/bnVtYmVyKSDihpIgU2VsZWN0aW9uXG4gIC8vIFJldHVybiBhIHRleHQgc2VsZWN0aW9uIHRoYXQgc3BhbnMgdGhlIGdpdmVuIHBvc2l0aW9ucyBvciwgaWZcbiAgLy8gdGhleSBhcmVuJ3QgdGV4dCBwb3NpdGlvbnMsIGZpbmQgYSB0ZXh0IHNlbGVjdGlvbiBuZWFyIHRoZW0uXG4gIC8vIGBiaWFzYCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG1ldGhvZCBzZWFyY2hlcyBmb3J3YXJkIChkZWZhdWx0KVxuICAvLyBvciBiYWNrd2FyZHMgKG5lZ2F0aXZlIG51bWJlcikgZmlyc3QuIFdpbGwgZmFsbCBiYWNrIHRvIGNhbGxpbmdcbiAgLy8gW2BTZWxlY3Rpb24ubmVhcmBdKCNzdGF0ZS5TZWxlY3Rpb25ebmVhcikgd2hlbiB0aGUgZG9jdW1lbnRcbiAgLy8gZG9lc24ndCBjb250YWluIGEgdmFsaWQgdGV4dCBwb3NpdGlvbi5cbiAgVGV4dFNlbGVjdGlvbi5iZXR3ZWVuID0gZnVuY3Rpb24gYmV0d2VlbiAoJGFuY2hvciwgJGhlYWQsIGJpYXMpIHtcbiAgICB2YXIgZFBvcyA9ICRhbmNob3IucG9zIC0gJGhlYWQucG9zO1xuICAgIGlmICghYmlhcyB8fCBkUG9zKSB7IGJpYXMgPSBkUG9zID49IDAgPyAxIDogLTE7IH1cbiAgICBpZiAoISRoZWFkLnBhcmVudC5pbmxpbmVDb250ZW50KSB7XG4gICAgICB2YXIgZm91bmQgPSBTZWxlY3Rpb24uZmluZEZyb20oJGhlYWQsIGJpYXMsIHRydWUpIHx8IFNlbGVjdGlvbi5maW5kRnJvbSgkaGVhZCwgLWJpYXMsIHRydWUpO1xuICAgICAgaWYgKGZvdW5kKSB7ICRoZWFkID0gZm91bmQuJGhlYWQ7IH1cbiAgICAgIGVsc2UgeyByZXR1cm4gU2VsZWN0aW9uLm5lYXIoJGhlYWQsIGJpYXMpIH1cbiAgICB9XG4gICAgaWYgKCEkYW5jaG9yLnBhcmVudC5pbmxpbmVDb250ZW50KSB7XG4gICAgICBpZiAoZFBvcyA9PSAwKSB7XG4gICAgICAgICRhbmNob3IgPSAkaGVhZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRhbmNob3IgPSAoU2VsZWN0aW9uLmZpbmRGcm9tKCRhbmNob3IsIC1iaWFzLCB0cnVlKSB8fCBTZWxlY3Rpb24uZmluZEZyb20oJGFuY2hvciwgYmlhcywgdHJ1ZSkpLiRhbmNob3I7XG4gICAgICAgIGlmICgoJGFuY2hvci5wb3MgPCAkaGVhZC5wb3MpICE9IChkUG9zIDwgMCkpIHsgJGFuY2hvciA9ICRoZWFkOyB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgVGV4dFNlbGVjdGlvbigkYW5jaG9yLCAkaGVhZClcbiAgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggVGV4dFNlbGVjdGlvbi5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyQxICk7XG5cbiAgcmV0dXJuIFRleHRTZWxlY3Rpb247XG59KFNlbGVjdGlvbikpO1xuXG5TZWxlY3Rpb24uanNvbklEKFwidGV4dFwiLCBUZXh0U2VsZWN0aW9uKTtcblxudmFyIFRleHRCb29rbWFyayA9IGZ1bmN0aW9uIFRleHRCb29rbWFyayhhbmNob3IsIGhlYWQpIHtcbiAgdGhpcy5hbmNob3IgPSBhbmNob3I7XG4gIHRoaXMuaGVhZCA9IGhlYWQ7XG59O1xuVGV4dEJvb2ttYXJrLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiBtYXAgKG1hcHBpbmcpIHtcbiAgcmV0dXJuIG5ldyBUZXh0Qm9va21hcmsobWFwcGluZy5tYXAodGhpcy5hbmNob3IpLCBtYXBwaW5nLm1hcCh0aGlzLmhlYWQpKVxufTtcblRleHRCb29rbWFyay5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uIHJlc29sdmUgKGRvYykge1xuICByZXR1cm4gVGV4dFNlbGVjdGlvbi5iZXR3ZWVuKGRvYy5yZXNvbHZlKHRoaXMuYW5jaG9yKSwgZG9jLnJlc29sdmUodGhpcy5oZWFkKSlcbn07XG5cbi8vIDo6LSBBIG5vZGUgc2VsZWN0aW9uIGlzIGEgc2VsZWN0aW9uIHRoYXQgcG9pbnRzIGF0IGEgc2luZ2xlIG5vZGUuXG4vLyBBbGwgbm9kZXMgbWFya2VkIFtzZWxlY3RhYmxlXSgjbW9kZWwuTm9kZVNwZWMuc2VsZWN0YWJsZSkgY2FuIGJlXG4vLyB0aGUgdGFyZ2V0IG9mIGEgbm9kZSBzZWxlY3Rpb24uIEluIHN1Y2ggYSBzZWxlY3Rpb24sIGBmcm9tYCBhbmRcbi8vIGB0b2AgcG9pbnQgZGlyZWN0bHkgYmVmb3JlIGFuZCBhZnRlciB0aGUgc2VsZWN0ZWQgbm9kZSwgYGFuY2hvcmBcbi8vIGVxdWFscyBgZnJvbWAsIGFuZCBgaGVhZGAgZXF1YWxzIGB0b2AuLlxudmFyIE5vZGVTZWxlY3Rpb24gPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChTZWxlY3Rpb24pIHtcbiAgZnVuY3Rpb24gTm9kZVNlbGVjdGlvbigkcG9zKSB7XG4gICAgdmFyIG5vZGUgPSAkcG9zLm5vZGVBZnRlcjtcbiAgICB2YXIgJGVuZCA9ICRwb3Mubm9kZSgwKS5yZXNvbHZlKCRwb3MucG9zICsgbm9kZS5ub2RlU2l6ZSk7XG4gICAgU2VsZWN0aW9uLmNhbGwodGhpcywgJHBvcywgJGVuZCk7XG4gICAgLy8gOjogTm9kZSBUaGUgc2VsZWN0ZWQgbm9kZS5cbiAgICB0aGlzLm5vZGUgPSBub2RlO1xuICB9XG5cbiAgaWYgKCBTZWxlY3Rpb24gKSBOb2RlU2VsZWN0aW9uLl9fcHJvdG9fXyA9IFNlbGVjdGlvbjtcbiAgTm9kZVNlbGVjdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBTZWxlY3Rpb24gJiYgU2VsZWN0aW9uLnByb3RvdHlwZSApO1xuICBOb2RlU2VsZWN0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE5vZGVTZWxlY3Rpb247XG5cbiAgTm9kZVNlbGVjdGlvbi5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gbWFwIChkb2MsIG1hcHBpbmcpIHtcbiAgICB2YXIgcmVmID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy5hbmNob3IpO1xuICAgIHZhciBkZWxldGVkID0gcmVmLmRlbGV0ZWQ7XG4gICAgdmFyIHBvcyA9IHJlZi5wb3M7XG4gICAgdmFyICRwb3MgPSBkb2MucmVzb2x2ZShwb3MpO1xuICAgIGlmIChkZWxldGVkKSB7IHJldHVybiBTZWxlY3Rpb24ubmVhcigkcG9zKSB9XG4gICAgcmV0dXJuIG5ldyBOb2RlU2VsZWN0aW9uKCRwb3MpXG4gIH07XG5cbiAgTm9kZVNlbGVjdGlvbi5wcm90b3R5cGUuY29udGVudCA9IGZ1bmN0aW9uIGNvbnRlbnQgKCkge1xuICAgIHJldHVybiBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbSh0aGlzLm5vZGUpLCAwLCAwKVxuICB9O1xuXG4gIE5vZGVTZWxlY3Rpb24ucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gZXEgKG90aGVyKSB7XG4gICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbiAmJiBvdGhlci5hbmNob3IgPT0gdGhpcy5hbmNob3JcbiAgfTtcblxuICBOb2RlU2VsZWN0aW9uLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICAgIHJldHVybiB7dHlwZTogXCJub2RlXCIsIGFuY2hvcjogdGhpcy5hbmNob3J9XG4gIH07XG5cbiAgTm9kZVNlbGVjdGlvbi5wcm90b3R5cGUuZ2V0Qm9va21hcmsgPSBmdW5jdGlvbiBnZXRCb29rbWFyayAoKSB7IHJldHVybiBuZXcgTm9kZUJvb2ttYXJrKHRoaXMuYW5jaG9yKSB9O1xuXG4gIE5vZGVTZWxlY3Rpb24uZnJvbUpTT04gPSBmdW5jdGlvbiBmcm9tSlNPTiAoZG9jLCBqc29uKSB7XG4gICAgaWYgKHR5cGVvZiBqc29uLmFuY2hvciAhPSBcIm51bWJlclwiKVxuICAgICAgeyB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIE5vZGVTZWxlY3Rpb24uZnJvbUpTT05cIikgfVxuICAgIHJldHVybiBuZXcgTm9kZVNlbGVjdGlvbihkb2MucmVzb2x2ZShqc29uLmFuY2hvcikpXG4gIH07XG5cbiAgLy8gOjogKE5vZGUsIG51bWJlcikg4oaSIE5vZGVTZWxlY3Rpb25cbiAgLy8gQ3JlYXRlIGEgbm9kZSBzZWxlY3Rpb24gZnJvbSBub24tcmVzb2x2ZWQgcG9zaXRpb25zLlxuICBOb2RlU2VsZWN0aW9uLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZSAoZG9jLCBmcm9tKSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzKGRvYy5yZXNvbHZlKGZyb20pKVxuICB9O1xuXG4gIC8vIDo6IChOb2RlKSDihpIgYm9vbFxuICAvLyBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGdpdmVuIG5vZGUgbWF5IGJlIHNlbGVjdGVkIGFzIGEgbm9kZVxuICAvLyBzZWxlY3Rpb24uXG4gIE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlID0gZnVuY3Rpb24gaXNTZWxlY3RhYmxlIChub2RlKSB7XG4gICAgcmV0dXJuICFub2RlLmlzVGV4dCAmJiBub2RlLnR5cGUuc3BlYy5zZWxlY3RhYmxlICE9PSBmYWxzZVxuICB9O1xuXG4gIHJldHVybiBOb2RlU2VsZWN0aW9uO1xufShTZWxlY3Rpb24pKTtcblxuTm9kZVNlbGVjdGlvbi5wcm90b3R5cGUudmlzaWJsZSA9IGZhbHNlO1xuXG5TZWxlY3Rpb24uanNvbklEKFwibm9kZVwiLCBOb2RlU2VsZWN0aW9uKTtcblxudmFyIE5vZGVCb29rbWFyayA9IGZ1bmN0aW9uIE5vZGVCb29rbWFyayhhbmNob3IpIHtcbiAgdGhpcy5hbmNob3IgPSBhbmNob3I7XG59O1xuTm9kZUJvb2ttYXJrLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiBtYXAgKG1hcHBpbmcpIHtcbiAgdmFyIHJlZiA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMuYW5jaG9yKTtcbiAgICB2YXIgZGVsZXRlZCA9IHJlZi5kZWxldGVkO1xuICAgIHZhciBwb3MgPSByZWYucG9zO1xuICByZXR1cm4gZGVsZXRlZCA/IG5ldyBUZXh0Qm9va21hcmsocG9zLCBwb3MpIDogbmV3IE5vZGVCb29rbWFyayhwb3MpXG59O1xuTm9kZUJvb2ttYXJrLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZSAoZG9jKSB7XG4gIHZhciAkcG9zID0gZG9jLnJlc29sdmUodGhpcy5hbmNob3IpLCBub2RlID0gJHBvcy5ub2RlQWZ0ZXI7XG4gIGlmIChub2RlICYmIE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKG5vZGUpKSB7IHJldHVybiBuZXcgTm9kZVNlbGVjdGlvbigkcG9zKSB9XG4gIHJldHVybiBTZWxlY3Rpb24ubmVhcigkcG9zKVxufTtcblxuLy8gOjotIEEgc2VsZWN0aW9uIHR5cGUgdGhhdCByZXByZXNlbnRzIHNlbGVjdGluZyB0aGUgd2hvbGUgZG9jdW1lbnRcbi8vICh3aGljaCBjYW4gbm90IG5lY2Vzc2FyaWx5IGJlIGV4cHJlc3NlZCB3aXRoIGEgdGV4dCBzZWxlY3Rpb24sIHdoZW5cbi8vIHRoZXJlIGFyZSBmb3IgZXhhbXBsZSBsZWFmIGJsb2NrIG5vZGVzIGF0IHRoZSBzdGFydCBvciBlbmQgb2YgdGhlXG4vLyBkb2N1bWVudCkuXG52YXIgQWxsU2VsZWN0aW9uID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoU2VsZWN0aW9uKSB7XG4gIGZ1bmN0aW9uIEFsbFNlbGVjdGlvbihkb2MpIHtcbiAgICBTZWxlY3Rpb24uY2FsbCh0aGlzLCBkb2MucmVzb2x2ZSgwKSwgZG9jLnJlc29sdmUoZG9jLmNvbnRlbnQuc2l6ZSkpO1xuICB9XG5cbiAgaWYgKCBTZWxlY3Rpb24gKSBBbGxTZWxlY3Rpb24uX19wcm90b19fID0gU2VsZWN0aW9uO1xuICBBbGxTZWxlY3Rpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggU2VsZWN0aW9uICYmIFNlbGVjdGlvbi5wcm90b3R5cGUgKTtcbiAgQWxsU2VsZWN0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFsbFNlbGVjdGlvbjtcblxuICBBbGxTZWxlY3Rpb24ucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlICh0ciwgY29udGVudCkge1xuICAgIGlmICggY29udGVudCA9PT0gdm9pZCAwICkgY29udGVudCA9IFNsaWNlLmVtcHR5O1xuXG4gICAgaWYgKGNvbnRlbnQgPT0gU2xpY2UuZW1wdHkpIHtcbiAgICAgIHRyLmRlbGV0ZSgwLCB0ci5kb2MuY29udGVudC5zaXplKTtcbiAgICAgIHZhciBzZWwgPSBTZWxlY3Rpb24uYXRTdGFydCh0ci5kb2MpO1xuICAgICAgaWYgKCFzZWwuZXEodHIuc2VsZWN0aW9uKSkgeyB0ci5zZXRTZWxlY3Rpb24oc2VsKTsgfVxuICAgIH0gZWxzZSB7XG4gICAgICBTZWxlY3Rpb24ucHJvdG90eXBlLnJlcGxhY2UuY2FsbCh0aGlzLCB0ciwgY29udGVudCk7XG4gICAgfVxuICB9O1xuXG4gIEFsbFNlbGVjdGlvbi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHsgcmV0dXJuIHt0eXBlOiBcImFsbFwifSB9O1xuXG4gIEFsbFNlbGVjdGlvbi5mcm9tSlNPTiA9IGZ1bmN0aW9uIGZyb21KU09OIChkb2MpIHsgcmV0dXJuIG5ldyBBbGxTZWxlY3Rpb24oZG9jKSB9O1xuXG4gIEFsbFNlbGVjdGlvbi5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gbWFwIChkb2MpIHsgcmV0dXJuIG5ldyBBbGxTZWxlY3Rpb24oZG9jKSB9O1xuXG4gIEFsbFNlbGVjdGlvbi5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbiBlcSAob3RoZXIpIHsgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgQWxsU2VsZWN0aW9uIH07XG5cbiAgQWxsU2VsZWN0aW9uLnByb3RvdHlwZS5nZXRCb29rbWFyayA9IGZ1bmN0aW9uIGdldEJvb2ttYXJrICgpIHsgcmV0dXJuIEFsbEJvb2ttYXJrIH07XG5cbiAgcmV0dXJuIEFsbFNlbGVjdGlvbjtcbn0oU2VsZWN0aW9uKSk7XG5cblNlbGVjdGlvbi5qc29uSUQoXCJhbGxcIiwgQWxsU2VsZWN0aW9uKTtcblxudmFyIEFsbEJvb2ttYXJrID0ge1xuICBtYXA6IGZ1bmN0aW9uIG1hcCgpIHsgcmV0dXJuIHRoaXMgfSxcbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZShkb2MpIHsgcmV0dXJuIG5ldyBBbGxTZWxlY3Rpb24oZG9jKSB9XG59O1xuXG4vLyBGSVhNRSB3ZSdsbCBuZWVkIHNvbWUgYXdhcmVuZXNzIG9mIHRleHQgZGlyZWN0aW9uIHdoZW4gc2Nhbm5pbmcgZm9yIHNlbGVjdGlvbnNcblxuLy8gVHJ5IHRvIGZpbmQgYSBzZWxlY3Rpb24gaW5zaWRlIHRoZSBnaXZlbiBub2RlLiBgcG9zYCBwb2ludHMgYXQgdGhlXG4vLyBwb3NpdGlvbiB3aGVyZSB0aGUgc2VhcmNoIHN0YXJ0cy4gV2hlbiBgdGV4dGAgaXMgdHJ1ZSwgb25seSByZXR1cm5cbi8vIHRleHQgc2VsZWN0aW9ucy5cbmZ1bmN0aW9uIGZpbmRTZWxlY3Rpb25Jbihkb2MsIG5vZGUsIHBvcywgaW5kZXgsIGRpciwgdGV4dCkge1xuICBpZiAobm9kZS5pbmxpbmVDb250ZW50KSB7IHJldHVybiBUZXh0U2VsZWN0aW9uLmNyZWF0ZShkb2MsIHBvcykgfVxuICBmb3IgKHZhciBpID0gaW5kZXggLSAoZGlyID4gMCA/IDAgOiAxKTsgZGlyID4gMCA/IGkgPCBub2RlLmNoaWxkQ291bnQgOiBpID49IDA7IGkgKz0gZGlyKSB7XG4gICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZChpKTtcbiAgICBpZiAoIWNoaWxkLmlzQXRvbSkge1xuICAgICAgdmFyIGlubmVyID0gZmluZFNlbGVjdGlvbkluKGRvYywgY2hpbGQsIHBvcyArIGRpciwgZGlyIDwgMCA/IGNoaWxkLmNoaWxkQ291bnQgOiAwLCBkaXIsIHRleHQpO1xuICAgICAgaWYgKGlubmVyKSB7IHJldHVybiBpbm5lciB9XG4gICAgfSBlbHNlIGlmICghdGV4dCAmJiBOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShjaGlsZCkpIHtcbiAgICAgIHJldHVybiBOb2RlU2VsZWN0aW9uLmNyZWF0ZShkb2MsIHBvcyAtIChkaXIgPCAwID8gY2hpbGQubm9kZVNpemUgOiAwKSlcbiAgICB9XG4gICAgcG9zICs9IGNoaWxkLm5vZGVTaXplICogZGlyO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvblRvSW5zZXJ0aW9uRW5kKHRyLCBzdGFydExlbiwgYmlhcykge1xuICB2YXIgbGFzdCA9IHRyLnN0ZXBzLmxlbmd0aCAtIDE7XG4gIGlmIChsYXN0IDwgc3RhcnRMZW4pIHsgcmV0dXJuIH1cbiAgdmFyIHN0ZXAgPSB0ci5zdGVwc1tsYXN0XTtcbiAgaWYgKCEoc3RlcCBpbnN0YW5jZW9mIFJlcGxhY2VTdGVwIHx8IHN0ZXAgaW5zdGFuY2VvZiBSZXBsYWNlQXJvdW5kU3RlcCkpIHsgcmV0dXJuIH1cbiAgdmFyIG1hcCA9IHRyLm1hcHBpbmcubWFwc1tsYXN0XSwgZW5kO1xuICBtYXAuZm9yRWFjaChmdW5jdGlvbiAoX2Zyb20sIF90bywgX25ld0Zyb20sIG5ld1RvKSB7IGlmIChlbmQgPT0gbnVsbCkgeyBlbmQgPSBuZXdUbzsgfSB9KTtcbiAgdHIuc2V0U2VsZWN0aW9uKFNlbGVjdGlvbi5uZWFyKHRyLmRvYy5yZXNvbHZlKGVuZCksIGJpYXMpKTtcbn1cblxudmFyIFVQREFURURfU0VMID0gMSwgVVBEQVRFRF9NQVJLUyA9IDIsIFVQREFURURfU0NST0xMID0gNDtcblxuLy8gOjotIEFuIGVkaXRvciBzdGF0ZSB0cmFuc2FjdGlvbiwgd2hpY2ggY2FuIGJlIGFwcGxpZWQgdG8gYSBzdGF0ZSB0b1xuLy8gY3JlYXRlIGFuIHVwZGF0ZWQgc3RhdGUuIFVzZVxuLy8gW2BFZGl0b3JTdGF0ZS50cmBdKCNzdGF0ZS5FZGl0b3JTdGF0ZS50cikgdG8gY3JlYXRlIGFuIGluc3RhbmNlLlxuLy9cbi8vIFRyYW5zYWN0aW9ucyB0cmFjayBjaGFuZ2VzIHRvIHRoZSBkb2N1bWVudCAodGhleSBhcmUgYSBzdWJjbGFzcyBvZlxuLy8gW2BUcmFuc2Zvcm1gXSgjdHJhbnNmb3JtLlRyYW5zZm9ybSkpLCBidXQgYWxzbyBvdGhlciBzdGF0ZSBjaGFuZ2VzLFxuLy8gbGlrZSBzZWxlY3Rpb24gdXBkYXRlcyBhbmQgYWRqdXN0bWVudHMgb2YgdGhlIHNldCBvZiBbc3RvcmVkXG4vLyBtYXJrc10oI3N0YXRlLkVkaXRvclN0YXRlLnN0b3JlZE1hcmtzKS4gSW4gYWRkaXRpb24sIHlvdSBjYW4gc3RvcmVcbi8vIG1ldGFkYXRhIHByb3BlcnRpZXMgaW4gYSB0cmFuc2FjdGlvbiwgd2hpY2ggYXJlIGV4dHJhIHBpZWNlcyBvZlxuLy8gaW5mb3JtYXRpb24gdGhhdCBjbGllbnQgY29kZSBvciBwbHVnaW5zIGNhbiB1c2UgdG8gZGVzY3JpYmUgd2hhdCBhXG4vLyB0cmFuc2FjaW9uIHJlcHJlc2VudHMsIHNvIHRoYXQgdGhleSBjYW4gdXBkYXRlIHRoZWlyIFtvd25cbi8vIHN0YXRlXSgjc3RhdGUuU3RhdGVGaWVsZCkgYWNjb3JkaW5nbHkuXG4vL1xuLy8gVGhlIFtlZGl0b3Igdmlld10oI3ZpZXcuRWRpdG9yVmlldykgdXNlcyBhIGZldyBtZXRhZGF0YSBwcm9wZXJ0aWVzOlxuLy8gaXQgd2lsbCBhdHRhY2ggYSBwcm9wZXJ0eSBgXCJwb2ludGVyXCJgIHdpdGggdGhlIHZhbHVlIGB0cnVlYCB0b1xuLy8gc2VsZWN0aW9uIHRyYW5zYWN0aW9ucyBkaXJlY3RseSBjYXVzZWQgYnkgbW91c2Ugb3IgdG91Y2ggaW5wdXQsIGFuZFxuLy8gYSBgXCJ1aUV2ZW50XCJgIHByb3BlcnR5IG9mIHRoYXQgbWF5IGJlIGBcInBhc3RlXCJgLCBgXCJjdXRcImAsIG9yIGBcImRyb3BcImAuXG52YXIgVHJhbnNhY3Rpb24gPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChUcmFuc2Zvcm0pIHtcbiAgZnVuY3Rpb24gVHJhbnNhY3Rpb24oc3RhdGUpIHtcbiAgICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBzdGF0ZS5kb2MpO1xuICAgIC8vIDo6IG51bWJlclxuICAgIC8vIFRoZSB0aW1lc3RhbXAgYXNzb2NpYXRlZCB3aXRoIHRoaXMgdHJhbnNhY3Rpb24sIGluIHRoZSBzYW1lXG4gICAgLy8gZm9ybWF0IGFzIGBEYXRlLm5vdygpYC5cbiAgICB0aGlzLnRpbWUgPSBEYXRlLm5vdygpO1xuICAgIHRoaXMuY3VyU2VsZWN0aW9uID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIC8vIFRoZSBzdGVwIGNvdW50IGZvciB3aGljaCB0aGUgY3VycmVudCBzZWxlY3Rpb24gaXMgdmFsaWQuXG4gICAgdGhpcy5jdXJTZWxlY3Rpb25Gb3IgPSAwO1xuICAgIC8vIDo6ID9bTWFya11cbiAgICAvLyBUaGUgc3RvcmVkIG1hcmtzIHNldCBieSB0aGlzIHRyYW5zYWN0aW9uLCBpZiBhbnkuXG4gICAgdGhpcy5zdG9yZWRNYXJrcyA9IHN0YXRlLnN0b3JlZE1hcmtzO1xuICAgIC8vIEJpdGZpZWxkIHRvIHRyYWNrIHdoaWNoIGFzcGVjdHMgb2YgdGhlIHN0YXRlIHdlcmUgdXBkYXRlZCBieVxuICAgIC8vIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgdGhpcy51cGRhdGVkID0gMDtcbiAgICAvLyBPYmplY3QgdXNlZCB0byBzdG9yZSBtZXRhZGF0YSBwcm9wZXJ0aWVzIGZvciB0aGUgdHJhbnNhY3Rpb24uXG4gICAgdGhpcy5tZXRhID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuXG4gIGlmICggVHJhbnNmb3JtICkgVHJhbnNhY3Rpb24uX19wcm90b19fID0gVHJhbnNmb3JtO1xuICBUcmFuc2FjdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUcmFuc2Zvcm0gJiYgVHJhbnNmb3JtLnByb3RvdHlwZSApO1xuICBUcmFuc2FjdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUcmFuc2FjdGlvbjtcblxuICB2YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBzZWxlY3Rpb246IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sc2VsZWN0aW9uU2V0OiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LHN0b3JlZE1hcmtzU2V0OiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGlzR2VuZXJpYzogeyBjb25maWd1cmFibGU6IHRydWUgfSxzY3JvbGxlZEludG9WaWV3OiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbiAgLy8gOjogU2VsZWN0aW9uXG4gIC8vIFRoZSB0cmFuc2FjdGlvbidzIGN1cnJlbnQgc2VsZWN0aW9uLiBUaGlzIGRlZmF1bHRzIHRvIHRoZSBlZGl0b3JcbiAgLy8gc2VsZWN0aW9uIFttYXBwZWRdKCNzdGF0ZS5TZWxlY3Rpb24ubWFwKSB0aHJvdWdoIHRoZSBzdGVwcyBpbiB0aGVcbiAgLy8gdHJhbnNhY3Rpb24sIGJ1dCBjYW4gYmUgb3ZlcndyaXR0ZW4gd2l0aFxuICAvLyBbYHNldFNlbGVjdGlvbmBdKCNzdGF0ZS5UcmFuc2FjdGlvbi5zZXRTZWxlY3Rpb24pLlxuICBwcm90b3R5cGVBY2Nlc3NvcnMuc2VsZWN0aW9uLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5jdXJTZWxlY3Rpb25Gb3IgPCB0aGlzLnN0ZXBzLmxlbmd0aCkge1xuICAgICAgdGhpcy5jdXJTZWxlY3Rpb24gPSB0aGlzLmN1clNlbGVjdGlvbi5tYXAodGhpcy5kb2MsIHRoaXMubWFwcGluZy5zbGljZSh0aGlzLmN1clNlbGVjdGlvbkZvcikpO1xuICAgICAgdGhpcy5jdXJTZWxlY3Rpb25Gb3IgPSB0aGlzLnN0ZXBzLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY3VyU2VsZWN0aW9uXG4gIH07XG5cbiAgLy8gOjogKFNlbGVjdGlvbikg4oaSIFRyYW5zYWN0aW9uXG4gIC8vIFVwZGF0ZSB0aGUgdHJhbnNhY3Rpb24ncyBjdXJyZW50IHNlbGVjdGlvbi4gV2lsbCBkZXRlcm1pbmUgdGhlXG4gIC8vIHNlbGVjdGlvbiB0aGF0IHRoZSBlZGl0b3IgZ2V0cyB3aGVuIHRoZSB0cmFuc2FjdGlvbiBpcyBhcHBsaWVkLlxuICBUcmFuc2FjdGlvbi5wcm90b3R5cGUuc2V0U2VsZWN0aW9uID0gZnVuY3Rpb24gc2V0U2VsZWN0aW9uIChzZWxlY3Rpb24pIHtcbiAgICBpZiAoc2VsZWN0aW9uLiRmcm9tLmRvYyAhPSB0aGlzLmRvYylcbiAgICAgIHsgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJTZWxlY3Rpb24gcGFzc2VkIHRvIHNldFNlbGVjdGlvbiBtdXN0IHBvaW50IGF0IHRoZSBjdXJyZW50IGRvY3VtZW50XCIpIH1cbiAgICB0aGlzLmN1clNlbGVjdGlvbiA9IHNlbGVjdGlvbjtcbiAgICB0aGlzLmN1clNlbGVjdGlvbkZvciA9IHRoaXMuc3RlcHMubGVuZ3RoO1xuICAgIHRoaXMudXBkYXRlZCA9ICh0aGlzLnVwZGF0ZWQgfCBVUERBVEVEX1NFTCkgJiB+VVBEQVRFRF9NQVJLUztcbiAgICB0aGlzLnN0b3JlZE1hcmtzID0gbnVsbDtcbiAgICByZXR1cm4gdGhpc1xuICB9O1xuXG4gIC8vIDo6IGJvb2xcbiAgLy8gV2hldGhlciB0aGUgc2VsZWN0aW9uIHdhcyBleHBsaWNpdGx5IHVwZGF0ZWQgYnkgdGhpcyB0cmFuc2FjdGlvbi5cbiAgcHJvdG90eXBlQWNjZXNzb3JzLnNlbGVjdGlvblNldC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLnVwZGF0ZWQgJiBVUERBVEVEX1NFTCkgPiAwXG4gIH07XG5cbiAgLy8gOjogKD9bTWFya10pIOKGkiBUcmFuc2FjdGlvblxuICAvLyBTZXQgdGhlIGN1cnJlbnQgc3RvcmVkIG1hcmtzLlxuICBUcmFuc2FjdGlvbi5wcm90b3R5cGUuc2V0U3RvcmVkTWFya3MgPSBmdW5jdGlvbiBzZXRTdG9yZWRNYXJrcyAobWFya3MpIHtcbiAgICB0aGlzLnN0b3JlZE1hcmtzID0gbWFya3M7XG4gICAgdGhpcy51cGRhdGVkIHw9IFVQREFURURfTUFSS1M7XG4gICAgcmV0dXJuIHRoaXNcbiAgfTtcblxuICAvLyA6OiAoW01hcmtdKSDihpIgVHJhbnNhY3Rpb25cbiAgLy8gTWFrZSBzdXJlIHRoZSBjdXJyZW50IHN0b3JlZCBtYXJrcyBvciwgaWYgdGhhdCBpcyBudWxsLCB0aGUgbWFya3NcbiAgLy8gYXQgdGhlIHNlbGVjdGlvbiwgbWF0Y2ggdGhlIGdpdmVuIHNldCBvZiBtYXJrcy4gRG9lcyBub3RoaW5nIGlmXG4gIC8vIHRoaXMgaXMgYWxyZWFkeSB0aGUgY2FzZS5cbiAgVHJhbnNhY3Rpb24ucHJvdG90eXBlLmVuc3VyZU1hcmtzID0gZnVuY3Rpb24gZW5zdXJlTWFya3MgKG1hcmtzKSB7XG4gICAgaWYgKCFNYXJrLnNhbWVTZXQodGhpcy5zdG9yZWRNYXJrcyB8fCB0aGlzLnNlbGVjdGlvbi4kZnJvbS5tYXJrcygpLCBtYXJrcykpXG4gICAgICB7IHRoaXMuc2V0U3RvcmVkTWFya3MobWFya3MpOyB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfTtcblxuICAvLyA6OiAoTWFyaykg4oaSIFRyYW5zYWN0aW9uXG4gIC8vIEFkZCBhIG1hcmsgdG8gdGhlIHNldCBvZiBzdG9yZWQgbWFya3MuXG4gIFRyYW5zYWN0aW9uLnByb3RvdHlwZS5hZGRTdG9yZWRNYXJrID0gZnVuY3Rpb24gYWRkU3RvcmVkTWFyayAobWFyaykge1xuICAgIHJldHVybiB0aGlzLmVuc3VyZU1hcmtzKG1hcmsuYWRkVG9TZXQodGhpcy5zdG9yZWRNYXJrcyB8fCB0aGlzLnNlbGVjdGlvbi4kaGVhZC5tYXJrcygpKSlcbiAgfTtcblxuICAvLyA6OiAodW5pb248TWFyaywgTWFya1R5cGU+KSDihpIgVHJhbnNhY3Rpb25cbiAgLy8gUmVtb3ZlIGEgbWFyayBvciBtYXJrIHR5cGUgZnJvbSB0aGUgc2V0IG9mIHN0b3JlZCBtYXJrcy5cbiAgVHJhbnNhY3Rpb24ucHJvdG90eXBlLnJlbW92ZVN0b3JlZE1hcmsgPSBmdW5jdGlvbiByZW1vdmVTdG9yZWRNYXJrIChtYXJrKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5zdXJlTWFya3MobWFyay5yZW1vdmVGcm9tU2V0KHRoaXMuc3RvcmVkTWFya3MgfHwgdGhpcy5zZWxlY3Rpb24uJGhlYWQubWFya3MoKSkpXG4gIH07XG5cbiAgLy8gOjogYm9vbFxuICAvLyBXaGV0aGVyIHRoZSBzdG9yZWQgbWFya3Mgd2VyZSBleHBsaWNpdGx5IHNldCBmb3IgdGhpcyB0cmFuc2FjdGlvbi5cbiAgcHJvdG90eXBlQWNjZXNzb3JzLnN0b3JlZE1hcmtzU2V0LmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMudXBkYXRlZCAmIFVQREFURURfTUFSS1MpID4gMFxuICB9O1xuXG4gIFRyYW5zYWN0aW9uLnByb3RvdHlwZS5hZGRTdGVwID0gZnVuY3Rpb24gYWRkU3RlcCAoc3RlcCwgZG9jKSB7XG4gICAgVHJhbnNmb3JtLnByb3RvdHlwZS5hZGRTdGVwLmNhbGwodGhpcywgc3RlcCwgZG9jKTtcbiAgICB0aGlzLnVwZGF0ZWQgPSB0aGlzLnVwZGF0ZWQgJiB+VVBEQVRFRF9NQVJLUztcbiAgICB0aGlzLnN0b3JlZE1hcmtzID0gbnVsbDtcbiAgfTtcblxuICAvLyA6OiAobnVtYmVyKSDihpIgVHJhbnNhY3Rpb25cbiAgLy8gVXBkYXRlIHRoZSB0aW1lc3RhbXAgZm9yIHRoZSB0cmFuc2FjdGlvbi5cbiAgVHJhbnNhY3Rpb24ucHJvdG90eXBlLnNldFRpbWUgPSBmdW5jdGlvbiBzZXRUaW1lICh0aW1lKSB7XG4gICAgdGhpcy50aW1lID0gdGltZTtcbiAgICByZXR1cm4gdGhpc1xuICB9O1xuXG4gIC8vIDo6IChTbGljZSkg4oaSIFRyYW5zYWN0aW9uXG4gIC8vIFJlcGxhY2UgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIHdpdGggdGhlIGdpdmVuIHNsaWNlLlxuICBUcmFuc2FjdGlvbi5wcm90b3R5cGUucmVwbGFjZVNlbGVjdGlvbiA9IGZ1bmN0aW9uIHJlcGxhY2VTZWxlY3Rpb24gKHNsaWNlKSB7XG4gICAgdGhpcy5zZWxlY3Rpb24ucmVwbGFjZSh0aGlzLCBzbGljZSk7XG4gICAgcmV0dXJuIHRoaXNcbiAgfTtcblxuICAvLyA6OiAoTm9kZSwgP2Jvb2wpIOKGkiBUcmFuc2FjdGlvblxuICAvLyBSZXBsYWNlIHRoZSBzZWxlY3Rpb24gd2l0aCB0aGUgZ2l2ZW4gbm9kZS4gV2hlbiBgaW5oZXJpdE1hcmtzYCBpc1xuICAvLyB0cnVlIGFuZCB0aGUgY29udGVudCBpcyBpbmxpbmUsIGl0IGluaGVyaXRzIHRoZSBtYXJrcyBmcm9tIHRoZVxuICAvLyBwbGFjZSB3aGVyZSBpdCBpcyBpbnNlcnRlZC5cbiAgVHJhbnNhY3Rpb24ucHJvdG90eXBlLnJlcGxhY2VTZWxlY3Rpb25XaXRoID0gZnVuY3Rpb24gcmVwbGFjZVNlbGVjdGlvbldpdGggKG5vZGUsIGluaGVyaXRNYXJrcykge1xuICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzLnNlbGVjdGlvbjtcbiAgICBpZiAoaW5oZXJpdE1hcmtzICE9PSBmYWxzZSlcbiAgICAgIHsgbm9kZSA9IG5vZGUubWFyayh0aGlzLnN0b3JlZE1hcmtzIHx8IChzZWxlY3Rpb24uZW1wdHkgPyBzZWxlY3Rpb24uJGZyb20ubWFya3MoKSA6IChzZWxlY3Rpb24uJGZyb20ubWFya3NBY3Jvc3Moc2VsZWN0aW9uLiR0bykgfHwgTWFyay5ub25lKSkpOyB9XG4gICAgc2VsZWN0aW9uLnJlcGxhY2VXaXRoKHRoaXMsIG5vZGUpO1xuICAgIHJldHVybiB0aGlzXG4gIH07XG5cbiAgLy8gOjogKCkg4oaSIFRyYW5zYWN0aW9uXG4gIC8vIERlbGV0ZSB0aGUgc2VsZWN0aW9uLlxuICBUcmFuc2FjdGlvbi5wcm90b3R5cGUuZGVsZXRlU2VsZWN0aW9uID0gZnVuY3Rpb24gZGVsZXRlU2VsZWN0aW9uICgpIHtcbiAgICB0aGlzLnNlbGVjdGlvbi5yZXBsYWNlKHRoaXMpO1xuICAgIHJldHVybiB0aGlzXG4gIH07XG5cbiAgLy8gOjogKHN0cmluZywgZnJvbTogP251bWJlciwgdG86ID9udW1iZXIpIOKGkiBUcmFuc2FjdGlvblxuICAvLyBSZXBsYWNlIHRoZSBnaXZlbiByYW5nZSwgb3IgdGhlIHNlbGVjdGlvbiBpZiBubyByYW5nZSBpcyBnaXZlbixcbiAgLy8gd2l0aCBhIHRleHQgbm9kZSBjb250YWluaW5nIHRoZSBnaXZlbiBzdHJpbmcuXG4gIFRyYW5zYWN0aW9uLnByb3RvdHlwZS5pbnNlcnRUZXh0ID0gZnVuY3Rpb24gaW5zZXJ0VGV4dCAodGV4dCwgZnJvbSwgdG8pIHtcbiAgICBpZiAoIHRvID09PSB2b2lkIDAgKSB0byA9IGZyb207XG5cbiAgICB2YXIgc2NoZW1hID0gdGhpcy5kb2MudHlwZS5zY2hlbWE7XG4gICAgaWYgKGZyb20gPT0gbnVsbCkge1xuICAgICAgaWYgKCF0ZXh0KSB7IHJldHVybiB0aGlzLmRlbGV0ZVNlbGVjdGlvbigpIH1cbiAgICAgIHJldHVybiB0aGlzLnJlcGxhY2VTZWxlY3Rpb25XaXRoKHNjaGVtYS50ZXh0KHRleHQpLCB0cnVlKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXRleHQpIHsgcmV0dXJuIHRoaXMuZGVsZXRlUmFuZ2UoZnJvbSwgdG8pIH1cbiAgICAgIHZhciBtYXJrcyA9IHRoaXMuc3RvcmVkTWFya3M7XG4gICAgICBpZiAoIW1hcmtzKSB7XG4gICAgICAgIHZhciAkZnJvbSA9IHRoaXMuZG9jLnJlc29sdmUoZnJvbSk7XG4gICAgICAgIG1hcmtzID0gdG8gPT0gZnJvbSA/ICRmcm9tLm1hcmtzKCkgOiAkZnJvbS5tYXJrc0Fjcm9zcyh0aGlzLmRvYy5yZXNvbHZlKHRvKSk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlcGxhY2VSYW5nZVdpdGgoZnJvbSwgdG8sIHNjaGVtYS50ZXh0KHRleHQsIG1hcmtzKSk7XG4gICAgICBpZiAoIXRoaXMuc2VsZWN0aW9uLmVtcHR5KSB7IHRoaXMuc2V0U2VsZWN0aW9uKFNlbGVjdGlvbi5uZWFyKHRoaXMuc2VsZWN0aW9uLiR0bykpOyB9XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgfTtcblxuICAvLyA6OiAodW5pb248c3RyaW5nLCBQbHVnaW4sIFBsdWdpbktleT4sIGFueSkg4oaSIFRyYW5zYWN0aW9uXG4gIC8vIFN0b3JlIGEgbWV0YWRhdGEgcHJvcGVydHkgaW4gdGhpcyB0cmFuc2FjdGlvbiwga2V5ZWQgZWl0aGVyIGJ5XG4gIC8vIG5hbWUgb3IgYnkgcGx1Z2luLlxuICBUcmFuc2FjdGlvbi5wcm90b3R5cGUuc2V0TWV0YSA9IGZ1bmN0aW9uIHNldE1ldGEgKGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLm1ldGFbdHlwZW9mIGtleSA9PSBcInN0cmluZ1wiID8ga2V5IDoga2V5LmtleV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gdGhpc1xuICB9O1xuXG4gIC8vIDo6ICh1bmlvbjxzdHJpbmcsIFBsdWdpbiwgUGx1Z2luS2V5Pikg4oaSIGFueVxuICAvLyBSZXRyaWV2ZSBhIG1ldGFkYXRhIHByb3BlcnR5IGZvciBhIGdpdmVuIG5hbWUgb3IgcGx1Z2luLlxuICBUcmFuc2FjdGlvbi5wcm90b3R5cGUuZ2V0TWV0YSA9IGZ1bmN0aW9uIGdldE1ldGEgKGtleSkge1xuICAgIHJldHVybiB0aGlzLm1ldGFbdHlwZW9mIGtleSA9PSBcInN0cmluZ1wiID8ga2V5IDoga2V5LmtleV1cbiAgfTtcblxuICAvLyA6OiBib29sXG4gIC8vIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHRyYW5zYWN0aW9uIGRvZXNuJ3QgY29udGFpbiBhbnkgbWV0YWRhdGEsXG4gIC8vIGFuZCBjYW4gdGh1cyBzYWZlbHkgYmUgZXh0ZW5kZWQuXG4gIHByb3RvdHlwZUFjY2Vzc29ycy5pc0dlbmVyaWMuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIF8gaW4gdGhpcy5tZXRhKSB7IHJldHVybiBmYWxzZSB9XG4gICAgcmV0dXJuIHRydWVcbiAgfTtcblxuICAvLyA6OiAoKSDihpIgVHJhbnNhY3Rpb25cbiAgLy8gSW5kaWNhdGUgdGhhdCB0aGUgZWRpdG9yIHNob3VsZCBzY3JvbGwgdGhlIHNlbGVjdGlvbiBpbnRvIHZpZXdcbiAgLy8gd2hlbiB1cGRhdGVkIHRvIHRoZSBzdGF0ZSBwcm9kdWNlZCBieSB0aGlzIHRyYW5zYWN0aW9uLlxuICBUcmFuc2FjdGlvbi5wcm90b3R5cGUuc2Nyb2xsSW50b1ZpZXcgPSBmdW5jdGlvbiBzY3JvbGxJbnRvVmlldyAoKSB7XG4gICAgdGhpcy51cGRhdGVkIHw9IFVQREFURURfU0NST0xMO1xuICAgIHJldHVybiB0aGlzXG4gIH07XG5cbiAgcHJvdG90eXBlQWNjZXNzb3JzLnNjcm9sbGVkSW50b1ZpZXcuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy51cGRhdGVkICYgVVBEQVRFRF9TQ1JPTEwpID4gMFxuICB9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBUcmFuc2FjdGlvbi5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyApO1xuXG4gIHJldHVybiBUcmFuc2FjdGlvbjtcbn0oVHJhbnNmb3JtKSk7XG5cbmZ1bmN0aW9uIGJpbmQoZiwgc2VsZikge1xuICByZXR1cm4gIXNlbGYgfHwgIWYgPyBmIDogZi5iaW5kKHNlbGYpXG59XG5cbnZhciBGaWVsZERlc2MgPSBmdW5jdGlvbiBGaWVsZERlc2MobmFtZSwgZGVzYywgc2VsZikge1xuICB0aGlzLm5hbWUgPSBuYW1lO1xuICB0aGlzLmluaXQgPSBiaW5kKGRlc2MuaW5pdCwgc2VsZik7XG4gIHRoaXMuYXBwbHkgPSBiaW5kKGRlc2MuYXBwbHksIHNlbGYpO1xufTtcblxudmFyIGJhc2VGaWVsZHMgPSBbXG4gIG5ldyBGaWVsZERlc2MoXCJkb2NcIiwge1xuICAgIGluaXQ6IGZ1bmN0aW9uIGluaXQoY29uZmlnKSB7IHJldHVybiBjb25maWcuZG9jIHx8IGNvbmZpZy5zY2hlbWEudG9wTm9kZVR5cGUuY3JlYXRlQW5kRmlsbCgpIH0sXG4gICAgYXBwbHk6IGZ1bmN0aW9uIGFwcGx5KHRyKSB7IHJldHVybiB0ci5kb2MgfVxuICB9KSxcblxuICBuZXcgRmllbGREZXNjKFwic2VsZWN0aW9uXCIsIHtcbiAgICBpbml0OiBmdW5jdGlvbiBpbml0KGNvbmZpZywgaW5zdGFuY2UpIHsgcmV0dXJuIGNvbmZpZy5zZWxlY3Rpb24gfHwgU2VsZWN0aW9uLmF0U3RhcnQoaW5zdGFuY2UuZG9jKSB9LFxuICAgIGFwcGx5OiBmdW5jdGlvbiBhcHBseSh0cikgeyByZXR1cm4gdHIuc2VsZWN0aW9uIH1cbiAgfSksXG5cbiAgbmV3IEZpZWxkRGVzYyhcInN0b3JlZE1hcmtzXCIsIHtcbiAgICBpbml0OiBmdW5jdGlvbiBpbml0KGNvbmZpZykgeyByZXR1cm4gY29uZmlnLnN0b3JlZE1hcmtzIHx8IG51bGwgfSxcbiAgICBhcHBseTogZnVuY3Rpb24gYXBwbHkodHIsIF9tYXJrcywgX29sZCwgc3RhdGUpIHsgcmV0dXJuIHN0YXRlLnNlbGVjdGlvbi4kY3Vyc29yID8gdHIuc3RvcmVkTWFya3MgOiBudWxsIH1cbiAgfSksXG5cbiAgbmV3IEZpZWxkRGVzYyhcInNjcm9sbFRvU2VsZWN0aW9uXCIsIHtcbiAgICBpbml0OiBmdW5jdGlvbiBpbml0KCkgeyByZXR1cm4gMCB9LFxuICAgIGFwcGx5OiBmdW5jdGlvbiBhcHBseSh0ciwgcHJldikgeyByZXR1cm4gdHIuc2Nyb2xsZWRJbnRvVmlldyA/IHByZXYgKyAxIDogcHJldiB9XG4gIH0pXG5dO1xuXG4vLyBPYmplY3Qgd3JhcHBpbmcgdGhlIHBhcnQgb2YgYSBzdGF0ZSBvYmplY3QgdGhhdCBzdGF5cyB0aGUgc2FtZVxuLy8gYWNyb3NzIHRyYW5zYWN0aW9ucy4gU3RvcmVkIGluIHRoZSBzdGF0ZSdzIGBjb25maWdgIHByb3BlcnR5LlxudmFyIENvbmZpZ3VyYXRpb24gPSBmdW5jdGlvbiBDb25maWd1cmF0aW9uKHNjaGVtYSwgcGx1Z2lucykge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgdGhpcy5maWVsZHMgPSBiYXNlRmllbGRzLmNvbmNhdCgpO1xuICB0aGlzLnBsdWdpbnMgPSBbXTtcbiAgdGhpcy5wbHVnaW5zQnlLZXkgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBpZiAocGx1Z2lucykgeyBwbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbikge1xuICAgIGlmICh0aGlzJDEucGx1Z2luc0J5S2V5W3BsdWdpbi5rZXldKVxuICAgICAgeyB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkFkZGluZyBkaWZmZXJlbnQgaW5zdGFuY2VzIG9mIGEga2V5ZWQgcGx1Z2luIChcIiArIHBsdWdpbi5rZXkgKyBcIilcIikgfVxuICAgIHRoaXMkMS5wbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgICB0aGlzJDEucGx1Z2luc0J5S2V5W3BsdWdpbi5rZXldID0gcGx1Z2luO1xuICAgIGlmIChwbHVnaW4uc3BlYy5zdGF0ZSlcbiAgICAgIHsgdGhpcyQxLmZpZWxkcy5wdXNoKG5ldyBGaWVsZERlc2MocGx1Z2luLmtleSwgcGx1Z2luLnNwZWMuc3RhdGUsIHBsdWdpbikpOyB9XG4gIH0pOyB9XG59O1xuXG4vLyA6Oi0gVGhlIHN0YXRlIG9mIGEgUHJvc2VNaXJyb3IgZWRpdG9yIGlzIHJlcHJlc2VudGVkIGJ5IGFuIG9iamVjdFxuLy8gb2YgdGhpcyB0eXBlLiBBIHN0YXRlIGlzIGEgcGVyc2lzdGVudCBkYXRhIHN0cnVjdHVyZeKAlGl0IGlzbid0XG4vLyB1cGRhdGVkLCBidXQgcmF0aGVyIGEgbmV3IHN0YXRlIHZhbHVlIGlzIGNvbXB1dGVkIGZyb20gYW4gb2xkIG9uZVxuLy8gdXNpbmcgdGhlIFtgYXBwbHlgXSgjc3RhdGUuRWRpdG9yU3RhdGUuYXBwbHkpIG1ldGhvZC5cbi8vXG4vLyBBIHN0YXRlIGhvbGRzIGEgbnVtYmVyIG9mIGJ1aWx0LWluIGZpZWxkcywgYW5kIHBsdWdpbnMgY2FuXG4vLyBbZGVmaW5lXSgjc3RhdGUuUGx1Z2luU3BlYy5zdGF0ZSkgYWRkaXRpb25hbCBmaWVsZHMuXG52YXIgRWRpdG9yU3RhdGUgPSBmdW5jdGlvbiBFZGl0b3JTdGF0ZShjb25maWcpIHtcbiAgdGhpcy5jb25maWcgPSBjb25maWc7XG59O1xuXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzJDEgPSB7IHNjaGVtYTogeyBjb25maWd1cmFibGU6IHRydWUgfSxwbHVnaW5zOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LHRyOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbi8vIGRvYzo6IE5vZGVcbi8vIFRoZSBjdXJyZW50IGRvY3VtZW50LlxuXG4vLyBzZWxlY3Rpb246OiBTZWxlY3Rpb25cbi8vIFRoZSBzZWxlY3Rpb24uXG5cbi8vIHN0b3JlZE1hcmtzOjogP1tNYXJrXVxuLy8gQSBzZXQgb2YgbWFya3MgdG8gYXBwbHkgdG8gdGhlIG5leHQgaW5wdXQuIFdpbGwgYmUgbnVsbCB3aGVuXG4vLyBubyBleHBsaWNpdCBtYXJrcyBoYXZlIGJlZW4gc2V0LlxuXG4vLyA6OiBTY2hlbWFcbi8vIFRoZSBzY2hlbWEgb2YgdGhlIHN0YXRlJ3MgZG9jdW1lbnQuXG5wcm90b3R5cGVBY2Nlc3NvcnMkMS5zY2hlbWEuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jb25maWcuc2NoZW1hXG59O1xuXG4vLyA6OiBbUGx1Z2luXVxuLy8gVGhlIHBsdWdpbnMgdGhhdCBhcmUgYWN0aXZlIGluIHRoaXMgc3RhdGUuXG5wcm90b3R5cGVBY2Nlc3NvcnMkMS5wbHVnaW5zLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY29uZmlnLnBsdWdpbnNcbn07XG5cbi8vIDo6IChUcmFuc2FjdGlvbikg4oaSIEVkaXRvclN0YXRlXG4vLyBBcHBseSB0aGUgZ2l2ZW4gdHJhbnNhY3Rpb24gdG8gcHJvZHVjZSBhIG5ldyBzdGF0ZS5cbkVkaXRvclN0YXRlLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uIGFwcGx5ICh0cikge1xuICByZXR1cm4gdGhpcy5hcHBseVRyYW5zYWN0aW9uKHRyKS5zdGF0ZVxufTtcblxuLy8gOiAoVHJhbnNhY3Rpb24pIOKGkiBib29sXG5FZGl0b3JTdGF0ZS5wcm90b3R5cGUuZmlsdGVyVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiBmaWx0ZXJUcmFuc2FjdGlvbiAodHIsIGlnbm9yZSkge1xuICAgIGlmICggaWdub3JlID09PSB2b2lkIDAgKSBpZ25vcmUgPSAtMTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29uZmlnLnBsdWdpbnMubGVuZ3RoOyBpKyspIHsgaWYgKGkgIT0gaWdub3JlKSB7XG4gICAgdmFyIHBsdWdpbiA9IHRoaXMuY29uZmlnLnBsdWdpbnNbaV07XG4gICAgaWYgKHBsdWdpbi5zcGVjLmZpbHRlclRyYW5zYWN0aW9uICYmICFwbHVnaW4uc3BlYy5maWx0ZXJUcmFuc2FjdGlvbi5jYWxsKHBsdWdpbiwgdHIsIHRoaXMpKVxuICAgICAgeyByZXR1cm4gZmFsc2UgfVxuICB9IH1cbiAgcmV0dXJuIHRydWVcbn07XG5cbi8vIDo6IChUcmFuc2FjdGlvbikg4oaSIHtzdGF0ZTogRWRpdG9yU3RhdGUsIHRyYW5zYWN0aW9uczogW1RyYW5zYWN0aW9uXX1cbi8vIFZlcmJvc2UgdmFyaWFudCBvZiBbYGFwcGx5YF0oI3N0YXRlLkVkaXRvclN0YXRlLmFwcGx5KSB0aGF0XG4vLyByZXR1cm5zIHRoZSBwcmVjaXNlIHRyYW5zYWN0aW9ucyB0aGF0IHdlcmUgYXBwbGllZCAod2hpY2ggbWlnaHRcbi8vIGJlIGluZmx1ZW5jZWQgYnkgdGhlIFt0cmFuc2FjdGlvblxuLy8gaG9va3NdKCNzdGF0ZS5QbHVnaW5TcGVjLmZpbHRlclRyYW5zYWN0aW9uKSBvZlxuLy8gcGx1Z2lucykgYWxvbmcgd2l0aCB0aGUgbmV3IHN0YXRlLlxuRWRpdG9yU3RhdGUucHJvdG90eXBlLmFwcGx5VHJhbnNhY3Rpb24gPSBmdW5jdGlvbiBhcHBseVRyYW5zYWN0aW9uIChyb290VHIpIHtcbiAgaWYgKCF0aGlzLmZpbHRlclRyYW5zYWN0aW9uKHJvb3RUcikpIHsgcmV0dXJuIHtzdGF0ZTogdGhpcywgdHJhbnNhY3Rpb25zOiBbXX0gfVxuXG4gIHZhciB0cnMgPSBbcm9vdFRyXSwgbmV3U3RhdGUgPSB0aGlzLmFwcGx5SW5uZXIocm9vdFRyKSwgc2VlbiA9IG51bGw7XG4gIC8vIFRoaXMgbG9vcCByZXBlYXRlZGx5IGdpdmVzIHBsdWdpbnMgYSBjaGFuY2UgdG8gcmVzcG9uZCB0b1xuICAvLyB0cmFuc2FjdGlvbnMgYXMgbmV3IHRyYW5zYWN0aW9ucyBhcmUgYWRkZWQsIG1ha2luZyBzdXJlIHRvIG9ubHlcbiAgLy8gcGFzcyB0aGUgdHJhbnNhY3Rpb25zIHRoZSBwbHVnaW4gZGlkIG5vdCBzZWUgYmVmb3JlLlxuICAgZm9yICg7Oykge1xuICAgIHZhciBoYXZlTmV3ID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbmZpZy5wbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcGx1Z2luID0gdGhpcy5jb25maWcucGx1Z2luc1tpXTtcbiAgICAgIGlmIChwbHVnaW4uc3BlYy5hcHBlbmRUcmFuc2FjdGlvbikge1xuICAgICAgICB2YXIgbiA9IHNlZW4gPyBzZWVuW2ldLm4gOiAwLCBvbGRTdGF0ZSA9IHNlZW4gPyBzZWVuW2ldLnN0YXRlIDogdGhpcztcbiAgICAgICAgdmFyIHRyID0gbiA8IHRycy5sZW5ndGggJiZcbiAgICAgICAgICAgIHBsdWdpbi5zcGVjLmFwcGVuZFRyYW5zYWN0aW9uLmNhbGwocGx1Z2luLCBuID8gdHJzLnNsaWNlKG4pIDogdHJzLCBvbGRTdGF0ZSwgbmV3U3RhdGUpO1xuICAgICAgICBpZiAodHIgJiYgbmV3U3RhdGUuZmlsdGVyVHJhbnNhY3Rpb24odHIsIGkpKSB7XG4gICAgICAgICAgdHIuc2V0TWV0YShcImFwcGVuZGVkVHJhbnNhY3Rpb25cIiwgcm9vdFRyKTtcbiAgICAgICAgICBpZiAoIXNlZW4pIHtcbiAgICAgICAgICAgIHNlZW4gPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5jb25maWcucGx1Z2lucy5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgeyBzZWVuLnB1c2goaiA8IGkgPyB7c3RhdGU6IG5ld1N0YXRlLCBuOiB0cnMubGVuZ3RofSA6IHtzdGF0ZTogdGhpcywgbjogMH0pOyB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRycy5wdXNoKHRyKTtcbiAgICAgICAgICBuZXdTdGF0ZSA9IG5ld1N0YXRlLmFwcGx5SW5uZXIodHIpO1xuICAgICAgICAgIGhhdmVOZXcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWVuKSB7IHNlZW5baV0gPSB7c3RhdGU6IG5ld1N0YXRlLCBuOiB0cnMubGVuZ3RofTsgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWhhdmVOZXcpIHsgcmV0dXJuIHtzdGF0ZTogbmV3U3RhdGUsIHRyYW5zYWN0aW9uczogdHJzfSB9XG4gIH1cbn07XG5cbi8vIDogKFRyYW5zYWN0aW9uKSDihpIgRWRpdG9yU3RhdGVcbkVkaXRvclN0YXRlLnByb3RvdHlwZS5hcHBseUlubmVyID0gZnVuY3Rpb24gYXBwbHlJbm5lciAodHIpIHtcbiAgaWYgKCF0ci5iZWZvcmUuZXEodGhpcy5kb2MpKSB7IHRocm93IG5ldyBSYW5nZUVycm9yKFwiQXBwbHlpbmcgYSBtaXNtYXRjaGVkIHRyYW5zYWN0aW9uXCIpIH1cbiAgdmFyIG5ld0luc3RhbmNlID0gbmV3IEVkaXRvclN0YXRlKHRoaXMuY29uZmlnKSwgZmllbGRzID0gdGhpcy5jb25maWcuZmllbGRzO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBmaWVsZCA9IGZpZWxkc1tpXTtcbiAgICBuZXdJbnN0YW5jZVtmaWVsZC5uYW1lXSA9IGZpZWxkLmFwcGx5KHRyLCB0aGlzW2ZpZWxkLm5hbWVdLCB0aGlzLCBuZXdJbnN0YW5jZSk7XG4gIH1cbiAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgYXBwbHlMaXN0ZW5lcnMubGVuZ3RoOyBpJDErKykgeyBhcHBseUxpc3RlbmVyc1tpJDFdKHRoaXMsIHRyLCBuZXdJbnN0YW5jZSk7IH1cbiAgcmV0dXJuIG5ld0luc3RhbmNlXG59O1xuXG4vLyA6OiBUcmFuc2FjdGlvblxuLy8gU3RhcnQgYSBbdHJhbnNhY3Rpb25dKCNzdGF0ZS5UcmFuc2FjdGlvbikgZnJvbSB0aGlzIHN0YXRlLlxucHJvdG90eXBlQWNjZXNzb3JzJDEudHIuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKHRoaXMpIH07XG5cbi8vIDo6IChPYmplY3QpIOKGkiBFZGl0b3JTdGF0ZVxuLy8gQ3JlYXRlIGEgbmV3IHN0YXRlLlxuLy9cbi8vIGNvbmZpZzo6LSBDb25maWd1cmF0aW9uIG9wdGlvbnMuIE11c3QgY29udGFpbiBgc2NoZW1hYCBvciBgZG9jYCAob3IgYm90aCkuXG4vL1xuLy8gICAgc2NoZW1hOjogP1NjaGVtYVxuLy8gICAgVGhlIHNjaGVtYSB0byB1c2UgKG9ubHkgcmVsZXZhbnQgaWYgbm8gYGRvY2AgaXMgc3BlY2lmaWVkKS5cbi8vXG4vLyAgICBkb2M6OiA/Tm9kZVxuLy8gICAgVGhlIHN0YXJ0aW5nIGRvY3VtZW50LlxuLy9cbi8vICAgIHNlbGVjdGlvbjo6ID9TZWxlY3Rpb25cbi8vICAgIEEgdmFsaWQgc2VsZWN0aW9uIGluIHRoZSBkb2N1bWVudC5cbi8vXG4vLyAgICBzdG9yZWRNYXJrczo6ID9bTWFya11cbi8vICAgIFRoZSBpbml0aWFsIHNldCBvZiBbc3RvcmVkIG1hcmtzXSgjc3RhdGUuRWRpdG9yU3RhdGUuc3RvcmVkTWFya3MpLlxuLy9cbi8vICAgIHBsdWdpbnM6OiA/W1BsdWdpbl1cbi8vICAgIFRoZSBwbHVnaW5zIHRoYXQgc2hvdWxkIGJlIGFjdGl2ZSBpbiB0aGlzIHN0YXRlLlxuRWRpdG9yU3RhdGUuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlIChjb25maWcpIHtcbiAgdmFyICRjb25maWcgPSBuZXcgQ29uZmlndXJhdGlvbihjb25maWcuZG9jID8gY29uZmlnLmRvYy50eXBlLnNjaGVtYSA6IGNvbmZpZy5zY2hlbWEsIGNvbmZpZy5wbHVnaW5zKTtcbiAgdmFyIGluc3RhbmNlID0gbmV3IEVkaXRvclN0YXRlKCRjb25maWcpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8ICRjb25maWcuZmllbGRzLmxlbmd0aDsgaSsrKVxuICAgIHsgaW5zdGFuY2VbJGNvbmZpZy5maWVsZHNbaV0ubmFtZV0gPSAkY29uZmlnLmZpZWxkc1tpXS5pbml0KGNvbmZpZywgaW5zdGFuY2UpOyB9XG4gIHJldHVybiBpbnN0YW5jZVxufTtcblxuLy8gOjogKE9iamVjdCkg4oaSIEVkaXRvclN0YXRlXG4vLyBDcmVhdGUgYSBuZXcgc3RhdGUgYmFzZWQgb24gdGhpcyBvbmUsIGJ1dCB3aXRoIGFuIGFkanVzdGVkIHNldCBvZlxuLy8gYWN0aXZlIHBsdWdpbnMuIFN0YXRlIGZpZWxkcyB0aGF0IGV4aXN0IGluIGJvdGggc2V0cyBvZiBwbHVnaW5zXG4vLyBhcmUga2VwdCB1bmNoYW5nZWQuIFRob3NlIHRoYXQgbm8gbG9uZ2VyIGV4aXN0IGFyZSBkcm9wcGVkLCBhbmRcbi8vIHRob3NlIHRoYXQgYXJlIG5ldyBhcmUgaW5pdGlhbGl6ZWQgdXNpbmcgdGhlaXJcbi8vIFtgaW5pdGBdKCNzdGF0ZS5TdGF0ZUZpZWxkLmluaXQpIG1ldGhvZCwgcGFzc2luZyBpbiB0aGUgbmV3XG4vLyBjb25maWd1cmF0aW9uIG9iamVjdC4uXG4vL1xuLy8gY29uZmlnOjotIGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xuLy9cbi8vICAgcGx1Z2luczo6IFtQbHVnaW5dXG4vLyAgIE5ldyBzZXQgb2YgYWN0aXZlIHBsdWdpbnMuXG5FZGl0b3JTdGF0ZS5wcm90b3R5cGUucmVjb25maWd1cmUgPSBmdW5jdGlvbiByZWNvbmZpZ3VyZSAoY29uZmlnKSB7XG4gIHZhciAkY29uZmlnID0gbmV3IENvbmZpZ3VyYXRpb24odGhpcy5zY2hlbWEsIGNvbmZpZy5wbHVnaW5zKTtcbiAgdmFyIGZpZWxkcyA9ICRjb25maWcuZmllbGRzLCBpbnN0YW5jZSA9IG5ldyBFZGl0b3JTdGF0ZSgkY29uZmlnKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbmFtZSA9IGZpZWxkc1tpXS5uYW1lO1xuICAgIGluc3RhbmNlW25hbWVdID0gdGhpcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IHRoaXNbbmFtZV0gOiBmaWVsZHNbaV0uaW5pdChjb25maWcsIGluc3RhbmNlKTtcbiAgfVxuICByZXR1cm4gaW5zdGFuY2Vcbn07XG5cbi8vIDo6ICg/dW5pb248T2JqZWN0PFBsdWdpbj4sIHN0cmluZywgbnVtYmVyPikg4oaSIE9iamVjdFxuLy8gU2VyaWFsaXplIHRoaXMgc3RhdGUgdG8gSlNPTi4gSWYgeW91IHdhbnQgdG8gc2VyaWFsaXplIHRoZSBzdGF0ZVxuLy8gb2YgcGx1Z2lucywgcGFzcyBhbiBvYmplY3QgbWFwcGluZyBwcm9wZXJ0eSBuYW1lcyB0byB1c2UgaW4gdGhlXG4vLyByZXN1bHRpbmcgSlNPTiBvYmplY3QgdG8gcGx1Z2luIG9iamVjdHMuIFRoZSBhcmd1bWVudCBtYXkgYWxzbyBiZVxuLy8gYSBzdHJpbmcgb3IgbnVtYmVyLCBpbiB3aGljaCBjYXNlIGl0IGlzIGlnbm9yZWQsIHRvIHN1cHBvcnQgdGhlXG4vLyB3YXkgYEpTT04uc3RyaW5naWZ5YCBjYWxscyBgdG9TdHJpbmdgIG1ldGhvZHMuXG5FZGl0b3JTdGF0ZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OIChwbHVnaW5GaWVsZHMpIHtcbiAgdmFyIHJlc3VsdCA9IHtkb2M6IHRoaXMuZG9jLnRvSlNPTigpLCBzZWxlY3Rpb246IHRoaXMuc2VsZWN0aW9uLnRvSlNPTigpfTtcbiAgaWYgKHRoaXMuc3RvcmVkTWFya3MpIHsgcmVzdWx0LnN0b3JlZE1hcmtzID0gdGhpcy5zdG9yZWRNYXJrcy5tYXAoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0udG9KU09OKCk7IH0pOyB9XG4gIGlmIChwbHVnaW5GaWVsZHMgJiYgdHlwZW9mIHBsdWdpbkZpZWxkcyA9PSAnb2JqZWN0JykgeyBmb3IgKHZhciBwcm9wIGluIHBsdWdpbkZpZWxkcykge1xuICAgIGlmIChwcm9wID09IFwiZG9jXCIgfHwgcHJvcCA9PSBcInNlbGVjdGlvblwiKVxuICAgICAgeyB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZSBKU09OIGZpZWxkcyBgZG9jYCBhbmQgYHNlbGVjdGlvbmAgYXJlIHJlc2VydmVkXCIpIH1cbiAgICB2YXIgcGx1Z2luID0gcGx1Z2luRmllbGRzW3Byb3BdLCBzdGF0ZSA9IHBsdWdpbi5zcGVjLnN0YXRlO1xuICAgIGlmIChzdGF0ZSAmJiBzdGF0ZS50b0pTT04pIHsgcmVzdWx0W3Byb3BdID0gc3RhdGUudG9KU09OLmNhbGwocGx1Z2luLCB0aGlzW3BsdWdpbi5rZXldKTsgfVxuICB9IH1cbiAgcmV0dXJuIHJlc3VsdFxufTtcblxuLy8gOjogKE9iamVjdCwgT2JqZWN0LCA/T2JqZWN0PFBsdWdpbj4pIOKGkiBFZGl0b3JTdGF0ZVxuLy8gRGVzZXJpYWxpemUgYSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGEgc3RhdGUuIGBjb25maWdgIHNob3VsZFxuLy8gaGF2ZSBhdCBsZWFzdCBhIGBzY2hlbWFgIGZpZWxkLCBhbmQgc2hvdWxkIGNvbnRhaW4gYXJyYXkgb2Zcbi8vIHBsdWdpbnMgdG8gaW5pdGlhbGl6ZSB0aGUgc3RhdGUgd2l0aC4gYHBsdWdpbkZpZWxkc2AgY2FuIGJlIHVzZWRcbi8vIHRvIGRlc2VyaWFsaXplIHRoZSBzdGF0ZSBvZiBwbHVnaW5zLCBieSBhc3NvY2lhdGluZyBwbHVnaW5cbi8vIGluc3RhbmNlcyB3aXRoIHRoZSBwcm9wZXJ0eSBuYW1lcyB0aGV5IHVzZSBpbiB0aGUgSlNPTiBvYmplY3QuXG4vL1xuLy8gY29uZmlnOjotIGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xuLy9cbi8vICAgc2NoZW1hOjogU2NoZW1hXG4vLyAgIFRoZSBzY2hlbWEgdG8gdXNlLlxuLy9cbi8vICAgcGx1Z2luczo6ID9bUGx1Z2luXVxuLy8gICBUaGUgc2V0IG9mIGFjdGl2ZSBwbHVnaW5zLlxuRWRpdG9yU3RhdGUuZnJvbUpTT04gPSBmdW5jdGlvbiBmcm9tSlNPTiAoY29uZmlnLCBqc29uLCBwbHVnaW5GaWVsZHMpIHtcbiAgaWYgKCFqc29uKSB7IHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgRWRpdG9yU3RhdGUuZnJvbUpTT05cIikgfVxuICBpZiAoIWNvbmZpZy5zY2hlbWEpIHsgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJSZXF1aXJlZCBjb25maWcgZmllbGQgJ3NjaGVtYScgbWlzc2luZ1wiKSB9XG4gIHZhciAkY29uZmlnID0gbmV3IENvbmZpZ3VyYXRpb24oY29uZmlnLnNjaGVtYSwgY29uZmlnLnBsdWdpbnMpO1xuICB2YXIgaW5zdGFuY2UgPSBuZXcgRWRpdG9yU3RhdGUoJGNvbmZpZyk7XG4gICRjb25maWcuZmllbGRzLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgaWYgKGZpZWxkLm5hbWUgPT0gXCJkb2NcIikge1xuICAgICAgaW5zdGFuY2UuZG9jID0gTm9kZS5mcm9tSlNPTihjb25maWcuc2NoZW1hLCBqc29uLmRvYyk7XG4gICAgfSBlbHNlIGlmIChmaWVsZC5uYW1lID09IFwic2VsZWN0aW9uXCIpIHtcbiAgICAgIGluc3RhbmNlLnNlbGVjdGlvbiA9IFNlbGVjdGlvbi5mcm9tSlNPTihpbnN0YW5jZS5kb2MsIGpzb24uc2VsZWN0aW9uKTtcbiAgICB9IGVsc2UgaWYgKGZpZWxkLm5hbWUgPT0gXCJzdG9yZWRNYXJrc1wiKSB7XG4gICAgICBpZiAoanNvbi5zdG9yZWRNYXJrcykgeyBpbnN0YW5jZS5zdG9yZWRNYXJrcyA9IGpzb24uc3RvcmVkTWFya3MubWFwKGNvbmZpZy5zY2hlbWEubWFya0Zyb21KU09OKTsgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocGx1Z2luRmllbGRzKSB7IGZvciAodmFyIHByb3AgaW4gcGx1Z2luRmllbGRzKSB7XG4gICAgICAgIHZhciBwbHVnaW4gPSBwbHVnaW5GaWVsZHNbcHJvcF0sIHN0YXRlID0gcGx1Z2luLnNwZWMuc3RhdGU7XG4gICAgICAgIGlmIChwbHVnaW4ua2V5ID09IGZpZWxkLm5hbWUgJiYgc3RhdGUgJiYgc3RhdGUuZnJvbUpTT04gJiZcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChqc29uLCBwcm9wKSkge1xuICAgICAgICAgIC8vIFRoaXMgZmllbGQgYmVsb25ncyB0byBhIHBsdWdpbiBtYXBwZWQgdG8gYSBKU09OIGZpZWxkLCByZWFkIGl0IGZyb20gdGhlcmUuXG4gICAgICAgICAgaW5zdGFuY2VbZmllbGQubmFtZV0gPSBzdGF0ZS5mcm9tSlNPTi5jYWxsKHBsdWdpbiwgY29uZmlnLCBqc29uW3Byb3BdLCBpbnN0YW5jZSk7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgIH0gfVxuICAgICAgaW5zdGFuY2VbZmllbGQubmFtZV0gPSBmaWVsZC5pbml0KGNvbmZpZywgaW5zdGFuY2UpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBpbnN0YW5jZVxufTtcblxuLy8gS2x1ZGdlIHRvIGFsbG93IHRoZSB2aWV3IHRvIHRyYWNrIG1hcHBpbmdzIGJldHdlZW4gZGlmZmVyZW50XG4vLyBpbnN0YW5jZXMgb2YgYSBzdGF0ZS5cbi8vXG4vLyBGSVhNRSB0aGlzIGlzIG5vIGxvbmdlciBuZWVkZWQgYXMgb2YgcHJvc2VtaXJyb3ItdmlldyAxLjkuMCxcbi8vIHRob3VnaCBkdWUgdG8gYmFja3dhcmRzLWNvbXBhdCB3ZSBzaG91bGQgcHJvYmFibHkga2VlcCBpdCBhcm91bmRcbi8vIGZvciBhIHdoaWxlIChpZiBvbmx5IGFzIGEgbm8tb3ApXG5FZGl0b3JTdGF0ZS5hZGRBcHBseUxpc3RlbmVyID0gZnVuY3Rpb24gYWRkQXBwbHlMaXN0ZW5lciAoZikge1xuICBhcHBseUxpc3RlbmVycy5wdXNoKGYpO1xufTtcbkVkaXRvclN0YXRlLnJlbW92ZUFwcGx5TGlzdGVuZXIgPSBmdW5jdGlvbiByZW1vdmVBcHBseUxpc3RlbmVyIChmKSB7XG4gIHZhciBmb3VuZCA9IGFwcGx5TGlzdGVuZXJzLmluZGV4T2YoZik7XG4gIGlmIChmb3VuZCA+IC0xKSB7IGFwcGx5TGlzdGVuZXJzLnNwbGljZShmb3VuZCwgMSk7IH1cbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBFZGl0b3JTdGF0ZS5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyQxICk7XG5cbnZhciBhcHBseUxpc3RlbmVycyA9IFtdO1xuXG4vLyBQbHVnaW5TcGVjOjogaW50ZXJmYWNlXG4vL1xuLy8gVGhpcyBpcyB0aGUgdHlwZSBwYXNzZWQgdG8gdGhlIFtgUGx1Z2luYF0oI3N0YXRlLlBsdWdpbilcbi8vIGNvbnN0cnVjdG9yLiBJdCBwcm92aWRlcyBhIGRlZmluaXRpb24gZm9yIGEgcGx1Z2luLlxuLy9cbi8vICAgcHJvcHM6OiA/RWRpdG9yUHJvcHNcbi8vICAgVGhlIFt2aWV3IHByb3BzXSgjdmlldy5FZGl0b3JQcm9wcykgYWRkZWQgYnkgdGhpcyBwbHVnaW4uIFByb3BzXG4vLyAgIHRoYXQgYXJlIGZ1bmN0aW9ucyB3aWxsIGJlIGJvdW5kIHRvIGhhdmUgdGhlIHBsdWdpbiBpbnN0YW5jZSBhc1xuLy8gICB0aGVpciBgdGhpc2AgYmluZGluZy5cbi8vXG4vLyAgIHN0YXRlOjogP1N0YXRlRmllbGQ8YW55PlxuLy8gICBBbGxvd3MgYSBwbHVnaW4gdG8gZGVmaW5lIGEgW3N0YXRlIGZpZWxkXSgjc3RhdGUuU3RhdGVGaWVsZCksIGFuXG4vLyAgIGV4dHJhIHNsb3QgaW4gdGhlIHN0YXRlIG9iamVjdCBpbiB3aGljaCBpdCBjYW4ga2VlcCBpdHMgb3duIGRhdGEuXG4vL1xuLy8gICBrZXk6OiA/UGx1Z2luS2V5XG4vLyAgIENhbiBiZSB1c2VkIHRvIG1ha2UgdGhpcyBhIGtleWVkIHBsdWdpbi4gWW91IGNhbiBoYXZlIG9ubHkgb25lXG4vLyAgIHBsdWdpbiB3aXRoIGEgZ2l2ZW4ga2V5IGluIGEgZ2l2ZW4gc3RhdGUsIGJ1dCBpdCBpcyBwb3NzaWJsZSB0b1xuLy8gICBhY2Nlc3MgdGhlIHBsdWdpbidzIGNvbmZpZ3VyYXRpb24gYW5kIHN0YXRlIHRocm91Z2ggdGhlIGtleSxcbi8vICAgd2l0aG91dCBoYXZpbmcgYWNjZXNzIHRvIHRoZSBwbHVnaW4gaW5zdGFuY2Ugb2JqZWN0LlxuLy9cbi8vICAgdmlldzo6ID8oRWRpdG9yVmlldykg4oaSIE9iamVjdFxuLy8gICBXaGVuIHRoZSBwbHVnaW4gbmVlZHMgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgZWRpdG9yIHZpZXcsIG9yXG4vLyAgIHNldCBzb21ldGhpbmcgdXAgaW4gdGhlIERPTSwgdXNlIHRoaXMgZmllbGQuIFRoZSBmdW5jdGlvblxuLy8gICB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBwbHVnaW4ncyBzdGF0ZSBpcyBhc3NvY2lhdGVkIHdpdGggYW5cbi8vICAgZWRpdG9yIHZpZXcuXG4vL1xuLy8gICAgIHJldHVybjo6LVxuLy8gICAgIFNob3VsZCByZXR1cm4gYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBvcHRpb25hbFxuLy8gICAgIHByb3BlcnRpZXM6XG4vL1xuLy8gICAgICAgdXBkYXRlOjogPyh2aWV3OiBFZGl0b3JWaWV3LCBwcmV2U3RhdGU6IEVkaXRvclN0YXRlKVxuLy8gICAgICAgQ2FsbGVkIHdoZW5ldmVyIHRoZSB2aWV3J3Mgc3RhdGUgaXMgdXBkYXRlZC5cbi8vXG4vLyAgICAgICBkZXN0cm95OjogPygpXG4vLyAgICAgICBDYWxsZWQgd2hlbiB0aGUgdmlldyBpcyBkZXN0cm95ZWQgb3IgcmVjZWl2ZXMgYSBzdGF0ZVxuLy8gICAgICAgd2l0aCBkaWZmZXJlbnQgcGx1Z2lucy5cbi8vXG4vLyAgIGZpbHRlclRyYW5zYWN0aW9uOjogPyhUcmFuc2FjdGlvbiwgRWRpdG9yU3RhdGUpIOKGkiBib29sXG4vLyAgIFdoZW4gcHJlc2VudCwgdGhpcyB3aWxsIGJlIGNhbGxlZCBiZWZvcmUgYSB0cmFuc2FjdGlvbiBpc1xuLy8gICBhcHBsaWVkIGJ5IHRoZSBzdGF0ZSwgYWxsb3dpbmcgdGhlIHBsdWdpbiB0byBjYW5jZWwgaXQgKGJ5XG4vLyAgIHJldHVybmluZyBmYWxzZSkuXG4vL1xuLy8gICBhcHBlbmRUcmFuc2FjdGlvbjo6ID8odHJhbnNhY3Rpb25zOiBbVHJhbnNhY3Rpb25dLCBvbGRTdGF0ZTogRWRpdG9yU3RhdGUsIG5ld1N0YXRlOiBFZGl0b3JTdGF0ZSkg4oaSID9UcmFuc2FjdGlvblxuLy8gICBBbGxvd3MgdGhlIHBsdWdpbiB0byBhcHBlbmQgYW5vdGhlciB0cmFuc2FjdGlvbiB0byBiZSBhcHBsaWVkXG4vLyAgIGFmdGVyIHRoZSBnaXZlbiBhcnJheSBvZiB0cmFuc2FjdGlvbnMuIFdoZW4gYW5vdGhlciBwbHVnaW5cbi8vICAgYXBwZW5kcyBhIHRyYW5zYWN0aW9uIGFmdGVyIHRoaXMgd2FzIGNhbGxlZCwgaXQgaXMgY2FsbGVkIGFnYWluXG4vLyAgIHdpdGggdGhlIG5ldyBzdGF0ZSBhbmQgbmV3IHRyYW5zYWN0aW9uc+KAlGJ1dCBvbmx5IHRoZSBuZXdcbi8vICAgdHJhbnNhY3Rpb25zLCBpLmUuIGl0IHdvbid0IGJlIHBhc3NlZCB0cmFuc2FjdGlvbnMgdGhhdCBpdFxuLy8gICBhbHJlYWR5IHNhdy5cblxuZnVuY3Rpb24gYmluZFByb3BzKG9iaiwgc2VsZiwgdGFyZ2V0KSB7XG4gIGZvciAodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgdmFyIHZhbCA9IG9ialtwcm9wXTtcbiAgICBpZiAodmFsIGluc3RhbmNlb2YgRnVuY3Rpb24pIHsgdmFsID0gdmFsLmJpbmQoc2VsZik7IH1cbiAgICBlbHNlIGlmIChwcm9wID09IFwiaGFuZGxlRE9NRXZlbnRzXCIpIHsgdmFsID0gYmluZFByb3BzKHZhbCwgc2VsZiwge30pOyB9XG4gICAgdGFyZ2V0W3Byb3BdID0gdmFsO1xuICB9XG4gIHJldHVybiB0YXJnZXRcbn1cblxuLy8gOjotIFBsdWdpbnMgYnVuZGxlIGZ1bmN0aW9uYWxpdHkgdGhhdCBjYW4gYmUgYWRkZWQgdG8gYW4gZWRpdG9yLlxuLy8gVGhleSBhcmUgcGFydCBvZiB0aGUgW2VkaXRvciBzdGF0ZV0oI3N0YXRlLkVkaXRvclN0YXRlKSBhbmRcbi8vIG1heSBpbmZsdWVuY2UgdGhhdCBzdGF0ZSBhbmQgdGhlIHZpZXcgdGhhdCBjb250YWlucyBpdC5cbnZhciBQbHVnaW4gPSBmdW5jdGlvbiBQbHVnaW4oc3BlYykge1xuICAvLyA6OiBFZGl0b3JQcm9wc1xuICAvLyBUaGUgW3Byb3BzXSgjdmlldy5FZGl0b3JQcm9wcykgZXhwb3J0ZWQgYnkgdGhpcyBwbHVnaW4uXG4gIHRoaXMucHJvcHMgPSB7fTtcbiAgaWYgKHNwZWMucHJvcHMpIHsgYmluZFByb3BzKHNwZWMucHJvcHMsIHRoaXMsIHRoaXMucHJvcHMpOyB9XG4gIC8vIDo6IE9iamVjdFxuICAvLyBUaGUgcGx1Z2luJ3MgW3NwZWMgb2JqZWN0XSgjc3RhdGUuUGx1Z2luU3BlYykuXG4gIHRoaXMuc3BlYyA9IHNwZWM7XG4gIHRoaXMua2V5ID0gc3BlYy5rZXkgPyBzcGVjLmtleS5rZXkgOiBjcmVhdGVLZXkoXCJwbHVnaW5cIik7XG59O1xuXG4vLyA6OiAoRWRpdG9yU3RhdGUpIOKGkiBhbnlcbi8vIEV4dHJhY3QgdGhlIHBsdWdpbidzIHN0YXRlIGZpZWxkIGZyb20gYW4gZWRpdG9yIHN0YXRlLlxuUGx1Z2luLnByb3RvdHlwZS5nZXRTdGF0ZSA9IGZ1bmN0aW9uIGdldFN0YXRlIChzdGF0ZSkgeyByZXR1cm4gc3RhdGVbdGhpcy5rZXldIH07XG5cbi8vIFN0YXRlRmllbGQ6OiBpbnRlcmZhY2U8VD5cbi8vIEEgcGx1Z2luIHNwZWMgbWF5IHByb3ZpZGUgYSBzdGF0ZSBmaWVsZCAodW5kZXIgaXRzXG4vLyBbYHN0YXRlYF0oI3N0YXRlLlBsdWdpblNwZWMuc3RhdGUpIHByb3BlcnR5KSBvZiB0aGlzIHR5cGUsIHdoaWNoXG4vLyBkZXNjcmliZXMgdGhlIHN0YXRlIGl0IHdhbnRzIHRvIGtlZXAuIEZ1bmN0aW9ucyBwcm92aWRlZCBoZXJlIGFyZVxuLy8gYWx3YXlzIGNhbGxlZCB3aXRoIHRoZSBwbHVnaW4gaW5zdGFuY2UgYXMgdGhlaXIgYHRoaXNgIGJpbmRpbmcuXG4vL1xuLy8gICBpbml0OjogKGNvbmZpZzogT2JqZWN0LCBpbnN0YW5jZTogRWRpdG9yU3RhdGUpIOKGkiBUXG4vLyAgIEluaXRpYWxpemUgdGhlIHZhbHVlIG9mIHRoZSBmaWVsZC4gYGNvbmZpZ2Agd2lsbCBiZSB0aGUgb2JqZWN0XG4vLyAgIHBhc3NlZCB0byBbYEVkaXRvclN0YXRlLmNyZWF0ZWBdKCNzdGF0ZS5FZGl0b3JTdGF0ZV5jcmVhdGUpLiBOb3RlXG4vLyAgIHRoYXQgYGluc3RhbmNlYCBpcyBhIGhhbGYtaW5pdGlhbGl6ZWQgc3RhdGUgaW5zdGFuY2UsIGFuZCB3aWxsXG4vLyAgIG5vdCBoYXZlIHZhbHVlcyBmb3IgcGx1Z2luIGZpZWxkcyBpbml0aWFsaXplZCBhZnRlciB0aGlzIG9uZS5cbi8vXG4vLyAgIGFwcGx5OjogKHRyOiBUcmFuc2FjdGlvbiwgdmFsdWU6IFQsIG9sZFN0YXRlOiBFZGl0b3JTdGF0ZSwgbmV3U3RhdGU6IEVkaXRvclN0YXRlKSDihpIgVFxuLy8gICBBcHBseSB0aGUgZ2l2ZW4gdHJhbnNhY3Rpb24gdG8gdGhpcyBzdGF0ZSBmaWVsZCwgcHJvZHVjaW5nIGEgbmV3XG4vLyAgIGZpZWxkIHZhbHVlLiBOb3RlIHRoYXQgdGhlIGBuZXdTdGF0ZWAgYXJndW1lbnQgaXMgYWdhaW4gYSBwYXJ0aWFsbHlcbi8vICAgY29uc3RydWN0ZWQgc3RhdGUgZG9lcyBub3QgeWV0IGNvbnRhaW4gdGhlIHN0YXRlIGZyb20gcGx1Z2luc1xuLy8gICBjb21pbmcgYWZ0ZXIgdGhpcyBvbmUuXG4vL1xuLy8gICB0b0pTT046OiA/KHZhbHVlOiBUKSDihpIgKlxuLy8gICBDb252ZXJ0IHRoaXMgZmllbGQgdG8gSlNPTi4gT3B0aW9uYWwsIGNhbiBiZSBsZWZ0IG9mZiB0byBkaXNhYmxlXG4vLyAgIEpTT04gc2VyaWFsaXphdGlvbiBmb3IgdGhlIGZpZWxkLlxuLy9cbi8vICAgZnJvbUpTT046OiA/KGNvbmZpZzogT2JqZWN0LCB2YWx1ZTogKiwgc3RhdGU6IEVkaXRvclN0YXRlKSDihpIgVFxuLy8gICBEZXNlcmlhbGl6ZSB0aGUgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGZpZWxkLiBOb3RlIHRoYXQgdGhlXG4vLyAgIGBzdGF0ZWAgYXJndW1lbnQgaXMgYWdhaW4gYSBoYWxmLWluaXRpYWxpemVkIHN0YXRlLlxuXG52YXIga2V5cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUtleShuYW1lKSB7XG4gIGlmIChuYW1lIGluIGtleXMpIHsgcmV0dXJuIG5hbWUgKyBcIiRcIiArICsra2V5c1tuYW1lXSB9XG4gIGtleXNbbmFtZV0gPSAwO1xuICByZXR1cm4gbmFtZSArIFwiJFwiXG59XG5cbi8vIDo6LSBBIGtleSBpcyB1c2VkIHRvIFt0YWddKCNzdGF0ZS5QbHVnaW5TcGVjLmtleSlcbi8vIHBsdWdpbnMgaW4gYSB3YXkgdGhhdCBtYWtlcyBpdCBwb3NzaWJsZSB0byBmaW5kIHRoZW0sIGdpdmVuIGFuXG4vLyBlZGl0b3Igc3RhdGUuIEFzc2lnbmluZyBhIGtleSBkb2VzIG1lYW4gb25seSBvbmUgcGx1Z2luIG9mIHRoYXRcbi8vIHR5cGUgY2FuIGJlIGFjdGl2ZSBpbiBhIHN0YXRlLlxudmFyIFBsdWdpbktleSA9IGZ1bmN0aW9uIFBsdWdpbktleShuYW1lKSB7XG5pZiAoIG5hbWUgPT09IHZvaWQgMCApIG5hbWUgPSBcImtleVwiO1xuIHRoaXMua2V5ID0gY3JlYXRlS2V5KG5hbWUpOyB9O1xuXG4vLyA6OiAoRWRpdG9yU3RhdGUpIOKGkiA/UGx1Z2luXG4vLyBHZXQgdGhlIGFjdGl2ZSBwbHVnaW4gd2l0aCB0aGlzIGtleSwgaWYgYW55LCBmcm9tIGFuIGVkaXRvclxuLy8gc3RhdGUuXG5QbHVnaW5LZXkucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoc3RhdGUpIHsgcmV0dXJuIHN0YXRlLmNvbmZpZy5wbHVnaW5zQnlLZXlbdGhpcy5rZXldIH07XG5cbi8vIDo6IChFZGl0b3JTdGF0ZSkg4oaSID9hbnlcbi8vIEdldCB0aGUgcGx1Z2luJ3Mgc3RhdGUgZnJvbSBhbiBlZGl0b3Igc3RhdGUuXG5QbHVnaW5LZXkucHJvdG90eXBlLmdldFN0YXRlID0gZnVuY3Rpb24gZ2V0U3RhdGUgKHN0YXRlKSB7IHJldHVybiBzdGF0ZVt0aGlzLmtleV0gfTtcblxuZXhwb3J0IHsgQWxsU2VsZWN0aW9uLCBFZGl0b3JTdGF0ZSwgTm9kZVNlbGVjdGlvbiwgUGx1Z2luLCBQbHVnaW5LZXksIFNlbGVjdGlvbiwgU2VsZWN0aW9uUmFuZ2UsIFRleHRTZWxlY3Rpb24sIFRyYW5zYWN0aW9uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lcy5qcy5tYXBcbiIsImltcG9ydCB7IFJlcGxhY2VFcnJvciwgU2xpY2UsIEZyYWdtZW50LCBNYXJrVHlwZSB9IGZyb20gJ3Byb3NlbWlycm9yLW1vZGVsJztcblxuLy8gTWFwcGFibGU6OiBpbnRlcmZhY2Vcbi8vIFRoZXJlIGFyZSBzZXZlcmFsIHRoaW5ncyB0aGF0IHBvc2l0aW9ucyBjYW4gYmUgbWFwcGVkIHRocm91Z2guXG4vLyBTdWNoIG9iamVjdHMgY29uZm9ybSB0byB0aGlzIGludGVyZmFjZS5cbi8vXG4vLyAgIG1hcDo6IChwb3M6IG51bWJlciwgYXNzb2M6ID9udW1iZXIpIOKGkiBudW1iZXJcbi8vICAgTWFwIGEgcG9zaXRpb24gdGhyb3VnaCB0aGlzIG9iamVjdC4gV2hlbiBnaXZlbiwgYGFzc29jYCAoc2hvdWxkXG4vLyAgIGJlIC0xIG9yIDEsIGRlZmF1bHRzIHRvIDEpIGRldGVybWluZXMgd2l0aCB3aGljaCBzaWRlIHRoZVxuLy8gICBwb3NpdGlvbiBpcyBhc3NvY2lhdGVkLCB3aGljaCBkZXRlcm1pbmVzIGluIHdoaWNoIGRpcmVjdGlvbiB0b1xuLy8gICBtb3ZlIHdoZW4gYSBjaHVuayBvZiBjb250ZW50IGlzIGluc2VydGVkIGF0IHRoZSBtYXBwZWQgcG9zaXRpb24uXG4vL1xuLy8gICBtYXBSZXN1bHQ6OiAocG9zOiBudW1iZXIsIGFzc29jOiA/bnVtYmVyKSDihpIgTWFwUmVzdWx0XG4vLyAgIE1hcCBhIHBvc2l0aW9uLCBhbmQgcmV0dXJuIGFuIG9iamVjdCBjb250YWluaW5nIGFkZGl0aW9uYWxcbi8vICAgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG1hcHBpbmcuIFRoZSByZXN1bHQncyBgZGVsZXRlZGAgZmllbGQgdGVsbHNcbi8vICAgeW91IHdoZXRoZXIgdGhlIHBvc2l0aW9uIHdhcyBkZWxldGVkIChjb21wbGV0ZWx5IGVuY2xvc2VkIGluIGFcbi8vICAgcmVwbGFjZWQgcmFuZ2UpIGR1cmluZyB0aGUgbWFwcGluZy4gV2hlbiBjb250ZW50IG9uIG9ubHkgb25lIHNpZGVcbi8vICAgaXMgZGVsZXRlZCwgdGhlIHBvc2l0aW9uIGl0c2VsZiBpcyBvbmx5IGNvbnNpZGVyZWQgZGVsZXRlZCB3aGVuXG4vLyAgIGBhc3NvY2AgcG9pbnRzIGluIHRoZSBkaXJlY3Rpb24gb2YgdGhlIGRlbGV0ZWQgY29udGVudC5cblxuLy8gUmVjb3ZlcnkgdmFsdWVzIGVuY29kZSBhIHJhbmdlIGluZGV4IGFuZCBhbiBvZmZzZXQuIFRoZXkgYXJlXG4vLyByZXByZXNlbnRlZCBhcyBudW1iZXJzLCBiZWNhdXNlIHRvbnMgb2YgdGhlbSB3aWxsIGJlIGNyZWF0ZWQgd2hlblxuLy8gbWFwcGluZywgZm9yIGV4YW1wbGUsIGEgbGFyZ2UgbnVtYmVyIG9mIGRlY29yYXRpb25zLiBUaGUgbnVtYmVyJ3Ncbi8vIGxvd2VyIDE2IGJpdHMgcHJvdmlkZSB0aGUgaW5kZXgsIHRoZSByZW1haW5pbmcgYml0cyB0aGUgb2Zmc2V0LlxuLy9cbi8vIE5vdGU6IFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGJpdCBzaGlmdCBvcGVyYXRvcnMgdG8gZW4tIGFuZFxuLy8gZGVjb2RlIHRoZXNlLCBzaW5jZSB0aG9zZSBjbGlwIHRvIDMyIGJpdHMsIHdoaWNoIHdlIG1pZ2h0IGluIHJhcmVcbi8vIGNhc2VzIHdhbnQgdG8gb3ZlcmZsb3cuIEEgNjQtYml0IGZsb2F0IGNhbiByZXByZXNlbnQgNDgtYml0XG4vLyBpbnRlZ2VycyBwcmVjaXNlbHkuXG5cbnZhciBsb3dlcjE2ID0gMHhmZmZmO1xudmFyIGZhY3RvcjE2ID0gTWF0aC5wb3coMiwgMTYpO1xuXG5mdW5jdGlvbiBtYWtlUmVjb3ZlcihpbmRleCwgb2Zmc2V0KSB7IHJldHVybiBpbmRleCArIG9mZnNldCAqIGZhY3RvcjE2IH1cbmZ1bmN0aW9uIHJlY292ZXJJbmRleCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgJiBsb3dlcjE2IH1cbmZ1bmN0aW9uIHJlY292ZXJPZmZzZXQodmFsdWUpIHsgcmV0dXJuICh2YWx1ZSAtICh2YWx1ZSAmIGxvd2VyMTYpKSAvIGZhY3RvcjE2IH1cblxuLy8gOjotIEFuIG9iamVjdCByZXByZXNlbnRpbmcgYSBtYXBwZWQgcG9zaXRpb24gd2l0aCBleHRyYVxuLy8gaW5mb3JtYXRpb24uXG52YXIgTWFwUmVzdWx0ID0gZnVuY3Rpb24gTWFwUmVzdWx0KHBvcywgZGVsZXRlZCwgcmVjb3Zlcikge1xuICBpZiAoIGRlbGV0ZWQgPT09IHZvaWQgMCApIGRlbGV0ZWQgPSBmYWxzZTtcbiAgaWYgKCByZWNvdmVyID09PSB2b2lkIDAgKSByZWNvdmVyID0gbnVsbDtcblxuICAvLyA6OiBudW1iZXIgVGhlIG1hcHBlZCB2ZXJzaW9uIG9mIHRoZSBwb3NpdGlvbi5cbiAgdGhpcy5wb3MgPSBwb3M7XG4gIC8vIDo6IGJvb2wgVGVsbHMgeW91IHdoZXRoZXIgdGhlIHBvc2l0aW9uIHdhcyBkZWxldGVkLCB0aGF0IGlzLFxuICAvLyB3aGV0aGVyIHRoZSBzdGVwIHJlbW92ZWQgaXRzIHN1cnJvdW5kaW5ncyBmcm9tIHRoZSBkb2N1bWVudC5cbiAgdGhpcy5kZWxldGVkID0gZGVsZXRlZDtcbiAgdGhpcy5yZWNvdmVyID0gcmVjb3Zlcjtcbn07XG5cbi8vIDo6IGNsYXNzIGV4dGVuZHMgTWFwcGFibGVcbi8vIEEgbWFwIGRlc2NyaWJpbmcgdGhlIGRlbGV0aW9ucyBhbmQgaW5zZXJ0aW9ucyBtYWRlIGJ5IGEgc3RlcCwgd2hpY2hcbi8vIGNhbiBiZSB1c2VkIHRvIGZpbmQgdGhlIGNvcnJlc3BvbmRlbmNlIGJldHdlZW4gcG9zaXRpb25zIGluIHRoZVxuLy8gcHJlLXN0ZXAgdmVyc2lvbiBvZiBhIGRvY3VtZW50IGFuZCB0aGUgc2FtZSBwb3NpdGlvbiBpbiB0aGVcbi8vIHBvc3Qtc3RlcCB2ZXJzaW9uLlxudmFyIFN0ZXBNYXAgPSBmdW5jdGlvbiBTdGVwTWFwKHJhbmdlcywgaW52ZXJ0ZWQpIHtcbiAgaWYgKCBpbnZlcnRlZCA9PT0gdm9pZCAwICkgaW52ZXJ0ZWQgPSBmYWxzZTtcblxuICB0aGlzLnJhbmdlcyA9IHJhbmdlcztcbiAgdGhpcy5pbnZlcnRlZCA9IGludmVydGVkO1xufTtcblxuU3RlcE1hcC5wcm90b3R5cGUucmVjb3ZlciA9IGZ1bmN0aW9uIHJlY292ZXIgKHZhbHVlKSB7XG4gIHZhciBkaWZmID0gMCwgaW5kZXggPSByZWNvdmVySW5kZXgodmFsdWUpO1xuICBpZiAoIXRoaXMuaW52ZXJ0ZWQpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmRleDsgaSsrKVxuICAgIHsgZGlmZiArPSB0aGlzLnJhbmdlc1tpICogMyArIDJdIC0gdGhpcy5yYW5nZXNbaSAqIDMgKyAxXTsgfSB9XG4gIHJldHVybiB0aGlzLnJhbmdlc1tpbmRleCAqIDNdICsgZGlmZiArIHJlY292ZXJPZmZzZXQodmFsdWUpXG59O1xuXG4vLyA6IChudW1iZXIsID9udW1iZXIpIOKGkiBNYXBSZXN1bHRcblN0ZXBNYXAucHJvdG90eXBlLm1hcFJlc3VsdCA9IGZ1bmN0aW9uIG1hcFJlc3VsdCAocG9zLCBhc3NvYykge1xuICBpZiAoIGFzc29jID09PSB2b2lkIDAgKSBhc3NvYyA9IDE7XG4gcmV0dXJuIHRoaXMuX21hcChwb3MsIGFzc29jLCBmYWxzZSkgfTtcblxuLy8gOiAobnVtYmVyLCA/bnVtYmVyKSDihpIgbnVtYmVyXG5TdGVwTWFwLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiBtYXAgKHBvcywgYXNzb2MpIHtcbiAgaWYgKCBhc3NvYyA9PT0gdm9pZCAwICkgYXNzb2MgPSAxO1xuIHJldHVybiB0aGlzLl9tYXAocG9zLCBhc3NvYywgdHJ1ZSkgfTtcblxuU3RlcE1hcC5wcm90b3R5cGUuX21hcCA9IGZ1bmN0aW9uIF9tYXAgKHBvcywgYXNzb2MsIHNpbXBsZSkge1xuICB2YXIgZGlmZiA9IDAsIG9sZEluZGV4ID0gdGhpcy5pbnZlcnRlZCA/IDIgOiAxLCBuZXdJbmRleCA9IHRoaXMuaW52ZXJ0ZWQgPyAxIDogMjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJhbmdlcy5sZW5ndGg7IGkgKz0gMykge1xuICAgIHZhciBzdGFydCA9IHRoaXMucmFuZ2VzW2ldIC0gKHRoaXMuaW52ZXJ0ZWQgPyBkaWZmIDogMCk7XG4gICAgaWYgKHN0YXJ0ID4gcG9zKSB7IGJyZWFrIH1cbiAgICB2YXIgb2xkU2l6ZSA9IHRoaXMucmFuZ2VzW2kgKyBvbGRJbmRleF0sIG5ld1NpemUgPSB0aGlzLnJhbmdlc1tpICsgbmV3SW5kZXhdLCBlbmQgPSBzdGFydCArIG9sZFNpemU7XG4gICAgaWYgKHBvcyA8PSBlbmQpIHtcbiAgICAgIHZhciBzaWRlID0gIW9sZFNpemUgPyBhc3NvYyA6IHBvcyA9PSBzdGFydCA/IC0xIDogcG9zID09IGVuZCA/IDEgOiBhc3NvYztcbiAgICAgIHZhciByZXN1bHQgPSBzdGFydCArIGRpZmYgKyAoc2lkZSA8IDAgPyAwIDogbmV3U2l6ZSk7XG4gICAgICBpZiAoc2ltcGxlKSB7IHJldHVybiByZXN1bHQgfVxuICAgICAgdmFyIHJlY292ZXIgPSBwb3MgPT0gKGFzc29jIDwgMCA/IHN0YXJ0IDogZW5kKSA/IG51bGwgOiBtYWtlUmVjb3ZlcihpIC8gMywgcG9zIC0gc3RhcnQpO1xuICAgICAgcmV0dXJuIG5ldyBNYXBSZXN1bHQocmVzdWx0LCBhc3NvYyA8IDAgPyBwb3MgIT0gc3RhcnQgOiBwb3MgIT0gZW5kLCByZWNvdmVyKVxuICAgIH1cbiAgICBkaWZmICs9IG5ld1NpemUgLSBvbGRTaXplO1xuICB9XG4gIHJldHVybiBzaW1wbGUgPyBwb3MgKyBkaWZmIDogbmV3IE1hcFJlc3VsdChwb3MgKyBkaWZmKVxufTtcblxuU3RlcE1hcC5wcm90b3R5cGUudG91Y2hlcyA9IGZ1bmN0aW9uIHRvdWNoZXMgKHBvcywgcmVjb3Zlcikge1xuICB2YXIgZGlmZiA9IDAsIGluZGV4ID0gcmVjb3ZlckluZGV4KHJlY292ZXIpO1xuICB2YXIgb2xkSW5kZXggPSB0aGlzLmludmVydGVkID8gMiA6IDEsIG5ld0luZGV4ID0gdGhpcy5pbnZlcnRlZCA/IDEgOiAyO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucmFuZ2VzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5yYW5nZXNbaV0gLSAodGhpcy5pbnZlcnRlZCA/IGRpZmYgOiAwKTtcbiAgICBpZiAoc3RhcnQgPiBwb3MpIHsgYnJlYWsgfVxuICAgIHZhciBvbGRTaXplID0gdGhpcy5yYW5nZXNbaSArIG9sZEluZGV4XSwgZW5kID0gc3RhcnQgKyBvbGRTaXplO1xuICAgIGlmIChwb3MgPD0gZW5kICYmIGkgPT0gaW5kZXggKiAzKSB7IHJldHVybiB0cnVlIH1cbiAgICBkaWZmICs9IHRoaXMucmFuZ2VzW2kgKyBuZXdJbmRleF0gLSBvbGRTaXplO1xuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gOjogKChvbGRTdGFydDogbnVtYmVyLCBvbGRFbmQ6IG51bWJlciwgbmV3U3RhcnQ6IG51bWJlciwgbmV3RW5kOiBudW1iZXIpKVxuLy8gQ2FsbHMgdGhlIGdpdmVuIGZ1bmN0aW9uIG9uIGVhY2ggb2YgdGhlIGNoYW5nZWQgcmFuZ2VzIGluY2x1ZGVkIGluXG4vLyB0aGlzIG1hcC5cblN0ZXBNYXAucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoIChmKSB7XG4gIHZhciBvbGRJbmRleCA9IHRoaXMuaW52ZXJ0ZWQgPyAyIDogMSwgbmV3SW5kZXggPSB0aGlzLmludmVydGVkID8gMSA6IDI7XG4gIGZvciAodmFyIGkgPSAwLCBkaWZmID0gMDsgaSA8IHRoaXMucmFuZ2VzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5yYW5nZXNbaV0sIG9sZFN0YXJ0ID0gc3RhcnQgLSAodGhpcy5pbnZlcnRlZCA/IGRpZmYgOiAwKSwgbmV3U3RhcnQgPSBzdGFydCArICh0aGlzLmludmVydGVkID8gMCA6IGRpZmYpO1xuICAgIHZhciBvbGRTaXplID0gdGhpcy5yYW5nZXNbaSArIG9sZEluZGV4XSwgbmV3U2l6ZSA9IHRoaXMucmFuZ2VzW2kgKyBuZXdJbmRleF07XG4gICAgZihvbGRTdGFydCwgb2xkU3RhcnQgKyBvbGRTaXplLCBuZXdTdGFydCwgbmV3U3RhcnQgKyBuZXdTaXplKTtcbiAgICBkaWZmICs9IG5ld1NpemUgLSBvbGRTaXplO1xuICB9XG59O1xuXG4vLyA6OiAoKSDihpIgU3RlcE1hcFxuLy8gQ3JlYXRlIGFuIGludmVydGVkIHZlcnNpb24gb2YgdGhpcyBtYXAuIFRoZSByZXN1bHQgY2FuIGJlIHVzZWQgdG9cbi8vIG1hcCBwb3NpdGlvbnMgaW4gdGhlIHBvc3Qtc3RlcCBkb2N1bWVudCB0byB0aGUgcHJlLXN0ZXAgZG9jdW1lbnQuXG5TdGVwTWFwLnByb3RvdHlwZS5pbnZlcnQgPSBmdW5jdGlvbiBpbnZlcnQgKCkge1xuICByZXR1cm4gbmV3IFN0ZXBNYXAodGhpcy5yYW5nZXMsICF0aGlzLmludmVydGVkKVxufTtcblxuU3RlcE1hcC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHJldHVybiAodGhpcy5pbnZlcnRlZCA/IFwiLVwiIDogXCJcIikgKyBKU09OLnN0cmluZ2lmeSh0aGlzLnJhbmdlcylcbn07XG5cbi8vIDo6IChuOiBudW1iZXIpIOKGkiBTdGVwTWFwXG4vLyBDcmVhdGUgYSBtYXAgdGhhdCBtb3ZlcyBhbGwgcG9zaXRpb25zIGJ5IG9mZnNldCBgbmAgKHdoaWNoIG1heSBiZVxuLy8gbmVnYXRpdmUpLiBUaGlzIGNhbiBiZSB1c2VmdWwgd2hlbiBhcHBseWluZyBzdGVwcyBtZWFudCBmb3IgYVxuLy8gc3ViLWRvY3VtZW50IHRvIGEgbGFyZ2VyIGRvY3VtZW50LCBvciB2aWNlLXZlcnNhLlxuU3RlcE1hcC5vZmZzZXQgPSBmdW5jdGlvbiBvZmZzZXQgKG4pIHtcbiAgcmV0dXJuIG4gPT0gMCA/IFN0ZXBNYXAuZW1wdHkgOiBuZXcgU3RlcE1hcChuIDwgMCA/IFswLCAtbiwgMF0gOiBbMCwgMCwgbl0pXG59O1xuXG5TdGVwTWFwLmVtcHR5ID0gbmV3IFN0ZXBNYXAoW10pO1xuXG4vLyA6OiBjbGFzcyBleHRlbmRzIE1hcHBhYmxlXG4vLyBBIG1hcHBpbmcgcmVwcmVzZW50cyBhIHBpcGVsaW5lIG9mIHplcm8gb3IgbW9yZSBbc3RlcFxuLy8gbWFwc10oI3RyYW5zZm9ybS5TdGVwTWFwKS4gSXQgaGFzIHNwZWNpYWwgcHJvdmlzaW9ucyBmb3IgbG9zc2xlc3NseVxuLy8gaGFuZGxpbmcgbWFwcGluZyBwb3NpdGlvbnMgdGhyb3VnaCBhIHNlcmllcyBvZiBzdGVwcyBpbiB3aGljaCBzb21lXG4vLyBzdGVwcyBhcmUgaW52ZXJ0ZWQgdmVyc2lvbnMgb2YgZWFybGllciBzdGVwcy4gKFRoaXMgY29tZXMgdXAgd2hlblxuLy8g4oCYW3JlYmFzaW5nXSgvZG9jcy9ndWlkZS8jdHJhbnNmb3JtLnJlYmFzaW5nKeKAmSBzdGVwcyBmb3Jcbi8vIGNvbGxhYm9yYXRpb24gb3IgaGlzdG9yeSBtYW5hZ2VtZW50LilcbnZhciBNYXBwaW5nID0gZnVuY3Rpb24gTWFwcGluZyhtYXBzLCBtaXJyb3IsIGZyb20sIHRvKSB7XG4gIC8vIDo6IFtTdGVwTWFwXVxuICAvLyBUaGUgc3RlcCBtYXBzIGluIHRoaXMgbWFwcGluZy5cbiAgdGhpcy5tYXBzID0gbWFwcyB8fCBbXTtcbiAgLy8gOjogbnVtYmVyXG4gIC8vIFRoZSBzdGFydGluZyBwb3NpdGlvbiBpbiB0aGUgYG1hcHNgIGFycmF5LCB1c2VkIHdoZW4gYG1hcGAgb3JcbiAgLy8gYG1hcFJlc3VsdGAgaXMgY2FsbGVkLlxuICB0aGlzLmZyb20gPSBmcm9tIHx8IDA7XG4gIC8vIDo6IG51bWJlclxuICAvLyBUaGUgZW5kIHBvc2l0aW9uIGluIHRoZSBgbWFwc2AgYXJyYXkuXG4gIHRoaXMudG8gPSB0byA9PSBudWxsID8gdGhpcy5tYXBzLmxlbmd0aCA6IHRvO1xuICB0aGlzLm1pcnJvciA9IG1pcnJvcjtcbn07XG5cbi8vIDo6ICg/bnVtYmVyLCA/bnVtYmVyKSDihpIgTWFwcGluZ1xuLy8gQ3JlYXRlIGEgbWFwcGluZyB0aGF0IG1hcHMgb25seSB0aHJvdWdoIGEgcGFydCBvZiB0aGlzIG9uZS5cbk1hcHBpbmcucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKGZyb20sIHRvKSB7XG4gICAgaWYgKCBmcm9tID09PSB2b2lkIDAgKSBmcm9tID0gMDtcbiAgICBpZiAoIHRvID09PSB2b2lkIDAgKSB0byA9IHRoaXMubWFwcy5sZW5ndGg7XG5cbiAgcmV0dXJuIG5ldyBNYXBwaW5nKHRoaXMubWFwcywgdGhpcy5taXJyb3IsIGZyb20sIHRvKVxufTtcblxuTWFwcGluZy5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKCkge1xuICByZXR1cm4gbmV3IE1hcHBpbmcodGhpcy5tYXBzLnNsaWNlKCksIHRoaXMubWlycm9yICYmIHRoaXMubWlycm9yLnNsaWNlKCksIHRoaXMuZnJvbSwgdGhpcy50bylcbn07XG5cbi8vIDo6IChTdGVwTWFwLCA/bnVtYmVyKVxuLy8gQWRkIGEgc3RlcCBtYXAgdG8gdGhlIGVuZCBvZiB0aGlzIG1hcHBpbmcuIElmIGBtaXJyb3JzYCBpc1xuLy8gZ2l2ZW4sIGl0IHNob3VsZCBiZSB0aGUgaW5kZXggb2YgdGhlIHN0ZXAgbWFwIHRoYXQgaXMgdGhlIG1pcnJvclxuLy8gaW1hZ2Ugb2YgdGhpcyBvbmUuXG5NYXBwaW5nLnByb3RvdHlwZS5hcHBlbmRNYXAgPSBmdW5jdGlvbiBhcHBlbmRNYXAgKG1hcCwgbWlycm9ycykge1xuICB0aGlzLnRvID0gdGhpcy5tYXBzLnB1c2gobWFwKTtcbiAgaWYgKG1pcnJvcnMgIT0gbnVsbCkgeyB0aGlzLnNldE1pcnJvcih0aGlzLm1hcHMubGVuZ3RoIC0gMSwgbWlycm9ycyk7IH1cbn07XG5cbi8vIDo6IChNYXBwaW5nKVxuLy8gQWRkIGFsbCB0aGUgc3RlcCBtYXBzIGluIGEgZ2l2ZW4gbWFwcGluZyB0byB0aGlzIG9uZSAocHJlc2VydmluZ1xuLy8gbWlycm9yaW5nIGluZm9ybWF0aW9uKS5cbk1hcHBpbmcucHJvdG90eXBlLmFwcGVuZE1hcHBpbmcgPSBmdW5jdGlvbiBhcHBlbmRNYXBwaW5nIChtYXBwaW5nKSB7XG4gIGZvciAodmFyIGkgPSAwLCBzdGFydFNpemUgPSB0aGlzLm1hcHMubGVuZ3RoOyBpIDwgbWFwcGluZy5tYXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG1pcnIgPSBtYXBwaW5nLmdldE1pcnJvcihpKTtcbiAgICB0aGlzLmFwcGVuZE1hcChtYXBwaW5nLm1hcHNbaV0sIG1pcnIgIT0gbnVsbCAmJiBtaXJyIDwgaSA/IHN0YXJ0U2l6ZSArIG1pcnIgOiBudWxsKTtcbiAgfVxufTtcblxuLy8gOjogKG51bWJlcikg4oaSID9udW1iZXJcbi8vIEZpbmRzIHRoZSBvZmZzZXQgb2YgdGhlIHN0ZXAgbWFwIHRoYXQgbWlycm9ycyB0aGUgbWFwIGF0IHRoZVxuLy8gZ2l2ZW4gb2Zmc2V0LCBpbiB0aGlzIG1hcHBpbmcgKGFzIHBlciB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvXG4vLyBgYXBwZW5kTWFwYCkuXG5NYXBwaW5nLnByb3RvdHlwZS5nZXRNaXJyb3IgPSBmdW5jdGlvbiBnZXRNaXJyb3IgKG4pIHtcbiAgaWYgKHRoaXMubWlycm9yKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5taXJyb3IubGVuZ3RoOyBpKyspXG4gICAgeyBpZiAodGhpcy5taXJyb3JbaV0gPT0gbikgeyByZXR1cm4gdGhpcy5taXJyb3JbaSArIChpICUgMiA/IC0xIDogMSldIH0gfSB9XG59O1xuXG5NYXBwaW5nLnByb3RvdHlwZS5zZXRNaXJyb3IgPSBmdW5jdGlvbiBzZXRNaXJyb3IgKG4sIG0pIHtcbiAgaWYgKCF0aGlzLm1pcnJvcikgeyB0aGlzLm1pcnJvciA9IFtdOyB9XG4gIHRoaXMubWlycm9yLnB1c2gobiwgbSk7XG59O1xuXG4vLyA6OiAoTWFwcGluZylcbi8vIEFwcGVuZCB0aGUgaW52ZXJzZSBvZiB0aGUgZ2l2ZW4gbWFwcGluZyB0byB0aGlzIG9uZS5cbk1hcHBpbmcucHJvdG90eXBlLmFwcGVuZE1hcHBpbmdJbnZlcnRlZCA9IGZ1bmN0aW9uIGFwcGVuZE1hcHBpbmdJbnZlcnRlZCAobWFwcGluZykge1xuICBmb3IgKHZhciBpID0gbWFwcGluZy5tYXBzLmxlbmd0aCAtIDEsIHRvdGFsU2l6ZSA9IHRoaXMubWFwcy5sZW5ndGggKyBtYXBwaW5nLm1hcHMubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgIHZhciBtaXJyID0gbWFwcGluZy5nZXRNaXJyb3IoaSk7XG4gICAgdGhpcy5hcHBlbmRNYXAobWFwcGluZy5tYXBzW2ldLmludmVydCgpLCBtaXJyICE9IG51bGwgJiYgbWlyciA+IGkgPyB0b3RhbFNpemUgLSBtaXJyIC0gMSA6IG51bGwpO1xuICB9XG59O1xuXG4vLyA6OiAoKSDihpIgTWFwcGluZ1xuLy8gQ3JlYXRlIGFuIGludmVydGVkIHZlcnNpb24gb2YgdGhpcyBtYXBwaW5nLlxuTWFwcGluZy5wcm90b3R5cGUuaW52ZXJ0ID0gZnVuY3Rpb24gaW52ZXJ0ICgpIHtcbiAgdmFyIGludmVyc2UgPSBuZXcgTWFwcGluZztcbiAgaW52ZXJzZS5hcHBlbmRNYXBwaW5nSW52ZXJ0ZWQodGhpcyk7XG4gIHJldHVybiBpbnZlcnNlXG59O1xuXG4vLyA6IChudW1iZXIsID9udW1iZXIpIOKGkiBudW1iZXJcbi8vIE1hcCBhIHBvc2l0aW9uIHRocm91Z2ggdGhpcyBtYXBwaW5nLlxuTWFwcGluZy5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gbWFwIChwb3MsIGFzc29jKSB7XG4gICAgaWYgKCBhc3NvYyA9PT0gdm9pZCAwICkgYXNzb2MgPSAxO1xuXG4gIGlmICh0aGlzLm1pcnJvcikgeyByZXR1cm4gdGhpcy5fbWFwKHBvcywgYXNzb2MsIHRydWUpIH1cbiAgZm9yICh2YXIgaSA9IHRoaXMuZnJvbTsgaSA8IHRoaXMudG87IGkrKylcbiAgICB7IHBvcyA9IHRoaXMubWFwc1tpXS5tYXAocG9zLCBhc3NvYyk7IH1cbiAgcmV0dXJuIHBvc1xufTtcblxuLy8gOiAobnVtYmVyLCA/bnVtYmVyKSDihpIgTWFwUmVzdWx0XG4vLyBNYXAgYSBwb3NpdGlvbiB0aHJvdWdoIHRoaXMgbWFwcGluZywgcmV0dXJuaW5nIGEgbWFwcGluZ1xuLy8gcmVzdWx0LlxuTWFwcGluZy5wcm90b3R5cGUubWFwUmVzdWx0ID0gZnVuY3Rpb24gbWFwUmVzdWx0IChwb3MsIGFzc29jKSB7XG4gIGlmICggYXNzb2MgPT09IHZvaWQgMCApIGFzc29jID0gMTtcbiByZXR1cm4gdGhpcy5fbWFwKHBvcywgYXNzb2MsIGZhbHNlKSB9O1xuXG5NYXBwaW5nLnByb3RvdHlwZS5fbWFwID0gZnVuY3Rpb24gX21hcCAocG9zLCBhc3NvYywgc2ltcGxlKSB7XG4gIHZhciBkZWxldGVkID0gZmFsc2U7XG5cbiAgZm9yICh2YXIgaSA9IHRoaXMuZnJvbTsgaSA8IHRoaXMudG87IGkrKykge1xuICAgIHZhciBtYXAgPSB0aGlzLm1hcHNbaV0sIHJlc3VsdCA9IG1hcC5tYXBSZXN1bHQocG9zLCBhc3NvYyk7XG4gICAgaWYgKHJlc3VsdC5yZWNvdmVyICE9IG51bGwpIHtcbiAgICAgIHZhciBjb3JyID0gdGhpcy5nZXRNaXJyb3IoaSk7XG4gICAgICBpZiAoY29yciAhPSBudWxsICYmIGNvcnIgPiBpICYmIGNvcnIgPCB0aGlzLnRvKSB7XG4gICAgICAgIGkgPSBjb3JyO1xuICAgICAgICBwb3MgPSB0aGlzLm1hcHNbY29ycl0ucmVjb3ZlcihyZXN1bHQucmVjb3Zlcik7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdC5kZWxldGVkKSB7IGRlbGV0ZWQgPSB0cnVlOyB9XG4gICAgcG9zID0gcmVzdWx0LnBvcztcbiAgfVxuXG4gIHJldHVybiBzaW1wbGUgPyBwb3MgOiBuZXcgTWFwUmVzdWx0KHBvcywgZGVsZXRlZClcbn07XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybUVycm9yKG1lc3NhZ2UpIHtcbiAgdmFyIGVyciA9IEVycm9yLmNhbGwodGhpcywgbWVzc2FnZSk7XG4gIGVyci5fX3Byb3RvX18gPSBUcmFuc2Zvcm1FcnJvci5wcm90b3R5cGU7XG4gIHJldHVybiBlcnJcbn1cblxuVHJhbnNmb3JtRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuVHJhbnNmb3JtRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVHJhbnNmb3JtRXJyb3I7XG5UcmFuc2Zvcm1FcnJvci5wcm90b3R5cGUubmFtZSA9IFwiVHJhbnNmb3JtRXJyb3JcIjtcblxuLy8gOjotIEFic3RyYWN0aW9uIHRvIGJ1aWxkIHVwIGFuZCB0cmFjayBhbiBhcnJheSBvZlxuLy8gW3N0ZXBzXSgjdHJhbnNmb3JtLlN0ZXApIHJlcHJlc2VudGluZyBhIGRvY3VtZW50IHRyYW5zZm9ybWF0aW9uLlxuLy9cbi8vIE1vc3QgdHJhbnNmb3JtaW5nIG1ldGhvZHMgcmV0dXJuIHRoZSBgVHJhbnNmb3JtYCBvYmplY3QgaXRzZWxmLCBzb1xuLy8gdGhhdCB0aGV5IGNhbiBiZSBjaGFpbmVkLlxudmFyIFRyYW5zZm9ybSA9IGZ1bmN0aW9uIFRyYW5zZm9ybShkb2MpIHtcbiAgLy8gOjogTm9kZVxuICAvLyBUaGUgY3VycmVudCBkb2N1bWVudCAodGhlIHJlc3VsdCBvZiBhcHBseWluZyB0aGUgc3RlcHMgaW4gdGhlXG4gIC8vIHRyYW5zZm9ybSkuXG4gIHRoaXMuZG9jID0gZG9jO1xuICAvLyA6OiBbU3RlcF1cbiAgLy8gVGhlIHN0ZXBzIGluIHRoaXMgdHJhbnNmb3JtLlxuICB0aGlzLnN0ZXBzID0gW107XG4gIC8vIDo6IFtOb2RlXVxuICAvLyBUaGUgZG9jdW1lbnRzIGJlZm9yZSBlYWNoIG9mIHRoZSBzdGVwcy5cbiAgdGhpcy5kb2NzID0gW107XG4gIC8vIDo6IE1hcHBpbmdcbiAgLy8gQSBtYXBwaW5nIHdpdGggdGhlIG1hcHMgZm9yIGVhY2ggb2YgdGhlIHN0ZXBzIGluIHRoaXMgdHJhbnNmb3JtLlxuICB0aGlzLm1hcHBpbmcgPSBuZXcgTWFwcGluZztcbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMgPSB7IGJlZm9yZTogeyBjb25maWd1cmFibGU6IHRydWUgfSxkb2NDaGFuZ2VkOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbi8vIDo6IE5vZGUgVGhlIHN0YXJ0aW5nIGRvY3VtZW50LlxucHJvdG90eXBlQWNjZXNzb3JzLmJlZm9yZS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmRvY3MubGVuZ3RoID8gdGhpcy5kb2NzWzBdIDogdGhpcy5kb2MgfTtcblxuLy8gOjogKHN0ZXA6IFN0ZXApIOKGkiB0aGlzXG4vLyBBcHBseSBhIG5ldyBzdGVwIGluIHRoaXMgdHJhbnNmb3JtLCBzYXZpbmcgdGhlIHJlc3VsdC4gVGhyb3dzIGFuXG4vLyBlcnJvciB3aGVuIHRoZSBzdGVwIGZhaWxzLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5zdGVwID0gZnVuY3Rpb24gc3RlcCAob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLm1heWJlU3RlcChvYmplY3QpO1xuICBpZiAocmVzdWx0LmZhaWxlZCkgeyB0aHJvdyBuZXcgVHJhbnNmb3JtRXJyb3IocmVzdWx0LmZhaWxlZCkgfVxuICByZXR1cm4gdGhpc1xufTtcblxuLy8gOjogKFN0ZXApIOKGkiBTdGVwUmVzdWx0XG4vLyBUcnkgdG8gYXBwbHkgYSBzdGVwIGluIHRoaXMgdHJhbnNmb3JtYXRpb24sIGlnbm9yaW5nIGl0IGlmIGl0XG4vLyBmYWlscy4gUmV0dXJucyB0aGUgc3RlcCByZXN1bHQuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLm1heWJlU3RlcCA9IGZ1bmN0aW9uIG1heWJlU3RlcCAoc3RlcCkge1xuICB2YXIgcmVzdWx0ID0gc3RlcC5hcHBseSh0aGlzLmRvYyk7XG4gIGlmICghcmVzdWx0LmZhaWxlZCkgeyB0aGlzLmFkZFN0ZXAoc3RlcCwgcmVzdWx0LmRvYyk7IH1cbiAgcmV0dXJuIHJlc3VsdFxufTtcblxuLy8gOjogYm9vbFxuLy8gVHJ1ZSB3aGVuIHRoZSBkb2N1bWVudCBoYXMgYmVlbiBjaGFuZ2VkICh3aGVuIHRoZXJlIGFyZSBhbnlcbi8vIHN0ZXBzKS5cbnByb3RvdHlwZUFjY2Vzc29ycy5kb2NDaGFuZ2VkLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuc3RlcHMubGVuZ3RoID4gMFxufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5hZGRTdGVwID0gZnVuY3Rpb24gYWRkU3RlcCAoc3RlcCwgZG9jKSB7XG4gIHRoaXMuZG9jcy5wdXNoKHRoaXMuZG9jKTtcbiAgdGhpcy5zdGVwcy5wdXNoKHN0ZXApO1xuICB0aGlzLm1hcHBpbmcuYXBwZW5kTWFwKHN0ZXAuZ2V0TWFwKCkpO1xuICB0aGlzLmRvYyA9IGRvYztcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBUcmFuc2Zvcm0ucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcblxuZnVuY3Rpb24gbXVzdE92ZXJyaWRlKCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJPdmVycmlkZSBtZVwiKSB9XG5cbnZhciBzdGVwc0J5SUQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4vLyA6Oi0gQSBzdGVwIG9iamVjdCByZXByZXNlbnRzIGFuIGF0b21pYyBjaGFuZ2UuIEl0IGdlbmVyYWxseSBhcHBsaWVzXG4vLyBvbmx5IHRvIHRoZSBkb2N1bWVudCBpdCB3YXMgY3JlYXRlZCBmb3IsIHNpbmNlIHRoZSBwb3NpdGlvbnNcbi8vIHN0b3JlZCBpbiBpdCB3aWxsIG9ubHkgbWFrZSBzZW5zZSBmb3IgdGhhdCBkb2N1bWVudC5cbi8vXG4vLyBOZXcgc3RlcHMgYXJlIGRlZmluZWQgYnkgY3JlYXRpbmcgY2xhc3NlcyB0aGF0IGV4dGVuZCBgU3RlcGAsXG4vLyBvdmVycmlkaW5nIHRoZSBgYXBwbHlgLCBgaW52ZXJ0YCwgYG1hcGAsIGBnZXRNYXBgIGFuZCBgZnJvbUpTT05gXG4vLyBtZXRob2RzLCBhbmQgcmVnaXN0ZXJpbmcgeW91ciBjbGFzcyB3aXRoIGEgdW5pcXVlXG4vLyBKU09OLXNlcmlhbGl6YXRpb24gaWRlbnRpZmllciB1c2luZ1xuLy8gW2BTdGVwLmpzb25JRGBdKCN0cmFuc2Zvcm0uU3RlcF5qc29uSUQpLlxudmFyIFN0ZXAgPSBmdW5jdGlvbiBTdGVwICgpIHt9O1xuXG5TdGVwLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uIGFwcGx5IChfZG9jKSB7IHJldHVybiBtdXN0T3ZlcnJpZGUoKSB9O1xuXG4vLyA6OiAoKSDihpIgU3RlcE1hcFxuLy8gR2V0IHRoZSBzdGVwIG1hcCB0aGF0IHJlcHJlc2VudHMgdGhlIGNoYW5nZXMgbWFkZSBieSB0aGlzIHN0ZXAsXG4vLyBhbmQgd2hpY2ggY2FuIGJlIHVzZWQgdG8gdHJhbnNmb3JtIGJldHdlZW4gcG9zaXRpb25zIGluIHRoZSBvbGRcbi8vIGFuZCB0aGUgbmV3IGRvY3VtZW50LlxuU3RlcC5wcm90b3R5cGUuZ2V0TWFwID0gZnVuY3Rpb24gZ2V0TWFwICgpIHsgcmV0dXJuIFN0ZXBNYXAuZW1wdHkgfTtcblxuLy8gOjogKGRvYzogTm9kZSkg4oaSIFN0ZXBcbi8vIENyZWF0ZSBhbiBpbnZlcnRlZCB2ZXJzaW9uIG9mIHRoaXMgc3RlcC4gTmVlZHMgdGhlIGRvY3VtZW50IGFzIGl0XG4vLyB3YXMgYmVmb3JlIHRoZSBzdGVwIGFzIGFyZ3VtZW50LlxuU3RlcC5wcm90b3R5cGUuaW52ZXJ0ID0gZnVuY3Rpb24gaW52ZXJ0IChfZG9jKSB7IHJldHVybiBtdXN0T3ZlcnJpZGUoKSB9O1xuXG4vLyA6OiAobWFwcGluZzogTWFwcGFibGUpIOKGkiA/U3RlcFxuLy8gTWFwIHRoaXMgc3RlcCB0aHJvdWdoIGEgbWFwcGFibGUgdGhpbmcsIHJldHVybmluZyBlaXRoZXIgYVxuLy8gdmVyc2lvbiBvZiB0aGF0IHN0ZXAgd2l0aCBpdHMgcG9zaXRpb25zIGFkanVzdGVkLCBvciBgbnVsbGAgaWZcbi8vIHRoZSBzdGVwIHdhcyBlbnRpcmVseSBkZWxldGVkIGJ5IHRoZSBtYXBwaW5nLlxuU3RlcC5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gbWFwIChfbWFwcGluZykgeyByZXR1cm4gbXVzdE92ZXJyaWRlKCkgfTtcblxuLy8gOjogKG90aGVyOiBTdGVwKSDihpIgP1N0ZXBcbi8vIFRyeSB0byBtZXJnZSB0aGlzIHN0ZXAgd2l0aCBhbm90aGVyIG9uZSwgdG8gYmUgYXBwbGllZCBkaXJlY3RseVxuLy8gYWZ0ZXIgaXQuIFJldHVybnMgdGhlIG1lcmdlZCBzdGVwIHdoZW4gcG9zc2libGUsIG51bGwgaWYgdGhlXG4vLyBzdGVwcyBjYW4ndCBiZSBtZXJnZWQuXG5TdGVwLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uIG1lcmdlIChfb3RoZXIpIHsgcmV0dXJuIG51bGwgfTtcblxuLy8gOjogKCkg4oaSIE9iamVjdFxuLy8gQ3JlYXRlIGEgSlNPTi1zZXJpYWxpemVhYmxlIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgc3RlcC4gV2hlblxuLy8gZGVmaW5pbmcgdGhpcyBmb3IgYSBjdXN0b20gc3ViY2xhc3MsIG1ha2Ugc3VyZSB0aGUgcmVzdWx0IG9iamVjdFxuLy8gaW5jbHVkZXMgdGhlIHN0ZXAgdHlwZSdzIFtKU09OIGlkXSgjdHJhbnNmb3JtLlN0ZXBeanNvbklEKSB1bmRlclxuLy8gdGhlIGBzdGVwVHlwZWAgcHJvcGVydHkuXG5TdGVwLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkgeyByZXR1cm4gbXVzdE92ZXJyaWRlKCkgfTtcblxuLy8gOjogKFNjaGVtYSwgT2JqZWN0KSDihpIgU3RlcFxuLy8gRGVzZXJpYWxpemUgYSBzdGVwIGZyb20gaXRzIEpTT04gcmVwcmVzZW50YXRpb24uIFdpbGwgY2FsbFxuLy8gdGhyb3VnaCB0byB0aGUgc3RlcCBjbGFzcycgb3duIGltcGxlbWVudGF0aW9uIG9mIHRoaXMgbWV0aG9kLlxuU3RlcC5mcm9tSlNPTiA9IGZ1bmN0aW9uIGZyb21KU09OIChzY2hlbWEsIGpzb24pIHtcbiAgaWYgKCFqc29uIHx8ICFqc29uLnN0ZXBUeXBlKSB7IHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgU3RlcC5mcm9tSlNPTlwiKSB9XG4gIHZhciB0eXBlID0gc3RlcHNCeUlEW2pzb24uc3RlcFR5cGVdO1xuICBpZiAoIXR5cGUpIHsgdGhyb3cgbmV3IFJhbmdlRXJyb3IoKFwiTm8gc3RlcCB0eXBlIFwiICsgKGpzb24uc3RlcFR5cGUpICsgXCIgZGVmaW5lZFwiKSkgfVxuICByZXR1cm4gdHlwZS5mcm9tSlNPTihzY2hlbWEsIGpzb24pXG59O1xuXG4vLyA6OiAoc3RyaW5nLCBjb25zdHJ1Y3RvcjxTdGVwPilcbi8vIFRvIGJlIGFibGUgdG8gc2VyaWFsaXplIHN0ZXBzIHRvIEpTT04sIGVhY2ggc3RlcCBuZWVkcyBhIHN0cmluZ1xuLy8gSUQgdG8gYXR0YWNoIHRvIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uLiBVc2UgdGhpcyBtZXRob2QgdG9cbi8vIHJlZ2lzdGVyIGFuIElEIGZvciB5b3VyIHN0ZXAgY2xhc3Nlcy4gVHJ5IHRvIHBpY2sgc29tZXRoaW5nXG4vLyB0aGF0J3MgdW5saWtlbHkgdG8gY2xhc2ggd2l0aCBzdGVwcyBmcm9tIG90aGVyIG1vZHVsZXMuXG5TdGVwLmpzb25JRCA9IGZ1bmN0aW9uIGpzb25JRCAoaWQsIHN0ZXBDbGFzcykge1xuICBpZiAoaWQgaW4gc3RlcHNCeUlEKSB7IHRocm93IG5ldyBSYW5nZUVycm9yKFwiRHVwbGljYXRlIHVzZSBvZiBzdGVwIEpTT04gSUQgXCIgKyBpZCkgfVxuICBzdGVwc0J5SURbaWRdID0gc3RlcENsYXNzO1xuICBzdGVwQ2xhc3MucHJvdG90eXBlLmpzb25JRCA9IGlkO1xuICByZXR1cm4gc3RlcENsYXNzXG59O1xuXG4vLyA6Oi0gVGhlIHJlc3VsdCBvZiBbYXBwbHlpbmddKCN0cmFuc2Zvcm0uU3RlcC5hcHBseSkgYSBzdGVwLiBDb250YWlucyBlaXRoZXIgYVxuLy8gbmV3IGRvY3VtZW50IG9yIGEgZmFpbHVyZSB2YWx1ZS5cbnZhciBTdGVwUmVzdWx0ID0gZnVuY3Rpb24gU3RlcFJlc3VsdChkb2MsIGZhaWxlZCkge1xuICAvLyA6OiA/Tm9kZSBUaGUgdHJhbnNmb3JtZWQgZG9jdW1lbnQuXG4gIHRoaXMuZG9jID0gZG9jO1xuICAvLyA6OiA/c3RyaW5nIFRleHQgcHJvdmlkaW5nIGluZm9ybWF0aW9uIGFib3V0IGEgZmFpbGVkIHN0ZXAuXG4gIHRoaXMuZmFpbGVkID0gZmFpbGVkO1xufTtcblxuLy8gOjogKE5vZGUpIOKGkiBTdGVwUmVzdWx0XG4vLyBDcmVhdGUgYSBzdWNjZXNzZnVsIHN0ZXAgcmVzdWx0LlxuU3RlcFJlc3VsdC5vayA9IGZ1bmN0aW9uIG9rIChkb2MpIHsgcmV0dXJuIG5ldyBTdGVwUmVzdWx0KGRvYywgbnVsbCkgfTtcblxuLy8gOjogKHN0cmluZykg4oaSIFN0ZXBSZXN1bHRcbi8vIENyZWF0ZSBhIGZhaWxlZCBzdGVwIHJlc3VsdC5cblN0ZXBSZXN1bHQuZmFpbCA9IGZ1bmN0aW9uIGZhaWwgKG1lc3NhZ2UpIHsgcmV0dXJuIG5ldyBTdGVwUmVzdWx0KG51bGwsIG1lc3NhZ2UpIH07XG5cbi8vIDo6IChOb2RlLCBudW1iZXIsIG51bWJlciwgU2xpY2UpIOKGkiBTdGVwUmVzdWx0XG4vLyBDYWxsIFtgTm9kZS5yZXBsYWNlYF0oI21vZGVsLk5vZGUucmVwbGFjZSkgd2l0aCB0aGUgZ2l2ZW5cbi8vIGFyZ3VtZW50cy4gQ3JlYXRlIGEgc3VjY2Vzc2Z1bCByZXN1bHQgaWYgaXQgc3VjY2VlZHMsIGFuZCBhXG4vLyBmYWlsZWQgb25lIGlmIGl0IHRocm93cyBhIGBSZXBsYWNlRXJyb3JgLlxuU3RlcFJlc3VsdC5mcm9tUmVwbGFjZSA9IGZ1bmN0aW9uIGZyb21SZXBsYWNlIChkb2MsIGZyb20sIHRvLCBzbGljZSkge1xuICB0cnkge1xuICAgIHJldHVybiBTdGVwUmVzdWx0Lm9rKGRvYy5yZXBsYWNlKGZyb20sIHRvLCBzbGljZSkpXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoZSBpbnN0YW5jZW9mIFJlcGxhY2VFcnJvcikgeyByZXR1cm4gU3RlcFJlc3VsdC5mYWlsKGUubWVzc2FnZSkgfVxuICAgIHRocm93IGVcbiAgfVxufTtcblxuLy8gOjotIFJlcGxhY2UgYSBwYXJ0IG9mIHRoZSBkb2N1bWVudCB3aXRoIGEgc2xpY2Ugb2YgbmV3IGNvbnRlbnQuXG52YXIgUmVwbGFjZVN0ZXAgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChTdGVwKSB7XG4gIGZ1bmN0aW9uIFJlcGxhY2VTdGVwKGZyb20sIHRvLCBzbGljZSwgc3RydWN0dXJlKSB7XG4gICAgU3RlcC5jYWxsKHRoaXMpO1xuICAgIC8vIDo6IG51bWJlclxuICAgIC8vIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVwbGFjZWQgcmFuZ2UuXG4gICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAvLyA6OiBudW1iZXJcbiAgICAvLyBUaGUgZW5kIHBvc2l0aW9uIG9mIHRoZSByZXBsYWNlZCByYW5nZS5cbiAgICB0aGlzLnRvID0gdG87XG4gICAgLy8gOjogU2xpY2VcbiAgICAvLyBUaGUgc2xpY2UgdG8gaW5zZXJ0LlxuICAgIHRoaXMuc2xpY2UgPSBzbGljZTtcbiAgICB0aGlzLnN0cnVjdHVyZSA9ICEhc3RydWN0dXJlO1xuICB9XG5cbiAgaWYgKCBTdGVwICkgUmVwbGFjZVN0ZXAuX19wcm90b19fID0gU3RlcDtcbiAgUmVwbGFjZVN0ZXAucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggU3RlcCAmJiBTdGVwLnByb3RvdHlwZSApO1xuICBSZXBsYWNlU3RlcC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSZXBsYWNlU3RlcDtcblxuICBSZXBsYWNlU3RlcC5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiBhcHBseSAoZG9jKSB7XG4gICAgaWYgKHRoaXMuc3RydWN0dXJlICYmIGNvbnRlbnRCZXR3ZWVuKGRvYywgdGhpcy5mcm9tLCB0aGlzLnRvKSlcbiAgICAgIHsgcmV0dXJuIFN0ZXBSZXN1bHQuZmFpbChcIlN0cnVjdHVyZSByZXBsYWNlIHdvdWxkIG92ZXJ3cml0ZSBjb250ZW50XCIpIH1cbiAgICByZXR1cm4gU3RlcFJlc3VsdC5mcm9tUmVwbGFjZShkb2MsIHRoaXMuZnJvbSwgdGhpcy50bywgdGhpcy5zbGljZSlcbiAgfTtcblxuICBSZXBsYWNlU3RlcC5wcm90b3R5cGUuZ2V0TWFwID0gZnVuY3Rpb24gZ2V0TWFwICgpIHtcbiAgICByZXR1cm4gbmV3IFN0ZXBNYXAoW3RoaXMuZnJvbSwgdGhpcy50byAtIHRoaXMuZnJvbSwgdGhpcy5zbGljZS5zaXplXSlcbiAgfTtcblxuICBSZXBsYWNlU3RlcC5wcm90b3R5cGUuaW52ZXJ0ID0gZnVuY3Rpb24gaW52ZXJ0IChkb2MpIHtcbiAgICByZXR1cm4gbmV3IFJlcGxhY2VTdGVwKHRoaXMuZnJvbSwgdGhpcy5mcm9tICsgdGhpcy5zbGljZS5zaXplLCBkb2Muc2xpY2UodGhpcy5mcm9tLCB0aGlzLnRvKSlcbiAgfTtcblxuICBSZXBsYWNlU3RlcC5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gbWFwIChtYXBwaW5nKSB7XG4gICAgdmFyIGZyb20gPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLmZyb20sIDEpLCB0byA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMudG8sIC0xKTtcbiAgICBpZiAoZnJvbS5kZWxldGVkICYmIHRvLmRlbGV0ZWQpIHsgcmV0dXJuIG51bGwgfVxuICAgIHJldHVybiBuZXcgUmVwbGFjZVN0ZXAoZnJvbS5wb3MsIE1hdGgubWF4KGZyb20ucG9zLCB0by5wb3MpLCB0aGlzLnNsaWNlKVxuICB9O1xuXG4gIFJlcGxhY2VTdGVwLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uIG1lcmdlIChvdGhlcikge1xuICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgUmVwbGFjZVN0ZXApIHx8IG90aGVyLnN0cnVjdHVyZSB8fCB0aGlzLnN0cnVjdHVyZSkgeyByZXR1cm4gbnVsbCB9XG5cbiAgICBpZiAodGhpcy5mcm9tICsgdGhpcy5zbGljZS5zaXplID09IG90aGVyLmZyb20gJiYgIXRoaXMuc2xpY2Uub3BlbkVuZCAmJiAhb3RoZXIuc2xpY2Uub3BlblN0YXJ0KSB7XG4gICAgICB2YXIgc2xpY2UgPSB0aGlzLnNsaWNlLnNpemUgKyBvdGhlci5zbGljZS5zaXplID09IDAgPyBTbGljZS5lbXB0eVxuICAgICAgICAgIDogbmV3IFNsaWNlKHRoaXMuc2xpY2UuY29udGVudC5hcHBlbmQob3RoZXIuc2xpY2UuY29udGVudCksIHRoaXMuc2xpY2Uub3BlblN0YXJ0LCBvdGhlci5zbGljZS5vcGVuRW5kKTtcbiAgICAgIHJldHVybiBuZXcgUmVwbGFjZVN0ZXAodGhpcy5mcm9tLCB0aGlzLnRvICsgKG90aGVyLnRvIC0gb3RoZXIuZnJvbSksIHNsaWNlLCB0aGlzLnN0cnVjdHVyZSlcbiAgICB9IGVsc2UgaWYgKG90aGVyLnRvID09IHRoaXMuZnJvbSAmJiAhdGhpcy5zbGljZS5vcGVuU3RhcnQgJiYgIW90aGVyLnNsaWNlLm9wZW5FbmQpIHtcbiAgICAgIHZhciBzbGljZSQxID0gdGhpcy5zbGljZS5zaXplICsgb3RoZXIuc2xpY2Uuc2l6ZSA9PSAwID8gU2xpY2UuZW1wdHlcbiAgICAgICAgICA6IG5ldyBTbGljZShvdGhlci5zbGljZS5jb250ZW50LmFwcGVuZCh0aGlzLnNsaWNlLmNvbnRlbnQpLCBvdGhlci5zbGljZS5vcGVuU3RhcnQsIHRoaXMuc2xpY2Uub3BlbkVuZCk7XG4gICAgICByZXR1cm4gbmV3IFJlcGxhY2VTdGVwKG90aGVyLmZyb20sIHRoaXMudG8sIHNsaWNlJDEsIHRoaXMuc3RydWN0dXJlKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfTtcblxuICBSZXBsYWNlU3RlcC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgICB2YXIganNvbiA9IHtzdGVwVHlwZTogXCJyZXBsYWNlXCIsIGZyb206IHRoaXMuZnJvbSwgdG86IHRoaXMudG99O1xuICAgIGlmICh0aGlzLnNsaWNlLnNpemUpIHsganNvbi5zbGljZSA9IHRoaXMuc2xpY2UudG9KU09OKCk7IH1cbiAgICBpZiAodGhpcy5zdHJ1Y3R1cmUpIHsganNvbi5zdHJ1Y3R1cmUgPSB0cnVlOyB9XG4gICAgcmV0dXJuIGpzb25cbiAgfTtcblxuICBSZXBsYWNlU3RlcC5mcm9tSlNPTiA9IGZ1bmN0aW9uIGZyb21KU09OIChzY2hlbWEsIGpzb24pIHtcbiAgICBpZiAodHlwZW9mIGpzb24uZnJvbSAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiBqc29uLnRvICE9IFwibnVtYmVyXCIpXG4gICAgICB7IHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgUmVwbGFjZVN0ZXAuZnJvbUpTT05cIikgfVxuICAgIHJldHVybiBuZXcgUmVwbGFjZVN0ZXAoanNvbi5mcm9tLCBqc29uLnRvLCBTbGljZS5mcm9tSlNPTihzY2hlbWEsIGpzb24uc2xpY2UpLCAhIWpzb24uc3RydWN0dXJlKVxuICB9O1xuXG4gIHJldHVybiBSZXBsYWNlU3RlcDtcbn0oU3RlcCkpO1xuXG5TdGVwLmpzb25JRChcInJlcGxhY2VcIiwgUmVwbGFjZVN0ZXApO1xuXG4vLyA6Oi0gUmVwbGFjZSBhIHBhcnQgb2YgdGhlIGRvY3VtZW50IHdpdGggYSBzbGljZSBvZiBjb250ZW50LCBidXRcbi8vIHByZXNlcnZlIGEgcmFuZ2Ugb2YgdGhlIHJlcGxhY2VkIGNvbnRlbnQgYnkgbW92aW5nIGl0IGludG8gdGhlXG4vLyBzbGljZS5cbnZhciBSZXBsYWNlQXJvdW5kU3RlcCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFN0ZXApIHtcbiAgZnVuY3Rpb24gUmVwbGFjZUFyb3VuZFN0ZXAoZnJvbSwgdG8sIGdhcEZyb20sIGdhcFRvLCBzbGljZSwgaW5zZXJ0LCBzdHJ1Y3R1cmUpIHtcbiAgICBTdGVwLmNhbGwodGhpcyk7XG4gICAgLy8gOjogbnVtYmVyXG4gICAgLy8gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXBsYWNlZCByYW5nZS5cbiAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgIC8vIDo6IG51bWJlclxuICAgIC8vIFRoZSBlbmQgcG9zaXRpb24gb2YgdGhlIHJlcGxhY2VkIHJhbmdlLlxuICAgIHRoaXMudG8gPSB0bztcbiAgICAvLyA6OiBudW1iZXJcbiAgICAvLyBUaGUgc3RhcnQgb2YgcHJlc2VydmVkIHJhbmdlLlxuICAgIHRoaXMuZ2FwRnJvbSA9IGdhcEZyb207XG4gICAgLy8gOjogbnVtYmVyXG4gICAgLy8gVGhlIGVuZCBvZiBwcmVzZXJ2ZWQgcmFuZ2UuXG4gICAgdGhpcy5nYXBUbyA9IGdhcFRvO1xuICAgIC8vIDo6IFNsaWNlXG4gICAgLy8gVGhlIHNsaWNlIHRvIGluc2VydC5cbiAgICB0aGlzLnNsaWNlID0gc2xpY2U7XG4gICAgLy8gOjogbnVtYmVyXG4gICAgLy8gVGhlIHBvc2l0aW9uIGluIHRoZSBzbGljZSB3aGVyZSB0aGUgcHJlc2VydmVkIHJhbmdlIHNob3VsZCBiZVxuICAgIC8vIGluc2VydGVkLlxuICAgIHRoaXMuaW5zZXJ0ID0gaW5zZXJ0O1xuICAgIHRoaXMuc3RydWN0dXJlID0gISFzdHJ1Y3R1cmU7XG4gIH1cblxuICBpZiAoIFN0ZXAgKSBSZXBsYWNlQXJvdW5kU3RlcC5fX3Byb3RvX18gPSBTdGVwO1xuICBSZXBsYWNlQXJvdW5kU3RlcC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBTdGVwICYmIFN0ZXAucHJvdG90eXBlICk7XG4gIFJlcGxhY2VBcm91bmRTdGVwLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJlcGxhY2VBcm91bmRTdGVwO1xuXG4gIFJlcGxhY2VBcm91bmRTdGVwLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uIGFwcGx5IChkb2MpIHtcbiAgICBpZiAodGhpcy5zdHJ1Y3R1cmUgJiYgKGNvbnRlbnRCZXR3ZWVuKGRvYywgdGhpcy5mcm9tLCB0aGlzLmdhcEZyb20pIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50QmV0d2Vlbihkb2MsIHRoaXMuZ2FwVG8sIHRoaXMudG8pKSlcbiAgICAgIHsgcmV0dXJuIFN0ZXBSZXN1bHQuZmFpbChcIlN0cnVjdHVyZSBnYXAtcmVwbGFjZSB3b3VsZCBvdmVyd3JpdGUgY29udGVudFwiKSB9XG5cbiAgICB2YXIgZ2FwID0gZG9jLnNsaWNlKHRoaXMuZ2FwRnJvbSwgdGhpcy5nYXBUbyk7XG4gICAgaWYgKGdhcC5vcGVuU3RhcnQgfHwgZ2FwLm9wZW5FbmQpXG4gICAgICB7IHJldHVybiBTdGVwUmVzdWx0LmZhaWwoXCJHYXAgaXMgbm90IGEgZmxhdCByYW5nZVwiKSB9XG4gICAgdmFyIGluc2VydGVkID0gdGhpcy5zbGljZS5pbnNlcnRBdCh0aGlzLmluc2VydCwgZ2FwLmNvbnRlbnQpO1xuICAgIGlmICghaW5zZXJ0ZWQpIHsgcmV0dXJuIFN0ZXBSZXN1bHQuZmFpbChcIkNvbnRlbnQgZG9lcyBub3QgZml0IGluIGdhcFwiKSB9XG4gICAgcmV0dXJuIFN0ZXBSZXN1bHQuZnJvbVJlcGxhY2UoZG9jLCB0aGlzLmZyb20sIHRoaXMudG8sIGluc2VydGVkKVxuICB9O1xuXG4gIFJlcGxhY2VBcm91bmRTdGVwLnByb3RvdHlwZS5nZXRNYXAgPSBmdW5jdGlvbiBnZXRNYXAgKCkge1xuICAgIHJldHVybiBuZXcgU3RlcE1hcChbdGhpcy5mcm9tLCB0aGlzLmdhcEZyb20gLSB0aGlzLmZyb20sIHRoaXMuaW5zZXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nYXBUbywgdGhpcy50byAtIHRoaXMuZ2FwVG8sIHRoaXMuc2xpY2Uuc2l6ZSAtIHRoaXMuaW5zZXJ0XSlcbiAgfTtcblxuICBSZXBsYWNlQXJvdW5kU3RlcC5wcm90b3R5cGUuaW52ZXJ0ID0gZnVuY3Rpb24gaW52ZXJ0IChkb2MpIHtcbiAgICB2YXIgZ2FwID0gdGhpcy5nYXBUbyAtIHRoaXMuZ2FwRnJvbTtcbiAgICByZXR1cm4gbmV3IFJlcGxhY2VBcm91bmRTdGVwKHRoaXMuZnJvbSwgdGhpcy5mcm9tICsgdGhpcy5zbGljZS5zaXplICsgZ2FwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mcm9tICsgdGhpcy5pbnNlcnQsIHRoaXMuZnJvbSArIHRoaXMuaW5zZXJ0ICsgZ2FwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jLnNsaWNlKHRoaXMuZnJvbSwgdGhpcy50bykucmVtb3ZlQmV0d2Vlbih0aGlzLmdhcEZyb20gLSB0aGlzLmZyb20sIHRoaXMuZ2FwVG8gLSB0aGlzLmZyb20pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nYXBGcm9tIC0gdGhpcy5mcm9tLCB0aGlzLnN0cnVjdHVyZSlcbiAgfTtcblxuICBSZXBsYWNlQXJvdW5kU3RlcC5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gbWFwIChtYXBwaW5nKSB7XG4gICAgdmFyIGZyb20gPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLmZyb20sIDEpLCB0byA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMudG8sIC0xKTtcbiAgICB2YXIgZ2FwRnJvbSA9IG1hcHBpbmcubWFwKHRoaXMuZ2FwRnJvbSwgLTEpLCBnYXBUbyA9IG1hcHBpbmcubWFwKHRoaXMuZ2FwVG8sIDEpO1xuICAgIGlmICgoZnJvbS5kZWxldGVkICYmIHRvLmRlbGV0ZWQpIHx8IGdhcEZyb20gPCBmcm9tLnBvcyB8fCBnYXBUbyA+IHRvLnBvcykgeyByZXR1cm4gbnVsbCB9XG4gICAgcmV0dXJuIG5ldyBSZXBsYWNlQXJvdW5kU3RlcChmcm9tLnBvcywgdG8ucG9zLCBnYXBGcm9tLCBnYXBUbywgdGhpcy5zbGljZSwgdGhpcy5pbnNlcnQsIHRoaXMuc3RydWN0dXJlKVxuICB9O1xuXG4gIFJlcGxhY2VBcm91bmRTdGVwLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICAgIHZhciBqc29uID0ge3N0ZXBUeXBlOiBcInJlcGxhY2VBcm91bmRcIiwgZnJvbTogdGhpcy5mcm9tLCB0bzogdGhpcy50byxcbiAgICAgICAgICAgICAgICBnYXBGcm9tOiB0aGlzLmdhcEZyb20sIGdhcFRvOiB0aGlzLmdhcFRvLCBpbnNlcnQ6IHRoaXMuaW5zZXJ0fTtcbiAgICBpZiAodGhpcy5zbGljZS5zaXplKSB7IGpzb24uc2xpY2UgPSB0aGlzLnNsaWNlLnRvSlNPTigpOyB9XG4gICAgaWYgKHRoaXMuc3RydWN0dXJlKSB7IGpzb24uc3RydWN0dXJlID0gdHJ1ZTsgfVxuICAgIHJldHVybiBqc29uXG4gIH07XG5cbiAgUmVwbGFjZUFyb3VuZFN0ZXAuZnJvbUpTT04gPSBmdW5jdGlvbiBmcm9tSlNPTiAoc2NoZW1hLCBqc29uKSB7XG4gICAgaWYgKHR5cGVvZiBqc29uLmZyb20gIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YganNvbi50byAhPSBcIm51bWJlclwiIHx8XG4gICAgICAgIHR5cGVvZiBqc29uLmdhcEZyb20gIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YganNvbi5nYXBUbyAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiBqc29uLmluc2VydCAhPSBcIm51bWJlclwiKVxuICAgICAgeyB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIFJlcGxhY2VBcm91bmRTdGVwLmZyb21KU09OXCIpIH1cbiAgICByZXR1cm4gbmV3IFJlcGxhY2VBcm91bmRTdGVwKGpzb24uZnJvbSwganNvbi50bywganNvbi5nYXBGcm9tLCBqc29uLmdhcFRvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2xpY2UuZnJvbUpTT04oc2NoZW1hLCBqc29uLnNsaWNlKSwganNvbi5pbnNlcnQsICEhanNvbi5zdHJ1Y3R1cmUpXG4gIH07XG5cbiAgcmV0dXJuIFJlcGxhY2VBcm91bmRTdGVwO1xufShTdGVwKSk7XG5cblN0ZXAuanNvbklEKFwicmVwbGFjZUFyb3VuZFwiLCBSZXBsYWNlQXJvdW5kU3RlcCk7XG5cbmZ1bmN0aW9uIGNvbnRlbnRCZXR3ZWVuKGRvYywgZnJvbSwgdG8pIHtcbiAgdmFyICRmcm9tID0gZG9jLnJlc29sdmUoZnJvbSksIGRpc3QgPSB0byAtIGZyb20sIGRlcHRoID0gJGZyb20uZGVwdGg7XG4gIHdoaWxlIChkaXN0ID4gMCAmJiBkZXB0aCA+IDAgJiYgJGZyb20uaW5kZXhBZnRlcihkZXB0aCkgPT0gJGZyb20ubm9kZShkZXB0aCkuY2hpbGRDb3VudCkge1xuICAgIGRlcHRoLS07XG4gICAgZGlzdC0tO1xuICB9XG4gIGlmIChkaXN0ID4gMCkge1xuICAgIHZhciBuZXh0ID0gJGZyb20ubm9kZShkZXB0aCkubWF5YmVDaGlsZCgkZnJvbS5pbmRleEFmdGVyKGRlcHRoKSk7XG4gICAgd2hpbGUgKGRpc3QgPiAwKSB7XG4gICAgICBpZiAoIW5leHQgfHwgbmV4dC5pc0xlYWYpIHsgcmV0dXJuIHRydWUgfVxuICAgICAgbmV4dCA9IG5leHQuZmlyc3RDaGlsZDtcbiAgICAgIGRpc3QtLTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGNhbkN1dChub2RlLCBzdGFydCwgZW5kKSB7XG4gIHJldHVybiAoc3RhcnQgPT0gMCB8fCBub2RlLmNhblJlcGxhY2Uoc3RhcnQsIG5vZGUuY2hpbGRDb3VudCkpICYmXG4gICAgKGVuZCA9PSBub2RlLmNoaWxkQ291bnQgfHwgbm9kZS5jYW5SZXBsYWNlKDAsIGVuZCkpXG59XG5cbi8vIDo6IChOb2RlUmFuZ2UpIOKGkiA/bnVtYmVyXG4vLyBUcnkgdG8gZmluZCBhIHRhcmdldCBkZXB0aCB0byB3aGljaCB0aGUgY29udGVudCBpbiB0aGUgZ2l2ZW4gcmFuZ2Vcbi8vIGNhbiBiZSBsaWZ0ZWQuIFdpbGwgbm90IGdvIGFjcm9zc1xuLy8gW2lzb2xhdGluZ10oI21vZGVsLk5vZGVTcGVjLmlzb2xhdGluZykgcGFyZW50IG5vZGVzLlxuZnVuY3Rpb24gbGlmdFRhcmdldChyYW5nZSkge1xuICB2YXIgcGFyZW50ID0gcmFuZ2UucGFyZW50O1xuICB2YXIgY29udGVudCA9IHBhcmVudC5jb250ZW50LmN1dEJ5SW5kZXgocmFuZ2Uuc3RhcnRJbmRleCwgcmFuZ2UuZW5kSW5kZXgpO1xuICBmb3IgKHZhciBkZXB0aCA9IHJhbmdlLmRlcHRoOzsgLS1kZXB0aCkge1xuICAgIHZhciBub2RlID0gcmFuZ2UuJGZyb20ubm9kZShkZXB0aCk7XG4gICAgdmFyIGluZGV4ID0gcmFuZ2UuJGZyb20uaW5kZXgoZGVwdGgpLCBlbmRJbmRleCA9IHJhbmdlLiR0by5pbmRleEFmdGVyKGRlcHRoKTtcbiAgICBpZiAoZGVwdGggPCByYW5nZS5kZXB0aCAmJiBub2RlLmNhblJlcGxhY2UoaW5kZXgsIGVuZEluZGV4LCBjb250ZW50KSlcbiAgICAgIHsgcmV0dXJuIGRlcHRoIH1cbiAgICBpZiAoZGVwdGggPT0gMCB8fCBub2RlLnR5cGUuc3BlYy5pc29sYXRpbmcgfHwgIWNhbkN1dChub2RlLCBpbmRleCwgZW5kSW5kZXgpKSB7IGJyZWFrIH1cbiAgfVxufVxuXG4vLyA6OiAoTm9kZVJhbmdlLCBudW1iZXIpIOKGkiB0aGlzXG4vLyBTcGxpdCB0aGUgY29udGVudCBpbiB0aGUgZ2l2ZW4gcmFuZ2Ugb2ZmIGZyb20gaXRzIHBhcmVudCwgaWYgdGhlcmVcbi8vIGlzIHNpYmxpbmcgY29udGVudCBiZWZvcmUgb3IgYWZ0ZXIgaXQsIGFuZCBtb3ZlIGl0IHVwIHRoZSB0cmVlIHRvXG4vLyB0aGUgZGVwdGggc3BlY2lmaWVkIGJ5IGB0YXJnZXRgLiBZb3UnbGwgcHJvYmFibHkgd2FudCB0byB1c2Vcbi8vIFtgbGlmdFRhcmdldGBdKCN0cmFuc2Zvcm0ubGlmdFRhcmdldCkgdG8gY29tcHV0ZSBgdGFyZ2V0YCwgdG8gbWFrZVxuLy8gc3VyZSB0aGUgbGlmdCBpcyB2YWxpZC5cblRyYW5zZm9ybS5wcm90b3R5cGUubGlmdCA9IGZ1bmN0aW9uKHJhbmdlLCB0YXJnZXQpIHtcbiAgdmFyICRmcm9tID0gcmFuZ2UuJGZyb207XG4gIHZhciAkdG8gPSByYW5nZS4kdG87XG4gIHZhciBkZXB0aCA9IHJhbmdlLmRlcHRoO1xuXG4gIHZhciBnYXBTdGFydCA9ICRmcm9tLmJlZm9yZShkZXB0aCArIDEpLCBnYXBFbmQgPSAkdG8uYWZ0ZXIoZGVwdGggKyAxKTtcbiAgdmFyIHN0YXJ0ID0gZ2FwU3RhcnQsIGVuZCA9IGdhcEVuZDtcblxuICB2YXIgYmVmb3JlID0gRnJhZ21lbnQuZW1wdHksIG9wZW5TdGFydCA9IDA7XG4gIGZvciAodmFyIGQgPSBkZXB0aCwgc3BsaXR0aW5nID0gZmFsc2U7IGQgPiB0YXJnZXQ7IGQtLSlcbiAgICB7IGlmIChzcGxpdHRpbmcgfHwgJGZyb20uaW5kZXgoZCkgPiAwKSB7XG4gICAgICBzcGxpdHRpbmcgPSB0cnVlO1xuICAgICAgYmVmb3JlID0gRnJhZ21lbnQuZnJvbSgkZnJvbS5ub2RlKGQpLmNvcHkoYmVmb3JlKSk7XG4gICAgICBvcGVuU3RhcnQrKztcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnQtLTtcbiAgICB9IH1cbiAgdmFyIGFmdGVyID0gRnJhZ21lbnQuZW1wdHksIG9wZW5FbmQgPSAwO1xuICBmb3IgKHZhciBkJDEgPSBkZXB0aCwgc3BsaXR0aW5nJDEgPSBmYWxzZTsgZCQxID4gdGFyZ2V0OyBkJDEtLSlcbiAgICB7IGlmIChzcGxpdHRpbmckMSB8fCAkdG8uYWZ0ZXIoZCQxICsgMSkgPCAkdG8uZW5kKGQkMSkpIHtcbiAgICAgIHNwbGl0dGluZyQxID0gdHJ1ZTtcbiAgICAgIGFmdGVyID0gRnJhZ21lbnQuZnJvbSgkdG8ubm9kZShkJDEpLmNvcHkoYWZ0ZXIpKTtcbiAgICAgIG9wZW5FbmQrKztcbiAgICB9IGVsc2Uge1xuICAgICAgZW5kKys7XG4gICAgfSB9XG5cbiAgcmV0dXJuIHRoaXMuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoc3RhcnQsIGVuZCwgZ2FwU3RhcnQsIGdhcEVuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFNsaWNlKGJlZm9yZS5hcHBlbmQoYWZ0ZXIpLCBvcGVuU3RhcnQsIG9wZW5FbmQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZWZvcmUuc2l6ZSAtIG9wZW5TdGFydCwgdHJ1ZSkpXG59O1xuXG4vLyA6OiAoTm9kZVJhbmdlLCBOb2RlVHlwZSwgP09iamVjdCwgP05vZGVSYW5nZSkg4oaSID9be3R5cGU6IE5vZGVUeXBlLCBhdHRyczogP09iamVjdH1dXG4vLyBUcnkgdG8gZmluZCBhIHZhbGlkIHdheSB0byB3cmFwIHRoZSBjb250ZW50IGluIHRoZSBnaXZlbiByYW5nZSBpbiBhXG4vLyBub2RlIG9mIHRoZSBnaXZlbiB0eXBlLiBNYXkgaW50cm9kdWNlIGV4dHJhIG5vZGVzIGFyb3VuZCBhbmQgaW5zaWRlXG4vLyB0aGUgd3JhcHBlciBub2RlLCBpZiBuZWNlc3NhcnkuIFJldHVybnMgbnVsbCBpZiBubyB2YWxpZCB3cmFwcGluZ1xuLy8gY291bGQgYmUgZm91bmQuIFdoZW4gYGlubmVyUmFuZ2VgIGlzIGdpdmVuLCB0aGF0IHJhbmdlJ3MgY29udGVudCBpc1xuLy8gdXNlZCBhcyB0aGUgY29udGVudCB0byBmaXQgaW50byB0aGUgd3JhcHBpbmcsIGluc3RlYWQgb2YgdGhlXG4vLyBjb250ZW50IG9mIGByYW5nZWAuXG5mdW5jdGlvbiBmaW5kV3JhcHBpbmcocmFuZ2UsIG5vZGVUeXBlLCBhdHRycywgaW5uZXJSYW5nZSkge1xuICBpZiAoIGlubmVyUmFuZ2UgPT09IHZvaWQgMCApIGlubmVyUmFuZ2UgPSByYW5nZTtcblxuICB2YXIgYXJvdW5kID0gZmluZFdyYXBwaW5nT3V0c2lkZShyYW5nZSwgbm9kZVR5cGUpO1xuICB2YXIgaW5uZXIgPSBhcm91bmQgJiYgZmluZFdyYXBwaW5nSW5zaWRlKGlubmVyUmFuZ2UsIG5vZGVUeXBlKTtcbiAgaWYgKCFpbm5lcikgeyByZXR1cm4gbnVsbCB9XG4gIHJldHVybiBhcm91bmQubWFwKHdpdGhBdHRycykuY29uY2F0KHt0eXBlOiBub2RlVHlwZSwgYXR0cnM6IGF0dHJzfSkuY29uY2F0KGlubmVyLm1hcCh3aXRoQXR0cnMpKVxufVxuXG5mdW5jdGlvbiB3aXRoQXR0cnModHlwZSkgeyByZXR1cm4ge3R5cGU6IHR5cGUsIGF0dHJzOiBudWxsfSB9XG5cbmZ1bmN0aW9uIGZpbmRXcmFwcGluZ091dHNpZGUocmFuZ2UsIHR5cGUpIHtcbiAgdmFyIHBhcmVudCA9IHJhbmdlLnBhcmVudDtcbiAgdmFyIHN0YXJ0SW5kZXggPSByYW5nZS5zdGFydEluZGV4O1xuICB2YXIgZW5kSW5kZXggPSByYW5nZS5lbmRJbmRleDtcbiAgdmFyIGFyb3VuZCA9IHBhcmVudC5jb250ZW50TWF0Y2hBdChzdGFydEluZGV4KS5maW5kV3JhcHBpbmcodHlwZSk7XG4gIGlmICghYXJvdW5kKSB7IHJldHVybiBudWxsIH1cbiAgdmFyIG91dGVyID0gYXJvdW5kLmxlbmd0aCA/IGFyb3VuZFswXSA6IHR5cGU7XG4gIHJldHVybiBwYXJlbnQuY2FuUmVwbGFjZVdpdGgoc3RhcnRJbmRleCwgZW5kSW5kZXgsIG91dGVyKSA/IGFyb3VuZCA6IG51bGxcbn1cblxuZnVuY3Rpb24gZmluZFdyYXBwaW5nSW5zaWRlKHJhbmdlLCB0eXBlKSB7XG4gIHZhciBwYXJlbnQgPSByYW5nZS5wYXJlbnQ7XG4gIHZhciBzdGFydEluZGV4ID0gcmFuZ2Uuc3RhcnRJbmRleDtcbiAgdmFyIGVuZEluZGV4ID0gcmFuZ2UuZW5kSW5kZXg7XG4gIHZhciBpbm5lciA9IHBhcmVudC5jaGlsZChzdGFydEluZGV4KTtcbiAgdmFyIGluc2lkZSA9IHR5cGUuY29udGVudE1hdGNoLmZpbmRXcmFwcGluZyhpbm5lci50eXBlKTtcbiAgaWYgKCFpbnNpZGUpIHsgcmV0dXJuIG51bGwgfVxuICB2YXIgbGFzdFR5cGUgPSBpbnNpZGUubGVuZ3RoID8gaW5zaWRlW2luc2lkZS5sZW5ndGggLSAxXSA6IHR5cGU7XG4gIHZhciBpbm5lck1hdGNoID0gbGFzdFR5cGUuY29udGVudE1hdGNoO1xuICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaW5uZXJNYXRjaCAmJiBpIDwgZW5kSW5kZXg7IGkrKylcbiAgICB7IGlubmVyTWF0Y2ggPSBpbm5lck1hdGNoLm1hdGNoVHlwZShwYXJlbnQuY2hpbGQoaSkudHlwZSk7IH1cbiAgaWYgKCFpbm5lck1hdGNoIHx8ICFpbm5lck1hdGNoLnZhbGlkRW5kKSB7IHJldHVybiBudWxsIH1cbiAgcmV0dXJuIGluc2lkZVxufVxuXG4vLyA6OiAoTm9kZVJhbmdlLCBbe3R5cGU6IE5vZGVUeXBlLCBhdHRyczogP09iamVjdH1dKSDihpIgdGhpc1xuLy8gV3JhcCB0aGUgZ2l2ZW4gW3JhbmdlXSgjbW9kZWwuTm9kZVJhbmdlKSBpbiB0aGUgZ2l2ZW4gc2V0IG9mIHdyYXBwZXJzLlxuLy8gVGhlIHdyYXBwZXJzIGFyZSBhc3N1bWVkIHRvIGJlIHZhbGlkIGluIHRoaXMgcG9zaXRpb24sIGFuZCBzaG91bGRcbi8vIHByb2JhYmx5IGJlIGNvbXB1dGVkIHdpdGggW2BmaW5kV3JhcHBpbmdgXSgjdHJhbnNmb3JtLmZpbmRXcmFwcGluZykuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbihyYW5nZSwgd3JhcHBlcnMpIHtcbiAgdmFyIGNvbnRlbnQgPSBGcmFnbWVudC5lbXB0eTtcbiAgZm9yICh2YXIgaSA9IHdyYXBwZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgIHsgY29udGVudCA9IEZyYWdtZW50LmZyb20od3JhcHBlcnNbaV0udHlwZS5jcmVhdGUod3JhcHBlcnNbaV0uYXR0cnMsIGNvbnRlbnQpKTsgfVxuXG4gIHZhciBzdGFydCA9IHJhbmdlLnN0YXJ0LCBlbmQgPSByYW5nZS5lbmQ7XG4gIHJldHVybiB0aGlzLnN0ZXAobmV3IFJlcGxhY2VBcm91bmRTdGVwKHN0YXJ0LCBlbmQsIHN0YXJ0LCBlbmQsIG5ldyBTbGljZShjb250ZW50LCAwLCAwKSwgd3JhcHBlcnMubGVuZ3RoLCB0cnVlKSlcbn07XG5cbi8vIDo6IChudW1iZXIsID9udW1iZXIsIE5vZGVUeXBlLCA/T2JqZWN0KSDihpIgdGhpc1xuLy8gU2V0IHRoZSB0eXBlIG9mIGFsbCB0ZXh0YmxvY2tzIChwYXJ0bHkpIGJldHdlZW4gYGZyb21gIGFuZCBgdG9gIHRvXG4vLyB0aGUgZ2l2ZW4gbm9kZSB0eXBlIHdpdGggdGhlIGdpdmVuIGF0dHJpYnV0ZXMuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnNldEJsb2NrVHlwZSA9IGZ1bmN0aW9uKGZyb20sIHRvLCB0eXBlLCBhdHRycykge1xuICB2YXIgdGhpcyQxID0gdGhpcztcbiAgaWYgKCB0byA9PT0gdm9pZCAwICkgdG8gPSBmcm9tO1xuXG4gIGlmICghdHlwZS5pc1RleHRibG9jaykgeyB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlR5cGUgZ2l2ZW4gdG8gc2V0QmxvY2tUeXBlIHNob3VsZCBiZSBhIHRleHRibG9ja1wiKSB9XG4gIHZhciBtYXBGcm9tID0gdGhpcy5zdGVwcy5sZW5ndGg7XG4gIHRoaXMuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgZnVuY3Rpb24gKG5vZGUsIHBvcykge1xuICAgIGlmIChub2RlLmlzVGV4dGJsb2NrICYmICFub2RlLmhhc01hcmt1cCh0eXBlLCBhdHRycykgJiYgY2FuQ2hhbmdlVHlwZSh0aGlzJDEuZG9jLCB0aGlzJDEubWFwcGluZy5zbGljZShtYXBGcm9tKS5tYXAocG9zKSwgdHlwZSkpIHtcbiAgICAgIC8vIEVuc3VyZSBhbGwgbWFya3VwIHRoYXQgaXNuJ3QgYWxsb3dlZCBpbiB0aGUgbmV3IG5vZGUgdHlwZSBpcyBjbGVhcmVkXG4gICAgICB0aGlzJDEuY2xlYXJJbmNvbXBhdGlibGUodGhpcyQxLm1hcHBpbmcuc2xpY2UobWFwRnJvbSkubWFwKHBvcywgMSksIHR5cGUpO1xuICAgICAgdmFyIG1hcHBpbmcgPSB0aGlzJDEubWFwcGluZy5zbGljZShtYXBGcm9tKTtcbiAgICAgIHZhciBzdGFydE0gPSBtYXBwaW5nLm1hcChwb3MsIDEpLCBlbmRNID0gbWFwcGluZy5tYXAocG9zICsgbm9kZS5ub2RlU2l6ZSwgMSk7XG4gICAgICB0aGlzJDEuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoc3RhcnRNLCBlbmRNLCBzdGFydE0gKyAxLCBlbmRNIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFNsaWNlKEZyYWdtZW50LmZyb20odHlwZS5jcmVhdGUoYXR0cnMsIG51bGwsIG5vZGUubWFya3MpKSwgMCwgMCksIDEsIHRydWUpKTtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiB0aGlzXG59O1xuXG5mdW5jdGlvbiBjYW5DaGFuZ2VUeXBlKGRvYywgcG9zLCB0eXBlKSB7XG4gIHZhciAkcG9zID0gZG9jLnJlc29sdmUocG9zKSwgaW5kZXggPSAkcG9zLmluZGV4KCk7XG4gIHJldHVybiAkcG9zLnBhcmVudC5jYW5SZXBsYWNlV2l0aChpbmRleCwgaW5kZXggKyAxLCB0eXBlKVxufVxuXG4vLyA6OiAobnVtYmVyLCA/Tm9kZVR5cGUsID9PYmplY3QsID9bTWFya10pIOKGkiB0aGlzXG4vLyBDaGFuZ2UgdGhlIHR5cGUsIGF0dHJpYnV0ZXMsIGFuZC9vciBtYXJrcyBvZiB0aGUgbm9kZSBhdCBgcG9zYC5cbi8vIFdoZW4gYHR5cGVgIGlzbid0IGdpdmVuLCB0aGUgZXhpc3Rpbmcgbm9kZSB0eXBlIGlzIHByZXNlcnZlZCxcblRyYW5zZm9ybS5wcm90b3R5cGUuc2V0Tm9kZU1hcmt1cCA9IGZ1bmN0aW9uKHBvcywgdHlwZSwgYXR0cnMsIG1hcmtzKSB7XG4gIHZhciBub2RlID0gdGhpcy5kb2Mubm9kZUF0KHBvcyk7XG4gIGlmICghbm9kZSkgeyB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk5vIG5vZGUgYXQgZ2l2ZW4gcG9zaXRpb25cIikgfVxuICBpZiAoIXR5cGUpIHsgdHlwZSA9IG5vZGUudHlwZTsgfVxuICB2YXIgbmV3Tm9kZSA9IHR5cGUuY3JlYXRlKGF0dHJzLCBudWxsLCBtYXJrcyB8fCBub2RlLm1hcmtzKTtcbiAgaWYgKG5vZGUuaXNMZWFmKVxuICAgIHsgcmV0dXJuIHRoaXMucmVwbGFjZVdpdGgocG9zLCBwb3MgKyBub2RlLm5vZGVTaXplLCBuZXdOb2RlKSB9XG5cbiAgaWYgKCF0eXBlLnZhbGlkQ29udGVudChub2RlLmNvbnRlbnQpKVxuICAgIHsgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGNvbnRlbnQgZm9yIG5vZGUgdHlwZSBcIiArIHR5cGUubmFtZSkgfVxuXG4gIHJldHVybiB0aGlzLnN0ZXAobmV3IFJlcGxhY2VBcm91bmRTdGVwKHBvcywgcG9zICsgbm9kZS5ub2RlU2l6ZSwgcG9zICsgMSwgcG9zICsgbm9kZS5ub2RlU2l6ZSAtIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBTbGljZShGcmFnbWVudC5mcm9tKG5ld05vZGUpLCAwLCAwKSwgMSwgdHJ1ZSkpXG59O1xuXG4vLyA6OiAoTm9kZSwgbnVtYmVyLCBudW1iZXIsID9bP3t0eXBlOiBOb2RlVHlwZSwgYXR0cnM6ID9PYmplY3R9XSkg4oaSIGJvb2xcbi8vIENoZWNrIHdoZXRoZXIgc3BsaXR0aW5nIGF0IHRoZSBnaXZlbiBwb3NpdGlvbiBpcyBhbGxvd2VkLlxuZnVuY3Rpb24gY2FuU3BsaXQoZG9jLCBwb3MsIGRlcHRoLCB0eXBlc0FmdGVyKSB7XG4gIGlmICggZGVwdGggPT09IHZvaWQgMCApIGRlcHRoID0gMTtcblxuICB2YXIgJHBvcyA9IGRvYy5yZXNvbHZlKHBvcyksIGJhc2UgPSAkcG9zLmRlcHRoIC0gZGVwdGg7XG4gIHZhciBpbm5lclR5cGUgPSAodHlwZXNBZnRlciAmJiB0eXBlc0FmdGVyW3R5cGVzQWZ0ZXIubGVuZ3RoIC0gMV0pIHx8ICRwb3MucGFyZW50O1xuICBpZiAoYmFzZSA8IDAgfHwgJHBvcy5wYXJlbnQudHlwZS5zcGVjLmlzb2xhdGluZyB8fFxuICAgICAgISRwb3MucGFyZW50LmNhblJlcGxhY2UoJHBvcy5pbmRleCgpLCAkcG9zLnBhcmVudC5jaGlsZENvdW50KSB8fFxuICAgICAgIWlubmVyVHlwZS50eXBlLnZhbGlkQ29udGVudCgkcG9zLnBhcmVudC5jb250ZW50LmN1dEJ5SW5kZXgoJHBvcy5pbmRleCgpLCAkcG9zLnBhcmVudC5jaGlsZENvdW50KSkpXG4gICAgeyByZXR1cm4gZmFsc2UgfVxuICBmb3IgKHZhciBkID0gJHBvcy5kZXB0aCAtIDEsIGkgPSBkZXB0aCAtIDI7IGQgPiBiYXNlOyBkLS0sIGktLSkge1xuICAgIHZhciBub2RlID0gJHBvcy5ub2RlKGQpLCBpbmRleCQxID0gJHBvcy5pbmRleChkKTtcbiAgICBpZiAobm9kZS50eXBlLnNwZWMuaXNvbGF0aW5nKSB7IHJldHVybiBmYWxzZSB9XG4gICAgdmFyIHJlc3QgPSBub2RlLmNvbnRlbnQuY3V0QnlJbmRleChpbmRleCQxLCBub2RlLmNoaWxkQ291bnQpO1xuICAgIHZhciBhZnRlciA9ICh0eXBlc0FmdGVyICYmIHR5cGVzQWZ0ZXJbaV0pIHx8IG5vZGU7XG4gICAgaWYgKGFmdGVyICE9IG5vZGUpIHsgcmVzdCA9IHJlc3QucmVwbGFjZUNoaWxkKDAsIGFmdGVyLnR5cGUuY3JlYXRlKGFmdGVyLmF0dHJzKSk7IH1cbiAgICBpZiAoIW5vZGUuY2FuUmVwbGFjZShpbmRleCQxICsgMSwgbm9kZS5jaGlsZENvdW50KSB8fCAhYWZ0ZXIudHlwZS52YWxpZENvbnRlbnQocmVzdCkpXG4gICAgICB7IHJldHVybiBmYWxzZSB9XG4gIH1cbiAgdmFyIGluZGV4ID0gJHBvcy5pbmRleEFmdGVyKGJhc2UpO1xuICB2YXIgYmFzZVR5cGUgPSB0eXBlc0FmdGVyICYmIHR5cGVzQWZ0ZXJbMF07XG4gIHJldHVybiAkcG9zLm5vZGUoYmFzZSkuY2FuUmVwbGFjZVdpdGgoaW5kZXgsIGluZGV4LCBiYXNlVHlwZSA/IGJhc2VUeXBlLnR5cGUgOiAkcG9zLm5vZGUoYmFzZSArIDEpLnR5cGUpXG59XG5cbi8vIDo6IChudW1iZXIsID9udW1iZXIsID9bP3t0eXBlOiBOb2RlVHlwZSwgYXR0cnM6ID9PYmplY3R9XSkg4oaSIHRoaXNcbi8vIFNwbGl0IHRoZSBub2RlIGF0IHRoZSBnaXZlbiBwb3NpdGlvbiwgYW5kIG9wdGlvbmFsbHksIGlmIGBkZXB0aGAgaXNcbi8vIGdyZWF0ZXIgdGhhbiBvbmUsIGFueSBudW1iZXIgb2Ygbm9kZXMgYWJvdmUgdGhhdC4gQnkgZGVmYXVsdCwgdGhlXG4vLyBwYXJ0cyBzcGxpdCBvZmYgd2lsbCBpbmhlcml0IHRoZSBub2RlIHR5cGUgb2YgdGhlIG9yaWdpbmFsIG5vZGUuXG4vLyBUaGlzIGNhbiBiZSBjaGFuZ2VkIGJ5IHBhc3NpbmcgYW4gYXJyYXkgb2YgdHlwZXMgYW5kIGF0dHJpYnV0ZXMgdG9cbi8vIHVzZSBhZnRlciB0aGUgc3BsaXQuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24ocG9zLCBkZXB0aCwgdHlwZXNBZnRlcikge1xuICBpZiAoIGRlcHRoID09PSB2b2lkIDAgKSBkZXB0aCA9IDE7XG5cbiAgdmFyICRwb3MgPSB0aGlzLmRvYy5yZXNvbHZlKHBvcyksIGJlZm9yZSA9IEZyYWdtZW50LmVtcHR5LCBhZnRlciA9IEZyYWdtZW50LmVtcHR5O1xuICBmb3IgKHZhciBkID0gJHBvcy5kZXB0aCwgZSA9ICRwb3MuZGVwdGggLSBkZXB0aCwgaSA9IGRlcHRoIC0gMTsgZCA+IGU7IGQtLSwgaS0tKSB7XG4gICAgYmVmb3JlID0gRnJhZ21lbnQuZnJvbSgkcG9zLm5vZGUoZCkuY29weShiZWZvcmUpKTtcbiAgICB2YXIgdHlwZUFmdGVyID0gdHlwZXNBZnRlciAmJiB0eXBlc0FmdGVyW2ldO1xuICAgIGFmdGVyID0gRnJhZ21lbnQuZnJvbSh0eXBlQWZ0ZXIgPyB0eXBlQWZ0ZXIudHlwZS5jcmVhdGUodHlwZUFmdGVyLmF0dHJzLCBhZnRlcikgOiAkcG9zLm5vZGUoZCkuY29weShhZnRlcikpO1xuICB9XG4gIHJldHVybiB0aGlzLnN0ZXAobmV3IFJlcGxhY2VTdGVwKHBvcywgcG9zLCBuZXcgU2xpY2UoYmVmb3JlLmFwcGVuZChhZnRlciksIGRlcHRoLCBkZXB0aCksIHRydWUpKVxufTtcblxuLy8gOjogKE5vZGUsIG51bWJlcikg4oaSIGJvb2xcbi8vIFRlc3Qgd2hldGhlciB0aGUgYmxvY2tzIGJlZm9yZSBhbmQgYWZ0ZXIgYSBnaXZlbiBwb3NpdGlvbiBjYW4gYmVcbi8vIGpvaW5lZC5cbmZ1bmN0aW9uIGNhbkpvaW4oZG9jLCBwb3MpIHtcbiAgdmFyICRwb3MgPSBkb2MucmVzb2x2ZShwb3MpLCBpbmRleCA9ICRwb3MuaW5kZXgoKTtcbiAgcmV0dXJuIGpvaW5hYmxlKCRwb3Mubm9kZUJlZm9yZSwgJHBvcy5ub2RlQWZ0ZXIpICYmXG4gICAgJHBvcy5wYXJlbnQuY2FuUmVwbGFjZShpbmRleCwgaW5kZXggKyAxKVxufVxuXG5mdW5jdGlvbiBqb2luYWJsZShhLCBiKSB7XG4gIHJldHVybiBhICYmIGIgJiYgIWEuaXNMZWFmICYmIGEuY2FuQXBwZW5kKGIpXG59XG5cbi8vIDo6IChOb2RlLCBudW1iZXIsID9udW1iZXIpIOKGkiA/bnVtYmVyXG4vLyBGaW5kIGFuIGFuY2VzdG9yIG9mIHRoZSBnaXZlbiBwb3NpdGlvbiB0aGF0IGNhbiBiZSBqb2luZWQgdG8gdGhlXG4vLyBibG9jayBiZWZvcmUgKG9yIGFmdGVyIGlmIGBkaXJgIGlzIHBvc2l0aXZlKS4gUmV0dXJucyB0aGUgam9pbmFibGVcbi8vIHBvaW50LCBpZiBhbnkuXG5mdW5jdGlvbiBqb2luUG9pbnQoZG9jLCBwb3MsIGRpcikge1xuICBpZiAoIGRpciA9PT0gdm9pZCAwICkgZGlyID0gLTE7XG5cbiAgdmFyICRwb3MgPSBkb2MucmVzb2x2ZShwb3MpO1xuICBmb3IgKHZhciBkID0gJHBvcy5kZXB0aDs7IGQtLSkge1xuICAgIHZhciBiZWZvcmUgPSAodm9pZCAwKSwgYWZ0ZXIgPSAodm9pZCAwKSwgaW5kZXggPSAkcG9zLmluZGV4KGQpO1xuICAgIGlmIChkID09ICRwb3MuZGVwdGgpIHtcbiAgICAgIGJlZm9yZSA9ICRwb3Mubm9kZUJlZm9yZTtcbiAgICAgIGFmdGVyID0gJHBvcy5ub2RlQWZ0ZXI7XG4gICAgfSBlbHNlIGlmIChkaXIgPiAwKSB7XG4gICAgICBiZWZvcmUgPSAkcG9zLm5vZGUoZCArIDEpO1xuICAgICAgaW5kZXgrKztcbiAgICAgIGFmdGVyID0gJHBvcy5ub2RlKGQpLm1heWJlQ2hpbGQoaW5kZXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBiZWZvcmUgPSAkcG9zLm5vZGUoZCkubWF5YmVDaGlsZChpbmRleCAtIDEpO1xuICAgICAgYWZ0ZXIgPSAkcG9zLm5vZGUoZCArIDEpO1xuICAgIH1cbiAgICBpZiAoYmVmb3JlICYmICFiZWZvcmUuaXNUZXh0YmxvY2sgJiYgam9pbmFibGUoYmVmb3JlLCBhZnRlcikgJiZcbiAgICAgICAgJHBvcy5ub2RlKGQpLmNhblJlcGxhY2UoaW5kZXgsIGluZGV4ICsgMSkpIHsgcmV0dXJuIHBvcyB9XG4gICAgaWYgKGQgPT0gMCkgeyBicmVhayB9XG4gICAgcG9zID0gZGlyIDwgMCA/ICRwb3MuYmVmb3JlKGQpIDogJHBvcy5hZnRlcihkKTtcbiAgfVxufVxuXG4vLyA6OiAobnVtYmVyLCA/bnVtYmVyKSDihpIgdGhpc1xuLy8gSm9pbiB0aGUgYmxvY2tzIGFyb3VuZCB0aGUgZ2l2ZW4gcG9zaXRpb24uIElmIGRlcHRoIGlzIDIsIHRoZWlyXG4vLyBsYXN0IGFuZCBmaXJzdCBzaWJsaW5ncyBhcmUgYWxzbyBqb2luZWQsIGFuZCBzbyBvbi5cblRyYW5zZm9ybS5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uKHBvcywgZGVwdGgpIHtcbiAgaWYgKCBkZXB0aCA9PT0gdm9pZCAwICkgZGVwdGggPSAxO1xuXG4gIHZhciBzdGVwID0gbmV3IFJlcGxhY2VTdGVwKHBvcyAtIGRlcHRoLCBwb3MgKyBkZXB0aCwgU2xpY2UuZW1wdHksIHRydWUpO1xuICByZXR1cm4gdGhpcy5zdGVwKHN0ZXApXG59O1xuXG4vLyA6OiAoTm9kZSwgbnVtYmVyLCBOb2RlVHlwZSkg4oaSID9udW1iZXJcbi8vIFRyeSB0byBmaW5kIGEgcG9pbnQgd2hlcmUgYSBub2RlIG9mIHRoZSBnaXZlbiB0eXBlIGNhbiBiZSBpbnNlcnRlZFxuLy8gbmVhciBgcG9zYCwgYnkgc2VhcmNoaW5nIHVwIHRoZSBub2RlIGhpZXJhcmNoeSB3aGVuIGBwb3NgIGl0c2VsZlxuLy8gaXNuJ3QgYSB2YWxpZCBwbGFjZSBidXQgaXMgYXQgdGhlIHN0YXJ0IG9yIGVuZCBvZiBhIG5vZGUuIFJldHVyblxuLy8gbnVsbCBpZiBubyBwb3NpdGlvbiB3YXMgZm91bmQuXG5mdW5jdGlvbiBpbnNlcnRQb2ludChkb2MsIHBvcywgbm9kZVR5cGUpIHtcbiAgdmFyICRwb3MgPSBkb2MucmVzb2x2ZShwb3MpO1xuICBpZiAoJHBvcy5wYXJlbnQuY2FuUmVwbGFjZVdpdGgoJHBvcy5pbmRleCgpLCAkcG9zLmluZGV4KCksIG5vZGVUeXBlKSkgeyByZXR1cm4gcG9zIH1cblxuICBpZiAoJHBvcy5wYXJlbnRPZmZzZXQgPT0gMClcbiAgICB7IGZvciAodmFyIGQgPSAkcG9zLmRlcHRoIC0gMTsgZCA+PSAwOyBkLS0pIHtcbiAgICAgIHZhciBpbmRleCA9ICRwb3MuaW5kZXgoZCk7XG4gICAgICBpZiAoJHBvcy5ub2RlKGQpLmNhblJlcGxhY2VXaXRoKGluZGV4LCBpbmRleCwgbm9kZVR5cGUpKSB7IHJldHVybiAkcG9zLmJlZm9yZShkICsgMSkgfVxuICAgICAgaWYgKGluZGV4ID4gMCkgeyByZXR1cm4gbnVsbCB9XG4gICAgfSB9XG4gIGlmICgkcG9zLnBhcmVudE9mZnNldCA9PSAkcG9zLnBhcmVudC5jb250ZW50LnNpemUpXG4gICAgeyBmb3IgKHZhciBkJDEgPSAkcG9zLmRlcHRoIC0gMTsgZCQxID49IDA7IGQkMS0tKSB7XG4gICAgICB2YXIgaW5kZXgkMSA9ICRwb3MuaW5kZXhBZnRlcihkJDEpO1xuICAgICAgaWYgKCRwb3Mubm9kZShkJDEpLmNhblJlcGxhY2VXaXRoKGluZGV4JDEsIGluZGV4JDEsIG5vZGVUeXBlKSkgeyByZXR1cm4gJHBvcy5hZnRlcihkJDEgKyAxKSB9XG4gICAgICBpZiAoaW5kZXgkMSA8ICRwb3Mubm9kZShkJDEpLmNoaWxkQ291bnQpIHsgcmV0dXJuIG51bGwgfVxuICAgIH0gfVxufVxuXG4vLyA6OiAoTm9kZSwgbnVtYmVyLCBTbGljZSkg4oaSID9udW1iZXJcbi8vIEZpbmRzIGEgcG9zaXRpb24gYXQgb3IgYXJvdW5kIHRoZSBnaXZlbiBwb3NpdGlvbiB3aGVyZSB0aGUgZ2l2ZW5cbi8vIHNsaWNlIGNhbiBiZSBpbnNlcnRlZC4gV2lsbCBsb29rIGF0IHBhcmVudCBub2RlcycgbmVhcmVzdCBib3VuZGFyeVxuLy8gYW5kIHRyeSB0aGVyZSwgZXZlbiBpZiB0aGUgb3JpZ2luYWwgcG9zaXRpb24gd2Fzbid0IGRpcmVjdGx5IGF0IHRoZVxuLy8gc3RhcnQgb3IgZW5kIG9mIHRoYXQgbm9kZS4gUmV0dXJucyBudWxsIHdoZW4gbm8gcG9zaXRpb24gd2FzIGZvdW5kLlxuZnVuY3Rpb24gZHJvcFBvaW50KGRvYywgcG9zLCBzbGljZSkge1xuICB2YXIgJHBvcyA9IGRvYy5yZXNvbHZlKHBvcyk7XG4gIGlmICghc2xpY2UuY29udGVudC5zaXplKSB7IHJldHVybiBwb3MgfVxuICB2YXIgY29udGVudCA9IHNsaWNlLmNvbnRlbnQ7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2Uub3BlblN0YXJ0OyBpKyspIHsgY29udGVudCA9IGNvbnRlbnQuZmlyc3RDaGlsZC5jb250ZW50OyB9XG4gIGZvciAodmFyIHBhc3MgPSAxOyBwYXNzIDw9IChzbGljZS5vcGVuU3RhcnQgPT0gMCAmJiBzbGljZS5zaXplID8gMiA6IDEpOyBwYXNzKyspIHtcbiAgICBmb3IgKHZhciBkID0gJHBvcy5kZXB0aDsgZCA+PSAwOyBkLS0pIHtcbiAgICAgIHZhciBiaWFzID0gZCA9PSAkcG9zLmRlcHRoID8gMCA6ICRwb3MucG9zIDw9ICgkcG9zLnN0YXJ0KGQgKyAxKSArICRwb3MuZW5kKGQgKyAxKSkgLyAyID8gLTEgOiAxO1xuICAgICAgdmFyIGluc2VydFBvcyA9ICRwb3MuaW5kZXgoZCkgKyAoYmlhcyA+IDAgPyAxIDogMCk7XG4gICAgICB2YXIgcGFyZW50ID0gJHBvcy5ub2RlKGQpLCBmaXRzID0gZmFsc2U7XG4gICAgICBpZiAocGFzcyA9PSAxKSB7XG4gICAgICAgIGZpdHMgPSBwYXJlbnQuY2FuUmVwbGFjZShpbnNlcnRQb3MsIGluc2VydFBvcywgY29udGVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgd3JhcHBpbmcgPSBwYXJlbnQuY29udGVudE1hdGNoQXQoaW5zZXJ0UG9zKS5maW5kV3JhcHBpbmcoY29udGVudC5maXJzdENoaWxkLnR5cGUpO1xuICAgICAgICBmaXRzID0gd3JhcHBpbmcgJiYgcGFyZW50LmNhblJlcGxhY2VXaXRoKGluc2VydFBvcywgaW5zZXJ0UG9zLCB3cmFwcGluZ1swXSk7XG4gICAgICB9XG4gICAgICBpZiAoZml0cylcbiAgICAgICAgeyByZXR1cm4gYmlhcyA9PSAwID8gJHBvcy5wb3MgOiBiaWFzIDwgMCA/ICRwb3MuYmVmb3JlKGQgKyAxKSA6ICRwb3MuYWZ0ZXIoZCArIDEpIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cblxuZnVuY3Rpb24gbWFwRnJhZ21lbnQoZnJhZ21lbnQsIGYsIHBhcmVudCkge1xuICB2YXIgbWFwcGVkID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhZ21lbnQuY2hpbGRDb3VudDsgaSsrKSB7XG4gICAgdmFyIGNoaWxkID0gZnJhZ21lbnQuY2hpbGQoaSk7XG4gICAgaWYgKGNoaWxkLmNvbnRlbnQuc2l6ZSkgeyBjaGlsZCA9IGNoaWxkLmNvcHkobWFwRnJhZ21lbnQoY2hpbGQuY29udGVudCwgZiwgY2hpbGQpKTsgfVxuICAgIGlmIChjaGlsZC5pc0lubGluZSkgeyBjaGlsZCA9IGYoY2hpbGQsIHBhcmVudCwgaSk7IH1cbiAgICBtYXBwZWQucHVzaChjaGlsZCk7XG4gIH1cbiAgcmV0dXJuIEZyYWdtZW50LmZyb21BcnJheShtYXBwZWQpXG59XG5cbi8vIDo6LSBBZGQgYSBtYXJrIHRvIGFsbCBpbmxpbmUgY29udGVudCBiZXR3ZWVuIHR3byBwb3NpdGlvbnMuXG52YXIgQWRkTWFya1N0ZXAgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChTdGVwKSB7XG4gIGZ1bmN0aW9uIEFkZE1hcmtTdGVwKGZyb20sIHRvLCBtYXJrKSB7XG4gICAgU3RlcC5jYWxsKHRoaXMpO1xuICAgIC8vIDo6IG51bWJlclxuICAgIC8vIFRoZSBzdGFydCBvZiB0aGUgbWFya2VkIHJhbmdlLlxuICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgLy8gOjogbnVtYmVyXG4gICAgLy8gVGhlIGVuZCBvZiB0aGUgbWFya2VkIHJhbmdlLlxuICAgIHRoaXMudG8gPSB0bztcbiAgICAvLyA6OiBNYXJrXG4gICAgLy8gVGhlIG1hcmsgdG8gYWRkLlxuICAgIHRoaXMubWFyayA9IG1hcms7XG4gIH1cblxuICBpZiAoIFN0ZXAgKSBBZGRNYXJrU3RlcC5fX3Byb3RvX18gPSBTdGVwO1xuICBBZGRNYXJrU3RlcC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBTdGVwICYmIFN0ZXAucHJvdG90eXBlICk7XG4gIEFkZE1hcmtTdGVwLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFkZE1hcmtTdGVwO1xuXG4gIEFkZE1hcmtTdGVwLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uIGFwcGx5IChkb2MpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBvbGRTbGljZSA9IGRvYy5zbGljZSh0aGlzLmZyb20sIHRoaXMudG8pLCAkZnJvbSA9IGRvYy5yZXNvbHZlKHRoaXMuZnJvbSk7XG4gICAgdmFyIHBhcmVudCA9ICRmcm9tLm5vZGUoJGZyb20uc2hhcmVkRGVwdGgodGhpcy50bykpO1xuICAgIHZhciBzbGljZSA9IG5ldyBTbGljZShtYXBGcmFnbWVudChvbGRTbGljZS5jb250ZW50LCBmdW5jdGlvbiAobm9kZSwgcGFyZW50KSB7XG4gICAgICBpZiAoIW5vZGUuaXNBdG9tIHx8ICFwYXJlbnQudHlwZS5hbGxvd3NNYXJrVHlwZSh0aGlzJDEubWFyay50eXBlKSkgeyByZXR1cm4gbm9kZSB9XG4gICAgICByZXR1cm4gbm9kZS5tYXJrKHRoaXMkMS5tYXJrLmFkZFRvU2V0KG5vZGUubWFya3MpKVxuICAgIH0sIHBhcmVudCksIG9sZFNsaWNlLm9wZW5TdGFydCwgb2xkU2xpY2Uub3BlbkVuZCk7XG4gICAgcmV0dXJuIFN0ZXBSZXN1bHQuZnJvbVJlcGxhY2UoZG9jLCB0aGlzLmZyb20sIHRoaXMudG8sIHNsaWNlKVxuICB9O1xuXG4gIEFkZE1hcmtTdGVwLnByb3RvdHlwZS5pbnZlcnQgPSBmdW5jdGlvbiBpbnZlcnQgKCkge1xuICAgIHJldHVybiBuZXcgUmVtb3ZlTWFya1N0ZXAodGhpcy5mcm9tLCB0aGlzLnRvLCB0aGlzLm1hcmspXG4gIH07XG5cbiAgQWRkTWFya1N0ZXAucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIG1hcCAobWFwcGluZykge1xuICAgIHZhciBmcm9tID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy5mcm9tLCAxKSwgdG8gPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLnRvLCAtMSk7XG4gICAgaWYgKGZyb20uZGVsZXRlZCAmJiB0by5kZWxldGVkIHx8IGZyb20ucG9zID49IHRvLnBvcykgeyByZXR1cm4gbnVsbCB9XG4gICAgcmV0dXJuIG5ldyBBZGRNYXJrU3RlcChmcm9tLnBvcywgdG8ucG9zLCB0aGlzLm1hcmspXG4gIH07XG5cbiAgQWRkTWFya1N0ZXAucHJvdG90eXBlLm1lcmdlID0gZnVuY3Rpb24gbWVyZ2UgKG90aGVyKSB7XG4gICAgaWYgKG90aGVyIGluc3RhbmNlb2YgQWRkTWFya1N0ZXAgJiZcbiAgICAgICAgb3RoZXIubWFyay5lcSh0aGlzLm1hcmspICYmXG4gICAgICAgIHRoaXMuZnJvbSA8PSBvdGhlci50byAmJiB0aGlzLnRvID49IG90aGVyLmZyb20pXG4gICAgICB7IHJldHVybiBuZXcgQWRkTWFya1N0ZXAoTWF0aC5taW4odGhpcy5mcm9tLCBvdGhlci5mcm9tKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgodGhpcy50bywgb3RoZXIudG8pLCB0aGlzLm1hcmspIH1cbiAgfTtcblxuICBBZGRNYXJrU3RlcC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgICByZXR1cm4ge3N0ZXBUeXBlOiBcImFkZE1hcmtcIiwgbWFyazogdGhpcy5tYXJrLnRvSlNPTigpLFxuICAgICAgICAgICAgZnJvbTogdGhpcy5mcm9tLCB0bzogdGhpcy50b31cbiAgfTtcblxuICBBZGRNYXJrU3RlcC5mcm9tSlNPTiA9IGZ1bmN0aW9uIGZyb21KU09OIChzY2hlbWEsIGpzb24pIHtcbiAgICBpZiAodHlwZW9mIGpzb24uZnJvbSAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiBqc29uLnRvICE9IFwibnVtYmVyXCIpXG4gICAgICB7IHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgQWRkTWFya1N0ZXAuZnJvbUpTT05cIikgfVxuICAgIHJldHVybiBuZXcgQWRkTWFya1N0ZXAoanNvbi5mcm9tLCBqc29uLnRvLCBzY2hlbWEubWFya0Zyb21KU09OKGpzb24ubWFyaykpXG4gIH07XG5cbiAgcmV0dXJuIEFkZE1hcmtTdGVwO1xufShTdGVwKSk7XG5cblN0ZXAuanNvbklEKFwiYWRkTWFya1wiLCBBZGRNYXJrU3RlcCk7XG5cbi8vIDo6LSBSZW1vdmUgYSBtYXJrIGZyb20gYWxsIGlubGluZSBjb250ZW50IGJldHdlZW4gdHdvIHBvc2l0aW9ucy5cbnZhciBSZW1vdmVNYXJrU3RlcCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFN0ZXApIHtcbiAgZnVuY3Rpb24gUmVtb3ZlTWFya1N0ZXAoZnJvbSwgdG8sIG1hcmspIHtcbiAgICBTdGVwLmNhbGwodGhpcyk7XG4gICAgLy8gOjogbnVtYmVyXG4gICAgLy8gVGhlIHN0YXJ0IG9mIHRoZSB1bm1hcmtlZCByYW5nZS5cbiAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgIC8vIDo6IG51bWJlclxuICAgIC8vIFRoZSBlbmQgb2YgdGhlIHVubWFya2VkIHJhbmdlLlxuICAgIHRoaXMudG8gPSB0bztcbiAgICAvLyA6OiBNYXJrXG4gICAgLy8gVGhlIG1hcmsgdG8gcmVtb3ZlLlxuICAgIHRoaXMubWFyayA9IG1hcms7XG4gIH1cblxuICBpZiAoIFN0ZXAgKSBSZW1vdmVNYXJrU3RlcC5fX3Byb3RvX18gPSBTdGVwO1xuICBSZW1vdmVNYXJrU3RlcC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBTdGVwICYmIFN0ZXAucHJvdG90eXBlICk7XG4gIFJlbW92ZU1hcmtTdGVwLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJlbW92ZU1hcmtTdGVwO1xuXG4gIFJlbW92ZU1hcmtTdGVwLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uIGFwcGx5IChkb2MpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBvbGRTbGljZSA9IGRvYy5zbGljZSh0aGlzLmZyb20sIHRoaXMudG8pO1xuICAgIHZhciBzbGljZSA9IG5ldyBTbGljZShtYXBGcmFnbWVudChvbGRTbGljZS5jb250ZW50LCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGUubWFyayh0aGlzJDEubWFyay5yZW1vdmVGcm9tU2V0KG5vZGUubWFya3MpKVxuICAgIH0pLCBvbGRTbGljZS5vcGVuU3RhcnQsIG9sZFNsaWNlLm9wZW5FbmQpO1xuICAgIHJldHVybiBTdGVwUmVzdWx0LmZyb21SZXBsYWNlKGRvYywgdGhpcy5mcm9tLCB0aGlzLnRvLCBzbGljZSlcbiAgfTtcblxuICBSZW1vdmVNYXJrU3RlcC5wcm90b3R5cGUuaW52ZXJ0ID0gZnVuY3Rpb24gaW52ZXJ0ICgpIHtcbiAgICByZXR1cm4gbmV3IEFkZE1hcmtTdGVwKHRoaXMuZnJvbSwgdGhpcy50bywgdGhpcy5tYXJrKVxuICB9O1xuXG4gIFJlbW92ZU1hcmtTdGVwLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiBtYXAgKG1hcHBpbmcpIHtcbiAgICB2YXIgZnJvbSA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMuZnJvbSwgMSksIHRvID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy50bywgLTEpO1xuICAgIGlmIChmcm9tLmRlbGV0ZWQgJiYgdG8uZGVsZXRlZCB8fCBmcm9tLnBvcyA+PSB0by5wb3MpIHsgcmV0dXJuIG51bGwgfVxuICAgIHJldHVybiBuZXcgUmVtb3ZlTWFya1N0ZXAoZnJvbS5wb3MsIHRvLnBvcywgdGhpcy5tYXJrKVxuICB9O1xuXG4gIFJlbW92ZU1hcmtTdGVwLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uIG1lcmdlIChvdGhlcikge1xuICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIFJlbW92ZU1hcmtTdGVwICYmXG4gICAgICAgIG90aGVyLm1hcmsuZXEodGhpcy5tYXJrKSAmJlxuICAgICAgICB0aGlzLmZyb20gPD0gb3RoZXIudG8gJiYgdGhpcy50byA+PSBvdGhlci5mcm9tKVxuICAgICAgeyByZXR1cm4gbmV3IFJlbW92ZU1hcmtTdGVwKE1hdGgubWluKHRoaXMuZnJvbSwgb3RoZXIuZnJvbSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KHRoaXMudG8sIG90aGVyLnRvKSwgdGhpcy5tYXJrKSB9XG4gIH07XG5cbiAgUmVtb3ZlTWFya1N0ZXAucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gICAgcmV0dXJuIHtzdGVwVHlwZTogXCJyZW1vdmVNYXJrXCIsIG1hcms6IHRoaXMubWFyay50b0pTT04oKSxcbiAgICAgICAgICAgIGZyb206IHRoaXMuZnJvbSwgdG86IHRoaXMudG99XG4gIH07XG5cbiAgUmVtb3ZlTWFya1N0ZXAuZnJvbUpTT04gPSBmdW5jdGlvbiBmcm9tSlNPTiAoc2NoZW1hLCBqc29uKSB7XG4gICAgaWYgKHR5cGVvZiBqc29uLmZyb20gIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YganNvbi50byAhPSBcIm51bWJlclwiKVxuICAgICAgeyB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIFJlbW92ZU1hcmtTdGVwLmZyb21KU09OXCIpIH1cbiAgICByZXR1cm4gbmV3IFJlbW92ZU1hcmtTdGVwKGpzb24uZnJvbSwganNvbi50bywgc2NoZW1hLm1hcmtGcm9tSlNPTihqc29uLm1hcmspKVxuICB9O1xuXG4gIHJldHVybiBSZW1vdmVNYXJrU3RlcDtcbn0oU3RlcCkpO1xuXG5TdGVwLmpzb25JRChcInJlbW92ZU1hcmtcIiwgUmVtb3ZlTWFya1N0ZXApO1xuXG4vLyA6OiAobnVtYmVyLCBudW1iZXIsIE1hcmspIOKGkiB0aGlzXG4vLyBBZGQgdGhlIGdpdmVuIG1hcmsgdG8gdGhlIGlubGluZSBjb250ZW50IGJldHdlZW4gYGZyb21gIGFuZCBgdG9gLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5hZGRNYXJrID0gZnVuY3Rpb24oZnJvbSwgdG8sIG1hcmspIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIHJlbW92ZWQgPSBbXSwgYWRkZWQgPSBbXSwgcmVtb3ZpbmcgPSBudWxsLCBhZGRpbmcgPSBudWxsO1xuICB0aGlzLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIGZ1bmN0aW9uIChub2RlLCBwb3MsIHBhcmVudCkge1xuICAgIGlmICghbm9kZS5pc0lubGluZSkgeyByZXR1cm4gfVxuICAgIHZhciBtYXJrcyA9IG5vZGUubWFya3M7XG4gICAgaWYgKCFtYXJrLmlzSW5TZXQobWFya3MpICYmIHBhcmVudC50eXBlLmFsbG93c01hcmtUeXBlKG1hcmsudHlwZSkpIHtcbiAgICAgIHZhciBzdGFydCA9IE1hdGgubWF4KHBvcywgZnJvbSksIGVuZCA9IE1hdGgubWluKHBvcyArIG5vZGUubm9kZVNpemUsIHRvKTtcbiAgICAgIHZhciBuZXdTZXQgPSBtYXJrLmFkZFRvU2V0KG1hcmtzKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXJrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIW1hcmtzW2ldLmlzSW5TZXQobmV3U2V0KSkge1xuICAgICAgICAgIGlmIChyZW1vdmluZyAmJiByZW1vdmluZy50byA9PSBzdGFydCAmJiByZW1vdmluZy5tYXJrLmVxKG1hcmtzW2ldKSlcbiAgICAgICAgICAgIHsgcmVtb3ZpbmcudG8gPSBlbmQ7IH1cbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7IHJlbW92ZWQucHVzaChyZW1vdmluZyA9IG5ldyBSZW1vdmVNYXJrU3RlcChzdGFydCwgZW5kLCBtYXJrc1tpXSkpOyB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGFkZGluZyAmJiBhZGRpbmcudG8gPT0gc3RhcnQpXG4gICAgICAgIHsgYWRkaW5nLnRvID0gZW5kOyB9XG4gICAgICBlbHNlXG4gICAgICAgIHsgYWRkZWQucHVzaChhZGRpbmcgPSBuZXcgQWRkTWFya1N0ZXAoc3RhcnQsIGVuZCwgbWFyaykpOyB9XG4gICAgfVxuICB9KTtcblxuICByZW1vdmVkLmZvckVhY2goZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHRoaXMkMS5zdGVwKHMpOyB9KTtcbiAgYWRkZWQuZm9yRWFjaChmdW5jdGlvbiAocykgeyByZXR1cm4gdGhpcyQxLnN0ZXAocyk7IH0pO1xuICByZXR1cm4gdGhpc1xufTtcblxuLy8gOjogKG51bWJlciwgbnVtYmVyLCA/dW5pb248TWFyaywgTWFya1R5cGU+KSDihpIgdGhpc1xuLy8gUmVtb3ZlIG1hcmtzIGZyb20gaW5saW5lIG5vZGVzIGJldHdlZW4gYGZyb21gIGFuZCBgdG9gLiBXaGVuIGBtYXJrYFxuLy8gaXMgYSBzaW5nbGUgbWFyaywgcmVtb3ZlIHByZWNpc2VseSB0aGF0IG1hcmsuIFdoZW4gaXQgaXMgYSBtYXJrIHR5cGUsXG4vLyByZW1vdmUgYWxsIG1hcmtzIG9mIHRoYXQgdHlwZS4gV2hlbiBpdCBpcyBudWxsLCByZW1vdmUgYWxsIG1hcmtzIG9mXG4vLyBhbnkgdHlwZS5cblRyYW5zZm9ybS5wcm90b3R5cGUucmVtb3ZlTWFyayA9IGZ1bmN0aW9uKGZyb20sIHRvLCBtYXJrKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuICBpZiAoIG1hcmsgPT09IHZvaWQgMCApIG1hcmsgPSBudWxsO1xuXG4gIHZhciBtYXRjaGVkID0gW10sIHN0ZXAgPSAwO1xuICB0aGlzLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIGZ1bmN0aW9uIChub2RlLCBwb3MpIHtcbiAgICBpZiAoIW5vZGUuaXNJbmxpbmUpIHsgcmV0dXJuIH1cbiAgICBzdGVwKys7XG4gICAgdmFyIHRvUmVtb3ZlID0gbnVsbDtcbiAgICBpZiAobWFyayBpbnN0YW5jZW9mIE1hcmtUeXBlKSB7XG4gICAgICB2YXIgc2V0ID0gbm9kZS5tYXJrcywgZm91bmQ7XG4gICAgICB3aGlsZSAoZm91bmQgPSBtYXJrLmlzSW5TZXQoc2V0KSkge1xuKHRvUmVtb3ZlIHx8ICh0b1JlbW92ZSA9IFtdKSkucHVzaChmb3VuZCk7XG4gICAgICAgIHNldCA9IGZvdW5kLnJlbW92ZUZyb21TZXQoc2V0KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1hcmspIHtcbiAgICAgIGlmIChtYXJrLmlzSW5TZXQobm9kZS5tYXJrcykpIHsgdG9SZW1vdmUgPSBbbWFya107IH1cbiAgICB9IGVsc2Uge1xuICAgICAgdG9SZW1vdmUgPSBub2RlLm1hcmtzO1xuICAgIH1cbiAgICBpZiAodG9SZW1vdmUgJiYgdG9SZW1vdmUubGVuZ3RoKSB7XG4gICAgICB2YXIgZW5kID0gTWF0aC5taW4ocG9zICsgbm9kZS5ub2RlU2l6ZSwgdG8pO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b1JlbW92ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc3R5bGUgPSB0b1JlbW92ZVtpXSwgZm91bmQkMSA9ICh2b2lkIDApO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1hdGNoZWQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB2YXIgbSA9IG1hdGNoZWRbal07XG4gICAgICAgICAgaWYgKG0uc3RlcCA9PSBzdGVwIC0gMSAmJiBzdHlsZS5lcShtYXRjaGVkW2pdLnN0eWxlKSkgeyBmb3VuZCQxID0gbTsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmb3VuZCQxKSB7XG4gICAgICAgICAgZm91bmQkMS50byA9IGVuZDtcbiAgICAgICAgICBmb3VuZCQxLnN0ZXAgPSBzdGVwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hdGNoZWQucHVzaCh7c3R5bGU6IHN0eWxlLCBmcm9tOiBNYXRoLm1heChwb3MsIGZyb20pLCB0bzogZW5kLCBzdGVwOiBzdGVwfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBtYXRjaGVkLmZvckVhY2goZnVuY3Rpb24gKG0pIHsgcmV0dXJuIHRoaXMkMS5zdGVwKG5ldyBSZW1vdmVNYXJrU3RlcChtLmZyb20sIG0udG8sIG0uc3R5bGUpKTsgfSk7XG4gIHJldHVybiB0aGlzXG59O1xuXG4vLyA6OiAobnVtYmVyLCBOb2RlVHlwZSwgP0NvbnRlbnRNYXRjaCkg4oaSIHRoaXNcbi8vIFJlbW92ZXMgYWxsIG1hcmtzIGFuZCBub2RlcyBmcm9tIHRoZSBjb250ZW50IG9mIHRoZSBub2RlIGF0IGBwb3NgXG4vLyB0aGF0IGRvbid0IG1hdGNoIHRoZSBnaXZlbiBuZXcgcGFyZW50IG5vZGUgdHlwZS4gQWNjZXB0cyBhblxuLy8gb3B0aW9uYWwgc3RhcnRpbmcgW2NvbnRlbnQgbWF0Y2hdKCNtb2RlbC5Db250ZW50TWF0Y2gpIGFzIHRoaXJkXG4vLyBhcmd1bWVudC5cblRyYW5zZm9ybS5wcm90b3R5cGUuY2xlYXJJbmNvbXBhdGlibGUgPSBmdW5jdGlvbihwb3MsIHBhcmVudFR5cGUsIG1hdGNoKSB7XG4gIGlmICggbWF0Y2ggPT09IHZvaWQgMCApIG1hdGNoID0gcGFyZW50VHlwZS5jb250ZW50TWF0Y2g7XG5cbiAgdmFyIG5vZGUgPSB0aGlzLmRvYy5ub2RlQXQocG9zKTtcbiAgdmFyIGRlbFN0ZXBzID0gW10sIGN1ciA9IHBvcyArIDE7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZENvdW50OyBpKyspIHtcbiAgICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkKGkpLCBlbmQgPSBjdXIgKyBjaGlsZC5ub2RlU2l6ZTtcbiAgICB2YXIgYWxsb3dlZCA9IG1hdGNoLm1hdGNoVHlwZShjaGlsZC50eXBlLCBjaGlsZC5hdHRycyk7XG4gICAgaWYgKCFhbGxvd2VkKSB7XG4gICAgICBkZWxTdGVwcy5wdXNoKG5ldyBSZXBsYWNlU3RlcChjdXIsIGVuZCwgU2xpY2UuZW1wdHkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWF0Y2ggPSBhbGxvd2VkO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjaGlsZC5tYXJrcy5sZW5ndGg7IGorKykgeyBpZiAoIXBhcmVudFR5cGUuYWxsb3dzTWFya1R5cGUoY2hpbGQubWFya3Nbal0udHlwZSkpXG4gICAgICAgIHsgdGhpcy5zdGVwKG5ldyBSZW1vdmVNYXJrU3RlcChjdXIsIGVuZCwgY2hpbGQubWFya3Nbal0pKTsgfSB9XG4gICAgfVxuICAgIGN1ciA9IGVuZDtcbiAgfVxuICBpZiAoIW1hdGNoLnZhbGlkRW5kKSB7XG4gICAgdmFyIGZpbGwgPSBtYXRjaC5maWxsQmVmb3JlKEZyYWdtZW50LmVtcHR5LCB0cnVlKTtcbiAgICB0aGlzLnJlcGxhY2UoY3VyLCBjdXIsIG5ldyBTbGljZShmaWxsLCAwLCAwKSk7XG4gIH1cbiAgZm9yICh2YXIgaSQxID0gZGVsU3RlcHMubGVuZ3RoIC0gMTsgaSQxID49IDA7IGkkMS0tKSB7IHRoaXMuc3RlcChkZWxTdGVwc1tpJDFdKTsgfVxuICByZXR1cm4gdGhpc1xufTtcblxuLy8gOjogKE5vZGUsIG51bWJlciwgP251bWJlciwgP1NsaWNlKSDihpIgP1N0ZXBcbi8vIOKAmEZpdOKAmSBhIHNsaWNlIGludG8gYSBnaXZlbiBwb3NpdGlvbiBpbiB0aGUgZG9jdW1lbnQsIHByb2R1Y2luZyBhXG4vLyBbc3RlcF0oI3RyYW5zZm9ybS5TdGVwKSB0aGF0IGluc2VydHMgaXQuIFdpbGwgcmV0dXJuIG51bGwgaWZcbi8vIHRoZXJlJ3Mgbm8gbWVhbmluZ2Z1bCB3YXkgdG8gaW5zZXJ0IHRoZSBzbGljZSBoZXJlLCBvciBpbnNlcnRpbmcgaXRcbi8vIHdvdWxkIGJlIGEgbm8tb3AgKGFuIGVtcHR5IHNsaWNlIG92ZXIgYW4gZW1wdHkgcmFuZ2UpLlxuZnVuY3Rpb24gcmVwbGFjZVN0ZXAoZG9jLCBmcm9tLCB0bywgc2xpY2UpIHtcbiAgaWYgKCB0byA9PT0gdm9pZCAwICkgdG8gPSBmcm9tO1xuICBpZiAoIHNsaWNlID09PSB2b2lkIDAgKSBzbGljZSA9IFNsaWNlLmVtcHR5O1xuXG4gIGlmIChmcm9tID09IHRvICYmICFzbGljZS5zaXplKSB7IHJldHVybiBudWxsIH1cblxuICB2YXIgJGZyb20gPSBkb2MucmVzb2x2ZShmcm9tKSwgJHRvID0gZG9jLnJlc29sdmUodG8pO1xuICAvLyBPcHRpbWl6YXRpb24gLS0gYXZvaWQgd29yayBpZiBpdCdzIG9idmlvdXMgdGhhdCBpdCdzIG5vdCBuZWVkZWQuXG4gIGlmIChmaXRzVHJpdmlhbGx5KCRmcm9tLCAkdG8sIHNsaWNlKSkgeyByZXR1cm4gbmV3IFJlcGxhY2VTdGVwKGZyb20sIHRvLCBzbGljZSkgfVxuICByZXR1cm4gbmV3IEZpdHRlcigkZnJvbSwgJHRvLCBzbGljZSkuZml0KClcbn1cblxuLy8gOjogKG51bWJlciwgP251bWJlciwgP1NsaWNlKSDihpIgdGhpc1xuLy8gUmVwbGFjZSB0aGUgcGFydCBvZiB0aGUgZG9jdW1lbnQgYmV0d2VlbiBgZnJvbWAgYW5kIGB0b2Agd2l0aCB0aGVcbi8vIGdpdmVuIGBzbGljZWAuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbihmcm9tLCB0bywgc2xpY2UpIHtcbiAgaWYgKCB0byA9PT0gdm9pZCAwICkgdG8gPSBmcm9tO1xuICBpZiAoIHNsaWNlID09PSB2b2lkIDAgKSBzbGljZSA9IFNsaWNlLmVtcHR5O1xuXG4gIHZhciBzdGVwID0gcmVwbGFjZVN0ZXAodGhpcy5kb2MsIGZyb20sIHRvLCBzbGljZSk7XG4gIGlmIChzdGVwKSB7IHRoaXMuc3RlcChzdGVwKTsgfVxuICByZXR1cm4gdGhpc1xufTtcblxuLy8gOjogKG51bWJlciwgbnVtYmVyLCB1bmlvbjxGcmFnbWVudCwgTm9kZSwgW05vZGVdPikg4oaSIHRoaXNcbi8vIFJlcGxhY2UgdGhlIGdpdmVuIHJhbmdlIHdpdGggdGhlIGdpdmVuIGNvbnRlbnQsIHdoaWNoIG1heSBiZSBhXG4vLyBmcmFnbWVudCwgbm9kZSwgb3IgYXJyYXkgb2Ygbm9kZXMuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnJlcGxhY2VXaXRoID0gZnVuY3Rpb24oZnJvbSwgdG8sIGNvbnRlbnQpIHtcbiAgcmV0dXJuIHRoaXMucmVwbGFjZShmcm9tLCB0bywgbmV3IFNsaWNlKEZyYWdtZW50LmZyb20oY29udGVudCksIDAsIDApKVxufTtcblxuLy8gOjogKG51bWJlciwgbnVtYmVyKSDihpIgdGhpc1xuLy8gRGVsZXRlIHRoZSBjb250ZW50IGJldHdlZW4gdGhlIGdpdmVuIHBvc2l0aW9ucy5cblRyYW5zZm9ybS5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24oZnJvbSwgdG8pIHtcbiAgcmV0dXJuIHRoaXMucmVwbGFjZShmcm9tLCB0bywgU2xpY2UuZW1wdHkpXG59O1xuXG4vLyA6OiAobnVtYmVyLCB1bmlvbjxGcmFnbWVudCwgTm9kZSwgW05vZGVdPikg4oaSIHRoaXNcbi8vIEluc2VydCB0aGUgZ2l2ZW4gY29udGVudCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG5UcmFuc2Zvcm0ucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uKHBvcywgY29udGVudCkge1xuICByZXR1cm4gdGhpcy5yZXBsYWNlV2l0aChwb3MsIHBvcywgY29udGVudClcbn07XG5cbmZ1bmN0aW9uIGZpdHNUcml2aWFsbHkoJGZyb20sICR0bywgc2xpY2UpIHtcbiAgcmV0dXJuICFzbGljZS5vcGVuU3RhcnQgJiYgIXNsaWNlLm9wZW5FbmQgJiYgJGZyb20uc3RhcnQoKSA9PSAkdG8uc3RhcnQoKSAmJlxuICAgICRmcm9tLnBhcmVudC5jYW5SZXBsYWNlKCRmcm9tLmluZGV4KCksICR0by5pbmRleCgpLCBzbGljZS5jb250ZW50KVxufVxuXG4vLyBBbGdvcml0aG0gZm9yICdwbGFjaW5nJyB0aGUgZWxlbWVudHMgb2YgYSBzbGljZSBpbnRvIGEgZ2FwOlxuLy9cbi8vIFdlIGNvbnNpZGVyIHRoZSBjb250ZW50IG9mIGVhY2ggbm9kZSB0aGF0IGlzIG9wZW4gdG8gdGhlIGxlZnQgdG8gYmVcbi8vIGluZGVwZW5kZW50bHkgcGxhY2VhYmxlLiBJLmUuIGluIDxwKFwiZm9vXCIpLCBwKFwiYmFyXCIpPiwgd2hlbiB0aGVcbi8vIHBhcmFncmFwaCBvbiB0aGUgbGVmdCBpcyBvcGVuLCBcImZvb1wiIGNhbiBiZSBwbGFjZWQgKHNvbWV3aGVyZSBvblxuLy8gdGhlIGxlZnQgc2lkZSBvZiB0aGUgcmVwbGFjZW1lbnQgZ2FwKSBpbmRlcGVuZGVudGx5IGZyb20gcChcImJhclwiKS5cbi8vXG4vLyBUaGlzIGNsYXNzIHRyYWNrcyB0aGUgc3RhdGUgb2YgdGhlIHBsYWNlbWVudCBwcm9ncmVzcyBpbiB0aGVcbi8vIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuLy9cbi8vICAtIGBmcm9udGllcmAgaG9sZHMgYSBzdGFjayBvZiBge3R5cGUsIG1hdGNofWAgb2JqZWN0cyB0aGF0XG4vLyAgICByZXByZXNlbnQgdGhlIG9wZW4gc2lkZSBvZiB0aGUgcmVwbGFjZW1lbnQuIEl0IHN0YXJ0cyBhdFxuLy8gICAgYCRmcm9tYCwgdGhlbiBtb3ZlcyBmb3J3YXJkIGFzIGNvbnRlbnQgaXMgcGxhY2VkLCBhbmQgaXMgZmluYWxseVxuLy8gICAgcmVjb25jaWxlZCB3aXRoIGAkdG9gLlxuLy9cbi8vICAtIGB1bnBsYWNlZGAgaXMgYSBzbGljZSB0aGF0IHJlcHJlc2VudHMgdGhlIGNvbnRlbnQgdGhhdCBoYXNuJ3Rcbi8vICAgIGJlZW4gcGxhY2VkIHlldC5cbi8vXG4vLyAgLSBgcGxhY2VkYCBpcyBhIGZyYWdtZW50IG9mIHBsYWNlZCBjb250ZW50LiBJdHMgb3Blbi1zdGFydCB2YWx1ZVxuLy8gICAgaXMgaW1wbGljaXQgaW4gYCRmcm9tYCwgYW5kIGl0cyBvcGVuLWVuZCB2YWx1ZSBpbiBgZnJvbnRpZXJgLlxudmFyIEZpdHRlciA9IGZ1bmN0aW9uIEZpdHRlcigkZnJvbSwgJHRvLCBzbGljZSkge1xuICB0aGlzLiR0byA9ICR0bztcbiAgdGhpcy4kZnJvbSA9ICRmcm9tO1xuICB0aGlzLnVucGxhY2VkID0gc2xpY2U7XG5cbiAgdGhpcy5mcm9udGllciA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8PSAkZnJvbS5kZXB0aDsgaSsrKSB7XG4gICAgdmFyIG5vZGUgPSAkZnJvbS5ub2RlKGkpO1xuICAgIHRoaXMuZnJvbnRpZXIucHVzaCh7XG4gICAgICB0eXBlOiBub2RlLnR5cGUsXG4gICAgICBtYXRjaDogbm9kZS5jb250ZW50TWF0Y2hBdCgkZnJvbS5pbmRleEFmdGVyKGkpKVxuICAgIH0pO1xuICB9XG5cbiAgdGhpcy5wbGFjZWQgPSBGcmFnbWVudC5lbXB0eTtcbiAgZm9yICh2YXIgaSQxID0gJGZyb20uZGVwdGg7IGkkMSA+IDA7IGkkMS0tKVxuICAgIHsgdGhpcy5wbGFjZWQgPSBGcmFnbWVudC5mcm9tKCRmcm9tLm5vZGUoaSQxKS5jb3B5KHRoaXMucGxhY2VkKSk7IH1cbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMkMSA9IHsgZGVwdGg6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxucHJvdG90eXBlQWNjZXNzb3JzJDEuZGVwdGguZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5mcm9udGllci5sZW5ndGggLSAxIH07XG5cbkZpdHRlci5wcm90b3R5cGUuZml0ID0gZnVuY3Rpb24gZml0ICgpIHtcbiAgLy8gQXMgbG9uZyBhcyB0aGVyZSdzIHVucGxhY2VkIGNvbnRlbnQsIHRyeSB0byBwbGFjZSBzb21lIG9mIGl0LlxuICAvLyBJZiB0aGF0IGZhaWxzLCBlaXRoZXIgaW5jcmVhc2UgdGhlIG9wZW4gc2NvcmUgb2YgdGhlIHVucGxhY2VkXG4gIC8vIHNsaWNlLCBvciBkcm9wIG5vZGVzIGZyb20gaXQsIGFuZCB0aGVuIHRyeSBhZ2Fpbi5cbiAgd2hpbGUgKHRoaXMudW5wbGFjZWQuc2l6ZSkge1xuICAgIHZhciBmaXQgPSB0aGlzLmZpbmRGaXR0YWJsZSgpO1xuICAgIGlmIChmaXQpIHsgdGhpcy5wbGFjZU5vZGVzKGZpdCk7IH1cbiAgICBlbHNlIHsgdGhpcy5vcGVuTW9yZSgpIHx8IHRoaXMuZHJvcE5vZGUoKTsgfVxuICB9XG4gIC8vIFdoZW4gdGhlcmUncyBpbmxpbmUgY29udGVudCBkaXJlY3RseSBhZnRlciB0aGUgZnJvbnRpZXIgX2FuZF9cbiAgLy8gZGlyZWN0bHkgYWZ0ZXIgYHRoaXMuJHRvYCwgd2UgbXVzdCBnZW5lcmF0ZSBhIGBSZXBsYWNlQXJvdW5kYFxuICAvLyBzdGVwIHRoYXQgcHVsbHMgdGhhdCBjb250ZW50IGludG8gdGhlIG5vZGUgYWZ0ZXIgdGhlIGZyb250aWVyLlxuICAvLyBUaGF0IG1lYW5zIHRoZSBmaXR0aW5nIG11c3QgYmUgZG9uZSB0byB0aGUgZW5kIG9mIHRoZSB0ZXh0YmxvY2tcbiAgLy8gbm9kZSBhZnRlciBgdGhpcy4kdG9gLCBub3QgYHRoaXMuJHRvYCBpdHNlbGYuXG4gIHZhciBtb3ZlSW5saW5lID0gdGhpcy5tdXN0TW92ZUlubGluZSgpLCBwbGFjZWRTaXplID0gdGhpcy5wbGFjZWQuc2l6ZSAtIHRoaXMuZGVwdGggLSB0aGlzLiRmcm9tLmRlcHRoO1xuICB2YXIgJGZyb20gPSB0aGlzLiRmcm9tLCAkdG8gPSB0aGlzLmNsb3NlKG1vdmVJbmxpbmUgPCAwID8gdGhpcy4kdG8gOiAkZnJvbS5kb2MucmVzb2x2ZShtb3ZlSW5saW5lKSk7XG4gIGlmICghJHRvKSB7IHJldHVybiBudWxsIH1cblxuICAvLyBJZiBjbG9zaW5nIHRvIGAkdG9gIHN1Y2NlZWRlZCwgY3JlYXRlIGEgc3RlcFxuICB2YXIgY29udGVudCA9IHRoaXMucGxhY2VkLCBvcGVuU3RhcnQgPSAkZnJvbS5kZXB0aCwgb3BlbkVuZCA9ICR0by5kZXB0aDtcbiAgd2hpbGUgKG9wZW5TdGFydCAmJiBvcGVuRW5kICYmIGNvbnRlbnQuY2hpbGRDb3VudCA9PSAxKSB7IC8vIE5vcm1hbGl6ZSBieSBkcm9wcGluZyBvcGVuIHBhcmVudCBub2Rlc1xuICAgIGNvbnRlbnQgPSBjb250ZW50LmZpcnN0Q2hpbGQuY29udGVudDtcbiAgICBvcGVuU3RhcnQtLTsgb3BlbkVuZC0tO1xuICB9XG4gIHZhciBzbGljZSA9IG5ldyBTbGljZShjb250ZW50LCBvcGVuU3RhcnQsIG9wZW5FbmQpO1xuICBpZiAobW92ZUlubGluZSA+IC0xKVxuICAgIHsgcmV0dXJuIG5ldyBSZXBsYWNlQXJvdW5kU3RlcCgkZnJvbS5wb3MsIG1vdmVJbmxpbmUsIHRoaXMuJHRvLnBvcywgdGhpcy4kdG8uZW5kKCksIHNsaWNlLCBwbGFjZWRTaXplKSB9XG4gIGlmIChzbGljZS5zaXplIHx8ICRmcm9tLnBvcyAhPSB0aGlzLiR0by5wb3MpIC8vIERvbid0IGdlbmVyYXRlIG5vLW9wIHN0ZXBzXG4gICAgeyByZXR1cm4gbmV3IFJlcGxhY2VTdGVwKCRmcm9tLnBvcywgJHRvLnBvcywgc2xpY2UpIH1cbn07XG5cbi8vIEZpbmQgYSBwb3NpdGlvbiBvbiB0aGUgc3RhcnQgc3BpbmUgb2YgYHRoaXMudW5wbGFjZWRgIHRoYXQgaGFzXG4vLyBjb250ZW50IHRoYXQgY2FuIGJlIG1vdmVkIHNvbWV3aGVyZSBvbiB0aGUgZnJvbnRpZXIuIFJldHVybnMgdHdvXG4vLyBkZXB0aHMsIG9uZSBmb3IgdGhlIHNsaWNlIGFuZCBvbmUgZm9yIHRoZSBmcm9udGllci5cbkZpdHRlci5wcm90b3R5cGUuZmluZEZpdHRhYmxlID0gZnVuY3Rpb24gZmluZEZpdHRhYmxlICgpIHtcbiAgLy8gT25seSB0cnkgd3JhcHBpbmcgbm9kZXMgKHBhc3MgMikgYWZ0ZXIgZmluZGluZyBhIHBsYWNlIHdpdGhvdXRcbiAgLy8gd3JhcHBpbmcgZmFpbGVkLlxuICBmb3IgKHZhciBwYXNzID0gMTsgcGFzcyA8PSAyOyBwYXNzKyspIHtcbiAgICBmb3IgKHZhciBzbGljZURlcHRoID0gdGhpcy51bnBsYWNlZC5vcGVuU3RhcnQ7IHNsaWNlRGVwdGggPj0gMDsgc2xpY2VEZXB0aC0tKSB7XG4gICAgICB2YXIgZnJhZ21lbnQgPSAodm9pZCAwKSwgcGFyZW50ID0gKHZvaWQgMCk7XG4gICAgICBpZiAoc2xpY2VEZXB0aCkge1xuICAgICAgICBwYXJlbnQgPSBjb250ZW50QXQodGhpcy51bnBsYWNlZC5jb250ZW50LCBzbGljZURlcHRoIC0gMSkuZmlyc3RDaGlsZDtcbiAgICAgICAgZnJhZ21lbnQgPSBwYXJlbnQuY29udGVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZyYWdtZW50ID0gdGhpcy51bnBsYWNlZC5jb250ZW50O1xuICAgICAgfVxuICAgICAgdmFyIGZpcnN0ID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcbiAgICAgIGZvciAodmFyIGZyb250aWVyRGVwdGggPSB0aGlzLmRlcHRoOyBmcm9udGllckRlcHRoID49IDA7IGZyb250aWVyRGVwdGgtLSkge1xuICAgICAgICB2YXIgcmVmID0gdGhpcy5mcm9udGllcltmcm9udGllckRlcHRoXTtcbiAgICAgICAgICB2YXIgdHlwZSA9IHJlZi50eXBlO1xuICAgICAgICAgIHZhciBtYXRjaCA9IHJlZi5tYXRjaDtcbiAgICAgICAgICB2YXIgd3JhcCA9ICh2b2lkIDApLCBpbmplY3QgPSAodm9pZCAwKTtcbiAgICAgICAgLy8gSW4gcGFzcyAxLCBpZiB0aGUgbmV4dCBub2RlIG1hdGNoZXMsIG9yIHRoZXJlIGlzIG5vIG5leHRcbiAgICAgICAgLy8gbm9kZSBidXQgdGhlIHBhcmVudHMgbG9vayBjb21wYXRpYmxlLCB3ZSd2ZSBmb3VuZCBhXG4gICAgICAgIC8vIHBsYWNlLlxuICAgICAgICBpZiAocGFzcyA9PSAxICYmIChmaXJzdCA/IG1hdGNoLm1hdGNoVHlwZShmaXJzdC50eXBlKSB8fCAoaW5qZWN0ID0gbWF0Y2guZmlsbEJlZm9yZShGcmFnbWVudC5mcm9tKGZpcnN0KSwgZmFsc2UpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICA6IHR5cGUuY29tcGF0aWJsZUNvbnRlbnQocGFyZW50LnR5cGUpKSlcbiAgICAgICAgICB7IHJldHVybiB7c2xpY2VEZXB0aDogc2xpY2VEZXB0aCwgZnJvbnRpZXJEZXB0aDogZnJvbnRpZXJEZXB0aCwgcGFyZW50OiBwYXJlbnQsIGluamVjdDogaW5qZWN0fSB9XG4gICAgICAgIC8vIEluIHBhc3MgMiwgbG9vayBmb3IgYSBzZXQgb2Ygd3JhcHBpbmcgbm9kZXMgdGhhdCBtYWtlXG4gICAgICAgIC8vIGBmaXJzdGAgZml0IGhlcmUuXG4gICAgICAgIGVsc2UgaWYgKHBhc3MgPT0gMiAmJiBmaXJzdCAmJiAod3JhcCA9IG1hdGNoLmZpbmRXcmFwcGluZyhmaXJzdC50eXBlKSkpXG4gICAgICAgICAgeyByZXR1cm4ge3NsaWNlRGVwdGg6IHNsaWNlRGVwdGgsIGZyb250aWVyRGVwdGg6IGZyb250aWVyRGVwdGgsIHBhcmVudDogcGFyZW50LCB3cmFwOiB3cmFwfSB9XG4gICAgICAgIC8vIERvbid0IGNvbnRpbnVlIGxvb2tpbmcgZnVydGhlciB1cCBpZiB0aGUgcGFyZW50IG5vZGVcbiAgICAgICAgLy8gd291bGQgZml0IGhlcmUuXG4gICAgICAgIGlmIChwYXJlbnQgJiYgbWF0Y2gubWF0Y2hUeXBlKHBhcmVudC50eXBlKSkgeyBicmVhayB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5GaXR0ZXIucHJvdG90eXBlLm9wZW5Nb3JlID0gZnVuY3Rpb24gb3Blbk1vcmUgKCkge1xuICB2YXIgcmVmID0gdGhpcy51bnBsYWNlZDtcbiAgICB2YXIgY29udGVudCA9IHJlZi5jb250ZW50O1xuICAgIHZhciBvcGVuU3RhcnQgPSByZWYub3BlblN0YXJ0O1xuICAgIHZhciBvcGVuRW5kID0gcmVmLm9wZW5FbmQ7XG4gIHZhciBpbm5lciA9IGNvbnRlbnRBdChjb250ZW50LCBvcGVuU3RhcnQpO1xuICBpZiAoIWlubmVyLmNoaWxkQ291bnQgfHwgaW5uZXIuZmlyc3RDaGlsZC5pc0xlYWYpIHsgcmV0dXJuIGZhbHNlIH1cbiAgdGhpcy51bnBsYWNlZCA9IG5ldyBTbGljZShjb250ZW50LCBvcGVuU3RhcnQgKyAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KG9wZW5FbmQsIGlubmVyLnNpemUgKyBvcGVuU3RhcnQgPj0gY29udGVudC5zaXplIC0gb3BlbkVuZCA/IG9wZW5TdGFydCArIDEgOiAwKSk7XG4gIHJldHVybiB0cnVlXG59O1xuXG5GaXR0ZXIucHJvdG90eXBlLmRyb3BOb2RlID0gZnVuY3Rpb24gZHJvcE5vZGUgKCkge1xuICB2YXIgcmVmID0gdGhpcy51bnBsYWNlZDtcbiAgICB2YXIgY29udGVudCA9IHJlZi5jb250ZW50O1xuICAgIHZhciBvcGVuU3RhcnQgPSByZWYub3BlblN0YXJ0O1xuICAgIHZhciBvcGVuRW5kID0gcmVmLm9wZW5FbmQ7XG4gIHZhciBpbm5lciA9IGNvbnRlbnRBdChjb250ZW50LCBvcGVuU3RhcnQpO1xuICBpZiAoaW5uZXIuY2hpbGRDb3VudCA8PSAxICYmIG9wZW5TdGFydCA+IDApIHtcbiAgICB2YXIgb3BlbkF0RW5kID0gY29udGVudC5zaXplIC0gb3BlblN0YXJ0IDw9IG9wZW5TdGFydCArIGlubmVyLnNpemU7XG4gICAgdGhpcy51bnBsYWNlZCA9IG5ldyBTbGljZShkcm9wRnJvbUZyYWdtZW50KGNvbnRlbnQsIG9wZW5TdGFydCAtIDEsIDEpLCBvcGVuU3RhcnQgLSAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlbkF0RW5kID8gb3BlblN0YXJ0IC0gMSA6IG9wZW5FbmQpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMudW5wbGFjZWQgPSBuZXcgU2xpY2UoZHJvcEZyb21GcmFnbWVudChjb250ZW50LCBvcGVuU3RhcnQsIDEpLCBvcGVuU3RhcnQsIG9wZW5FbmQpO1xuICB9XG59O1xuXG4vLyA6ICh7c2xpY2VEZXB0aDogbnVtYmVyLCBmcm9udGllckRlcHRoOiBudW1iZXIsIHBhcmVudDogP05vZGUsIHdyYXA6ID9bTm9kZVR5cGVdLCBpbmplY3Q6ID9GcmFnbWVudH0pXG4vLyBNb3ZlIGNvbnRlbnQgZnJvbSB0aGUgdW5wbGFjZWQgc2xpY2UgYXQgYHNsaWNlRGVwdGhgIHRvIHRoZVxuLy8gZnJvbnRpZXIgbm9kZSBhdCBgZnJvbnRpZXJEZXB0aGAuIENsb3NlIHRoYXQgZnJvbnRpZXIgbm9kZSB3aGVuXG4vLyBhcHBsaWNhYmxlLlxuRml0dGVyLnByb3RvdHlwZS5wbGFjZU5vZGVzID0gZnVuY3Rpb24gcGxhY2VOb2RlcyAocmVmKSB7XG4gICAgdmFyIHNsaWNlRGVwdGggPSByZWYuc2xpY2VEZXB0aDtcbiAgICB2YXIgZnJvbnRpZXJEZXB0aCA9IHJlZi5mcm9udGllckRlcHRoO1xuICAgIHZhciBwYXJlbnQgPSByZWYucGFyZW50O1xuICAgIHZhciBpbmplY3QgPSByZWYuaW5qZWN0O1xuICAgIHZhciB3cmFwID0gcmVmLndyYXA7XG5cbiAgd2hpbGUgKHRoaXMuZGVwdGggPiBmcm9udGllckRlcHRoKSB7IHRoaXMuY2xvc2VGcm9udGllck5vZGUoKTsgfVxuICBpZiAod3JhcCkgeyBmb3IgKHZhciBpID0gMDsgaSA8IHdyYXAubGVuZ3RoOyBpKyspIHsgdGhpcy5vcGVuRnJvbnRpZXJOb2RlKHdyYXBbaV0pOyB9IH1cblxuICB2YXIgc2xpY2UgPSB0aGlzLnVucGxhY2VkLCBmcmFnbWVudCA9IHBhcmVudCA/IHBhcmVudC5jb250ZW50IDogc2xpY2UuY29udGVudDtcbiAgdmFyIG9wZW5TdGFydCA9IHNsaWNlLm9wZW5TdGFydCAtIHNsaWNlRGVwdGg7XG4gIHZhciB0YWtlbiA9IDAsIGFkZCA9IFtdO1xuICB2YXIgcmVmJDEgPSB0aGlzLmZyb250aWVyW2Zyb250aWVyRGVwdGhdO1xuICAgIHZhciBtYXRjaCA9IHJlZiQxLm1hdGNoO1xuICAgIHZhciB0eXBlID0gcmVmJDEudHlwZTtcbiAgaWYgKGluamVjdCkge1xuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGluamVjdC5jaGlsZENvdW50OyBpJDErKykgeyBhZGQucHVzaChpbmplY3QuY2hpbGQoaSQxKSk7IH1cbiAgICBtYXRjaCA9IG1hdGNoLm1hdGNoRnJhZ21lbnQoaW5qZWN0KTtcbiAgfVxuICAvLyBDb21wdXRlcyB0aGUgYW1vdW50IG9mIChlbmQpIG9wZW4gbm9kZXMgYXQgdGhlIGVuZCBvZiB0aGVcbiAgLy8gZnJhZ21lbnQuIFdoZW4gMCwgdGhlIHBhcmVudCBpcyBvcGVuLCBidXQgbm8gbW9yZS4gV2hlblxuICAvLyBuZWdhdGl2ZSwgbm90aGluZyBpcyBvcGVuLlxuICB2YXIgb3BlbkVuZENvdW50ID0gKGZyYWdtZW50LnNpemUgKyBzbGljZURlcHRoKSAtIChzbGljZS5jb250ZW50LnNpemUgLSBzbGljZS5vcGVuRW5kKTtcbiAgLy8gU2NhbiBvdmVyIHRoZSBmcmFnbWVudCwgZml0dGluZyBhcyBtYW55IGNoaWxkIG5vZGVzIGFzXG4gIC8vIHBvc3NpYmxlLlxuICB3aGlsZSAodGFrZW4gPCBmcmFnbWVudC5jaGlsZENvdW50KSB7XG4gICAgdmFyIG5leHQgPSBmcmFnbWVudC5jaGlsZCh0YWtlbiksIG1hdGNoZXMgPSBtYXRjaC5tYXRjaFR5cGUobmV4dC50eXBlKTtcbiAgICBpZiAoIW1hdGNoZXMpIHsgYnJlYWsgfVxuICAgIHRha2VuKys7XG4gICAgaWYgKHRha2VuID4gMSB8fCBvcGVuU3RhcnQgPT0gMCB8fCBuZXh0LmNvbnRlbnQuc2l6ZSkgeyAvLyBEcm9wIGVtcHR5IG9wZW4gbm9kZXNcbiAgICAgIG1hdGNoID0gbWF0Y2hlcztcbiAgICAgIGFkZC5wdXNoKGNsb3NlTm9kZVN0YXJ0KG5leHQubWFyayh0eXBlLmFsbG93ZWRNYXJrcyhuZXh0Lm1hcmtzKSksIHRha2VuID09IDEgPyBvcGVuU3RhcnQgOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFrZW4gPT0gZnJhZ21lbnQuY2hpbGRDb3VudCA/IG9wZW5FbmRDb3VudCA6IC0xKSk7XG4gICAgfVxuICB9XG4gIHZhciB0b0VuZCA9IHRha2VuID09IGZyYWdtZW50LmNoaWxkQ291bnQ7XG4gIGlmICghdG9FbmQpIHsgb3BlbkVuZENvdW50ID0gLTE7IH1cblxuICB0aGlzLnBsYWNlZCA9IGFkZFRvRnJhZ21lbnQodGhpcy5wbGFjZWQsIGZyb250aWVyRGVwdGgsIEZyYWdtZW50LmZyb20oYWRkKSk7XG4gIHRoaXMuZnJvbnRpZXJbZnJvbnRpZXJEZXB0aF0ubWF0Y2ggPSBtYXRjaDtcblxuICAvLyBJZiB0aGUgcGFyZW50IHR5cGVzIG1hdGNoLCBhbmQgdGhlIGVudGlyZSBub2RlIHdhcyBtb3ZlZCwgYW5kXG4gIC8vIGl0J3Mgbm90IG9wZW4sIGNsb3NlIHRoaXMgZnJvbnRpZXIgbm9kZSByaWdodCBhd2F5LlxuICBpZiAodG9FbmQgJiYgb3BlbkVuZENvdW50IDwgMCAmJiBwYXJlbnQgJiYgcGFyZW50LnR5cGUgPT0gdGhpcy5mcm9udGllclt0aGlzLmRlcHRoXS50eXBlICYmIHRoaXMuZnJvbnRpZXIubGVuZ3RoID4gMSlcbiAgICB7IHRoaXMuY2xvc2VGcm9udGllck5vZGUoKTsgfVxuXG4gIC8vIEFkZCBuZXcgZnJvbnRpZXIgbm9kZXMgZm9yIGFueSBvcGVuIG5vZGVzIGF0IHRoZSBlbmQuXG4gIGZvciAodmFyIGkkMiA9IDAsIGN1ciA9IGZyYWdtZW50OyBpJDIgPCBvcGVuRW5kQ291bnQ7IGkkMisrKSB7XG4gICAgdmFyIG5vZGUgPSBjdXIubGFzdENoaWxkO1xuICAgIHRoaXMuZnJvbnRpZXIucHVzaCh7dHlwZTogbm9kZS50eXBlLCBtYXRjaDogbm9kZS5jb250ZW50TWF0Y2hBdChub2RlLmNoaWxkQ291bnQpfSk7XG4gICAgY3VyID0gbm9kZS5jb250ZW50O1xuICB9XG5cbiAgLy8gVXBkYXRlIGB0aGlzLnVucGxhY2VkYC4gRHJvcCB0aGUgZW50aXJlIG5vZGUgZnJvbSB3aGljaCB3ZVxuICAvLyBwbGFjZWQgaXQgd2UgZ290IHRvIGl0cyBlbmQsIG90aGVyd2lzZSBqdXN0IGRyb3AgdGhlIHBsYWNlZFxuICAvLyBub2Rlcy5cbiAgdGhpcy51bnBsYWNlZCA9ICF0b0VuZCA/IG5ldyBTbGljZShkcm9wRnJvbUZyYWdtZW50KHNsaWNlLmNvbnRlbnQsIHNsaWNlRGVwdGgsIHRha2VuKSwgc2xpY2Uub3BlblN0YXJ0LCBzbGljZS5vcGVuRW5kKVxuICAgIDogc2xpY2VEZXB0aCA9PSAwID8gU2xpY2UuZW1wdHlcbiAgICA6IG5ldyBTbGljZShkcm9wRnJvbUZyYWdtZW50KHNsaWNlLmNvbnRlbnQsIHNsaWNlRGVwdGggLSAxLCAxKSxcbiAgICAgICAgICAgICAgICBzbGljZURlcHRoIC0gMSwgb3BlbkVuZENvdW50IDwgMCA/IHNsaWNlLm9wZW5FbmQgOiBzbGljZURlcHRoIC0gMSk7XG59O1xuXG5GaXR0ZXIucHJvdG90eXBlLm11c3RNb3ZlSW5saW5lID0gZnVuY3Rpb24gbXVzdE1vdmVJbmxpbmUgKCkge1xuICBpZiAoIXRoaXMuJHRvLnBhcmVudC5pc1RleHRibG9jayB8fCB0aGlzLiR0by5lbmQoKSA9PSB0aGlzLiR0by5wb3MpIHsgcmV0dXJuIC0xIH1cbiAgdmFyIHRvcCA9IHRoaXMuZnJvbnRpZXJbdGhpcy5kZXB0aF0sIGxldmVsO1xuICBpZiAoIXRvcC50eXBlLmlzVGV4dGJsb2NrIHx8ICFjb250ZW50QWZ0ZXJGaXRzKHRoaXMuJHRvLCB0aGlzLiR0by5kZXB0aCwgdG9wLnR5cGUsIHRvcC5tYXRjaCwgZmFsc2UpIHx8XG4gICAgICAodGhpcy4kdG8uZGVwdGggPT0gdGhpcy5kZXB0aCAmJiAobGV2ZWwgPSB0aGlzLmZpbmRDbG9zZUxldmVsKHRoaXMuJHRvKSkgJiYgbGV2ZWwuZGVwdGggPT0gdGhpcy5kZXB0aCkpIHsgcmV0dXJuIC0xIH1cblxuICB2YXIgcmVmID0gdGhpcy4kdG87XG4gICAgdmFyIGRlcHRoID0gcmVmLmRlcHRoO1xuICAgIHZhciBhZnRlciA9IHRoaXMuJHRvLmFmdGVyKGRlcHRoKTtcbiAgd2hpbGUgKGRlcHRoID4gMSAmJiBhZnRlciA9PSB0aGlzLiR0by5lbmQoLS1kZXB0aCkpIHsgKythZnRlcjsgfVxuICByZXR1cm4gYWZ0ZXJcbn07XG5cbkZpdHRlci5wcm90b3R5cGUuZmluZENsb3NlTGV2ZWwgPSBmdW5jdGlvbiBmaW5kQ2xvc2VMZXZlbCAoJHRvKSB7XG4gIHNjYW46IGZvciAodmFyIGkgPSBNYXRoLm1pbih0aGlzLmRlcHRoLCAkdG8uZGVwdGgpOyBpID49IDA7IGktLSkge1xuICAgIHZhciByZWYgPSB0aGlzLmZyb250aWVyW2ldO1xuICAgICAgdmFyIG1hdGNoID0gcmVmLm1hdGNoO1xuICAgICAgdmFyIHR5cGUgPSByZWYudHlwZTtcbiAgICB2YXIgZHJvcElubmVyID0gaSA8ICR0by5kZXB0aCAmJiAkdG8uZW5kKGkgKyAxKSA9PSAkdG8ucG9zICsgKCR0by5kZXB0aCAtIChpICsgMSkpO1xuICAgIHZhciBmaXQgPSBjb250ZW50QWZ0ZXJGaXRzKCR0bywgaSwgdHlwZSwgbWF0Y2gsIGRyb3BJbm5lcik7XG4gICAgaWYgKCFmaXQpIHsgY29udGludWUgfVxuICAgIGZvciAodmFyIGQgPSBpIC0gMTsgZCA+PSAwOyBkLS0pIHtcbiAgICAgIHZhciByZWYkMSA9IHRoaXMuZnJvbnRpZXJbZF07XG4gICAgICAgIHZhciBtYXRjaCQxID0gcmVmJDEubWF0Y2g7XG4gICAgICAgIHZhciB0eXBlJDEgPSByZWYkMS50eXBlO1xuICAgICAgdmFyIG1hdGNoZXMgPSBjb250ZW50QWZ0ZXJGaXRzKCR0bywgZCwgdHlwZSQxLCBtYXRjaCQxLCB0cnVlKTtcbiAgICAgIGlmICghbWF0Y2hlcyB8fCBtYXRjaGVzLmNoaWxkQ291bnQpIHsgY29udGludWUgc2NhbiB9XG4gICAgfVxuICAgIHJldHVybiB7ZGVwdGg6IGksIGZpdDogZml0LCBtb3ZlOiBkcm9wSW5uZXIgPyAkdG8uZG9jLnJlc29sdmUoJHRvLmFmdGVyKGkgKyAxKSkgOiAkdG99XG4gIH1cbn07XG5cbkZpdHRlci5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiBjbG9zZSAoJHRvKSB7XG4gIHZhciBjbG9zZSA9IHRoaXMuZmluZENsb3NlTGV2ZWwoJHRvKTtcbiAgaWYgKCFjbG9zZSkgeyByZXR1cm4gbnVsbCB9XG5cbiAgd2hpbGUgKHRoaXMuZGVwdGggPiBjbG9zZS5kZXB0aCkgeyB0aGlzLmNsb3NlRnJvbnRpZXJOb2RlKCk7IH1cbiAgaWYgKGNsb3NlLmZpdC5jaGlsZENvdW50KSB7IHRoaXMucGxhY2VkID0gYWRkVG9GcmFnbWVudCh0aGlzLnBsYWNlZCwgY2xvc2UuZGVwdGgsIGNsb3NlLmZpdCk7IH1cbiAgJHRvID0gY2xvc2UubW92ZTtcbiAgZm9yICh2YXIgZCA9IGNsb3NlLmRlcHRoICsgMTsgZCA8PSAkdG8uZGVwdGg7IGQrKykge1xuICAgIHZhciBub2RlID0gJHRvLm5vZGUoZCksIGFkZCA9IG5vZGUudHlwZS5jb250ZW50TWF0Y2guZmlsbEJlZm9yZShub2RlLmNvbnRlbnQsIHRydWUsICR0by5pbmRleChkKSk7XG4gICAgdGhpcy5vcGVuRnJvbnRpZXJOb2RlKG5vZGUudHlwZSwgbm9kZS5hdHRycywgYWRkKTtcbiAgfVxuICByZXR1cm4gJHRvXG59O1xuXG5GaXR0ZXIucHJvdG90eXBlLm9wZW5Gcm9udGllck5vZGUgPSBmdW5jdGlvbiBvcGVuRnJvbnRpZXJOb2RlICh0eXBlLCBhdHRycywgY29udGVudCkge1xuICB2YXIgdG9wID0gdGhpcy5mcm9udGllclt0aGlzLmRlcHRoXTtcbiAgdG9wLm1hdGNoID0gdG9wLm1hdGNoLm1hdGNoVHlwZSh0eXBlKTtcbiAgdGhpcy5wbGFjZWQgPSBhZGRUb0ZyYWdtZW50KHRoaXMucGxhY2VkLCB0aGlzLmRlcHRoLCBGcmFnbWVudC5mcm9tKHR5cGUuY3JlYXRlKGF0dHJzLCBjb250ZW50KSkpO1xuICB0aGlzLmZyb250aWVyLnB1c2goe3R5cGU6IHR5cGUsIG1hdGNoOiB0eXBlLmNvbnRlbnRNYXRjaH0pO1xufTtcblxuRml0dGVyLnByb3RvdHlwZS5jbG9zZUZyb250aWVyTm9kZSA9IGZ1bmN0aW9uIGNsb3NlRnJvbnRpZXJOb2RlICgpIHtcbiAgdmFyIG9wZW4gPSB0aGlzLmZyb250aWVyLnBvcCgpO1xuICB2YXIgYWRkID0gb3Blbi5tYXRjaC5maWxsQmVmb3JlKEZyYWdtZW50LmVtcHR5LCB0cnVlKTtcbiAgaWYgKGFkZC5jaGlsZENvdW50KSB7IHRoaXMucGxhY2VkID0gYWRkVG9GcmFnbWVudCh0aGlzLnBsYWNlZCwgdGhpcy5mcm9udGllci5sZW5ndGgsIGFkZCk7IH1cbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBGaXR0ZXIucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMkMSApO1xuXG5mdW5jdGlvbiBkcm9wRnJvbUZyYWdtZW50KGZyYWdtZW50LCBkZXB0aCwgY291bnQpIHtcbiAgaWYgKGRlcHRoID09IDApIHsgcmV0dXJuIGZyYWdtZW50LmN1dEJ5SW5kZXgoY291bnQpIH1cbiAgcmV0dXJuIGZyYWdtZW50LnJlcGxhY2VDaGlsZCgwLCBmcmFnbWVudC5maXJzdENoaWxkLmNvcHkoZHJvcEZyb21GcmFnbWVudChmcmFnbWVudC5maXJzdENoaWxkLmNvbnRlbnQsIGRlcHRoIC0gMSwgY291bnQpKSlcbn1cblxuZnVuY3Rpb24gYWRkVG9GcmFnbWVudChmcmFnbWVudCwgZGVwdGgsIGNvbnRlbnQpIHtcbiAgaWYgKGRlcHRoID09IDApIHsgcmV0dXJuIGZyYWdtZW50LmFwcGVuZChjb250ZW50KSB9XG4gIHJldHVybiBmcmFnbWVudC5yZXBsYWNlQ2hpbGQoZnJhZ21lbnQuY2hpbGRDb3VudCAtIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQubGFzdENoaWxkLmNvcHkoYWRkVG9GcmFnbWVudChmcmFnbWVudC5sYXN0Q2hpbGQuY29udGVudCwgZGVwdGggLSAxLCBjb250ZW50KSkpXG59XG5cbmZ1bmN0aW9uIGNvbnRlbnRBdChmcmFnbWVudCwgZGVwdGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZXB0aDsgaSsrKSB7IGZyYWdtZW50ID0gZnJhZ21lbnQuZmlyc3RDaGlsZC5jb250ZW50OyB9XG4gIHJldHVybiBmcmFnbWVudFxufVxuXG5mdW5jdGlvbiBjbG9zZU5vZGVTdGFydChub2RlLCBvcGVuU3RhcnQsIG9wZW5FbmQpIHtcbiAgaWYgKG9wZW5TdGFydCA8PSAwKSB7IHJldHVybiBub2RlIH1cbiAgdmFyIGZyYWcgPSBub2RlLmNvbnRlbnQ7XG4gIGlmIChvcGVuU3RhcnQgPiAxKVxuICAgIHsgZnJhZyA9IGZyYWcucmVwbGFjZUNoaWxkKDAsIGNsb3NlTm9kZVN0YXJ0KGZyYWcuZmlyc3RDaGlsZCwgb3BlblN0YXJ0IC0gMSwgZnJhZy5jaGlsZENvdW50ID09IDEgPyBvcGVuRW5kIC0gMSA6IDApKTsgfVxuICBpZiAob3BlblN0YXJ0ID4gMCkge1xuICAgIGZyYWcgPSBub2RlLnR5cGUuY29udGVudE1hdGNoLmZpbGxCZWZvcmUoZnJhZykuYXBwZW5kKGZyYWcpO1xuICAgIGlmIChvcGVuRW5kIDw9IDApIHsgZnJhZyA9IGZyYWcuYXBwZW5kKG5vZGUudHlwZS5jb250ZW50TWF0Y2gubWF0Y2hGcmFnbWVudChmcmFnKS5maWxsQmVmb3JlKEZyYWdtZW50LmVtcHR5LCB0cnVlKSk7IH1cbiAgfVxuICByZXR1cm4gbm9kZS5jb3B5KGZyYWcpXG59XG5cbmZ1bmN0aW9uIGNvbnRlbnRBZnRlckZpdHMoJHRvLCBkZXB0aCwgdHlwZSwgbWF0Y2gsIG9wZW4pIHtcbiAgdmFyIG5vZGUgPSAkdG8ubm9kZShkZXB0aCksIGluZGV4ID0gb3BlbiA/ICR0by5pbmRleEFmdGVyKGRlcHRoKSA6ICR0by5pbmRleChkZXB0aCk7XG4gIGlmIChpbmRleCA9PSBub2RlLmNoaWxkQ291bnQgJiYgIXR5cGUuY29tcGF0aWJsZUNvbnRlbnQobm9kZS50eXBlKSkgeyByZXR1cm4gbnVsbCB9XG4gIHZhciBmaXQgPSBtYXRjaC5maWxsQmVmb3JlKG5vZGUuY29udGVudCwgdHJ1ZSwgaW5kZXgpO1xuICByZXR1cm4gZml0ICYmICFpbnZhbGlkTWFya3ModHlwZSwgbm9kZS5jb250ZW50LCBpbmRleCkgPyBmaXQgOiBudWxsXG59XG5cbmZ1bmN0aW9uIGludmFsaWRNYXJrcyh0eXBlLCBmcmFnbWVudCwgc3RhcnQpIHtcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZnJhZ21lbnQuY2hpbGRDb3VudDsgaSsrKVxuICAgIHsgaWYgKCF0eXBlLmFsbG93c01hcmtzKGZyYWdtZW50LmNoaWxkKGkpLm1hcmtzKSkgeyByZXR1cm4gdHJ1ZSB9IH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8vIDo6IChudW1iZXIsIG51bWJlciwgU2xpY2UpIOKGkiB0aGlzXG4vLyBSZXBsYWNlIGEgcmFuZ2Ugb2YgdGhlIGRvY3VtZW50IHdpdGggYSBnaXZlbiBzbGljZSwgdXNpbmcgYGZyb21gLFxuLy8gYHRvYCwgYW5kIHRoZSBzbGljZSdzIFtgb3BlblN0YXJ0YF0oI21vZGVsLlNsaWNlLm9wZW5TdGFydCkgcHJvcGVydHlcbi8vIGFzIGhpbnRzLCByYXRoZXIgdGhhbiBmaXhlZCBzdGFydCBhbmQgZW5kIHBvaW50cy4gVGhpcyBtZXRob2QgbWF5XG4vLyBncm93IHRoZSByZXBsYWNlZCBhcmVhIG9yIGNsb3NlIG9wZW4gbm9kZXMgaW4gdGhlIHNsaWNlIGluIG9yZGVyIHRvXG4vLyBnZXQgYSBmaXQgdGhhdCBpcyBtb3JlIGluIGxpbmUgd2l0aCBXWVNJV1lHIGV4cGVjdGF0aW9ucywgYnlcbi8vIGRyb3BwaW5nIGZ1bGx5IGNvdmVyZWQgcGFyZW50IG5vZGVzIG9mIHRoZSByZXBsYWNlZCByZWdpb24gd2hlblxuLy8gdGhleSBhcmUgbWFya2VkIFtub24tZGVmaW5pbmddKCNtb2RlbC5Ob2RlU3BlYy5kZWZpbmluZyksIG9yXG4vLyBpbmNsdWRpbmcgYW4gb3BlbiBwYXJlbnQgbm9kZSBmcm9tIHRoZSBzbGljZSB0aGF0IF9pc18gbWFya2VkIGFzXG4vLyBbZGVmaW5pbmddKCNtb2RlbC5Ob2RlU3BlYy5kZWZpbmluZykuXG4vL1xuLy8gVGhpcyBpcyB0aGUgbWV0aG9kLCBmb3IgZXhhbXBsZSwgdG8gaGFuZGxlIHBhc3RlLiBUaGUgc2ltaWxhclxuLy8gW2ByZXBsYWNlYF0oI3RyYW5zZm9ybS5UcmFuc2Zvcm0ucmVwbGFjZSkgbWV0aG9kIGlzIGEgbW9yZVxuLy8gcHJpbWl0aXZlIHRvb2wgd2hpY2ggd2lsbCBfbm90XyBtb3ZlIHRoZSBzdGFydCBhbmQgZW5kIG9mIGl0cyBnaXZlblxuLy8gcmFuZ2UsIGFuZCBpcyB1c2VmdWwgaW4gc2l0dWF0aW9ucyB3aGVyZSB5b3UgbmVlZCBtb3JlIHByZWNpc2Vcbi8vIGNvbnRyb2wgb3ZlciB3aGF0IGhhcHBlbnMuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnJlcGxhY2VSYW5nZSA9IGZ1bmN0aW9uKGZyb20sIHRvLCBzbGljZSkge1xuICBpZiAoIXNsaWNlLnNpemUpIHsgcmV0dXJuIHRoaXMuZGVsZXRlUmFuZ2UoZnJvbSwgdG8pIH1cblxuICB2YXIgJGZyb20gPSB0aGlzLmRvYy5yZXNvbHZlKGZyb20pLCAkdG8gPSB0aGlzLmRvYy5yZXNvbHZlKHRvKTtcbiAgaWYgKGZpdHNUcml2aWFsbHkoJGZyb20sICR0bywgc2xpY2UpKVxuICAgIHsgcmV0dXJuIHRoaXMuc3RlcChuZXcgUmVwbGFjZVN0ZXAoZnJvbSwgdG8sIHNsaWNlKSkgfVxuXG4gIHZhciB0YXJnZXREZXB0aHMgPSBjb3ZlcmVkRGVwdGhzKCRmcm9tLCB0aGlzLmRvYy5yZXNvbHZlKHRvKSk7XG4gIC8vIENhbid0IHJlcGxhY2UgdGhlIHdob2xlIGRvY3VtZW50LCBzbyByZW1vdmUgMCBpZiBpdCdzIHByZXNlbnRcbiAgaWYgKHRhcmdldERlcHRoc1t0YXJnZXREZXB0aHMubGVuZ3RoIC0gMV0gPT0gMCkgeyB0YXJnZXREZXB0aHMucG9wKCk7IH1cbiAgLy8gTmVnYXRpdmUgbnVtYmVycyByZXByZXNlbnQgbm90IGV4cGFuc2lvbiBvdmVyIHRoZSB3aG9sZSBub2RlIGF0XG4gIC8vIHRoYXQgZGVwdGgsIGJ1dCByZXBsYWNpbmcgZnJvbSAkZnJvbS5iZWZvcmUoLUQpIHRvICR0by5wb3MuXG4gIHZhciBwcmVmZXJyZWRUYXJnZXQgPSAtKCRmcm9tLmRlcHRoICsgMSk7XG4gIHRhcmdldERlcHRocy51bnNoaWZ0KHByZWZlcnJlZFRhcmdldCk7XG4gIC8vIFRoaXMgbG9vcCBwaWNrcyBhIHByZWZlcnJlZCB0YXJnZXQgZGVwdGgsIGlmIG9uZSBvZiB0aGUgY292ZXJpbmdcbiAgLy8gZGVwdGhzIGlzIG5vdCBvdXRzaWRlIG9mIGEgZGVmaW5pbmcgbm9kZSwgYW5kIGFkZHMgbmVnYXRpdmVcbiAgLy8gZGVwdGhzIGZvciBhbnkgZGVwdGggdGhhdCBoYXMgJGZyb20gYXQgaXRzIHN0YXJ0IGFuZCBkb2VzIG5vdFxuICAvLyBjcm9zcyBhIGRlZmluaW5nIG5vZGUuXG4gIGZvciAodmFyIGQgPSAkZnJvbS5kZXB0aCwgcG9zID0gJGZyb20ucG9zIC0gMTsgZCA+IDA7IGQtLSwgcG9zLS0pIHtcbiAgICB2YXIgc3BlYyA9ICRmcm9tLm5vZGUoZCkudHlwZS5zcGVjO1xuICAgIGlmIChzcGVjLmRlZmluaW5nIHx8IHNwZWMuaXNvbGF0aW5nKSB7IGJyZWFrIH1cbiAgICBpZiAodGFyZ2V0RGVwdGhzLmluZGV4T2YoZCkgPiAtMSkgeyBwcmVmZXJyZWRUYXJnZXQgPSBkOyB9XG4gICAgZWxzZSBpZiAoJGZyb20uYmVmb3JlKGQpID09IHBvcykgeyB0YXJnZXREZXB0aHMuc3BsaWNlKDEsIDAsIC1kKTsgfVxuICB9XG4gIC8vIFRyeSB0byBmaXQgZWFjaCBwb3NzaWJsZSBkZXB0aCBvZiB0aGUgc2xpY2UgaW50byBlYWNoIHBvc3NpYmxlXG4gIC8vIHRhcmdldCBkZXB0aCwgc3RhcnRpbmcgd2l0aCB0aGUgcHJlZmVycmVkIGRlcHRocy5cbiAgdmFyIHByZWZlcnJlZFRhcmdldEluZGV4ID0gdGFyZ2V0RGVwdGhzLmluZGV4T2YocHJlZmVycmVkVGFyZ2V0KTtcblxuICB2YXIgbGVmdE5vZGVzID0gW10sIHByZWZlcnJlZERlcHRoID0gc2xpY2Uub3BlblN0YXJ0O1xuICBmb3IgKHZhciBjb250ZW50ID0gc2xpY2UuY29udGVudCwgaSA9IDA7OyBpKyspIHtcbiAgICB2YXIgbm9kZSA9IGNvbnRlbnQuZmlyc3RDaGlsZDtcbiAgICBsZWZ0Tm9kZXMucHVzaChub2RlKTtcbiAgICBpZiAoaSA9PSBzbGljZS5vcGVuU3RhcnQpIHsgYnJlYWsgfVxuICAgIGNvbnRlbnQgPSBub2RlLmNvbnRlbnQ7XG4gIH1cbiAgLy8gQmFjayB1cCBpZiB0aGUgbm9kZSBkaXJlY3RseSBhYm92ZSBvcGVuU3RhcnQsIG9yIHRoZSBub2RlIGFib3ZlXG4gIC8vIHRoYXQgc2VwYXJhdGVkIG9ubHkgYnkgYSBub24tZGVmaW5pbmcgdGV4dGJsb2NrIG5vZGUsIGlzIGRlZmluaW5nLlxuICBpZiAocHJlZmVycmVkRGVwdGggPiAwICYmIGxlZnROb2Rlc1twcmVmZXJyZWREZXB0aCAtIDFdLnR5cGUuc3BlYy5kZWZpbmluZyAmJlxuICAgICAgJGZyb20ubm9kZShwcmVmZXJyZWRUYXJnZXRJbmRleCkudHlwZSAhPSBsZWZ0Tm9kZXNbcHJlZmVycmVkRGVwdGggLSAxXS50eXBlKVxuICAgIHsgcHJlZmVycmVkRGVwdGggLT0gMTsgfVxuICBlbHNlIGlmIChwcmVmZXJyZWREZXB0aCA+PSAyICYmIGxlZnROb2Rlc1twcmVmZXJyZWREZXB0aCAtIDFdLmlzVGV4dGJsb2NrICYmIGxlZnROb2Rlc1twcmVmZXJyZWREZXB0aCAtIDJdLnR5cGUuc3BlYy5kZWZpbmluZyAmJlxuICAgICAgICAgICAkZnJvbS5ub2RlKHByZWZlcnJlZFRhcmdldEluZGV4KS50eXBlICE9IGxlZnROb2Rlc1twcmVmZXJyZWREZXB0aCAtIDJdLnR5cGUpXG4gICAgeyBwcmVmZXJyZWREZXB0aCAtPSAyOyB9XG5cbiAgZm9yICh2YXIgaiA9IHNsaWNlLm9wZW5TdGFydDsgaiA+PSAwOyBqLS0pIHtcbiAgICB2YXIgb3BlbkRlcHRoID0gKGogKyBwcmVmZXJyZWREZXB0aCArIDEpICUgKHNsaWNlLm9wZW5TdGFydCArIDEpO1xuICAgIHZhciBpbnNlcnQgPSBsZWZ0Tm9kZXNbb3BlbkRlcHRoXTtcbiAgICBpZiAoIWluc2VydCkgeyBjb250aW51ZSB9XG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgdGFyZ2V0RGVwdGhzLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgIC8vIExvb3Agb3ZlciBwb3NzaWJsZSBleHBhbnNpb24gbGV2ZWxzLCBzdGFydGluZyB3aXRoIHRoZVxuICAgICAgLy8gcHJlZmVycmVkIG9uZVxuICAgICAgdmFyIHRhcmdldERlcHRoID0gdGFyZ2V0RGVwdGhzWyhpJDEgKyBwcmVmZXJyZWRUYXJnZXRJbmRleCkgJSB0YXJnZXREZXB0aHMubGVuZ3RoXSwgZXhwYW5kID0gdHJ1ZTtcbiAgICAgIGlmICh0YXJnZXREZXB0aCA8IDApIHsgZXhwYW5kID0gZmFsc2U7IHRhcmdldERlcHRoID0gLXRhcmdldERlcHRoOyB9XG4gICAgICB2YXIgcGFyZW50ID0gJGZyb20ubm9kZSh0YXJnZXREZXB0aCAtIDEpLCBpbmRleCA9ICRmcm9tLmluZGV4KHRhcmdldERlcHRoIC0gMSk7XG4gICAgICBpZiAocGFyZW50LmNhblJlcGxhY2VXaXRoKGluZGV4LCBpbmRleCwgaW5zZXJ0LnR5cGUsIGluc2VydC5tYXJrcykpXG4gICAgICAgIHsgcmV0dXJuIHRoaXMucmVwbGFjZSgkZnJvbS5iZWZvcmUodGFyZ2V0RGVwdGgpLCBleHBhbmQgPyAkdG8uYWZ0ZXIodGFyZ2V0RGVwdGgpIDogdG8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFNsaWNlKGNsb3NlRnJhZ21lbnQoc2xpY2UuY29udGVudCwgMCwgc2xpY2Uub3BlblN0YXJ0LCBvcGVuRGVwdGgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVuRGVwdGgsIHNsaWNlLm9wZW5FbmQpKSB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHN0YXJ0U3RlcHMgPSB0aGlzLnN0ZXBzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSQyID0gdGFyZ2V0RGVwdGhzLmxlbmd0aCAtIDE7IGkkMiA+PSAwOyBpJDItLSkge1xuICAgIHRoaXMucmVwbGFjZShmcm9tLCB0bywgc2xpY2UpO1xuICAgIGlmICh0aGlzLnN0ZXBzLmxlbmd0aCA+IHN0YXJ0U3RlcHMpIHsgYnJlYWsgfVxuICAgIHZhciBkZXB0aCA9IHRhcmdldERlcHRoc1tpJDJdO1xuICAgIGlmIChkZXB0aCA8IDApIHsgY29udGludWUgfVxuICAgIGZyb20gPSAkZnJvbS5iZWZvcmUoZGVwdGgpOyB0byA9ICR0by5hZnRlcihkZXB0aCk7XG4gIH1cbiAgcmV0dXJuIHRoaXNcbn07XG5cbmZ1bmN0aW9uIGNsb3NlRnJhZ21lbnQoZnJhZ21lbnQsIGRlcHRoLCBvbGRPcGVuLCBuZXdPcGVuLCBwYXJlbnQpIHtcbiAgaWYgKGRlcHRoIDwgb2xkT3Blbikge1xuICAgIHZhciBmaXJzdCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG4gICAgZnJhZ21lbnQgPSBmcmFnbWVudC5yZXBsYWNlQ2hpbGQoMCwgZmlyc3QuY29weShjbG9zZUZyYWdtZW50KGZpcnN0LmNvbnRlbnQsIGRlcHRoICsgMSwgb2xkT3BlbiwgbmV3T3BlbiwgZmlyc3QpKSk7XG4gIH1cbiAgaWYgKGRlcHRoID4gbmV3T3Blbikge1xuICAgIHZhciBtYXRjaCA9IHBhcmVudC5jb250ZW50TWF0Y2hBdCgwKTtcbiAgICB2YXIgc3RhcnQgPSBtYXRjaC5maWxsQmVmb3JlKGZyYWdtZW50KS5hcHBlbmQoZnJhZ21lbnQpO1xuICAgIGZyYWdtZW50ID0gc3RhcnQuYXBwZW5kKG1hdGNoLm1hdGNoRnJhZ21lbnQoc3RhcnQpLmZpbGxCZWZvcmUoRnJhZ21lbnQuZW1wdHksIHRydWUpKTtcbiAgfVxuICByZXR1cm4gZnJhZ21lbnRcbn1cblxuLy8gOjogKG51bWJlciwgbnVtYmVyLCBOb2RlKSDihpIgdGhpc1xuLy8gUmVwbGFjZSB0aGUgZ2l2ZW4gcmFuZ2Ugd2l0aCBhIG5vZGUsIGJ1dCB1c2UgYGZyb21gIGFuZCBgdG9gIGFzXG4vLyBoaW50cywgcmF0aGVyIHRoYW4gcHJlY2lzZSBwb3NpdGlvbnMuIFdoZW4gZnJvbSBhbmQgdG8gYXJlIHRoZSBzYW1lXG4vLyBhbmQgYXJlIGF0IHRoZSBzdGFydCBvciBlbmQgb2YgYSBwYXJlbnQgbm9kZSBpbiB3aGljaCB0aGUgZ2l2ZW5cbi8vIG5vZGUgZG9lc24ndCBmaXQsIHRoaXMgbWV0aG9kIG1heSBfbW92ZV8gdGhlbSBvdXQgdG93YXJkcyBhIHBhcmVudFxuLy8gdGhhdCBkb2VzIGFsbG93IHRoZSBnaXZlbiBub2RlIHRvIGJlIHBsYWNlZC4gV2hlbiB0aGUgZ2l2ZW4gcmFuZ2Vcbi8vIGNvbXBsZXRlbHkgY292ZXJzIGEgcGFyZW50IG5vZGUsIHRoaXMgbWV0aG9kIG1heSBjb21wbGV0ZWx5IHJlcGxhY2Vcbi8vIHRoYXQgcGFyZW50IG5vZGUuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnJlcGxhY2VSYW5nZVdpdGggPSBmdW5jdGlvbihmcm9tLCB0bywgbm9kZSkge1xuICBpZiAoIW5vZGUuaXNJbmxpbmUgJiYgZnJvbSA9PSB0byAmJiB0aGlzLmRvYy5yZXNvbHZlKGZyb20pLnBhcmVudC5jb250ZW50LnNpemUpIHtcbiAgICB2YXIgcG9pbnQgPSBpbnNlcnRQb2ludCh0aGlzLmRvYywgZnJvbSwgbm9kZS50eXBlKTtcbiAgICBpZiAocG9pbnQgIT0gbnVsbCkgeyBmcm9tID0gdG8gPSBwb2ludDsgfVxuICB9XG4gIHJldHVybiB0aGlzLnJlcGxhY2VSYW5nZShmcm9tLCB0bywgbmV3IFNsaWNlKEZyYWdtZW50LmZyb20obm9kZSksIDAsIDApKVxufTtcblxuLy8gOjogKG51bWJlciwgbnVtYmVyKSDihpIgdGhpc1xuLy8gRGVsZXRlIHRoZSBnaXZlbiByYW5nZSwgZXhwYW5kaW5nIGl0IHRvIGNvdmVyIGZ1bGx5IGNvdmVyZWRcbi8vIHBhcmVudCBub2RlcyB1bnRpbCBhIHZhbGlkIHJlcGxhY2UgaXMgZm91bmQuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLmRlbGV0ZVJhbmdlID0gZnVuY3Rpb24oZnJvbSwgdG8pIHtcbiAgdmFyICRmcm9tID0gdGhpcy5kb2MucmVzb2x2ZShmcm9tKSwgJHRvID0gdGhpcy5kb2MucmVzb2x2ZSh0byk7XG4gIHZhciBjb3ZlcmVkID0gY292ZXJlZERlcHRocygkZnJvbSwgJHRvKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3ZlcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlcHRoID0gY292ZXJlZFtpXSwgbGFzdCA9IGkgPT0gY292ZXJlZC5sZW5ndGggLSAxO1xuICAgIGlmICgobGFzdCAmJiBkZXB0aCA9PSAwKSB8fCAkZnJvbS5ub2RlKGRlcHRoKS50eXBlLmNvbnRlbnRNYXRjaC52YWxpZEVuZClcbiAgICAgIHsgcmV0dXJuIHRoaXMuZGVsZXRlKCRmcm9tLnN0YXJ0KGRlcHRoKSwgJHRvLmVuZChkZXB0aCkpIH1cbiAgICBpZiAoZGVwdGggPiAwICYmIChsYXN0IHx8ICRmcm9tLm5vZGUoZGVwdGggLSAxKS5jYW5SZXBsYWNlKCRmcm9tLmluZGV4KGRlcHRoIC0gMSksICR0by5pbmRleEFmdGVyKGRlcHRoIC0gMSkpKSlcbiAgICAgIHsgcmV0dXJuIHRoaXMuZGVsZXRlKCRmcm9tLmJlZm9yZShkZXB0aCksICR0by5hZnRlcihkZXB0aCkpIH1cbiAgfVxuICBmb3IgKHZhciBkID0gMTsgZCA8PSAkZnJvbS5kZXB0aCAmJiBkIDw9ICR0by5kZXB0aDsgZCsrKSB7XG4gICAgaWYgKGZyb20gLSAkZnJvbS5zdGFydChkKSA9PSAkZnJvbS5kZXB0aCAtIGQgJiYgdG8gPiAkZnJvbS5lbmQoZCkgJiYgJHRvLmVuZChkKSAtIHRvICE9ICR0by5kZXB0aCAtIGQpXG4gICAgICB7IHJldHVybiB0aGlzLmRlbGV0ZSgkZnJvbS5iZWZvcmUoZCksIHRvKSB9XG4gIH1cbiAgcmV0dXJuIHRoaXMuZGVsZXRlKGZyb20sIHRvKVxufTtcblxuLy8gOiAoUmVzb2x2ZWRQb3MsIFJlc29sdmVkUG9zKSDihpIgW251bWJlcl1cbi8vIFJldHVybnMgYW4gYXJyYXkgb2YgYWxsIGRlcHRocyBmb3Igd2hpY2ggJGZyb20gLSAkdG8gc3BhbnMgdGhlXG4vLyB3aG9sZSBjb250ZW50IG9mIHRoZSBub2RlcyBhdCB0aGF0IGRlcHRoLlxuZnVuY3Rpb24gY292ZXJlZERlcHRocygkZnJvbSwgJHRvKSB7XG4gIHZhciByZXN1bHQgPSBbXSwgbWluRGVwdGggPSBNYXRoLm1pbigkZnJvbS5kZXB0aCwgJHRvLmRlcHRoKTtcbiAgZm9yICh2YXIgZCA9IG1pbkRlcHRoOyBkID49IDA7IGQtLSkge1xuICAgIHZhciBzdGFydCA9ICRmcm9tLnN0YXJ0KGQpO1xuICAgIGlmIChzdGFydCA8ICRmcm9tLnBvcyAtICgkZnJvbS5kZXB0aCAtIGQpIHx8XG4gICAgICAgICR0by5lbmQoZCkgPiAkdG8ucG9zICsgKCR0by5kZXB0aCAtIGQpIHx8XG4gICAgICAgICRmcm9tLm5vZGUoZCkudHlwZS5zcGVjLmlzb2xhdGluZyB8fFxuICAgICAgICAkdG8ubm9kZShkKS50eXBlLnNwZWMuaXNvbGF0aW5nKSB7IGJyZWFrIH1cbiAgICBpZiAoc3RhcnQgPT0gJHRvLnN0YXJ0KGQpIHx8XG4gICAgICAgIChkID09ICRmcm9tLmRlcHRoICYmIGQgPT0gJHRvLmRlcHRoICYmICRmcm9tLnBhcmVudC5pbmxpbmVDb250ZW50ICYmICR0by5wYXJlbnQuaW5saW5lQ29udGVudCAmJlxuICAgICAgICAgZCAmJiAkdG8uc3RhcnQoZCAtIDEpID09IHN0YXJ0IC0gMSkpXG4gICAgICB7IHJlc3VsdC5wdXNoKGQpOyB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5leHBvcnQgeyBBZGRNYXJrU3RlcCwgTWFwUmVzdWx0LCBNYXBwaW5nLCBSZW1vdmVNYXJrU3RlcCwgUmVwbGFjZUFyb3VuZFN0ZXAsIFJlcGxhY2VTdGVwLCBTdGVwLCBTdGVwTWFwLCBTdGVwUmVzdWx0LCBUcmFuc2Zvcm0sIFRyYW5zZm9ybUVycm9yLCBjYW5Kb2luLCBjYW5TcGxpdCwgZHJvcFBvaW50LCBmaW5kV3JhcHBpbmcsIGluc2VydFBvaW50LCBqb2luUG9pbnQsIGxpZnRUYXJnZXQsIHJlcGxhY2VTdGVwIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lcy5qcy5tYXBcbiIsImltcG9ydCB7IFRleHRTZWxlY3Rpb24sIE5vZGVTZWxlY3Rpb24sIFNlbGVjdGlvbiwgQWxsU2VsZWN0aW9uIH0gZnJvbSAncHJvc2VtaXJyb3Itc3RhdGUnO1xuaW1wb3J0IHsgRE9NU2VyaWFsaXplciwgRnJhZ21lbnQsIE1hcmssIERPTVBhcnNlciwgU2xpY2UgfSBmcm9tICdwcm9zZW1pcnJvci1tb2RlbCc7XG5pbXBvcnQgeyBkcm9wUG9pbnQgfSBmcm9tICdwcm9zZW1pcnJvci10cmFuc2Zvcm0nO1xuXG52YXIgcmVzdWx0ID0ge307XG5cbmlmICh0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGRvY3VtZW50ICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgdmFyIGllX2VkZ2UgPSAvRWRnZVxcLyhcXGQrKS8uZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgdmFyIGllX3VwdG8xMCA9IC9NU0lFIFxcZC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgdmFyIGllXzExdXAgPSAvVHJpZGVudFxcLyg/Ols3LTldfFxcZHsyLH0pXFwuLipydjooXFxkKykvLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbiAgcmVzdWx0Lm1hYyA9IC9NYWMvLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKTtcbiAgdmFyIGllID0gcmVzdWx0LmllID0gISEoaWVfdXB0bzEwIHx8IGllXzExdXAgfHwgaWVfZWRnZSk7XG4gIHJlc3VsdC5pZV92ZXJzaW9uID0gaWVfdXB0bzEwID8gZG9jdW1lbnQuZG9jdW1lbnRNb2RlIHx8IDYgOiBpZV8xMXVwID8gK2llXzExdXBbMV0gOiBpZV9lZGdlID8gK2llX2VkZ2VbMV0gOiBudWxsO1xuICByZXN1bHQuZ2Vja28gPSAhaWUgJiYgL2dlY2tvXFwvKFxcZCspL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgcmVzdWx0LmdlY2tvX3ZlcnNpb24gPSByZXN1bHQuZ2Vja28gJiYgKygvRmlyZWZveFxcLyhcXGQrKS8uZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KSB8fCBbMCwgMF0pWzFdO1xuICB2YXIgY2hyb21lID0gIWllICYmIC9DaHJvbWVcXC8oXFxkKykvLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIHJlc3VsdC5jaHJvbWUgPSAhIWNocm9tZTtcbiAgcmVzdWx0LmNocm9tZV92ZXJzaW9uID0gY2hyb21lICYmICtjaHJvbWVbMV07XG4gIC8vIElzIHRydWUgZm9yIGJvdGggaU9TIGFuZCBpUGFkT1MgZm9yIGNvbnZlbmllbmNlXG4gIHJlc3VsdC5zYWZhcmkgPSAhaWUgJiYgL0FwcGxlIENvbXB1dGVyLy50ZXN0KG5hdmlnYXRvci52ZW5kb3IpO1xuICByZXN1bHQuaW9zID0gcmVzdWx0LnNhZmFyaSAmJiAoL01vYmlsZVxcL1xcdysvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgfHwgbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMik7XG4gIHJlc3VsdC5hbmRyb2lkID0gL0FuZHJvaWQgXFxkLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICByZXN1bHQud2Via2l0ID0gXCJ3ZWJraXRGb250U21vb3RoaW5nXCIgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xuICByZXN1bHQud2Via2l0X3ZlcnNpb24gPSByZXN1bHQud2Via2l0ICYmICsoL1xcYkFwcGxlV2ViS2l0XFwvKFxcZCspLy5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpIHx8IFswLCAwXSlbMV07XG59XG5cbnZhciBkb21JbmRleCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgZm9yICh2YXIgaW5kZXggPSAwOzsgaW5kZXgrKykge1xuICAgIG5vZGUgPSBub2RlLnByZXZpb3VzU2libGluZztcbiAgICBpZiAoIW5vZGUpIHsgcmV0dXJuIGluZGV4IH1cbiAgfVxufTtcblxudmFyIHBhcmVudE5vZGUgPSBmdW5jdGlvbihub2RlKSB7XG4gIHZhciBwYXJlbnQgPSBub2RlLmFzc2lnbmVkU2xvdCB8fCBub2RlLnBhcmVudE5vZGU7XG4gIHJldHVybiBwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlID09IDExID8gcGFyZW50Lmhvc3QgOiBwYXJlbnRcbn07XG5cbnZhciByZXVzZWRSYW5nZSA9IG51bGw7XG5cbi8vIE5vdGUgdGhhdCB0aGlzIHdpbGwgYWx3YXlzIHJldHVybiB0aGUgc2FtZSByYW5nZSwgYmVjYXVzZSBET00gcmFuZ2Vcbi8vIG9iamVjdHMgYXJlIGV2ZXJ5IGV4cGVuc2l2ZSwgYW5kIGtlZXAgc2xvd2luZyBkb3duIHN1YnNlcXVlbnQgRE9NXG4vLyB1cGRhdGVzLCBmb3Igc29tZSByZWFzb24uXG52YXIgdGV4dFJhbmdlID0gZnVuY3Rpb24obm9kZSwgZnJvbSwgdG8pIHtcbiAgdmFyIHJhbmdlID0gcmV1c2VkUmFuZ2UgfHwgKHJldXNlZFJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKSk7XG4gIHJhbmdlLnNldEVuZChub2RlLCB0byA9PSBudWxsID8gbm9kZS5ub2RlVmFsdWUubGVuZ3RoIDogdG8pO1xuICByYW5nZS5zZXRTdGFydChub2RlLCBmcm9tIHx8IDApO1xuICByZXR1cm4gcmFuZ2Vcbn07XG5cbi8vIFNjYW5zIGZvcndhcmQgYW5kIGJhY2t3YXJkIHRocm91Z2ggRE9NIHBvc2l0aW9ucyBlcXVpdmFsZW50IHRvIHRoZVxuLy8gZ2l2ZW4gb25lIHRvIHNlZSBpZiB0aGUgdHdvIGFyZSBpbiB0aGUgc2FtZSBwbGFjZSAoaS5lLiBhZnRlciBhXG4vLyB0ZXh0IG5vZGUgdnMgYXQgdGhlIGVuZCBvZiB0aGF0IHRleHQgbm9kZSlcbnZhciBpc0VxdWl2YWxlbnRQb3NpdGlvbiA9IGZ1bmN0aW9uKG5vZGUsIG9mZiwgdGFyZ2V0Tm9kZSwgdGFyZ2V0T2ZmKSB7XG4gIHJldHVybiB0YXJnZXROb2RlICYmIChzY2FuRm9yKG5vZGUsIG9mZiwgdGFyZ2V0Tm9kZSwgdGFyZ2V0T2ZmLCAtMSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjYW5Gb3Iobm9kZSwgb2ZmLCB0YXJnZXROb2RlLCB0YXJnZXRPZmYsIDEpKVxufTtcblxudmFyIGF0b21FbGVtZW50cyA9IC9eKGltZ3xicnxpbnB1dHx0ZXh0YXJlYXxocikkL2k7XG5cbmZ1bmN0aW9uIHNjYW5Gb3Iobm9kZSwgb2ZmLCB0YXJnZXROb2RlLCB0YXJnZXRPZmYsIGRpcikge1xuICBmb3IgKDs7KSB7XG4gICAgaWYgKG5vZGUgPT0gdGFyZ2V0Tm9kZSAmJiBvZmYgPT0gdGFyZ2V0T2ZmKSB7IHJldHVybiB0cnVlIH1cbiAgICBpZiAob2ZmID09IChkaXIgPCAwID8gMCA6IG5vZGVTaXplKG5vZGUpKSkge1xuICAgICAgdmFyIHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgIGlmIChwYXJlbnQubm9kZVR5cGUgIT0gMSB8fCBoYXNCbG9ja0Rlc2Mobm9kZSkgfHwgYXRvbUVsZW1lbnRzLnRlc3Qobm9kZS5ub2RlTmFtZSkgfHwgbm9kZS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKVxuICAgICAgICB7IHJldHVybiBmYWxzZSB9XG4gICAgICBvZmYgPSBkb21JbmRleChub2RlKSArIChkaXIgPCAwID8gMCA6IDEpO1xuICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICB9IGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSkge1xuICAgICAgbm9kZSA9IG5vZGUuY2hpbGROb2Rlc1tvZmYgKyAoZGlyIDwgMCA/IC0xIDogMCldO1xuICAgICAgaWYgKG5vZGUuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIikgeyByZXR1cm4gZmFsc2UgfVxuICAgICAgb2ZmID0gZGlyIDwgMCA/IG5vZGVTaXplKG5vZGUpIDogMDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG5vZGVTaXplKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT0gMyA/IG5vZGUubm9kZVZhbHVlLmxlbmd0aCA6IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGhcbn1cblxuZnVuY3Rpb24gaXNPbkVkZ2Uobm9kZSwgb2Zmc2V0LCBwYXJlbnQpIHtcbiAgZm9yICh2YXIgYXRTdGFydCA9IG9mZnNldCA9PSAwLCBhdEVuZCA9IG9mZnNldCA9PSBub2RlU2l6ZShub2RlKTsgYXRTdGFydCB8fCBhdEVuZDspIHtcbiAgICBpZiAobm9kZSA9PSBwYXJlbnQpIHsgcmV0dXJuIHRydWUgfVxuICAgIHZhciBpbmRleCA9IGRvbUluZGV4KG5vZGUpO1xuICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgaWYgKCFub2RlKSB7IHJldHVybiBmYWxzZSB9XG4gICAgYXRTdGFydCA9IGF0U3RhcnQgJiYgaW5kZXggPT0gMDtcbiAgICBhdEVuZCA9IGF0RW5kICYmIGluZGV4ID09IG5vZGVTaXplKG5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhc0Jsb2NrRGVzYyhkb20pIHtcbiAgdmFyIGRlc2M7XG4gIGZvciAodmFyIGN1ciA9IGRvbTsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSkgeyBpZiAoZGVzYyA9IGN1ci5wbVZpZXdEZXNjKSB7IGJyZWFrIH0gfVxuICByZXR1cm4gZGVzYyAmJiBkZXNjLm5vZGUgJiYgZGVzYy5ub2RlLmlzQmxvY2sgJiYgKGRlc2MuZG9tID09IGRvbSB8fCBkZXNjLmNvbnRlbnRET00gPT0gZG9tKVxufVxuXG4vLyBXb3JrIGFyb3VuZCBDaHJvbWUgaXNzdWUgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDQ3NTIzXG4vLyAoaXNDb2xsYXBzZWQgaW5hcHByb3ByaWF0ZWx5IHJldHVybnMgdHJ1ZSBpbiBzaGFkb3cgZG9tKVxudmFyIHNlbGVjdGlvbkNvbGxhcHNlZCA9IGZ1bmN0aW9uKGRvbVNlbCkge1xuICB2YXIgY29sbGFwc2VkID0gZG9tU2VsLmlzQ29sbGFwc2VkO1xuICBpZiAoY29sbGFwc2VkICYmIHJlc3VsdC5jaHJvbWUgJiYgZG9tU2VsLnJhbmdlQ291bnQgJiYgIWRvbVNlbC5nZXRSYW5nZUF0KDApLmNvbGxhcHNlZClcbiAgICB7IGNvbGxhcHNlZCA9IGZhbHNlOyB9XG4gIHJldHVybiBjb2xsYXBzZWRcbn07XG5cbmZ1bmN0aW9uIGtleUV2ZW50KGtleUNvZGUsIGtleSkge1xuICB2YXIgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpO1xuICBldmVudC5pbml0RXZlbnQoXCJrZXlkb3duXCIsIHRydWUsIHRydWUpO1xuICBldmVudC5rZXlDb2RlID0ga2V5Q29kZTtcbiAgZXZlbnQua2V5ID0gZXZlbnQuY29kZSA9IGtleTtcbiAgcmV0dXJuIGV2ZW50XG59XG5cbmZ1bmN0aW9uIHdpbmRvd1JlY3QoZG9jKSB7XG4gIHJldHVybiB7bGVmdDogMCwgcmlnaHQ6IGRvYy5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgsXG4gICAgICAgICAgdG9wOiAwLCBib3R0b206IGRvYy5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0fVxufVxuXG5mdW5jdGlvbiBnZXRTaWRlKHZhbHVlLCBzaWRlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gXCJudW1iZXJcIiA/IHZhbHVlIDogdmFsdWVbc2lkZV1cbn1cblxuZnVuY3Rpb24gY2xpZW50UmVjdChub2RlKSB7XG4gIHZhciByZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgLy8gQWRqdXN0IGZvciBlbGVtZW50cyB3aXRoIHN0eWxlIFwidHJhbnNmb3JtOiBzY2FsZSgpXCJcbiAgdmFyIHNjYWxlWCA9IChyZWN0LndpZHRoIC8gbm9kZS5vZmZzZXRXaWR0aCkgfHwgMTtcbiAgdmFyIHNjYWxlWSA9IChyZWN0LmhlaWdodCAvIG5vZGUub2Zmc2V0SGVpZ2h0KSB8fCAxO1xuICAvLyBNYWtlIHN1cmUgc2Nyb2xsYmFyIHdpZHRoIGlzbid0IGluY2x1ZGVkIGluIHRoZSByZWN0YW5nbGVcbiAgcmV0dXJuIHtsZWZ0OiByZWN0LmxlZnQsIHJpZ2h0OiByZWN0LmxlZnQgKyBub2RlLmNsaWVudFdpZHRoICogc2NhbGVYLFxuICAgICAgICAgIHRvcDogcmVjdC50b3AsIGJvdHRvbTogcmVjdC50b3AgKyBub2RlLmNsaWVudEhlaWdodCAqIHNjYWxlWX1cbn1cblxuZnVuY3Rpb24gc2Nyb2xsUmVjdEludG9WaWV3KHZpZXcsIHJlY3QsIHN0YXJ0RE9NKSB7XG4gIHZhciBzY3JvbGxUaHJlc2hvbGQgPSB2aWV3LnNvbWVQcm9wKFwic2Nyb2xsVGhyZXNob2xkXCIpIHx8IDAsIHNjcm9sbE1hcmdpbiA9IHZpZXcuc29tZVByb3AoXCJzY3JvbGxNYXJnaW5cIikgfHwgNTtcbiAgdmFyIGRvYyA9IHZpZXcuZG9tLm93bmVyRG9jdW1lbnQ7XG4gIGZvciAodmFyIHBhcmVudCA9IHN0YXJ0RE9NIHx8IHZpZXcuZG9tOzsgcGFyZW50ID0gcGFyZW50Tm9kZShwYXJlbnQpKSB7XG4gICAgaWYgKCFwYXJlbnQpIHsgYnJlYWsgfVxuICAgIGlmIChwYXJlbnQubm9kZVR5cGUgIT0gMSkgeyBjb250aW51ZSB9XG4gICAgdmFyIGF0VG9wID0gcGFyZW50ID09IGRvYy5ib2R5IHx8IHBhcmVudC5ub2RlVHlwZSAhPSAxO1xuICAgIHZhciBib3VuZGluZyA9IGF0VG9wID8gd2luZG93UmVjdChkb2MpIDogY2xpZW50UmVjdChwYXJlbnQpO1xuICAgIHZhciBtb3ZlWCA9IDAsIG1vdmVZID0gMDtcbiAgICBpZiAocmVjdC50b3AgPCBib3VuZGluZy50b3AgKyBnZXRTaWRlKHNjcm9sbFRocmVzaG9sZCwgXCJ0b3BcIikpXG4gICAgICB7IG1vdmVZID0gLShib3VuZGluZy50b3AgLSByZWN0LnRvcCArIGdldFNpZGUoc2Nyb2xsTWFyZ2luLCBcInRvcFwiKSk7IH1cbiAgICBlbHNlIGlmIChyZWN0LmJvdHRvbSA+IGJvdW5kaW5nLmJvdHRvbSAtIGdldFNpZGUoc2Nyb2xsVGhyZXNob2xkLCBcImJvdHRvbVwiKSlcbiAgICAgIHsgbW92ZVkgPSByZWN0LmJvdHRvbSAtIGJvdW5kaW5nLmJvdHRvbSArIGdldFNpZGUoc2Nyb2xsTWFyZ2luLCBcImJvdHRvbVwiKTsgfVxuICAgIGlmIChyZWN0LmxlZnQgPCBib3VuZGluZy5sZWZ0ICsgZ2V0U2lkZShzY3JvbGxUaHJlc2hvbGQsIFwibGVmdFwiKSlcbiAgICAgIHsgbW92ZVggPSAtKGJvdW5kaW5nLmxlZnQgLSByZWN0LmxlZnQgKyBnZXRTaWRlKHNjcm9sbE1hcmdpbiwgXCJsZWZ0XCIpKTsgfVxuICAgIGVsc2UgaWYgKHJlY3QucmlnaHQgPiBib3VuZGluZy5yaWdodCAtIGdldFNpZGUoc2Nyb2xsVGhyZXNob2xkLCBcInJpZ2h0XCIpKVxuICAgICAgeyBtb3ZlWCA9IHJlY3QucmlnaHQgLSBib3VuZGluZy5yaWdodCArIGdldFNpZGUoc2Nyb2xsTWFyZ2luLCBcInJpZ2h0XCIpOyB9XG4gICAgaWYgKG1vdmVYIHx8IG1vdmVZKSB7XG4gICAgICBpZiAoYXRUb3ApIHtcbiAgICAgICAgZG9jLmRlZmF1bHRWaWV3LnNjcm9sbEJ5KG1vdmVYLCBtb3ZlWSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc3RhcnRYID0gcGFyZW50LnNjcm9sbExlZnQsIHN0YXJ0WSA9IHBhcmVudC5zY3JvbGxUb3A7XG4gICAgICAgIGlmIChtb3ZlWSkgeyBwYXJlbnQuc2Nyb2xsVG9wICs9IG1vdmVZOyB9XG4gICAgICAgIGlmIChtb3ZlWCkgeyBwYXJlbnQuc2Nyb2xsTGVmdCArPSBtb3ZlWDsgfVxuICAgICAgICB2YXIgZFggPSBwYXJlbnQuc2Nyb2xsTGVmdCAtIHN0YXJ0WCwgZFkgPSBwYXJlbnQuc2Nyb2xsVG9wIC0gc3RhcnRZO1xuICAgICAgICByZWN0ID0ge2xlZnQ6IHJlY3QubGVmdCAtIGRYLCB0b3A6IHJlY3QudG9wIC0gZFksIHJpZ2h0OiByZWN0LnJpZ2h0IC0gZFgsIGJvdHRvbTogcmVjdC5ib3R0b20gLSBkWX07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhdFRvcCkgeyBicmVhayB9XG4gIH1cbn1cblxuLy8gU3RvcmUgdGhlIHNjcm9sbCBwb3NpdGlvbiBvZiB0aGUgZWRpdG9yJ3MgcGFyZW50IG5vZGVzLCBhbG9uZyB3aXRoXG4vLyB0aGUgdG9wIHBvc2l0aW9uIG9mIGFuIGVsZW1lbnQgbmVhciB0aGUgdG9wIG9mIHRoZSBlZGl0b3IsIHdoaWNoXG4vLyB3aWxsIGJlIHVzZWQgdG8gbWFrZSBzdXJlIHRoZSB2aXNpYmxlIHZpZXdwb3J0IHJlbWFpbnMgc3RhYmxlIGV2ZW5cbi8vIHdoZW4gdGhlIHNpemUgb2YgdGhlIGNvbnRlbnQgYWJvdmUgY2hhbmdlcy5cbmZ1bmN0aW9uIHN0b3JlU2Nyb2xsUG9zKHZpZXcpIHtcbiAgdmFyIHJlY3QgPSB2aWV3LmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgc3RhcnRZID0gTWF0aC5tYXgoMCwgcmVjdC50b3ApO1xuICB2YXIgcmVmRE9NLCByZWZUb3A7XG4gIGZvciAodmFyIHggPSAocmVjdC5sZWZ0ICsgcmVjdC5yaWdodCkgLyAyLCB5ID0gc3RhcnRZICsgMTtcbiAgICAgICB5IDwgTWF0aC5taW4oaW5uZXJIZWlnaHQsIHJlY3QuYm90dG9tKTsgeSArPSA1KSB7XG4gICAgdmFyIGRvbSA9IHZpZXcucm9vdC5lbGVtZW50RnJvbVBvaW50KHgsIHkpO1xuICAgIGlmIChkb20gPT0gdmlldy5kb20gfHwgIXZpZXcuZG9tLmNvbnRhaW5zKGRvbSkpIHsgY29udGludWUgfVxuICAgIHZhciBsb2NhbFJlY3QgPSBkb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgaWYgKGxvY2FsUmVjdC50b3AgPj0gc3RhcnRZIC0gMjApIHtcbiAgICAgIHJlZkRPTSA9IGRvbTtcbiAgICAgIHJlZlRvcCA9IGxvY2FsUmVjdC50b3A7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuICByZXR1cm4ge3JlZkRPTTogcmVmRE9NLCByZWZUb3A6IHJlZlRvcCwgc3RhY2s6IHNjcm9sbFN0YWNrKHZpZXcuZG9tKX1cbn1cblxuZnVuY3Rpb24gc2Nyb2xsU3RhY2soZG9tKSB7XG4gIHZhciBzdGFjayA9IFtdLCBkb2MgPSBkb20ub3duZXJEb2N1bWVudDtcbiAgZm9yICg7IGRvbTsgZG9tID0gcGFyZW50Tm9kZShkb20pKSB7XG4gICAgc3RhY2sucHVzaCh7ZG9tOiBkb20sIHRvcDogZG9tLnNjcm9sbFRvcCwgbGVmdDogZG9tLnNjcm9sbExlZnR9KTtcbiAgICBpZiAoZG9tID09IGRvYykgeyBicmVhayB9XG4gIH1cbiAgcmV0dXJuIHN0YWNrXG59XG5cbi8vIFJlc2V0IHRoZSBzY3JvbGwgcG9zaXRpb24gb2YgdGhlIGVkaXRvcidzIHBhcmVudCBub2RlcyB0byB0aGF0IHdoYXRcbi8vIGl0IHdhcyBiZWZvcmUsIHdoZW4gc3RvcmVTY3JvbGxQb3Mgd2FzIGNhbGxlZC5cbmZ1bmN0aW9uIHJlc2V0U2Nyb2xsUG9zKHJlZikge1xuICB2YXIgcmVmRE9NID0gcmVmLnJlZkRPTTtcbiAgdmFyIHJlZlRvcCA9IHJlZi5yZWZUb3A7XG4gIHZhciBzdGFjayA9IHJlZi5zdGFjaztcblxuICB2YXIgbmV3UmVmVG9wID0gcmVmRE9NID8gcmVmRE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCA6IDA7XG4gIHJlc3RvcmVTY3JvbGxTdGFjayhzdGFjaywgbmV3UmVmVG9wID09IDAgPyAwIDogbmV3UmVmVG9wIC0gcmVmVG9wKTtcbn1cblxuZnVuY3Rpb24gcmVzdG9yZVNjcm9sbFN0YWNrKHN0YWNrLCBkVG9wKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcmVmID0gc3RhY2tbaV07XG4gICAgdmFyIGRvbSA9IHJlZi5kb207XG4gICAgdmFyIHRvcCA9IHJlZi50b3A7XG4gICAgdmFyIGxlZnQgPSByZWYubGVmdDtcbiAgICBpZiAoZG9tLnNjcm9sbFRvcCAhPSB0b3AgKyBkVG9wKSB7IGRvbS5zY3JvbGxUb3AgPSB0b3AgKyBkVG9wOyB9XG4gICAgaWYgKGRvbS5zY3JvbGxMZWZ0ICE9IGxlZnQpIHsgZG9tLnNjcm9sbExlZnQgPSBsZWZ0OyB9XG4gIH1cbn1cblxudmFyIHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgPSBudWxsO1xuLy8gRmVhdHVyZS1kZXRlY3RzIHN1cHBvcnQgZm9yIC5mb2N1cyh7cHJldmVudFNjcm9sbDogdHJ1ZX0pLCBhbmQgdXNlc1xuLy8gYSBmYWxsYmFjayBrbHVkZ2Ugd2hlbiBub3Qgc3VwcG9ydGVkLlxuZnVuY3Rpb24gZm9jdXNQcmV2ZW50U2Nyb2xsKGRvbSkge1xuICBpZiAoZG9tLnNldEFjdGl2ZSkgeyByZXR1cm4gZG9tLnNldEFjdGl2ZSgpIH0gLy8gaW4gSUVcbiAgaWYgKHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQpIHsgcmV0dXJuIGRvbS5mb2N1cyhwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkKSB9XG5cbiAgdmFyIHN0b3JlZCA9IHNjcm9sbFN0YWNrKGRvbSk7XG4gIGRvbS5mb2N1cyhwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkID09IG51bGwgPyB7XG4gICAgZ2V0IHByZXZlbnRTY3JvbGwoKSB7XG4gICAgICBwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkID0ge3ByZXZlbnRTY3JvbGw6IHRydWV9O1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH0gOiB1bmRlZmluZWQpO1xuICBpZiAoIXByZXZlbnRTY3JvbGxTdXBwb3J0ZWQpIHtcbiAgICBwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgcmVzdG9yZVNjcm9sbFN0YWNrKHN0b3JlZCwgMCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZE9mZnNldEluTm9kZShub2RlLCBjb29yZHMpIHtcbiAgdmFyIGNsb3Nlc3QsIGR4Q2xvc2VzdCA9IDJlOCwgY29vcmRzQ2xvc2VzdCwgb2Zmc2V0ID0gMDtcbiAgdmFyIHJvd0JvdCA9IGNvb3Jkcy50b3AsIHJvd1RvcCA9IGNvb3Jkcy50b3A7XG4gIGZvciAodmFyIGNoaWxkID0gbm9kZS5maXJzdENoaWxkLCBjaGlsZEluZGV4ID0gMDsgY2hpbGQ7IGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmcsIGNoaWxkSW5kZXgrKykge1xuICAgIHZhciByZWN0cyA9ICh2b2lkIDApO1xuICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PSAxKSB7IHJlY3RzID0gY2hpbGQuZ2V0Q2xpZW50UmVjdHMoKTsgfVxuICAgIGVsc2UgaWYgKGNoaWxkLm5vZGVUeXBlID09IDMpIHsgcmVjdHMgPSB0ZXh0UmFuZ2UoY2hpbGQpLmdldENsaWVudFJlY3RzKCk7IH1cbiAgICBlbHNlIHsgY29udGludWUgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHJlY3QgPSByZWN0c1tpXTtcbiAgICAgIGlmIChyZWN0LnRvcCA8PSByb3dCb3QgJiYgcmVjdC5ib3R0b20gPj0gcm93VG9wKSB7XG4gICAgICAgIHJvd0JvdCA9IE1hdGgubWF4KHJlY3QuYm90dG9tLCByb3dCb3QpO1xuICAgICAgICByb3dUb3AgPSBNYXRoLm1pbihyZWN0LnRvcCwgcm93VG9wKTtcbiAgICAgICAgdmFyIGR4ID0gcmVjdC5sZWZ0ID4gY29vcmRzLmxlZnQgPyByZWN0LmxlZnQgLSBjb29yZHMubGVmdFxuICAgICAgICAgICAgOiByZWN0LnJpZ2h0IDwgY29vcmRzLmxlZnQgPyBjb29yZHMubGVmdCAtIHJlY3QucmlnaHQgOiAwO1xuICAgICAgICBpZiAoZHggPCBkeENsb3Nlc3QpIHtcbiAgICAgICAgICBjbG9zZXN0ID0gY2hpbGQ7XG4gICAgICAgICAgZHhDbG9zZXN0ID0gZHg7XG4gICAgICAgICAgY29vcmRzQ2xvc2VzdCA9IGR4ICYmIGNsb3Nlc3Qubm9kZVR5cGUgPT0gMyA/IHtsZWZ0OiByZWN0LnJpZ2h0IDwgY29vcmRzLmxlZnQgPyByZWN0LnJpZ2h0IDogcmVjdC5sZWZ0LCB0b3A6IGNvb3Jkcy50b3B9IDogY29vcmRzO1xuICAgICAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PSAxICYmIGR4KVxuICAgICAgICAgICAgeyBvZmZzZXQgPSBjaGlsZEluZGV4ICsgKGNvb3Jkcy5sZWZ0ID49IChyZWN0LmxlZnQgKyByZWN0LnJpZ2h0KSAvIDIgPyAxIDogMCk7IH1cbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWNsb3Nlc3QgJiYgKGNvb3Jkcy5sZWZ0ID49IHJlY3QucmlnaHQgJiYgY29vcmRzLnRvcCA+PSByZWN0LnRvcCB8fFxuICAgICAgICAgICAgICAgICAgICAgICBjb29yZHMubGVmdCA+PSByZWN0LmxlZnQgJiYgY29vcmRzLnRvcCA+PSByZWN0LmJvdHRvbSkpXG4gICAgICAgIHsgb2Zmc2V0ID0gY2hpbGRJbmRleCArIDE7IH1cbiAgICB9XG4gIH1cbiAgaWYgKGNsb3Nlc3QgJiYgY2xvc2VzdC5ub2RlVHlwZSA9PSAzKSB7IHJldHVybiBmaW5kT2Zmc2V0SW5UZXh0KGNsb3Nlc3QsIGNvb3Jkc0Nsb3Nlc3QpIH1cbiAgaWYgKCFjbG9zZXN0IHx8IChkeENsb3Nlc3QgJiYgY2xvc2VzdC5ub2RlVHlwZSA9PSAxKSkgeyByZXR1cm4ge25vZGU6IG5vZGUsIG9mZnNldDogb2Zmc2V0fSB9XG4gIHJldHVybiBmaW5kT2Zmc2V0SW5Ob2RlKGNsb3Nlc3QsIGNvb3Jkc0Nsb3Nlc3QpXG59XG5cbmZ1bmN0aW9uIGZpbmRPZmZzZXRJblRleHQobm9kZSwgY29vcmRzKSB7XG4gIHZhciBsZW4gPSBub2RlLm5vZGVWYWx1ZS5sZW5ndGg7XG4gIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICByYW5nZS5zZXRFbmQobm9kZSwgaSArIDEpO1xuICAgIHJhbmdlLnNldFN0YXJ0KG5vZGUsIGkpO1xuICAgIHZhciByZWN0ID0gc2luZ2xlUmVjdChyYW5nZSwgMSk7XG4gICAgaWYgKHJlY3QudG9wID09IHJlY3QuYm90dG9tKSB7IGNvbnRpbnVlIH1cbiAgICBpZiAoaW5SZWN0KGNvb3JkcywgcmVjdCkpXG4gICAgICB7IHJldHVybiB7bm9kZTogbm9kZSwgb2Zmc2V0OiBpICsgKGNvb3Jkcy5sZWZ0ID49IChyZWN0LmxlZnQgKyByZWN0LnJpZ2h0KSAvIDIgPyAxIDogMCl9IH1cbiAgfVxuICByZXR1cm4ge25vZGU6IG5vZGUsIG9mZnNldDogMH1cbn1cblxuZnVuY3Rpb24gaW5SZWN0KGNvb3JkcywgcmVjdCkge1xuICByZXR1cm4gY29vcmRzLmxlZnQgPj0gcmVjdC5sZWZ0IC0gMSAmJiBjb29yZHMubGVmdCA8PSByZWN0LnJpZ2h0ICsgMSYmXG4gICAgY29vcmRzLnRvcCA+PSByZWN0LnRvcCAtIDEgJiYgY29vcmRzLnRvcCA8PSByZWN0LmJvdHRvbSArIDFcbn1cblxuZnVuY3Rpb24gdGFyZ2V0S2x1ZGdlKGRvbSwgY29vcmRzKSB7XG4gIHZhciBwYXJlbnQgPSBkb20ucGFyZW50Tm9kZTtcbiAgaWYgKHBhcmVudCAmJiAvXmxpJC9pLnRlc3QocGFyZW50Lm5vZGVOYW1lKSAmJiBjb29yZHMubGVmdCA8IGRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0KVxuICAgIHsgcmV0dXJuIHBhcmVudCB9XG4gIHJldHVybiBkb21cbn1cblxuZnVuY3Rpb24gcG9zRnJvbUVsZW1lbnQodmlldywgZWx0LCBjb29yZHMpIHtcbiAgdmFyIHJlZiA9IGZpbmRPZmZzZXRJbk5vZGUoZWx0LCBjb29yZHMpO1xuICB2YXIgbm9kZSA9IHJlZi5ub2RlO1xuICB2YXIgb2Zmc2V0ID0gcmVmLm9mZnNldDtcbiAgdmFyIGJpYXMgPSAtMTtcbiAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSAmJiAhbm9kZS5maXJzdENoaWxkKSB7XG4gICAgdmFyIHJlY3QgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGJpYXMgPSByZWN0LmxlZnQgIT0gcmVjdC5yaWdodCAmJiBjb29yZHMubGVmdCA+IChyZWN0LmxlZnQgKyByZWN0LnJpZ2h0KSAvIDIgPyAxIDogLTE7XG4gIH1cbiAgcmV0dXJuIHZpZXcuZG9jVmlldy5wb3NGcm9tRE9NKG5vZGUsIG9mZnNldCwgYmlhcylcbn1cblxuZnVuY3Rpb24gcG9zRnJvbUNhcmV0KHZpZXcsIG5vZGUsIG9mZnNldCwgY29vcmRzKSB7XG4gIC8vIEJyb3dzZXIgKGluIGNhcmV0UG9zaXRpb24vUmFuZ2VGcm9tUG9pbnQpIHdpbGwgYWdyZXNzaXZlbHlcbiAgLy8gbm9ybWFsaXplIHRvd2FyZHMgbmVhcmJ5IGlubGluZSBub2Rlcy4gU2luY2Ugd2UgYXJlIGludGVyZXN0ZWQgaW5cbiAgLy8gcG9zaXRpb25zIGJldHdlZW4gYmxvY2sgbm9kZXMgdG9vLCB3ZSBmaXJzdCB3YWxrIHVwIHRoZSBoaWVyYXJjaHlcbiAgLy8gb2Ygbm9kZXMgdG8gc2VlIGlmIHRoZXJlIGFyZSBibG9jayBub2RlcyB0aGF0IHRoZSBjb29yZGluYXRlc1xuICAvLyBmYWxsIG91dHNpZGUgb2YuIElmIHNvLCB3ZSB0YWtlIHRoZSBwb3NpdGlvbiBiZWZvcmUvYWZ0ZXIgdGhhdFxuICAvLyBibG9jay4gSWYgbm90LCB3ZSBjYWxsIGBwb3NGcm9tRE9NYCBvbiB0aGUgcmF3IG5vZGUvb2Zmc2V0LlxuICB2YXIgb3V0c2lkZSA9IC0xO1xuICBmb3IgKHZhciBjdXIgPSBub2RlOzspIHtcbiAgICBpZiAoY3VyID09IHZpZXcuZG9tKSB7IGJyZWFrIH1cbiAgICB2YXIgZGVzYyA9IHZpZXcuZG9jVmlldy5uZWFyZXN0RGVzYyhjdXIsIHRydWUpO1xuICAgIGlmICghZGVzYykgeyByZXR1cm4gbnVsbCB9XG4gICAgaWYgKGRlc2Mubm9kZS5pc0Jsb2NrICYmIGRlc2MucGFyZW50KSB7XG4gICAgICB2YXIgcmVjdCA9IGRlc2MuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgaWYgKHJlY3QubGVmdCA+IGNvb3Jkcy5sZWZ0IHx8IHJlY3QudG9wID4gY29vcmRzLnRvcCkgeyBvdXRzaWRlID0gZGVzYy5wb3NCZWZvcmU7IH1cbiAgICAgIGVsc2UgaWYgKHJlY3QucmlnaHQgPCBjb29yZHMubGVmdCB8fCByZWN0LmJvdHRvbSA8IGNvb3Jkcy50b3ApIHsgb3V0c2lkZSA9IGRlc2MucG9zQWZ0ZXI7IH1cbiAgICAgIGVsc2UgeyBicmVhayB9XG4gICAgfVxuICAgIGN1ciA9IGRlc2MuZG9tLnBhcmVudE5vZGU7XG4gIH1cbiAgcmV0dXJuIG91dHNpZGUgPiAtMSA/IG91dHNpZGUgOiB2aWV3LmRvY1ZpZXcucG9zRnJvbURPTShub2RlLCBvZmZzZXQpXG59XG5cbmZ1bmN0aW9uIGVsZW1lbnRGcm9tUG9pbnQoZWxlbWVudCwgY29vcmRzLCBib3gpIHtcbiAgdmFyIGxlbiA9IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7XG4gIGlmIChsZW4gJiYgYm94LnRvcCA8IGJveC5ib3R0b20pIHtcbiAgICBmb3IgKHZhciBzdGFydEkgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihsZW4gLSAxLCBNYXRoLmZsb29yKGxlbiAqIChjb29yZHMudG9wIC0gYm94LnRvcCkgLyAoYm94LmJvdHRvbSAtIGJveC50b3ApKSAtIDIpKSwgaSA9IHN0YXJ0STs7KSB7XG4gICAgICB2YXIgY2hpbGQgPSBlbGVtZW50LmNoaWxkTm9kZXNbaV07XG4gICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICB2YXIgcmVjdHMgPSBjaGlsZC5nZXRDbGllbnRSZWN0cygpO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlY3RzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdmFyIHJlY3QgPSByZWN0c1tqXTtcbiAgICAgICAgICBpZiAoaW5SZWN0KGNvb3JkcywgcmVjdCkpIHsgcmV0dXJuIGVsZW1lbnRGcm9tUG9pbnQoY2hpbGQsIGNvb3JkcywgcmVjdCkgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoKGkgPSAoaSArIDEpICUgbGVuKSA9PSBzdGFydEkpIHsgYnJlYWsgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZWxlbWVudFxufVxuXG4vLyBHaXZlbiBhbiB4LHkgcG9zaXRpb24gb24gdGhlIGVkaXRvciwgZ2V0IHRoZSBwb3NpdGlvbiBpbiB0aGUgZG9jdW1lbnQuXG5mdW5jdGlvbiBwb3NBdENvb3Jkcyh2aWV3LCBjb29yZHMpIHtcbiAgdmFyIGFzc2lnbiwgYXNzaWduJDE7XG5cbiAgdmFyIGRvYyA9IHZpZXcuZG9tLm93bmVyRG9jdW1lbnQsIG5vZGUsIG9mZnNldDtcbiAgaWYgKGRvYy5jYXJldFBvc2l0aW9uRnJvbVBvaW50KSB7XG4gICAgdHJ5IHsgLy8gRmlyZWZveCB0aHJvd3MgZm9yIHRoaXMgY2FsbCBpbiBoYXJkLXRvLXByZWRpY3QgY2lyY3Vtc3RhbmNlcyAoIzk5NClcbiAgICAgIHZhciBwb3MkMSA9IGRvYy5jYXJldFBvc2l0aW9uRnJvbVBvaW50KGNvb3Jkcy5sZWZ0LCBjb29yZHMudG9wKTtcbiAgICAgIGlmIChwb3MkMSkgeyAoKGFzc2lnbiA9IHBvcyQxLCBub2RlID0gYXNzaWduLm9mZnNldE5vZGUsIG9mZnNldCA9IGFzc2lnbi5vZmZzZXQpKTsgfVxuICAgIH0gY2F0Y2ggKF8pIHt9XG4gIH1cbiAgaWYgKCFub2RlICYmIGRvYy5jYXJldFJhbmdlRnJvbVBvaW50KSB7XG4gICAgdmFyIHJhbmdlID0gZG9jLmNhcmV0UmFuZ2VGcm9tUG9pbnQoY29vcmRzLmxlZnQsIGNvb3Jkcy50b3ApO1xuICAgIGlmIChyYW5nZSkgeyAoKGFzc2lnbiQxID0gcmFuZ2UsIG5vZGUgPSBhc3NpZ24kMS5zdGFydENvbnRhaW5lciwgb2Zmc2V0ID0gYXNzaWduJDEuc3RhcnRPZmZzZXQpKTsgfVxuICB9XG5cbiAgdmFyIGVsdCA9ICh2aWV3LnJvb3QuZWxlbWVudEZyb21Qb2ludCA/IHZpZXcucm9vdCA6IGRvYykuZWxlbWVudEZyb21Qb2ludChjb29yZHMubGVmdCwgY29vcmRzLnRvcCArIDEpLCBwb3M7XG4gIGlmICghZWx0IHx8ICF2aWV3LmRvbS5jb250YWlucyhlbHQubm9kZVR5cGUgIT0gMSA/IGVsdC5wYXJlbnROb2RlIDogZWx0KSkge1xuICAgIHZhciBib3ggPSB2aWV3LmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBpZiAoIWluUmVjdChjb29yZHMsIGJveCkpIHsgcmV0dXJuIG51bGwgfVxuICAgIGVsdCA9IGVsZW1lbnRGcm9tUG9pbnQodmlldy5kb20sIGNvb3JkcywgYm94KTtcbiAgICBpZiAoIWVsdCkgeyByZXR1cm4gbnVsbCB9XG4gIH1cbiAgLy8gU2FmYXJpJ3MgY2FyZXRSYW5nZUZyb21Qb2ludCByZXR1cm5zIG5vbnNlbnNlIHdoZW4gb24gYSBkcmFnZ2FibGUgZWxlbWVudFxuICBpZiAocmVzdWx0LnNhZmFyaSkge1xuICAgIGZvciAodmFyIHAgPSBlbHQ7IG5vZGUgJiYgcDsgcCA9IHBhcmVudE5vZGUocCkpXG4gICAgICB7IGlmIChwLmRyYWdnYWJsZSkgeyBub2RlID0gb2Zmc2V0ID0gbnVsbDsgfSB9XG4gIH1cbiAgZWx0ID0gdGFyZ2V0S2x1ZGdlKGVsdCwgY29vcmRzKTtcbiAgaWYgKG5vZGUpIHtcbiAgICBpZiAocmVzdWx0LmdlY2tvICYmIG5vZGUubm9kZVR5cGUgPT0gMSkge1xuICAgICAgLy8gRmlyZWZveCB3aWxsIHNvbWV0aW1lcyByZXR1cm4gb2Zmc2V0cyBpbnRvIDxpbnB1dD4gbm9kZXMsIHdoaWNoXG4gICAgICAvLyBoYXZlIG5vIGFjdHVhbCBjaGlsZHJlbiwgZnJvbSBjYXJldFBvc2l0aW9uRnJvbVBvaW50ICgjOTUzKVxuICAgICAgb2Zmc2V0ID0gTWF0aC5taW4ob2Zmc2V0LCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoKTtcbiAgICAgIC8vIEl0J2xsIGFsc28gbW92ZSB0aGUgcmV0dXJuZWQgcG9zaXRpb24gYmVmb3JlIGltYWdlIG5vZGVzLFxuICAgICAgLy8gZXZlbiBpZiB0aG9zZSBhcmUgYmVoaW5kIGl0LlxuICAgICAgaWYgKG9mZnNldCA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG5leHQgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XSwgYm94JDE7XG4gICAgICAgIGlmIChuZXh0Lm5vZGVOYW1lID09IFwiSU1HXCIgJiYgKGJveCQxID0gbmV4dC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSkucmlnaHQgPD0gY29vcmRzLmxlZnQgJiZcbiAgICAgICAgICAgIGJveCQxLmJvdHRvbSA+IGNvb3Jkcy50b3ApXG4gICAgICAgICAgeyBvZmZzZXQrKzsgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBTdXNwaWNpb3VzbHkgc3BlY2lmaWMga2x1ZGdlIHRvIHdvcmsgYXJvdW5kIGNhcmV0KkZyb21Qb2ludFxuICAgIC8vIG5ldmVyIHJldHVybmluZyBhIHBvc2l0aW9uIGF0IHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50XG4gICAgaWYgKG5vZGUgPT0gdmlldy5kb20gJiYgb2Zmc2V0ID09IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggLSAxICYmIG5vZGUubGFzdENoaWxkLm5vZGVUeXBlID09IDEgJiZcbiAgICAgICAgY29vcmRzLnRvcCA+IG5vZGUubGFzdENoaWxkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmJvdHRvbSlcbiAgICAgIHsgcG9zID0gdmlldy5zdGF0ZS5kb2MuY29udGVudC5zaXplOyB9XG4gICAgLy8gSWdub3JlIHBvc2l0aW9ucyBkaXJlY3RseSBhZnRlciBhIEJSLCBzaW5jZSBjYXJldCpGcm9tUG9pbnRcbiAgICAvLyAncm91bmQgdXAnIHBvc2l0aW9ucyB0aGF0IHdvdWxkIGJlIG1vcmUgYWNjdXJhdGVseSBwbGFjZWRcbiAgICAvLyBiZWZvcmUgdGhlIEJSIG5vZGUuXG4gICAgZWxzZSBpZiAob2Zmc2V0ID09IDAgfHwgbm9kZS5ub2RlVHlwZSAhPSAxIHx8IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXS5ub2RlTmFtZSAhPSBcIkJSXCIpXG4gICAgICB7IHBvcyA9IHBvc0Zyb21DYXJldCh2aWV3LCBub2RlLCBvZmZzZXQsIGNvb3Jkcyk7IH1cbiAgfVxuICBpZiAocG9zID09IG51bGwpIHsgcG9zID0gcG9zRnJvbUVsZW1lbnQodmlldywgZWx0LCBjb29yZHMpOyB9XG5cbiAgdmFyIGRlc2MgPSB2aWV3LmRvY1ZpZXcubmVhcmVzdERlc2MoZWx0LCB0cnVlKTtcbiAgcmV0dXJuIHtwb3M6IHBvcywgaW5zaWRlOiBkZXNjID8gZGVzYy5wb3NBdFN0YXJ0IC0gZGVzYy5ib3JkZXIgOiAtMX1cbn1cblxuZnVuY3Rpb24gc2luZ2xlUmVjdChvYmplY3QsIGJpYXMpIHtcbiAgdmFyIHJlY3RzID0gb2JqZWN0LmdldENsaWVudFJlY3RzKCk7XG4gIHJldHVybiAhcmVjdHMubGVuZ3RoID8gb2JqZWN0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDogcmVjdHNbYmlhcyA8IDAgPyAwIDogcmVjdHMubGVuZ3RoIC0gMV1cbn1cblxudmFyIEJJREkgPSAvW1xcdTA1OTAtXFx1MDVmNFxcdTA2MDAtXFx1MDZmZlxcdTA3MDAtXFx1MDhhY10vO1xuXG4vLyA6IChFZGl0b3JWaWV3LCBudW1iZXIsIG51bWJlcikg4oaSIHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyLCByaWdodDogbnVtYmVyLCBib3R0b206IG51bWJlcn1cbi8vIEdpdmVuIGEgcG9zaXRpb24gaW4gdGhlIGRvY3VtZW50IG1vZGVsLCBnZXQgYSBib3VuZGluZyBib3ggb2YgdGhlXG4vLyBjaGFyYWN0ZXIgYXQgdGhhdCBwb3NpdGlvbiwgcmVsYXRpdmUgdG8gdGhlIHdpbmRvdy5cbmZ1bmN0aW9uIGNvb3Jkc0F0UG9zKHZpZXcsIHBvcywgc2lkZSkge1xuICB2YXIgcmVmID0gdmlldy5kb2NWaWV3LmRvbUZyb21Qb3MocG9zLCBzaWRlIDwgMCA/IC0xIDogMSk7XG4gIHZhciBub2RlID0gcmVmLm5vZGU7XG4gIHZhciBvZmZzZXQgPSByZWYub2Zmc2V0O1xuXG4gIHZhciBzdXBwb3J0RW1wdHlSYW5nZSA9IHJlc3VsdC53ZWJraXQgfHwgcmVzdWx0LmdlY2tvO1xuICBpZiAobm9kZS5ub2RlVHlwZSA9PSAzKSB7XG4gICAgLy8gVGhlc2UgYnJvd3NlcnMgc3VwcG9ydCBxdWVyeWluZyBlbXB0eSB0ZXh0IHJhbmdlcy4gUHJlZmVyIHRoYXQgaW5cbiAgICAvLyBiaWRpIGNvbnRleHQgb3Igd2hlbiBhdCB0aGUgZW5kIG9mIGEgbm9kZS5cbiAgICBpZiAoc3VwcG9ydEVtcHR5UmFuZ2UgJiYgKEJJREkudGVzdChub2RlLm5vZGVWYWx1ZSkgfHwgKHNpZGUgPCAwID8gIW9mZnNldCA6IG9mZnNldCA9PSBub2RlLm5vZGVWYWx1ZS5sZW5ndGgpKSkge1xuICAgICAgdmFyIHJlY3QgPSBzaW5nbGVSZWN0KHRleHRSYW5nZShub2RlLCBvZmZzZXQsIG9mZnNldCksIHNpZGUpO1xuICAgICAgLy8gRmlyZWZveCByZXR1cm5zIGJhZCByZXN1bHRzICh0aGUgcG9zaXRpb24gYmVmb3JlIHRoZSBzcGFjZSlcbiAgICAgIC8vIHdoZW4gcXVlcnlpbmcgYSBwb3NpdGlvbiBkaXJlY3RseSBhZnRlciBsaW5lLWJyb2tlblxuICAgICAgLy8gd2hpdGVzcGFjZS4gRGV0ZWN0IHRoaXMgc2l0dWF0aW9uIGFuZCBhbmQga2x1ZGdlIGFyb3VuZCBpdFxuICAgICAgaWYgKHJlc3VsdC5nZWNrbyAmJiBvZmZzZXQgJiYgL1xccy8udGVzdChub2RlLm5vZGVWYWx1ZVtvZmZzZXQgLSAxXSkgJiYgb2Zmc2V0IDwgbm9kZS5ub2RlVmFsdWUubGVuZ3RoKSB7XG4gICAgICAgIHZhciByZWN0QmVmb3JlID0gc2luZ2xlUmVjdCh0ZXh0UmFuZ2Uobm9kZSwgb2Zmc2V0IC0gMSwgb2Zmc2V0IC0gMSksIC0xKTtcbiAgICAgICAgaWYgKHJlY3RCZWZvcmUudG9wID09IHJlY3QudG9wKSB7XG4gICAgICAgICAgdmFyIHJlY3RBZnRlciA9IHNpbmdsZVJlY3QodGV4dFJhbmdlKG5vZGUsIG9mZnNldCwgb2Zmc2V0ICsgMSksIC0xKTtcbiAgICAgICAgICBpZiAocmVjdEFmdGVyLnRvcCAhPSByZWN0LnRvcClcbiAgICAgICAgICAgIHsgcmV0dXJuIGZsYXR0ZW5WKHJlY3RBZnRlciwgcmVjdEFmdGVyLmxlZnQgPCByZWN0QmVmb3JlLmxlZnQpIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlY3RcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGZyb20gPSBvZmZzZXQsIHRvID0gb2Zmc2V0LCB0YWtlU2lkZSA9IHNpZGUgPCAwID8gMSA6IC0xO1xuICAgICAgaWYgKHNpZGUgPCAwICYmICFvZmZzZXQpIHsgdG8rKzsgdGFrZVNpZGUgPSAtMTsgfVxuICAgICAgZWxzZSBpZiAoc2lkZSA+PSAwICYmIG9mZnNldCA9PSBub2RlLm5vZGVWYWx1ZS5sZW5ndGgpIHsgZnJvbS0tOyB0YWtlU2lkZSA9IDE7IH1cbiAgICAgIGVsc2UgaWYgKHNpZGUgPCAwKSB7IGZyb20tLTsgfVxuICAgICAgZWxzZSB7IHRvICsrOyB9XG4gICAgICByZXR1cm4gZmxhdHRlblYoc2luZ2xlUmVjdCh0ZXh0UmFuZ2Uobm9kZSwgZnJvbSwgdG8pLCB0YWtlU2lkZSksIHRha2VTaWRlIDwgMClcbiAgICB9XG4gIH1cblxuICAvLyBSZXR1cm4gYSBob3Jpem9udGFsIGxpbmUgaW4gYmxvY2sgY29udGV4dFxuICBpZiAoIXZpZXcuc3RhdGUuZG9jLnJlc29sdmUocG9zKS5wYXJlbnQuaW5saW5lQ29udGVudCkge1xuICAgIGlmIChvZmZzZXQgJiYgKHNpZGUgPCAwIHx8IG9mZnNldCA9PSBub2RlU2l6ZShub2RlKSkpIHtcbiAgICAgIHZhciBiZWZvcmUgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV07XG4gICAgICBpZiAoYmVmb3JlLm5vZGVUeXBlID09IDEpIHsgcmV0dXJuIGZsYXR0ZW5IKGJlZm9yZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgZmFsc2UpIH1cbiAgICB9XG4gICAgaWYgKG9mZnNldCA8IG5vZGVTaXplKG5vZGUpKSB7XG4gICAgICB2YXIgYWZ0ZXIgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XTtcbiAgICAgIGlmIChhZnRlci5ub2RlVHlwZSA9PSAxKSB7IHJldHVybiBmbGF0dGVuSChhZnRlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgdHJ1ZSkgfVxuICAgIH1cbiAgICByZXR1cm4gZmxhdHRlbkgobm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgc2lkZSA+PSAwKVxuICB9XG5cbiAgLy8gSW5saW5lLCBub3QgaW4gdGV4dCBub2RlICh0aGlzIGlzIG5vdCBCaWRpLXNhZmUpXG4gIGlmIChvZmZzZXQgJiYgKHNpZGUgPCAwIHx8IG9mZnNldCA9PSBub2RlU2l6ZShub2RlKSkpIHtcbiAgICB2YXIgYmVmb3JlJDEgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV07XG4gICAgdmFyIHRhcmdldCA9IGJlZm9yZSQxLm5vZGVUeXBlID09IDMgPyB0ZXh0UmFuZ2UoYmVmb3JlJDEsIG5vZGVTaXplKGJlZm9yZSQxKSAtIChzdXBwb3J0RW1wdHlSYW5nZSA/IDAgOiAxKSlcbiAgICAgICAgLy8gQlIgbm9kZXMgdGVuZCB0byBvbmx5IHJldHVybiB0aGUgcmVjdGFuZ2xlIGJlZm9yZSB0aGVtLlxuICAgICAgICAvLyBPbmx5IHVzZSB0aGVtIGlmIHRoZXkgYXJlIHRoZSBsYXN0IGVsZW1lbnQgaW4gdGhlaXIgcGFyZW50XG4gICAgICAgIDogYmVmb3JlJDEubm9kZVR5cGUgPT0gMSAmJiAoYmVmb3JlJDEubm9kZU5hbWUgIT0gXCJCUlwiIHx8ICFiZWZvcmUkMS5uZXh0U2libGluZykgPyBiZWZvcmUkMSA6IG51bGw7XG4gICAgaWYgKHRhcmdldCkgeyByZXR1cm4gZmxhdHRlblYoc2luZ2xlUmVjdCh0YXJnZXQsIDEpLCBmYWxzZSkgfVxuICB9XG4gIGlmIChvZmZzZXQgPCBub2RlU2l6ZShub2RlKSkge1xuICAgIHZhciBhZnRlciQxID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgd2hpbGUgKGFmdGVyJDEucG1WaWV3RGVzYyAmJiBhZnRlciQxLnBtVmlld0Rlc2MuaWdub3JlRm9yQ29vcmRzKSB7IGFmdGVyJDEgPSBhZnRlciQxLm5leHRTaWJsaW5nOyB9XG4gICAgdmFyIHRhcmdldCQxID0gIWFmdGVyJDEgPyBudWxsIDogYWZ0ZXIkMS5ub2RlVHlwZSA9PSAzID8gdGV4dFJhbmdlKGFmdGVyJDEsIDAsIChzdXBwb3J0RW1wdHlSYW5nZSA/IDAgOiAxKSlcbiAgICAgICAgOiBhZnRlciQxLm5vZGVUeXBlID09IDEgPyBhZnRlciQxIDogbnVsbDtcbiAgICBpZiAodGFyZ2V0JDEpIHsgcmV0dXJuIGZsYXR0ZW5WKHNpbmdsZVJlY3QodGFyZ2V0JDEsIC0xKSwgdHJ1ZSkgfVxuICB9XG4gIC8vIEFsbCBlbHNlIGZhaWxlZCwganVzdCB0cnkgdG8gZ2V0IGEgcmVjdGFuZ2xlIGZvciB0aGUgdGFyZ2V0IG5vZGVcbiAgcmV0dXJuIGZsYXR0ZW5WKHNpbmdsZVJlY3Qobm9kZS5ub2RlVHlwZSA9PSAzID8gdGV4dFJhbmdlKG5vZGUpIDogbm9kZSwgLXNpZGUpLCBzaWRlID49IDApXG59XG5cbmZ1bmN0aW9uIGZsYXR0ZW5WKHJlY3QsIGxlZnQpIHtcbiAgaWYgKHJlY3Qud2lkdGggPT0gMCkgeyByZXR1cm4gcmVjdCB9XG4gIHZhciB4ID0gbGVmdCA/IHJlY3QubGVmdCA6IHJlY3QucmlnaHQ7XG4gIHJldHVybiB7dG9wOiByZWN0LnRvcCwgYm90dG9tOiByZWN0LmJvdHRvbSwgbGVmdDogeCwgcmlnaHQ6IHh9XG59XG5cbmZ1bmN0aW9uIGZsYXR0ZW5IKHJlY3QsIHRvcCkge1xuICBpZiAocmVjdC5oZWlnaHQgPT0gMCkgeyByZXR1cm4gcmVjdCB9XG4gIHZhciB5ID0gdG9wID8gcmVjdC50b3AgOiByZWN0LmJvdHRvbTtcbiAgcmV0dXJuIHt0b3A6IHksIGJvdHRvbTogeSwgbGVmdDogcmVjdC5sZWZ0LCByaWdodDogcmVjdC5yaWdodH1cbn1cblxuZnVuY3Rpb24gd2l0aEZsdXNoZWRTdGF0ZSh2aWV3LCBzdGF0ZSwgZikge1xuICB2YXIgdmlld1N0YXRlID0gdmlldy5zdGF0ZSwgYWN0aXZlID0gdmlldy5yb290LmFjdGl2ZUVsZW1lbnQ7XG4gIGlmICh2aWV3U3RhdGUgIT0gc3RhdGUpIHsgdmlldy51cGRhdGVTdGF0ZShzdGF0ZSk7IH1cbiAgaWYgKGFjdGl2ZSAhPSB2aWV3LmRvbSkgeyB2aWV3LmZvY3VzKCk7IH1cbiAgdHJ5IHtcbiAgICByZXR1cm4gZigpXG4gIH0gZmluYWxseSB7XG4gICAgaWYgKHZpZXdTdGF0ZSAhPSBzdGF0ZSkgeyB2aWV3LnVwZGF0ZVN0YXRlKHZpZXdTdGF0ZSk7IH1cbiAgICBpZiAoYWN0aXZlICE9IHZpZXcuZG9tICYmIGFjdGl2ZSkgeyBhY3RpdmUuZm9jdXMoKTsgfVxuICB9XG59XG5cbi8vIDogKEVkaXRvclZpZXcsIG51bWJlciwgbnVtYmVyKVxuLy8gV2hldGhlciB2ZXJ0aWNhbCBwb3NpdGlvbiBtb3Rpb24gaW4gYSBnaXZlbiBkaXJlY3Rpb25cbi8vIGZyb20gYSBwb3NpdGlvbiB3b3VsZCBsZWF2ZSBhIHRleHQgYmxvY2suXG5mdW5jdGlvbiBlbmRPZlRleHRibG9ja1ZlcnRpY2FsKHZpZXcsIHN0YXRlLCBkaXIpIHtcbiAgdmFyIHNlbCA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgdmFyICRwb3MgPSBkaXIgPT0gXCJ1cFwiID8gc2VsLiRmcm9tIDogc2VsLiR0bztcbiAgcmV0dXJuIHdpdGhGbHVzaGVkU3RhdGUodmlldywgc3RhdGUsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVmID0gdmlldy5kb2NWaWV3LmRvbUZyb21Qb3MoJHBvcy5wb3MsIGRpciA9PSBcInVwXCIgPyAtMSA6IDEpO1xuICAgIHZhciBkb20gPSByZWYubm9kZTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICB2YXIgbmVhcmVzdCA9IHZpZXcuZG9jVmlldy5uZWFyZXN0RGVzYyhkb20sIHRydWUpO1xuICAgICAgaWYgKCFuZWFyZXN0KSB7IGJyZWFrIH1cbiAgICAgIGlmIChuZWFyZXN0Lm5vZGUuaXNCbG9jaykgeyBkb20gPSBuZWFyZXN0LmRvbTsgYnJlYWsgfVxuICAgICAgZG9tID0gbmVhcmVzdC5kb20ucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgdmFyIGNvb3JkcyA9IGNvb3Jkc0F0UG9zKHZpZXcsICRwb3MucG9zLCAxKTtcbiAgICBmb3IgKHZhciBjaGlsZCA9IGRvbS5maXJzdENoaWxkOyBjaGlsZDsgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZykge1xuICAgICAgdmFyIGJveGVzID0gKHZvaWQgMCk7XG4gICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT0gMSkgeyBib3hlcyA9IGNoaWxkLmdldENsaWVudFJlY3RzKCk7IH1cbiAgICAgIGVsc2UgaWYgKGNoaWxkLm5vZGVUeXBlID09IDMpIHsgYm94ZXMgPSB0ZXh0UmFuZ2UoY2hpbGQsIDAsIGNoaWxkLm5vZGVWYWx1ZS5sZW5ndGgpLmdldENsaWVudFJlY3RzKCk7IH1cbiAgICAgIGVsc2UgeyBjb250aW51ZSB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJveGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBib3ggPSBib3hlc1tpXTtcbiAgICAgICAgaWYgKGJveC5ib3R0b20gPiBib3gudG9wICsgMSAmJlxuICAgICAgICAgICAgKGRpciA9PSBcInVwXCIgPyBjb29yZHMudG9wIC0gYm94LnRvcCA+IChib3guYm90dG9tIC0gY29vcmRzLnRvcCkgKiAyXG4gICAgICAgICAgICAgOiBib3guYm90dG9tIC0gY29vcmRzLmJvdHRvbSA+IChjb29yZHMuYm90dG9tIC0gYm94LnRvcCkgKiAyKSlcbiAgICAgICAgICB7IHJldHVybiBmYWxzZSB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH0pXG59XG5cbnZhciBtYXliZVJUTCA9IC9bXFx1MDU5MC1cXHUwOGFjXS87XG5cbmZ1bmN0aW9uIGVuZE9mVGV4dGJsb2NrSG9yaXpvbnRhbCh2aWV3LCBzdGF0ZSwgZGlyKSB7XG4gIHZhciByZWYgPSBzdGF0ZS5zZWxlY3Rpb247XG4gIHZhciAkaGVhZCA9IHJlZi4kaGVhZDtcbiAgaWYgKCEkaGVhZC5wYXJlbnQuaXNUZXh0YmxvY2spIHsgcmV0dXJuIGZhbHNlIH1cbiAgdmFyIG9mZnNldCA9ICRoZWFkLnBhcmVudE9mZnNldCwgYXRTdGFydCA9ICFvZmZzZXQsIGF0RW5kID0gb2Zmc2V0ID09ICRoZWFkLnBhcmVudC5jb250ZW50LnNpemU7XG4gIHZhciBzZWwgPSB2aWV3LnJvb3QuZ2V0U2VsZWN0aW9uKCk7XG4gIC8vIElmIHRoZSB0ZXh0YmxvY2sgaXMgYWxsIExUUiwgb3IgdGhlIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0XG4gIC8vIFNlbGVjdGlvbi5tb2RpZnkgKEVkZ2UpLCBmYWxsIGJhY2sgdG8gYSBwcmltaXRpdmUgYXBwcm9hY2hcbiAgaWYgKCFtYXliZVJUTC50ZXN0KCRoZWFkLnBhcmVudC50ZXh0Q29udGVudCkgfHwgIXNlbC5tb2RpZnkpXG4gICAgeyByZXR1cm4gZGlyID09IFwibGVmdFwiIHx8IGRpciA9PSBcImJhY2t3YXJkXCIgPyBhdFN0YXJ0IDogYXRFbmQgfVxuXG4gIHJldHVybiB3aXRoRmx1c2hlZFN0YXRlKHZpZXcsIHN0YXRlLCBmdW5jdGlvbiAoKSB7XG4gICAgLy8gVGhpcyBpcyBhIGh1Z2UgaGFjaywgYnV0IGFwcGVhcnMgdG8gYmUgdGhlIGJlc3Qgd2UgY2FuXG4gICAgLy8gY3VycmVudGx5IGRvOiB1c2UgYFNlbGVjdGlvbi5tb2RpZnlgIHRvIG1vdmUgdGhlIHNlbGVjdGlvbiBieVxuICAgIC8vIG9uZSBjaGFyYWN0ZXIsIGFuZCBzZWUgaWYgdGhhdCBtb3ZlcyB0aGUgY3Vyc29yIG91dCBvZiB0aGVcbiAgICAvLyB0ZXh0YmxvY2sgKG9yIGRvZXNuJ3QgbW92ZSBpdCBhdCBhbGwsIHdoZW4gYXQgdGhlIHN0YXJ0L2VuZCBvZlxuICAgIC8vIHRoZSBkb2N1bWVudCkuXG4gICAgdmFyIG9sZFJhbmdlID0gc2VsLmdldFJhbmdlQXQoMCksIG9sZE5vZGUgPSBzZWwuZm9jdXNOb2RlLCBvbGRPZmYgPSBzZWwuZm9jdXNPZmZzZXQ7XG4gICAgdmFyIG9sZEJpZGlMZXZlbCA9IHNlbC5jYXJldEJpZGlMZXZlbDsgLy8gT25seSBmb3IgRmlyZWZveFxuICAgIHNlbC5tb2RpZnkoXCJtb3ZlXCIsIGRpciwgXCJjaGFyYWN0ZXJcIik7XG4gICAgdmFyIHBhcmVudERPTSA9ICRoZWFkLmRlcHRoID8gdmlldy5kb2NWaWV3LmRvbUFmdGVyUG9zKCRoZWFkLmJlZm9yZSgpKSA6IHZpZXcuZG9tO1xuICAgIHZhciByZXN1bHQgPSAhcGFyZW50RE9NLmNvbnRhaW5zKHNlbC5mb2N1c05vZGUubm9kZVR5cGUgPT0gMSA/IHNlbC5mb2N1c05vZGUgOiBzZWwuZm9jdXNOb2RlLnBhcmVudE5vZGUpIHx8XG4gICAgICAgIChvbGROb2RlID09IHNlbC5mb2N1c05vZGUgJiYgb2xkT2ZmID09IHNlbC5mb2N1c09mZnNldCk7XG4gICAgLy8gUmVzdG9yZSB0aGUgcHJldmlvdXMgc2VsZWN0aW9uXG4gICAgc2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgIHNlbC5hZGRSYW5nZShvbGRSYW5nZSk7XG4gICAgaWYgKG9sZEJpZGlMZXZlbCAhPSBudWxsKSB7IHNlbC5jYXJldEJpZGlMZXZlbCA9IG9sZEJpZGlMZXZlbDsgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfSlcbn1cblxudmFyIGNhY2hlZFN0YXRlID0gbnVsbCwgY2FjaGVkRGlyID0gbnVsbCwgY2FjaGVkUmVzdWx0ID0gZmFsc2U7XG5mdW5jdGlvbiBlbmRPZlRleHRibG9jayh2aWV3LCBzdGF0ZSwgZGlyKSB7XG4gIGlmIChjYWNoZWRTdGF0ZSA9PSBzdGF0ZSAmJiBjYWNoZWREaXIgPT0gZGlyKSB7IHJldHVybiBjYWNoZWRSZXN1bHQgfVxuICBjYWNoZWRTdGF0ZSA9IHN0YXRlOyBjYWNoZWREaXIgPSBkaXI7XG4gIHJldHVybiBjYWNoZWRSZXN1bHQgPSBkaXIgPT0gXCJ1cFwiIHx8IGRpciA9PSBcImRvd25cIlxuICAgID8gZW5kT2ZUZXh0YmxvY2tWZXJ0aWNhbCh2aWV3LCBzdGF0ZSwgZGlyKVxuICAgIDogZW5kT2ZUZXh0YmxvY2tIb3Jpem9udGFsKHZpZXcsIHN0YXRlLCBkaXIpXG59XG5cbi8vIE5vZGVWaWV3OjogaW50ZXJmYWNlXG4vL1xuLy8gQnkgZGVmYXVsdCwgZG9jdW1lbnQgbm9kZXMgYXJlIHJlbmRlcmVkIHVzaW5nIHRoZSByZXN1bHQgb2YgdGhlXG4vLyBbYHRvRE9NYF0oI21vZGVsLk5vZGVTcGVjLnRvRE9NKSBtZXRob2Qgb2YgdGhlaXIgc3BlYywgYW5kIG1hbmFnZWRcbi8vIGVudGlyZWx5IGJ5IHRoZSBlZGl0b3IuIEZvciBzb21lIHVzZSBjYXNlcywgc3VjaCBhcyBlbWJlZGRlZFxuLy8gbm9kZS1zcGVjaWZpYyBlZGl0aW5nIGludGVyZmFjZXMsIHlvdSB3YW50IG1vcmUgY29udHJvbCBvdmVyXG4vLyB0aGUgYmVoYXZpb3Igb2YgYSBub2RlJ3MgaW4tZWRpdG9yIHJlcHJlc2VudGF0aW9uLCBhbmQgbmVlZCB0b1xuLy8gW2RlZmluZV0oI3ZpZXcuRWRpdG9yUHJvcHMubm9kZVZpZXdzKSBhIGN1c3RvbSBub2RlIHZpZXcuXG4vL1xuLy8gTWFyayB2aWV3cyBvbmx5IHN1cHBvcnQgYGRvbWAgYW5kIGBjb250ZW50RE9NYCwgYW5kIGRvbid0IHN1cHBvcnRcbi8vIGFueSBvZiB0aGUgbm9kZSB2aWV3IG1ldGhvZHMuXG4vL1xuLy8gT2JqZWN0cyByZXR1cm5lZCBhcyBub2RlIHZpZXdzIG11c3QgY29uZm9ybSB0byB0aGlzIGludGVyZmFjZS5cbi8vXG4vLyAgIGRvbTo6ID9kb20uTm9kZVxuLy8gICBUaGUgb3V0ZXIgRE9NIG5vZGUgdGhhdCByZXByZXNlbnRzIHRoZSBkb2N1bWVudCBub2RlLiBXaGVuIG5vdFxuLy8gICBnaXZlbiwgdGhlIGRlZmF1bHQgc3RyYXRlZ3kgaXMgdXNlZCB0byBjcmVhdGUgYSBET00gbm9kZS5cbi8vXG4vLyAgIGNvbnRlbnRET006OiA/ZG9tLk5vZGVcbi8vICAgVGhlIERPTSBub2RlIHRoYXQgc2hvdWxkIGhvbGQgdGhlIG5vZGUncyBjb250ZW50LiBPbmx5IG1lYW5pbmdmdWxcbi8vICAgaWYgdGhlIG5vZGUgdmlldyBhbHNvIGRlZmluZXMgYSBgZG9tYCBwcm9wZXJ0eSBhbmQgaWYgaXRzIG5vZGVcbi8vICAgdHlwZSBpcyBub3QgYSBsZWFmIG5vZGUgdHlwZS4gV2hlbiB0aGlzIGlzIHByZXNlbnQsIFByb3NlTWlycm9yXG4vLyAgIHdpbGwgdGFrZSBjYXJlIG9mIHJlbmRlcmluZyB0aGUgbm9kZSdzIGNoaWxkcmVuIGludG8gaXQuIFdoZW4gaXRcbi8vICAgaXMgbm90IHByZXNlbnQsIHRoZSBub2RlIHZpZXcgaXRzZWxmIGlzIHJlc3BvbnNpYmxlIGZvciByZW5kZXJpbmdcbi8vICAgKG9yIGRlY2lkaW5nIG5vdCB0byByZW5kZXIpIGl0cyBjaGlsZCBub2Rlcy5cbi8vXG4vLyAgIHVwZGF0ZTo6ID8obm9kZTogTm9kZSwgZGVjb3JhdGlvbnM6IFtEZWNvcmF0aW9uXSwgaW5uZXJEZWNvcmF0aW9uczogRGVjb3JhdGlvblNvdXJjZSkg4oaSIGJvb2xcbi8vICAgV2hlbiBnaXZlbiwgdGhpcyB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSB2aWV3IGlzIHVwZGF0aW5nIGl0c2VsZi5cbi8vICAgSXQgd2lsbCBiZSBnaXZlbiBhIG5vZGUgKHBvc3NpYmx5IG9mIGEgZGlmZmVyZW50IHR5cGUpLCBhbiBhcnJheVxuLy8gICBvZiBhY3RpdmUgZGVjb3JhdGlvbnMgYXJvdW5kIHRoZSBub2RlICh3aGljaCBhcmUgYXV0b21hdGljYWxseVxuLy8gICBkcmF3biwgYW5kIHRoZSBub2RlIHZpZXcgbWF5IGlnbm9yZSBpZiBpdCBpc24ndCBpbnRlcmVzdGVkIGluXG4vLyAgIHRoZW0pLCBhbmQgYSBbZGVjb3JhdGlvbiBzb3VyY2VdKCN2aWV3LkRlY29yYXRpb25Tb3VyY2UpIHRoYXRcbi8vICAgcmVwcmVzZW50cyBhbnkgZGVjb3JhdGlvbnMgdGhhdCBhcHBseSB0byB0aGUgY29udGVudCBvZiB0aGUgbm9kZVxuLy8gICAod2hpY2ggYWdhaW4gbWF5IGJlIGlnbm9yZWQpLiBJdCBzaG91bGQgcmV0dXJuIHRydWUgaWYgaXQgd2FzXG4vLyAgIGFibGUgdG8gdXBkYXRlIHRvIHRoYXQgbm9kZSwgYW5kIGZhbHNlIG90aGVyd2lzZS4gSWYgdGhlIG5vZGVcbi8vICAgdmlldyBoYXMgYSBgY29udGVudERPTWAgcHJvcGVydHkgKG9yIG5vIGBkb21gIHByb3BlcnR5KSwgdXBkYXRpbmdcbi8vICAgaXRzIGNoaWxkIG5vZGVzIHdpbGwgYmUgaGFuZGxlZCBieSBQcm9zZU1pcnJvci5cbi8vXG4vLyAgIHNlbGVjdE5vZGU6OiA/KClcbi8vICAgQ2FuIGJlIHVzZWQgdG8gb3ZlcnJpZGUgdGhlIHdheSB0aGUgbm9kZSdzIHNlbGVjdGVkIHN0YXR1cyAoYXMgYVxuLy8gICBub2RlIHNlbGVjdGlvbikgaXMgZGlzcGxheWVkLlxuLy9cbi8vICAgZGVzZWxlY3ROb2RlOjogPygpXG4vLyAgIFdoZW4gZGVmaW5pbmcgYSBgc2VsZWN0Tm9kZWAgbWV0aG9kLCB5b3Ugc2hvdWxkIGFsc28gcHJvdmlkZSBhXG4vLyAgIGBkZXNlbGVjdE5vZGVgIG1ldGhvZCB0byByZW1vdmUgdGhlIGVmZmVjdCBhZ2Fpbi5cbi8vXG4vLyAgIHNldFNlbGVjdGlvbjo6ID8oYW5jaG9yOiBudW1iZXIsIGhlYWQ6IG51bWJlciwgcm9vdDogZG9tLkRvY3VtZW50KVxuLy8gICBUaGlzIHdpbGwgYmUgY2FsbGVkIHRvIGhhbmRsZSBzZXR0aW5nIHRoZSBzZWxlY3Rpb24gaW5zaWRlIHRoZVxuLy8gICBub2RlLiBUaGUgYGFuY2hvcmAgYW5kIGBoZWFkYCBwb3NpdGlvbnMgYXJlIHJlbGF0aXZlIHRvIHRoZSBzdGFydFxuLy8gICBvZiB0aGUgbm9kZS4gQnkgZGVmYXVsdCwgYSBET00gc2VsZWN0aW9uIHdpbGwgYmUgY3JlYXRlZCBiZXR3ZWVuXG4vLyAgIHRoZSBET00gcG9zaXRpb25zIGNvcnJlc3BvbmRpbmcgdG8gdGhvc2UgcG9zaXRpb25zLCBidXQgaWYgeW91XG4vLyAgIG92ZXJyaWRlIGl0IHlvdSBjYW4gZG8gc29tZXRoaW5nIGVsc2UuXG4vL1xuLy8gICBzdG9wRXZlbnQ6OiA/KGV2ZW50OiBkb20uRXZlbnQpIOKGkiBib29sXG4vLyAgIENhbiBiZSB1c2VkIHRvIHByZXZlbnQgdGhlIGVkaXRvciB2aWV3IGZyb20gdHJ5aW5nIHRvIGhhbmRsZSBzb21lXG4vLyAgIG9yIGFsbCBET00gZXZlbnRzIHRoYXQgYnViYmxlIHVwIGZyb20gdGhlIG5vZGUgdmlldy4gRXZlbnRzIGZvclxuLy8gICB3aGljaCB0aGlzIHJldHVybnMgdHJ1ZSBhcmUgbm90IGhhbmRsZWQgYnkgdGhlIGVkaXRvci5cbi8vXG4vLyAgIGlnbm9yZU11dGF0aW9uOjogPyhkb20uTXV0YXRpb25SZWNvcmQpIOKGkiBib29sXG4vLyAgIENhbGxlZCB3aGVuIGEgRE9NXG4vLyAgIFttdXRhdGlvbl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL011dGF0aW9uT2JzZXJ2ZXIpXG4vLyAgIG9yIGEgc2VsZWN0aW9uIGNoYW5nZSBoYXBwZW5zIHdpdGhpbiB0aGUgdmlldy4gV2hlbiB0aGUgY2hhbmdlIGlzXG4vLyAgIGEgc2VsZWN0aW9uIGNoYW5nZSwgdGhlIHJlY29yZCB3aWxsIGhhdmUgYSBgdHlwZWAgcHJvcGVydHkgb2Zcbi8vICAgYFwic2VsZWN0aW9uXCJgICh3aGljaCBkb2Vzbid0IG9jY3VyIGZvciBuYXRpdmUgbXV0YXRpb24gcmVjb3JkcykuXG4vLyAgIFJldHVybiBmYWxzZSBpZiB0aGUgZWRpdG9yIHNob3VsZCByZS1yZWFkIHRoZSBzZWxlY3Rpb24gb3Jcbi8vICAgcmUtcGFyc2UgdGhlIHJhbmdlIGFyb3VuZCB0aGUgbXV0YXRpb24sIHRydWUgaWYgaXQgY2FuIHNhZmVseSBiZVxuLy8gICBpZ25vcmVkLlxuLy9cbi8vICAgZGVzdHJveTo6ID8oKVxuLy8gICBDYWxsZWQgd2hlbiB0aGUgbm9kZSB2aWV3IGlzIHJlbW92ZWQgZnJvbSB0aGUgZWRpdG9yIG9yIHRoZSB3aG9sZVxuLy8gICBlZGl0b3IgaXMgZGVzdHJveWVkLiAoTm90IGF2YWlsYWJsZSBmb3IgbWFya3MuKVxuXG4vLyBWaWV3IGRlc2NyaXB0aW9ucyBhcmUgZGF0YSBzdHJ1Y3R1cmVzIHRoYXQgZGVzY3JpYmUgdGhlIERPTSB0aGF0IGlzXG4vLyB1c2VkIHRvIHJlcHJlc2VudCB0aGUgZWRpdG9yJ3MgY29udGVudC4gVGhleSBhcmUgdXNlZCBmb3I6XG4vL1xuLy8gLSBJbmNyZW1lbnRhbCByZWRyYXdpbmcgd2hlbiB0aGUgZG9jdW1lbnQgY2hhbmdlc1xuLy9cbi8vIC0gRmlndXJpbmcgb3V0IHdoYXQgcGFydCBvZiB0aGUgZG9jdW1lbnQgYSBnaXZlbiBET00gcG9zaXRpb25cbi8vICAgY29ycmVzcG9uZHMgdG9cbi8vXG4vLyAtIFdpcmluZyBpbiBjdXN0b20gaW1wbGVtZW50YXRpb25zIG9mIHRoZSBlZGl0aW5nIGludGVyZmFjZSBmb3IgYVxuLy8gICBnaXZlbiBub2RlXG4vL1xuLy8gVGhleSBmb3JtIGEgZG91Ymx5LWxpbmtlZCBtdXRhYmxlIHRyZWUsIHN0YXJ0aW5nIGF0IGB2aWV3LmRvY1ZpZXdgLlxuXG52YXIgTk9UX0RJUlRZID0gMCwgQ0hJTERfRElSVFkgPSAxLCBDT05URU5UX0RJUlRZID0gMiwgTk9ERV9ESVJUWSA9IDM7XG5cbi8vIFN1cGVyY2xhc3MgZm9yIHRoZSB2YXJpb3VzIGtpbmRzIG9mIGRlc2NyaXB0aW9ucy4gRGVmaW5lcyB0aGVpclxuLy8gYmFzaWMgc3RydWN0dXJlIGFuZCBzaGFyZWQgbWV0aG9kcy5cbnZhciBWaWV3RGVzYyA9IGZ1bmN0aW9uIFZpZXdEZXNjKHBhcmVudCwgY2hpbGRyZW4sIGRvbSwgY29udGVudERPTSkge1xuICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB0aGlzLmRvbSA9IGRvbTtcbiAgLy8gQW4gZXhwYW5kbyBwcm9wZXJ0eSBvbiB0aGUgRE9NIG5vZGUgcHJvdmlkZXMgYSBsaW5rIGJhY2sgdG8gaXRzXG4gIC8vIGRlc2NyaXB0aW9uLlxuICBkb20ucG1WaWV3RGVzYyA9IHRoaXM7XG4gIC8vIFRoaXMgaXMgdGhlIG5vZGUgdGhhdCBob2xkcyB0aGUgY2hpbGQgdmlld3MuIEl0IG1heSBiZSBudWxsIGZvclxuICAvLyBkZXNjcyB0aGF0IGRvbid0IGhhdmUgY2hpbGRyZW4uXG4gIHRoaXMuY29udGVudERPTSA9IGNvbnRlbnRET007XG4gIHRoaXMuZGlydHkgPSBOT1RfRElSVFk7XG59O1xuXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBzaXplOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGJvcmRlcjogeyBjb25maWd1cmFibGU6IHRydWUgfSxwb3NCZWZvcmU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0scG9zQXRTdGFydDogeyBjb25maWd1cmFibGU6IHRydWUgfSxwb3NBZnRlcjogeyBjb25maWd1cmFibGU6IHRydWUgfSxwb3NBdEVuZDogeyBjb25maWd1cmFibGU6IHRydWUgfSxjb250ZW50TG9zdDogeyBjb25maWd1cmFibGU6IHRydWUgfSxkb21BdG9tOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGlnbm9yZUZvckNvb3JkczogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG4vLyBVc2VkIHRvIGNoZWNrIHdoZXRoZXIgYSBnaXZlbiBkZXNjcmlwdGlvbiBjb3JyZXNwb25kcyB0byBhXG4vLyB3aWRnZXQvbWFyay9ub2RlLlxuVmlld0Rlc2MucHJvdG90eXBlLm1hdGNoZXNXaWRnZXQgPSBmdW5jdGlvbiBtYXRjaGVzV2lkZ2V0ICgpIHsgcmV0dXJuIGZhbHNlIH07XG5WaWV3RGVzYy5wcm90b3R5cGUubWF0Y2hlc01hcmsgPSBmdW5jdGlvbiBtYXRjaGVzTWFyayAoKSB7IHJldHVybiBmYWxzZSB9O1xuVmlld0Rlc2MucHJvdG90eXBlLm1hdGNoZXNOb2RlID0gZnVuY3Rpb24gbWF0Y2hlc05vZGUgKCkgeyByZXR1cm4gZmFsc2UgfTtcblZpZXdEZXNjLnByb3RvdHlwZS5tYXRjaGVzSGFjayA9IGZ1bmN0aW9uIG1hdGNoZXNIYWNrIChfbm9kZU5hbWUpIHsgcmV0dXJuIGZhbHNlIH07XG5cbi8vIDogKCkg4oaSID9QYXJzZVJ1bGVcbi8vIFdoZW4gcGFyc2luZyBpbi1lZGl0b3IgY29udGVudCAoaW4gZG9tY2hhbmdlLmpzKSwgd2UgYWxsb3dcbi8vIGRlc2NyaXB0aW9ucyB0byBkZXRlcm1pbmUgdGhlIHBhcnNlIHJ1bGVzIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG9cbi8vIHBhcnNlIHRoZW0uXG5WaWV3RGVzYy5wcm90b3R5cGUucGFyc2VSdWxlID0gZnVuY3Rpb24gcGFyc2VSdWxlICgpIHsgcmV0dXJuIG51bGwgfTtcblxuLy8gOiAoZG9tLkV2ZW50KSDihpIgYm9vbFxuLy8gVXNlZCBieSB0aGUgZWRpdG9yJ3MgZXZlbnQgaGFuZGxlciB0byBpZ25vcmUgZXZlbnRzIHRoYXQgY29tZVxuLy8gZnJvbSBjZXJ0YWluIGRlc2NzLlxuVmlld0Rlc2MucHJvdG90eXBlLnN0b3BFdmVudCA9IGZ1bmN0aW9uIHN0b3BFdmVudCAoKSB7IHJldHVybiBmYWxzZSB9O1xuXG4vLyBUaGUgc2l6ZSBvZiB0aGUgY29udGVudCByZXByZXNlbnRlZCBieSB0aGlzIGRlc2MuXG5wcm90b3R5cGVBY2Nlc3NvcnMuc2l6ZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzaXplID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7IHNpemUgKz0gdGhpcy5jaGlsZHJlbltpXS5zaXplOyB9XG4gIHJldHVybiBzaXplXG59O1xuXG4vLyBGb3IgYmxvY2sgbm9kZXMsIHRoaXMgcmVwcmVzZW50cyB0aGUgc3BhY2UgdGFrZW4gdXAgYnkgdGhlaXJcbi8vIHN0YXJ0L2VuZCB0b2tlbnMuXG5wcm90b3R5cGVBY2Nlc3NvcnMuYm9yZGVyLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDAgfTtcblxuVmlld0Rlc2MucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95ICgpIHtcbiAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICBpZiAodGhpcy5kb20ucG1WaWV3RGVzYyA9PSB0aGlzKSB7IHRoaXMuZG9tLnBtVmlld0Rlc2MgPSBudWxsOyB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKylcbiAgICB7IHRoaXMuY2hpbGRyZW5baV0uZGVzdHJveSgpOyB9XG59O1xuXG5WaWV3RGVzYy5wcm90b3R5cGUucG9zQmVmb3JlQ2hpbGQgPSBmdW5jdGlvbiBwb3NCZWZvcmVDaGlsZCAoY2hpbGQpIHtcbiAgZm9yICh2YXIgaSA9IDAsIHBvcyA9IHRoaXMucG9zQXRTdGFydDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY3VyID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICBpZiAoY3VyID09IGNoaWxkKSB7IHJldHVybiBwb3MgfVxuICAgIHBvcyArPSBjdXIuc2l6ZTtcbiAgfVxufTtcblxucHJvdG90eXBlQWNjZXNzb3JzLnBvc0JlZm9yZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnBhcmVudC5wb3NCZWZvcmVDaGlsZCh0aGlzKVxufTtcblxucHJvdG90eXBlQWNjZXNzb3JzLnBvc0F0U3RhcnQuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC5wb3NCZWZvcmVDaGlsZCh0aGlzKSArIHRoaXMuYm9yZGVyIDogMFxufTtcblxucHJvdG90eXBlQWNjZXNzb3JzLnBvc0FmdGVyLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucG9zQmVmb3JlICsgdGhpcy5zaXplXG59O1xuXG5wcm90b3R5cGVBY2Nlc3NvcnMucG9zQXRFbmQuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5wb3NBdFN0YXJ0ICsgdGhpcy5zaXplIC0gMiAqIHRoaXMuYm9yZGVyXG59O1xuXG4vLyA6IChkb20uTm9kZSwgbnVtYmVyLCA/bnVtYmVyKSDihpIgbnVtYmVyXG5WaWV3RGVzYy5wcm90b3R5cGUubG9jYWxQb3NGcm9tRE9NID0gZnVuY3Rpb24gbG9jYWxQb3NGcm9tRE9NIChkb20sIG9mZnNldCwgYmlhcykge1xuICAvLyBJZiB0aGUgRE9NIHBvc2l0aW9uIGlzIGluIHRoZSBjb250ZW50LCB1c2UgdGhlIGNoaWxkIGRlc2MgYWZ0ZXJcbiAgLy8gaXQgdG8gZmlndXJlIG91dCBhIHBvc2l0aW9uLlxuICBpZiAodGhpcy5jb250ZW50RE9NICYmIHRoaXMuY29udGVudERPTS5jb250YWlucyhkb20ubm9kZVR5cGUgPT0gMSA/IGRvbSA6IGRvbS5wYXJlbnROb2RlKSkge1xuICAgIGlmIChiaWFzIDwgMCkge1xuICAgICAgdmFyIGRvbUJlZm9yZSwgZGVzYztcbiAgICAgIGlmIChkb20gPT0gdGhpcy5jb250ZW50RE9NKSB7XG4gICAgICAgIGRvbUJlZm9yZSA9IGRvbS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2hpbGUgKGRvbS5wYXJlbnROb2RlICE9IHRoaXMuY29udGVudERPTSkgeyBkb20gPSBkb20ucGFyZW50Tm9kZTsgfVxuICAgICAgICBkb21CZWZvcmUgPSBkb20ucHJldmlvdXNTaWJsaW5nO1xuICAgICAgfVxuICAgICAgd2hpbGUgKGRvbUJlZm9yZSAmJiAhKChkZXNjID0gZG9tQmVmb3JlLnBtVmlld0Rlc2MpICYmIGRlc2MucGFyZW50ID09IHRoaXMpKSB7IGRvbUJlZm9yZSA9IGRvbUJlZm9yZS5wcmV2aW91c1NpYmxpbmc7IH1cbiAgICAgIHJldHVybiBkb21CZWZvcmUgPyB0aGlzLnBvc0JlZm9yZUNoaWxkKGRlc2MpICsgZGVzYy5zaXplIDogdGhpcy5wb3NBdFN0YXJ0XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkb21BZnRlciwgZGVzYyQxO1xuICAgICAgaWYgKGRvbSA9PSB0aGlzLmNvbnRlbnRET00pIHtcbiAgICAgICAgZG9tQWZ0ZXIgPSBkb20uY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2hpbGUgKGRvbS5wYXJlbnROb2RlICE9IHRoaXMuY29udGVudERPTSkgeyBkb20gPSBkb20ucGFyZW50Tm9kZTsgfVxuICAgICAgICBkb21BZnRlciA9IGRvbS5uZXh0U2libGluZztcbiAgICAgIH1cbiAgICAgIHdoaWxlIChkb21BZnRlciAmJiAhKChkZXNjJDEgPSBkb21BZnRlci5wbVZpZXdEZXNjKSAmJiBkZXNjJDEucGFyZW50ID09IHRoaXMpKSB7IGRvbUFmdGVyID0gZG9tQWZ0ZXIubmV4dFNpYmxpbmc7IH1cbiAgICAgIHJldHVybiBkb21BZnRlciA/IHRoaXMucG9zQmVmb3JlQ2hpbGQoZGVzYyQxKSA6IHRoaXMucG9zQXRFbmRcbiAgICB9XG4gIH1cbiAgLy8gT3RoZXJ3aXNlLCB1c2UgdmFyaW91cyBoZXVyaXN0aWNzLCBmYWxsaW5nIGJhY2sgb24gdGhlIGJpYXNcbiAgLy8gcGFyYW1ldGVyLCB0byBkZXRlcm1pbmUgd2hldGhlciB0byByZXR1cm4gdGhlIHBvc2l0aW9uIGF0IHRoZVxuICAvLyBzdGFydCBvciBhdCB0aGUgZW5kIG9mIHRoaXMgdmlldyBkZXNjLlxuICB2YXIgYXRFbmQ7XG4gIGlmIChkb20gPT0gdGhpcy5kb20gJiYgdGhpcy5jb250ZW50RE9NKSB7XG4gICAgYXRFbmQgPSBvZmZzZXQgPiBkb21JbmRleCh0aGlzLmNvbnRlbnRET00pO1xuICB9IGVsc2UgaWYgKHRoaXMuY29udGVudERPTSAmJiB0aGlzLmNvbnRlbnRET00gIT0gdGhpcy5kb20gJiYgdGhpcy5kb20uY29udGFpbnModGhpcy5jb250ZW50RE9NKSkge1xuICAgIGF0RW5kID0gZG9tLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKHRoaXMuY29udGVudERPTSkgJiAyO1xuICB9IGVsc2UgaWYgKHRoaXMuZG9tLmZpcnN0Q2hpbGQpIHtcbiAgICBpZiAob2Zmc2V0ID09IDApIHsgZm9yICh2YXIgc2VhcmNoID0gZG9tOzsgc2VhcmNoID0gc2VhcmNoLnBhcmVudE5vZGUpIHtcbiAgICAgIGlmIChzZWFyY2ggPT0gdGhpcy5kb20pIHsgYXRFbmQgPSBmYWxzZTsgYnJlYWsgfVxuICAgICAgaWYgKHNlYXJjaC5wYXJlbnROb2RlLmZpcnN0Q2hpbGQgIT0gc2VhcmNoKSB7IGJyZWFrIH1cbiAgICB9IH1cbiAgICBpZiAoYXRFbmQgPT0gbnVsbCAmJiBvZmZzZXQgPT0gZG9tLmNoaWxkTm9kZXMubGVuZ3RoKSB7IGZvciAodmFyIHNlYXJjaCQxID0gZG9tOzsgc2VhcmNoJDEgPSBzZWFyY2gkMS5wYXJlbnROb2RlKSB7XG4gICAgICBpZiAoc2VhcmNoJDEgPT0gdGhpcy5kb20pIHsgYXRFbmQgPSB0cnVlOyBicmVhayB9XG4gICAgICBpZiAoc2VhcmNoJDEucGFyZW50Tm9kZS5sYXN0Q2hpbGQgIT0gc2VhcmNoJDEpIHsgYnJlYWsgfVxuICAgIH0gfVxuICB9XG4gIHJldHVybiAoYXRFbmQgPT0gbnVsbCA/IGJpYXMgPiAwIDogYXRFbmQpID8gdGhpcy5wb3NBdEVuZCA6IHRoaXMucG9zQXRTdGFydFxufTtcblxuLy8gU2NhbiB1cCB0aGUgZG9tIGZpbmRpbmcgdGhlIGZpcnN0IGRlc2MgdGhhdCBpcyBhIGRlc2NlbmRhbnQgb2Zcbi8vIHRoaXMgb25lLlxuVmlld0Rlc2MucHJvdG90eXBlLm5lYXJlc3REZXNjID0gZnVuY3Rpb24gbmVhcmVzdERlc2MgKGRvbSwgb25seU5vZGVzKSB7XG4gIGZvciAodmFyIGZpcnN0ID0gdHJ1ZSwgY3VyID0gZG9tOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlKSB7XG4gICAgdmFyIGRlc2MgPSB0aGlzLmdldERlc2MoY3VyKTtcbiAgICBpZiAoZGVzYyAmJiAoIW9ubHlOb2RlcyB8fCBkZXNjLm5vZGUpKSB7XG4gICAgICAvLyBJZiBkb20gaXMgb3V0c2lkZSBvZiB0aGlzIGRlc2MncyBub2RlRE9NLCBkb24ndCBjb3VudCBpdC5cbiAgICAgIGlmIChmaXJzdCAmJiBkZXNjLm5vZGVET00gJiZcbiAgICAgICAgICAhKGRlc2Mubm9kZURPTS5ub2RlVHlwZSA9PSAxID8gZGVzYy5ub2RlRE9NLmNvbnRhaW5zKGRvbS5ub2RlVHlwZSA9PSAxID8gZG9tIDogZG9tLnBhcmVudE5vZGUpIDogZGVzYy5ub2RlRE9NID09IGRvbSkpXG4gICAgICAgIHsgZmlyc3QgPSBmYWxzZTsgfVxuICAgICAgZWxzZVxuICAgICAgICB7IHJldHVybiBkZXNjIH1cbiAgICB9XG4gIH1cbn07XG5cblZpZXdEZXNjLnByb3RvdHlwZS5nZXREZXNjID0gZnVuY3Rpb24gZ2V0RGVzYyAoZG9tKSB7XG4gIHZhciBkZXNjID0gZG9tLnBtVmlld0Rlc2M7XG4gIGZvciAodmFyIGN1ciA9IGRlc2M7IGN1cjsgY3VyID0gY3VyLnBhcmVudCkgeyBpZiAoY3VyID09IHRoaXMpIHsgcmV0dXJuIGRlc2MgfSB9XG59O1xuXG5WaWV3RGVzYy5wcm90b3R5cGUucG9zRnJvbURPTSA9IGZ1bmN0aW9uIHBvc0Zyb21ET00gKGRvbSwgb2Zmc2V0LCBiaWFzKSB7XG4gIGZvciAodmFyIHNjYW4gPSBkb207IHNjYW47IHNjYW4gPSBzY2FuLnBhcmVudE5vZGUpIHtcbiAgICB2YXIgZGVzYyA9IHRoaXMuZ2V0RGVzYyhzY2FuKTtcbiAgICBpZiAoZGVzYykgeyByZXR1cm4gZGVzYy5sb2NhbFBvc0Zyb21ET00oZG9tLCBvZmZzZXQsIGJpYXMpIH1cbiAgfVxuICByZXR1cm4gLTFcbn07XG5cbi8vIDogKG51bWJlcikg4oaSID9Ob2RlVmlld0Rlc2Ncbi8vIEZpbmQgdGhlIGRlc2MgZm9yIHRoZSBub2RlIGFmdGVyIHRoZSBnaXZlbiBwb3MsIGlmIGFueS4gKFdoZW4gYVxuLy8gcGFyZW50IG5vZGUgb3ZlcnJvZGUgcmVuZGVyaW5nLCB0aGVyZSBtaWdodCBub3QgYmUgb25lLilcblZpZXdEZXNjLnByb3RvdHlwZS5kZXNjQXQgPSBmdW5jdGlvbiBkZXNjQXQgKHBvcykge1xuICBmb3IgKHZhciBpID0gMCwgb2Zmc2V0ID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBvZmZzZXQgKyBjaGlsZC5zaXplO1xuICAgIGlmIChvZmZzZXQgPT0gcG9zICYmIGVuZCAhPSBvZmZzZXQpIHtcbiAgICAgIHdoaWxlICghY2hpbGQuYm9yZGVyICYmIGNoaWxkLmNoaWxkcmVuLmxlbmd0aCkgeyBjaGlsZCA9IGNoaWxkLmNoaWxkcmVuWzBdOyB9XG4gICAgICByZXR1cm4gY2hpbGRcbiAgICB9XG4gICAgaWYgKHBvcyA8IGVuZCkgeyByZXR1cm4gY2hpbGQuZGVzY0F0KHBvcyAtIG9mZnNldCAtIGNoaWxkLmJvcmRlcikgfVxuICAgIG9mZnNldCA9IGVuZDtcbiAgfVxufTtcblxuLy8gOiAobnVtYmVyLCBudW1iZXIpIOKGkiB7bm9kZTogZG9tLk5vZGUsIG9mZnNldDogbnVtYmVyfVxuVmlld0Rlc2MucHJvdG90eXBlLmRvbUZyb21Qb3MgPSBmdW5jdGlvbiBkb21Gcm9tUG9zIChwb3MsIHNpZGUpIHtcbiAgaWYgKCF0aGlzLmNvbnRlbnRET00pIHsgcmV0dXJuIHtub2RlOiB0aGlzLmRvbSwgb2Zmc2V0OiAwfSB9XG4gIC8vIEZpcnN0IGZpbmQgdGhlIHBvc2l0aW9uIGluIHRoZSBjaGlsZCBhcnJheVxuICB2YXIgaSA9IDAsIG9mZnNldCA9IDA7XG4gIGZvciAodmFyIGN1clBvcyA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgZW5kID0gY3VyUG9zICsgY2hpbGQuc2l6ZTtcbiAgICBpZiAoZW5kID4gcG9zIHx8IGNoaWxkIGluc3RhbmNlb2YgVHJhaWxpbmdIYWNrVmlld0Rlc2MpIHsgb2Zmc2V0ID0gcG9zIC0gY3VyUG9zOyBicmVhayB9XG4gICAgY3VyUG9zID0gZW5kO1xuICB9XG4gIC8vIElmIHRoaXMgcG9pbnRzIGludG8gdGhlIG1pZGRsZSBvZiBhIGNoaWxkLCBjYWxsIHRocm91Z2hcbiAgaWYgKG9mZnNldCkgeyByZXR1cm4gdGhpcy5jaGlsZHJlbltpXS5kb21Gcm9tUG9zKG9mZnNldCAtIHRoaXMuY2hpbGRyZW5baV0uYm9yZGVyLCBzaWRlKSB9XG4gIC8vIEdvIGJhY2sgaWYgdGhlcmUgd2VyZSBhbnkgemVyby1sZW5ndGggd2lkZ2V0cyB3aXRoIHNpZGUgPj0gMCBiZWZvcmUgdGhpcyBwb2ludFxuICBmb3IgKHZhciBwcmV2ID0gKHZvaWQgMCk7IGkgJiYgIShwcmV2ID0gdGhpcy5jaGlsZHJlbltpIC0gMV0pLnNpemUgJiYgcHJldiBpbnN0YW5jZW9mIFdpZGdldFZpZXdEZXNjICYmIHByZXYud2lkZ2V0LnR5cGUuc2lkZSA+PSAwOyBpLS0pIHt9XG4gIC8vIFNjYW4gdG93YXJkcyB0aGUgZmlyc3QgdXNlYWJsZSBub2RlXG4gIGlmIChzaWRlIDw9IDApIHtcbiAgICB2YXIgcHJldiQxLCBlbnRlciA9IHRydWU7XG4gICAgZm9yICg7OyBpLS0sIGVudGVyID0gZmFsc2UpIHtcbiAgICAgIHByZXYkMSA9IGkgPyB0aGlzLmNoaWxkcmVuW2kgLSAxXSA6IG51bGw7XG4gICAgICBpZiAoIXByZXYkMSB8fCBwcmV2JDEuZG9tLnBhcmVudE5vZGUgPT0gdGhpcy5jb250ZW50RE9NKSB7IGJyZWFrIH1cbiAgICB9XG4gICAgaWYgKHByZXYkMSAmJiBzaWRlICYmIGVudGVyICYmICFwcmV2JDEuYm9yZGVyICYmICFwcmV2JDEuZG9tQXRvbSkgeyByZXR1cm4gcHJldiQxLmRvbUZyb21Qb3MocHJldiQxLnNpemUsIHNpZGUpIH1cbiAgICByZXR1cm4ge25vZGU6IHRoaXMuY29udGVudERPTSwgb2Zmc2V0OiBwcmV2JDEgPyBkb21JbmRleChwcmV2JDEuZG9tKSArIDEgOiAwfVxuICB9IGVsc2Uge1xuICAgIHZhciBuZXh0LCBlbnRlciQxID0gdHJ1ZTtcbiAgICBmb3IgKDs7IGkrKywgZW50ZXIkMSA9IGZhbHNlKSB7XG4gICAgICBuZXh0ID0gaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoID8gdGhpcy5jaGlsZHJlbltpXSA6IG51bGw7XG4gICAgICBpZiAoIW5leHQgfHwgbmV4dC5kb20ucGFyZW50Tm9kZSA9PSB0aGlzLmNvbnRlbnRET00pIHsgYnJlYWsgfVxuICAgIH1cbiAgICBpZiAobmV4dCAmJiBlbnRlciQxICYmICFuZXh0LmJvcmRlciAmJiAhbmV4dC5kb21BdG9tKSB7IHJldHVybiBuZXh0LmRvbUZyb21Qb3MoMCwgc2lkZSkgfVxuICAgIHJldHVybiB7bm9kZTogdGhpcy5jb250ZW50RE9NLCBvZmZzZXQ6IG5leHQgPyBkb21JbmRleChuZXh0LmRvbSkgOiB0aGlzLmNvbnRlbnRET00uY2hpbGROb2Rlcy5sZW5ndGh9XG4gIH1cbn07XG5cbi8vIFVzZWQgdG8gZmluZCBhIERPTSByYW5nZSBpbiBhIHNpbmdsZSBwYXJlbnQgZm9yIGEgZ2l2ZW4gY2hhbmdlZFxuLy8gcmFuZ2UuXG5WaWV3RGVzYy5wcm90b3R5cGUucGFyc2VSYW5nZSA9IGZ1bmN0aW9uIHBhcnNlUmFuZ2UgKGZyb20sIHRvLCBiYXNlKSB7XG4gICAgaWYgKCBiYXNlID09PSB2b2lkIDAgKSBiYXNlID0gMDtcblxuICBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGggPT0gMClcbiAgICB7IHJldHVybiB7bm9kZTogdGhpcy5jb250ZW50RE9NLCBmcm9tOiBmcm9tLCB0bzogdG8sIGZyb21PZmZzZXQ6IDAsIHRvT2Zmc2V0OiB0aGlzLmNvbnRlbnRET00uY2hpbGROb2Rlcy5sZW5ndGh9IH1cblxuICB2YXIgZnJvbU9mZnNldCA9IC0xLCB0b09mZnNldCA9IC0xO1xuICBmb3IgKHZhciBvZmZzZXQgPSBiYXNlLCBpID0gMDs7IGkrKykge1xuICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IG9mZnNldCArIGNoaWxkLnNpemU7XG4gICAgaWYgKGZyb21PZmZzZXQgPT0gLTEgJiYgZnJvbSA8PSBlbmQpIHtcbiAgICAgIHZhciBjaGlsZEJhc2UgPSBvZmZzZXQgKyBjaGlsZC5ib3JkZXI7XG4gICAgICAvLyBGSVhNRSBtYXliZSBkZXNjZW5kIG1hcmsgdmlld3MgdG8gcGFyc2UgYSBuYXJyb3dlciByYW5nZT9cbiAgICAgIGlmIChmcm9tID49IGNoaWxkQmFzZSAmJiB0byA8PSBlbmQgLSBjaGlsZC5ib3JkZXIgJiYgY2hpbGQubm9kZSAmJlxuICAgICAgICAgIGNoaWxkLmNvbnRlbnRET00gJiYgdGhpcy5jb250ZW50RE9NLmNvbnRhaW5zKGNoaWxkLmNvbnRlbnRET00pKVxuICAgICAgICB7IHJldHVybiBjaGlsZC5wYXJzZVJhbmdlKGZyb20sIHRvLCBjaGlsZEJhc2UpIH1cblxuICAgICAgZnJvbSA9IG9mZnNldDtcbiAgICAgIGZvciAodmFyIGogPSBpOyBqID4gMDsgai0tKSB7XG4gICAgICAgIHZhciBwcmV2ID0gdGhpcy5jaGlsZHJlbltqIC0gMV07XG4gICAgICAgIGlmIChwcmV2LnNpemUgJiYgcHJldi5kb20ucGFyZW50Tm9kZSA9PSB0aGlzLmNvbnRlbnRET00gJiYgIXByZXYuZW1wdHlDaGlsZEF0KDEpKSB7XG4gICAgICAgICAgZnJvbU9mZnNldCA9IGRvbUluZGV4KHByZXYuZG9tKSArIDE7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBmcm9tIC09IHByZXYuc2l6ZTtcbiAgICAgIH1cbiAgICAgIGlmIChmcm9tT2Zmc2V0ID09IC0xKSB7IGZyb21PZmZzZXQgPSAwOyB9XG4gICAgfVxuICAgIGlmIChmcm9tT2Zmc2V0ID4gLTEgJiYgKGVuZCA+IHRvIHx8IGkgPT0gdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxKSkge1xuICAgICAgdG8gPSBlbmQ7XG4gICAgICBmb3IgKHZhciBqJDEgPSBpICsgMTsgaiQxIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGokMSsrKSB7XG4gICAgICAgIHZhciBuZXh0ID0gdGhpcy5jaGlsZHJlbltqJDFdO1xuICAgICAgICBpZiAobmV4dC5zaXplICYmIG5leHQuZG9tLnBhcmVudE5vZGUgPT0gdGhpcy5jb250ZW50RE9NICYmICFuZXh0LmVtcHR5Q2hpbGRBdCgtMSkpIHtcbiAgICAgICAgICB0b09mZnNldCA9IGRvbUluZGV4KG5leHQuZG9tKTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIHRvICs9IG5leHQuc2l6ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0b09mZnNldCA9PSAtMSkgeyB0b09mZnNldCA9IHRoaXMuY29udGVudERPTS5jaGlsZE5vZGVzLmxlbmd0aDsgfVxuICAgICAgYnJlYWtcbiAgICB9XG4gICAgb2Zmc2V0ID0gZW5kO1xuICB9XG4gIHJldHVybiB7bm9kZTogdGhpcy5jb250ZW50RE9NLCBmcm9tOiBmcm9tLCB0bzogdG8sIGZyb21PZmZzZXQ6IGZyb21PZmZzZXQsIHRvT2Zmc2V0OiB0b09mZnNldH1cbn07XG5cblZpZXdEZXNjLnByb3RvdHlwZS5lbXB0eUNoaWxkQXQgPSBmdW5jdGlvbiBlbXB0eUNoaWxkQXQgKHNpZGUpIHtcbiAgaWYgKHRoaXMuYm9yZGVyIHx8ICF0aGlzLmNvbnRlbnRET00gfHwgIXRoaXMuY2hpbGRyZW4ubGVuZ3RoKSB7IHJldHVybiBmYWxzZSB9XG4gIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5bc2lkZSA8IDAgPyAwIDogdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIGNoaWxkLnNpemUgPT0gMCB8fCBjaGlsZC5lbXB0eUNoaWxkQXQoc2lkZSlcbn07XG5cbi8vIDogKG51bWJlcikg4oaSIGRvbS5Ob2RlXG5WaWV3RGVzYy5wcm90b3R5cGUuZG9tQWZ0ZXJQb3MgPSBmdW5jdGlvbiBkb21BZnRlclBvcyAocG9zKSB7XG4gIHZhciByZWYgPSB0aGlzLmRvbUZyb21Qb3MocG9zLCAwKTtcbiAgICB2YXIgbm9kZSA9IHJlZi5ub2RlO1xuICAgIHZhciBvZmZzZXQgPSByZWYub2Zmc2V0O1xuICBpZiAobm9kZS5ub2RlVHlwZSAhPSAxIHx8IG9mZnNldCA9PSBub2RlLmNoaWxkTm9kZXMubGVuZ3RoKVxuICAgIHsgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJObyBub2RlIGFmdGVyIHBvcyBcIiArIHBvcykgfVxuICByZXR1cm4gbm9kZS5jaGlsZE5vZGVzW29mZnNldF1cbn07XG5cbi8vIDogKG51bWJlciwgbnVtYmVyLCBkb20uRG9jdW1lbnQpXG4vLyBWaWV3IGRlc2NzIGFyZSByZXNwb25zaWJsZSBmb3Igc2V0dGluZyBhbnkgc2VsZWN0aW9uIHRoYXQgZmFsbHNcbi8vIGVudGlyZWx5IGluc2lkZSBvZiB0aGVtLCBzbyB0aGF0IGN1c3RvbSBpbXBsZW1lbnRhdGlvbnMgY2FuIGRvXG4vLyBjdXN0b20gdGhpbmdzIHdpdGggdGhlIHNlbGVjdGlvbi4gTm90ZSB0aGF0IHRoaXMgZmFsbHMgYXBhcnQgd2hlblxuLy8gYSBzZWxlY3Rpb24gc3RhcnRzIGluIHN1Y2ggYSBub2RlIGFuZCBlbmRzIGluIGFub3RoZXIsIGluIHdoaWNoXG4vLyBjYXNlIHdlIGp1c3QgdXNlIHdoYXRldmVyIGRvbUZyb21Qb3MgcHJvZHVjZXMgYXMgYSBiZXN0IGVmZm9ydC5cblZpZXdEZXNjLnByb3RvdHlwZS5zZXRTZWxlY3Rpb24gPSBmdW5jdGlvbiBzZXRTZWxlY3Rpb24gKGFuY2hvciwgaGVhZCwgcm9vdCwgZm9yY2UpIHtcbiAgLy8gSWYgdGhlIHNlbGVjdGlvbiBmYWxscyBlbnRpcmVseSBpbiBhIGNoaWxkLCBnaXZlIGl0IHRvIHRoYXQgY2hpbGRcbiAgdmFyIGZyb20gPSBNYXRoLm1pbihhbmNob3IsIGhlYWQpLCB0byA9IE1hdGgubWF4KGFuY2hvciwgaGVhZCk7XG4gIGZvciAodmFyIGkgPSAwLCBvZmZzZXQgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IG9mZnNldCArIGNoaWxkLnNpemU7XG4gICAgaWYgKGZyb20gPiBvZmZzZXQgJiYgdG8gPCBlbmQpXG4gICAgICB7IHJldHVybiBjaGlsZC5zZXRTZWxlY3Rpb24oYW5jaG9yIC0gb2Zmc2V0IC0gY2hpbGQuYm9yZGVyLCBoZWFkIC0gb2Zmc2V0IC0gY2hpbGQuYm9yZGVyLCByb290LCBmb3JjZSkgfVxuICAgIG9mZnNldCA9IGVuZDtcbiAgfVxuXG4gIHZhciBhbmNob3JET00gPSB0aGlzLmRvbUZyb21Qb3MoYW5jaG9yLCBhbmNob3IgPyAtMSA6IDEpO1xuICB2YXIgaGVhZERPTSA9IGhlYWQgPT0gYW5jaG9yID8gYW5jaG9yRE9NIDogdGhpcy5kb21Gcm9tUG9zKGhlYWQsIGhlYWQgPyAtMSA6IDEpO1xuICB2YXIgZG9tU2VsID0gcm9vdC5nZXRTZWxlY3Rpb24oKTtcblxuICB2YXIgYnJLbHVkZ2UgPSBmYWxzZTtcbiAgLy8gT24gRmlyZWZveCwgdXNpbmcgU2VsZWN0aW9uLmNvbGxhcHNlIHRvIHB1dCB0aGUgY3Vyc29yIGFmdGVyIGFcbiAgLy8gQlIgbm9kZSBmb3Igc29tZSByZWFzb24gZG9lc24ndCBhbHdheXMgd29yayAoIzEwNzMpLiBPbiBTYWZhcmksXG4gIC8vIHRoZSBjdXJzb3Igc29tZXRpbWVzIGluZXhwbGljYWJsZSB2aXN1YWxseSBsYWdzIGJlaGluZCBpdHNcbiAgLy8gcmVwb3J0ZWQgcG9zaXRpb24gaW4gc3VjaCBzaXR1YXRpb25zICgjMTA5MikuXG4gIGlmICgocmVzdWx0LmdlY2tvIHx8IHJlc3VsdC5zYWZhcmkpICYmIGFuY2hvciA9PSBoZWFkKSB7XG4gICAgdmFyIG5vZGUgPSBhbmNob3JET00ubm9kZTtcbiAgICAgIHZhciBvZmZzZXQkMSA9IGFuY2hvckRPTS5vZmZzZXQ7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMykge1xuICAgICAgYnJLbHVkZ2UgPSBvZmZzZXQkMSAmJiBub2RlLm5vZGVWYWx1ZVtvZmZzZXQkMSAtIDFdID09IFwiXFxuXCI7XG4gICAgICAvLyBJc3N1ZSAjMTEyOFxuICAgICAgaWYgKGJyS2x1ZGdlICYmIG9mZnNldCQxID09IG5vZGUubm9kZVZhbHVlLmxlbmd0aCkge1xuICAgICAgICBmb3IgKHZhciBzY2FuID0gbm9kZSwgYWZ0ZXIgPSAodm9pZCAwKTsgc2Nhbjsgc2NhbiA9IHNjYW4ucGFyZW50Tm9kZSkge1xuICAgICAgICAgIGlmIChhZnRlciA9IHNjYW4ubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgIGlmIChhZnRlci5ub2RlTmFtZSA9PSBcIkJSXCIpXG4gICAgICAgICAgICAgIHsgYW5jaG9yRE9NID0gaGVhZERPTSA9IHtub2RlOiBhZnRlci5wYXJlbnROb2RlLCBvZmZzZXQ6IGRvbUluZGV4KGFmdGVyKSArIDF9OyB9XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZGVzYyA9IHNjYW4ucG1WaWV3RGVzYztcbiAgICAgICAgICBpZiAoZGVzYyAmJiBkZXNjLm5vZGUgJiYgZGVzYy5ub2RlLmlzQmxvY2spIHsgYnJlYWsgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwcmV2ID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldCQxIC0gMV07XG4gICAgICBicktsdWRnZSA9IHByZXYgJiYgKHByZXYubm9kZU5hbWUgPT0gXCJCUlwiIHx8IHByZXYuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIik7XG4gICAgfVxuICB9XG4gIC8vIEZpcmVmb3ggY2FuIGFjdCBzdHJhbmdlbHkgd2hlbiB0aGUgc2VsZWN0aW9uIGlzIGluIGZyb250IG9mIGFuXG4gIC8vIHVuZWRpdGFibGUgbm9kZS4gU2VlICMxMTYzIGFuZCBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xNzA5NTM2XG4gIGlmIChyZXN1bHQuZ2Vja28gJiYgZG9tU2VsLmZvY3VzTm9kZSAmJiBkb21TZWwuZm9jdXNOb2RlICE9IGhlYWRET00ubm9kZSAmJiBkb21TZWwuZm9jdXNOb2RlLm5vZGVUeXBlID09IDEpIHtcbiAgICB2YXIgYWZ0ZXIkMSA9IGRvbVNlbC5mb2N1c05vZGUuY2hpbGROb2Rlc1tkb21TZWwuZm9jdXNPZmZzZXRdO1xuICAgIGlmIChhZnRlciQxICYmIGFmdGVyJDEuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIikgeyBmb3JjZSA9IHRydWU7IH1cbiAgfVxuXG4gIGlmICghKGZvcmNlIHx8IGJyS2x1ZGdlICYmIHJlc3VsdC5zYWZhcmkpICYmXG4gICAgICBpc0VxdWl2YWxlbnRQb3NpdGlvbihhbmNob3JET00ubm9kZSwgYW5jaG9yRE9NLm9mZnNldCwgZG9tU2VsLmFuY2hvck5vZGUsIGRvbVNlbC5hbmNob3JPZmZzZXQpICYmXG4gICAgICBpc0VxdWl2YWxlbnRQb3NpdGlvbihoZWFkRE9NLm5vZGUsIGhlYWRET00ub2Zmc2V0LCBkb21TZWwuZm9jdXNOb2RlLCBkb21TZWwuZm9jdXNPZmZzZXQpKVxuICAgIHsgcmV0dXJuIH1cblxuICAvLyBTZWxlY3Rpb24uZXh0ZW5kIGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSBhbiAnaW52ZXJ0ZWQnIHNlbGVjdGlvblxuICAvLyAob25lIHdoZXJlIHRoZSBmb2N1cyBpcyBiZWZvcmUgdGhlIGFuY2hvciksIGJ1dCBub3QgYWxsXG4gIC8vIGJyb3dzZXJzIHN1cHBvcnQgaXQgeWV0LlxuICB2YXIgZG9tU2VsRXh0ZW5kZWQgPSBmYWxzZTtcbiAgaWYgKChkb21TZWwuZXh0ZW5kIHx8IGFuY2hvciA9PSBoZWFkKSAmJiAhYnJLbHVkZ2UpIHtcbiAgICBkb21TZWwuY29sbGFwc2UoYW5jaG9yRE9NLm5vZGUsIGFuY2hvckRPTS5vZmZzZXQpO1xuICAgIHRyeSB7XG4gICAgICBpZiAoYW5jaG9yICE9IGhlYWQpIHsgZG9tU2VsLmV4dGVuZChoZWFkRE9NLm5vZGUsIGhlYWRET00ub2Zmc2V0KTsgfVxuICAgICAgZG9tU2VsRXh0ZW5kZWQgPSB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gSW4gc29tZSBjYXNlcyB3aXRoIENocm9tZSB0aGUgc2VsZWN0aW9uIGlzIGVtcHR5IGFmdGVyIGNhbGxpbmdcbiAgICAgIC8vIGNvbGxhcHNlLCBldmVuIHdoZW4gaXQgc2hvdWxkIGJlIHZhbGlkLiBUaGlzIGFwcGVhcnMgdG8gYmUgYSBidWcsIGJ1dFxuICAgICAgLy8gaXQgaXMgZGlmZmljdWx0IHRvIGlzb2xhdGUuIElmIHRoaXMgaGFwcGVucyBmYWxsYmFjayB0byB0aGUgb2xkIHBhdGhcbiAgICAgIC8vIHdpdGhvdXQgdXNpbmcgZXh0ZW5kLlxuICAgICAgaWYgKCEoZXJyIGluc3RhbmNlb2YgRE9NRXhjZXB0aW9uKSkgeyB0aHJvdyBlcnIgfVxuICAgICAgLy8gZGVjbGFyZSBnbG9iYWw6IERPTUV4Y2VwdGlvblxuICAgIH1cbiAgfVxuICBpZiAoIWRvbVNlbEV4dGVuZGVkKSB7XG4gICAgaWYgKGFuY2hvciA+IGhlYWQpIHsgdmFyIHRtcCA9IGFuY2hvckRPTTsgYW5jaG9yRE9NID0gaGVhZERPTTsgaGVhZERPTSA9IHRtcDsgfVxuICAgIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgcmFuZ2Uuc2V0RW5kKGhlYWRET00ubm9kZSwgaGVhZERPTS5vZmZzZXQpO1xuICAgIHJhbmdlLnNldFN0YXJ0KGFuY2hvckRPTS5ub2RlLCBhbmNob3JET00ub2Zmc2V0KTtcbiAgICBkb21TZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgZG9tU2VsLmFkZFJhbmdlKHJhbmdlKTtcbiAgfVxufTtcblxuLy8gOiAoZG9tLk11dGF0aW9uUmVjb3JkKSDihpIgYm9vbFxuVmlld0Rlc2MucHJvdG90eXBlLmlnbm9yZU11dGF0aW9uID0gZnVuY3Rpb24gaWdub3JlTXV0YXRpb24gKG11dGF0aW9uKSB7XG4gIHJldHVybiAhdGhpcy5jb250ZW50RE9NICYmIG11dGF0aW9uLnR5cGUgIT0gXCJzZWxlY3Rpb25cIlxufTtcblxucHJvdG90eXBlQWNjZXNzb3JzLmNvbnRlbnRMb3N0LmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY29udGVudERPTSAmJiB0aGlzLmNvbnRlbnRET00gIT0gdGhpcy5kb20gJiYgIXRoaXMuZG9tLmNvbnRhaW5zKHRoaXMuY29udGVudERPTSlcbn07XG5cbi8vIFJlbW92ZSBhIHN1YnRyZWUgb2YgdGhlIGVsZW1lbnQgdHJlZSB0aGF0IGhhcyBiZWVuIHRvdWNoZWRcbi8vIGJ5IGEgRE9NIGNoYW5nZSwgc28gdGhhdCB0aGUgbmV4dCB1cGRhdGUgd2lsbCByZWRyYXcgaXQuXG5WaWV3RGVzYy5wcm90b3R5cGUubWFya0RpcnR5ID0gZnVuY3Rpb24gbWFya0RpcnR5IChmcm9tLCB0bykge1xuICBmb3IgKHZhciBvZmZzZXQgPSAwLCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBvZmZzZXQgKyBjaGlsZC5zaXplO1xuICAgIGlmIChvZmZzZXQgPT0gZW5kID8gZnJvbSA8PSBlbmQgJiYgdG8gPj0gb2Zmc2V0IDogZnJvbSA8IGVuZCAmJiB0byA+IG9mZnNldCkge1xuICAgICAgdmFyIHN0YXJ0SW5zaWRlID0gb2Zmc2V0ICsgY2hpbGQuYm9yZGVyLCBlbmRJbnNpZGUgPSBlbmQgLSBjaGlsZC5ib3JkZXI7XG4gICAgICBpZiAoZnJvbSA+PSBzdGFydEluc2lkZSAmJiB0byA8PSBlbmRJbnNpZGUpIHtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZyb20gPT0gb2Zmc2V0IHx8IHRvID09IGVuZCA/IENPTlRFTlRfRElSVFkgOiBDSElMRF9ESVJUWTtcbiAgICAgICAgaWYgKGZyb20gPT0gc3RhcnRJbnNpZGUgJiYgdG8gPT0gZW5kSW5zaWRlICYmXG4gICAgICAgICAgICAoY2hpbGQuY29udGVudExvc3QgfHwgY2hpbGQuZG9tLnBhcmVudE5vZGUgIT0gdGhpcy5jb250ZW50RE9NKSkgeyBjaGlsZC5kaXJ0eSA9IE5PREVfRElSVFk7IH1cbiAgICAgICAgZWxzZSB7IGNoaWxkLm1hcmtEaXJ0eShmcm9tIC0gc3RhcnRJbnNpZGUsIHRvIC0gc3RhcnRJbnNpZGUpOyB9XG4gICAgICAgIHJldHVyblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hpbGQuZGlydHkgPSBjaGlsZC5kb20gPT0gY2hpbGQuY29udGVudERPTSAmJiBjaGlsZC5kb20ucGFyZW50Tm9kZSA9PSB0aGlzLmNvbnRlbnRET00gPyBDT05URU5UX0RJUlRZIDogTk9ERV9ESVJUWTtcbiAgICAgIH1cbiAgICB9XG4gICAgb2Zmc2V0ID0gZW5kO1xuICB9XG4gIHRoaXMuZGlydHkgPSBDT05URU5UX0RJUlRZO1xufTtcblxuVmlld0Rlc2MucHJvdG90eXBlLm1hcmtQYXJlbnRzRGlydHkgPSBmdW5jdGlvbiBtYXJrUGFyZW50c0RpcnR5ICgpIHtcbiAgdmFyIGxldmVsID0gMTtcbiAgZm9yICh2YXIgbm9kZSA9IHRoaXMucGFyZW50OyBub2RlOyBub2RlID0gbm9kZS5wYXJlbnQsIGxldmVsKyspIHtcbiAgICB2YXIgZGlydHkgPSBsZXZlbCA9PSAxID8gQ09OVEVOVF9ESVJUWSA6IENISUxEX0RJUlRZO1xuICAgIGlmIChub2RlLmRpcnR5IDwgZGlydHkpIHsgbm9kZS5kaXJ0eSA9IGRpcnR5OyB9XG4gIH1cbn07XG5cbnByb3RvdHlwZUFjY2Vzc29ycy5kb21BdG9tLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlIH07XG5cbnByb3RvdHlwZUFjY2Vzc29ycy5pZ25vcmVGb3JDb29yZHMuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2UgfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFZpZXdEZXNjLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzICk7XG5cbi8vIFJldXNlZCBhcnJheSB0byBhdm9pZCBhbGxvY2F0aW5nIGZyZXNoIGFycmF5cyBmb3IgdGhpbmdzIHRoYXQgd2lsbFxuLy8gc3RheSBlbXB0eSBhbnl3YXkuXG52YXIgbm90aGluZyA9IFtdO1xuXG4vLyBBIHdpZGdldCBkZXNjIHJlcHJlc2VudHMgYSB3aWRnZXQgZGVjb3JhdGlvbiwgd2hpY2ggaXMgYSBET00gbm9kZVxuLy8gZHJhd24gYmV0d2VlbiB0aGUgZG9jdW1lbnQgbm9kZXMuXG52YXIgV2lkZ2V0Vmlld0Rlc2MgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChWaWV3RGVzYykge1xuICBmdW5jdGlvbiBXaWRnZXRWaWV3RGVzYyhwYXJlbnQsIHdpZGdldCwgdmlldywgcG9zKSB7XG4gICAgdmFyIHNlbGYsIGRvbSA9IHdpZGdldC50eXBlLnRvRE9NO1xuICAgIGlmICh0eXBlb2YgZG9tID09IFwiZnVuY3Rpb25cIikgeyBkb20gPSBkb20odmlldywgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzZWxmKSB7IHJldHVybiBwb3MgfVxuICAgICAgaWYgKHNlbGYucGFyZW50KSB7IHJldHVybiBzZWxmLnBhcmVudC5wb3NCZWZvcmVDaGlsZChzZWxmKSB9XG4gICAgfSk7IH1cbiAgICBpZiAoIXdpZGdldC50eXBlLnNwZWMucmF3KSB7XG4gICAgICBpZiAoZG9tLm5vZGVUeXBlICE9IDEpIHtcbiAgICAgICAgdmFyIHdyYXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgd3JhcC5hcHBlbmRDaGlsZChkb20pO1xuICAgICAgICBkb20gPSB3cmFwO1xuICAgICAgfVxuICAgICAgZG9tLmNvbnRlbnRFZGl0YWJsZSA9IGZhbHNlO1xuICAgICAgZG9tLmNsYXNzTGlzdC5hZGQoXCJQcm9zZU1pcnJvci13aWRnZXRcIik7XG4gICAgfVxuICAgIFZpZXdEZXNjLmNhbGwodGhpcywgcGFyZW50LCBub3RoaW5nLCBkb20sIG51bGwpO1xuICAgIHRoaXMud2lkZ2V0ID0gd2lkZ2V0O1xuICAgIHNlbGYgPSB0aGlzO1xuICB9XG5cbiAgaWYgKCBWaWV3RGVzYyApIFdpZGdldFZpZXdEZXNjLl9fcHJvdG9fXyA9IFZpZXdEZXNjO1xuICBXaWRnZXRWaWV3RGVzYy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBWaWV3RGVzYyAmJiBWaWV3RGVzYy5wcm90b3R5cGUgKTtcbiAgV2lkZ2V0Vmlld0Rlc2MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gV2lkZ2V0Vmlld0Rlc2M7XG5cbiAgdmFyIHByb3RvdHlwZUFjY2Vzc29ycyQxID0geyBkb21BdG9tOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbiAgV2lkZ2V0Vmlld0Rlc2MucHJvdG90eXBlLm1hdGNoZXNXaWRnZXQgPSBmdW5jdGlvbiBtYXRjaGVzV2lkZ2V0ICh3aWRnZXQpIHtcbiAgICByZXR1cm4gdGhpcy5kaXJ0eSA9PSBOT1RfRElSVFkgJiYgd2lkZ2V0LnR5cGUuZXEodGhpcy53aWRnZXQudHlwZSlcbiAgfTtcblxuICBXaWRnZXRWaWV3RGVzYy5wcm90b3R5cGUucGFyc2VSdWxlID0gZnVuY3Rpb24gcGFyc2VSdWxlICgpIHsgcmV0dXJuIHtpZ25vcmU6IHRydWV9IH07XG5cbiAgV2lkZ2V0Vmlld0Rlc2MucHJvdG90eXBlLnN0b3BFdmVudCA9IGZ1bmN0aW9uIHN0b3BFdmVudCAoZXZlbnQpIHtcbiAgICB2YXIgc3RvcCA9IHRoaXMud2lkZ2V0LnNwZWMuc3RvcEV2ZW50O1xuICAgIHJldHVybiBzdG9wID8gc3RvcChldmVudCkgOiBmYWxzZVxuICB9O1xuXG4gIFdpZGdldFZpZXdEZXNjLnByb3RvdHlwZS5pZ25vcmVNdXRhdGlvbiA9IGZ1bmN0aW9uIGlnbm9yZU11dGF0aW9uIChtdXRhdGlvbikge1xuICAgIHJldHVybiBtdXRhdGlvbi50eXBlICE9IFwic2VsZWN0aW9uXCIgfHwgdGhpcy53aWRnZXQuc3BlYy5pZ25vcmVTZWxlY3Rpb25cbiAgfTtcblxuICBwcm90b3R5cGVBY2Nlc3NvcnMkMS5kb21BdG9tLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWUgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggV2lkZ2V0Vmlld0Rlc2MucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMkMSApO1xuXG4gIHJldHVybiBXaWRnZXRWaWV3RGVzYztcbn0oVmlld0Rlc2MpKTtcblxudmFyIENvbXBvc2l0aW9uVmlld0Rlc2MgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChWaWV3RGVzYykge1xuICBmdW5jdGlvbiBDb21wb3NpdGlvblZpZXdEZXNjKHBhcmVudCwgZG9tLCB0ZXh0RE9NLCB0ZXh0KSB7XG4gICAgVmlld0Rlc2MuY2FsbCh0aGlzLCBwYXJlbnQsIG5vdGhpbmcsIGRvbSwgbnVsbCk7XG4gICAgdGhpcy50ZXh0RE9NID0gdGV4dERPTTtcbiAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICB9XG5cbiAgaWYgKCBWaWV3RGVzYyApIENvbXBvc2l0aW9uVmlld0Rlc2MuX19wcm90b19fID0gVmlld0Rlc2M7XG4gIENvbXBvc2l0aW9uVmlld0Rlc2MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVmlld0Rlc2MgJiYgVmlld0Rlc2MucHJvdG90eXBlICk7XG4gIENvbXBvc2l0aW9uVmlld0Rlc2MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29tcG9zaXRpb25WaWV3RGVzYztcblxuICB2YXIgcHJvdG90eXBlQWNjZXNzb3JzJDIgPSB7IHNpemU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxuICBwcm90b3R5cGVBY2Nlc3NvcnMkMi5zaXplLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudGV4dC5sZW5ndGggfTtcblxuICBDb21wb3NpdGlvblZpZXdEZXNjLnByb3RvdHlwZS5sb2NhbFBvc0Zyb21ET00gPSBmdW5jdGlvbiBsb2NhbFBvc0Zyb21ET00gKGRvbSwgb2Zmc2V0KSB7XG4gICAgaWYgKGRvbSAhPSB0aGlzLnRleHRET00pIHsgcmV0dXJuIHRoaXMucG9zQXRTdGFydCArIChvZmZzZXQgPyB0aGlzLnNpemUgOiAwKSB9XG4gICAgcmV0dXJuIHRoaXMucG9zQXRTdGFydCArIG9mZnNldFxuICB9O1xuXG4gIENvbXBvc2l0aW9uVmlld0Rlc2MucHJvdG90eXBlLmRvbUZyb21Qb3MgPSBmdW5jdGlvbiBkb21Gcm9tUG9zIChwb3MpIHtcbiAgICByZXR1cm4ge25vZGU6IHRoaXMudGV4dERPTSwgb2Zmc2V0OiBwb3N9XG4gIH07XG5cbiAgQ29tcG9zaXRpb25WaWV3RGVzYy5wcm90b3R5cGUuaWdub3JlTXV0YXRpb24gPSBmdW5jdGlvbiBpZ25vcmVNdXRhdGlvbiAobXV0KSB7XG4gICAgcmV0dXJuIG11dC50eXBlID09PSAnY2hhcmFjdGVyRGF0YScgJiYgbXV0LnRhcmdldC5ub2RlVmFsdWUgPT0gbXV0Lm9sZFZhbHVlXG4gICB9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBDb21wb3NpdGlvblZpZXdEZXNjLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzJDIgKTtcblxuICByZXR1cm4gQ29tcG9zaXRpb25WaWV3RGVzYztcbn0oVmlld0Rlc2MpKTtcblxuLy8gQSBtYXJrIGRlc2MgcmVwcmVzZW50cyBhIG1hcmsuIE1heSBoYXZlIG11bHRpcGxlIGNoaWxkcmVuLFxuLy8gZGVwZW5kaW5nIG9uIGhvdyB0aGUgbWFyayBpcyBzcGxpdC4gTm90ZSB0aGF0IG1hcmtzIGFyZSBkcmF3biB1c2luZ1xuLy8gYSBmaXhlZCBuZXN0aW5nIG9yZGVyLCBmb3Igc2ltcGxpY2l0eSBhbmQgcHJlZGljdGFiaWxpdHksIHNvIGluXG4vLyBzb21lIGNhc2VzIHRoZXkgd2lsbCBiZSBzcGxpdCBtb3JlIG9mdGVuIHRoYW4gd291bGQgYXBwZWFyXG4vLyBuZWNlc3NhcnkuXG52YXIgTWFya1ZpZXdEZXNjID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoVmlld0Rlc2MpIHtcbiAgZnVuY3Rpb24gTWFya1ZpZXdEZXNjKHBhcmVudCwgbWFyaywgZG9tLCBjb250ZW50RE9NKSB7XG4gICAgVmlld0Rlc2MuY2FsbCh0aGlzLCBwYXJlbnQsIFtdLCBkb20sIGNvbnRlbnRET00pO1xuICAgIHRoaXMubWFyayA9IG1hcms7XG4gIH1cblxuICBpZiAoIFZpZXdEZXNjICkgTWFya1ZpZXdEZXNjLl9fcHJvdG9fXyA9IFZpZXdEZXNjO1xuICBNYXJrVmlld0Rlc2MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVmlld0Rlc2MgJiYgVmlld0Rlc2MucHJvdG90eXBlICk7XG4gIE1hcmtWaWV3RGVzYy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNYXJrVmlld0Rlc2M7XG5cbiAgTWFya1ZpZXdEZXNjLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZSAocGFyZW50LCBtYXJrLCBpbmxpbmUsIHZpZXcpIHtcbiAgICB2YXIgY3VzdG9tID0gdmlldy5ub2RlVmlld3NbbWFyay50eXBlLm5hbWVdO1xuICAgIHZhciBzcGVjID0gY3VzdG9tICYmIGN1c3RvbShtYXJrLCB2aWV3LCBpbmxpbmUpO1xuICAgIGlmICghc3BlYyB8fCAhc3BlYy5kb20pXG4gICAgICB7IHNwZWMgPSBET01TZXJpYWxpemVyLnJlbmRlclNwZWMoZG9jdW1lbnQsIG1hcmsudHlwZS5zcGVjLnRvRE9NKG1hcmssIGlubGluZSkpOyB9XG4gICAgcmV0dXJuIG5ldyBNYXJrVmlld0Rlc2MocGFyZW50LCBtYXJrLCBzcGVjLmRvbSwgc3BlYy5jb250ZW50RE9NIHx8IHNwZWMuZG9tKVxuICB9O1xuXG4gIE1hcmtWaWV3RGVzYy5wcm90b3R5cGUucGFyc2VSdWxlID0gZnVuY3Rpb24gcGFyc2VSdWxlICgpIHsgcmV0dXJuIHttYXJrOiB0aGlzLm1hcmsudHlwZS5uYW1lLCBhdHRyczogdGhpcy5tYXJrLmF0dHJzLCBjb250ZW50RWxlbWVudDogdGhpcy5jb250ZW50RE9NfSB9O1xuXG4gIE1hcmtWaWV3RGVzYy5wcm90b3R5cGUubWF0Y2hlc01hcmsgPSBmdW5jdGlvbiBtYXRjaGVzTWFyayAobWFyaykgeyByZXR1cm4gdGhpcy5kaXJ0eSAhPSBOT0RFX0RJUlRZICYmIHRoaXMubWFyay5lcShtYXJrKSB9O1xuXG4gIE1hcmtWaWV3RGVzYy5wcm90b3R5cGUubWFya0RpcnR5ID0gZnVuY3Rpb24gbWFya0RpcnR5IChmcm9tLCB0bykge1xuICAgIFZpZXdEZXNjLnByb3RvdHlwZS5tYXJrRGlydHkuY2FsbCh0aGlzLCBmcm9tLCB0byk7XG4gICAgLy8gTW92ZSBkaXJ0eSBpbmZvIHRvIG5lYXJlc3Qgbm9kZSB2aWV3XG4gICAgaWYgKHRoaXMuZGlydHkgIT0gTk9UX0RJUlRZKSB7XG4gICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG4gICAgICB3aGlsZSAoIXBhcmVudC5ub2RlKSB7IHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7IH1cbiAgICAgIGlmIChwYXJlbnQuZGlydHkgPCB0aGlzLmRpcnR5KSB7IHBhcmVudC5kaXJ0eSA9IHRoaXMuZGlydHk7IH1cbiAgICAgIHRoaXMuZGlydHkgPSBOT1RfRElSVFk7XG4gICAgfVxuICB9O1xuXG4gIE1hcmtWaWV3RGVzYy5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoZnJvbSwgdG8sIHZpZXcpIHtcbiAgICB2YXIgY29weSA9IE1hcmtWaWV3RGVzYy5jcmVhdGUodGhpcy5wYXJlbnQsIHRoaXMubWFyaywgdHJ1ZSwgdmlldyk7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5jaGlsZHJlbiwgc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICBpZiAodG8gPCBzaXplKSB7IG5vZGVzID0gcmVwbGFjZU5vZGVzKG5vZGVzLCB0bywgc2l6ZSwgdmlldyk7IH1cbiAgICBpZiAoZnJvbSA+IDApIHsgbm9kZXMgPSByZXBsYWNlTm9kZXMobm9kZXMsIDAsIGZyb20sIHZpZXcpOyB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykgeyBub2Rlc1tpXS5wYXJlbnQgPSBjb3B5OyB9XG4gICAgY29weS5jaGlsZHJlbiA9IG5vZGVzO1xuICAgIHJldHVybiBjb3B5XG4gIH07XG5cbiAgcmV0dXJuIE1hcmtWaWV3RGVzYztcbn0oVmlld0Rlc2MpKTtcblxuLy8gTm9kZSB2aWV3IGRlc2NzIGFyZSB0aGUgbWFpbiwgbW9zdCBjb21tb24gdHlwZSBvZiB2aWV3IGRlc2MsIGFuZFxuLy8gY29ycmVzcG9uZCB0byBhbiBhY3R1YWwgbm9kZSBpbiB0aGUgZG9jdW1lbnQuIFVubGlrZSBtYXJrIGRlc2NzLFxuLy8gdGhleSBwb3B1bGF0ZSB0aGVpciBjaGlsZCBhcnJheSB0aGVtc2VsdmVzLlxudmFyIE5vZGVWaWV3RGVzYyA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFZpZXdEZXNjKSB7XG4gIGZ1bmN0aW9uIE5vZGVWaWV3RGVzYyhwYXJlbnQsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBkb20sIGNvbnRlbnRET00sIG5vZGVET00sIHZpZXcsIHBvcykge1xuICAgIFZpZXdEZXNjLmNhbGwodGhpcywgcGFyZW50LCBub2RlLmlzTGVhZiA/IG5vdGhpbmcgOiBbXSwgZG9tLCBjb250ZW50RE9NKTtcbiAgICB0aGlzLm5vZGVET00gPSBub2RlRE9NO1xuICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgdGhpcy5vdXRlckRlY28gPSBvdXRlckRlY287XG4gICAgdGhpcy5pbm5lckRlY28gPSBpbm5lckRlY287XG4gICAgaWYgKGNvbnRlbnRET00pIHsgdGhpcy51cGRhdGVDaGlsZHJlbih2aWV3LCBwb3MpOyB9XG4gIH1cblxuICBpZiAoIFZpZXdEZXNjICkgTm9kZVZpZXdEZXNjLl9fcHJvdG9fXyA9IFZpZXdEZXNjO1xuICBOb2RlVmlld0Rlc2MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVmlld0Rlc2MgJiYgVmlld0Rlc2MucHJvdG90eXBlICk7XG4gIE5vZGVWaWV3RGVzYy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBOb2RlVmlld0Rlc2M7XG5cbiAgdmFyIHByb3RvdHlwZUFjY2Vzc29ycyQzID0geyBzaXplOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGJvcmRlcjogeyBjb25maWd1cmFibGU6IHRydWUgfSxkb21BdG9tOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbiAgLy8gQnkgZGVmYXVsdCwgYSBub2RlIGlzIHJlbmRlcmVkIHVzaW5nIHRoZSBgdG9ET01gIG1ldGhvZCBmcm9tIHRoZVxuICAvLyBub2RlIHR5cGUgc3BlYy4gQnV0IGNsaWVudCBjb2RlIGNhbiB1c2UgdGhlIGBub2RlVmlld3NgIHNwZWMgdG9cbiAgLy8gc3VwcGx5IGEgY3VzdG9tIG5vZGUgdmlldywgd2hpY2ggY2FuIGluZmx1ZW5jZSB2YXJpb3VzIGFzcGVjdHMgb2ZcbiAgLy8gdGhlIHdheSB0aGUgbm9kZSB3b3Jrcy5cbiAgLy9cbiAgLy8gKFVzaW5nIHN1YmNsYXNzaW5nIGZvciB0aGlzIHdhcyBpbnRlbnRpb25hbGx5IGRlY2lkZWQgYWdhaW5zdCxcbiAgLy8gc2luY2UgaXQnZCByZXF1aXJlIGV4cG9zaW5nIGEgd2hvbGUgc2xldyBvZiBmaW5pY2t5XG4gIC8vIGltcGxlbWVudGF0aW9uIGRldGFpbHMgdG8gdGhlIHVzZXIgY29kZSB0aGF0IHRoZXkgcHJvYmFibHkgd2lsbFxuICAvLyBuZXZlciBuZWVkLilcbiAgTm9kZVZpZXdEZXNjLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZSAocGFyZW50LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldywgcG9zKSB7XG4gICAgdmFyIGFzc2lnbjtcblxuICAgIHZhciBjdXN0b20gPSB2aWV3Lm5vZGVWaWV3c1tub2RlLnR5cGUubmFtZV0sIGRlc2NPYmo7XG4gICAgdmFyIHNwZWMgPSBjdXN0b20gJiYgY3VzdG9tKG5vZGUsIHZpZXcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIChUaGlzIGlzIGEgZnVuY3Rpb24gdGhhdCBhbGxvd3MgdGhlIGN1c3RvbSB2aWV3IHRvIGZpbmQgaXRzXG4gICAgICAvLyBvd24gcG9zaXRpb24pXG4gICAgICBpZiAoIWRlc2NPYmopIHsgcmV0dXJuIHBvcyB9XG4gICAgICBpZiAoZGVzY09iai5wYXJlbnQpIHsgcmV0dXJuIGRlc2NPYmoucGFyZW50LnBvc0JlZm9yZUNoaWxkKGRlc2NPYmopIH1cbiAgICB9LCBvdXRlckRlY28sIGlubmVyRGVjbyk7XG5cbiAgICB2YXIgZG9tID0gc3BlYyAmJiBzcGVjLmRvbSwgY29udGVudERPTSA9IHNwZWMgJiYgc3BlYy5jb250ZW50RE9NO1xuICAgIGlmIChub2RlLmlzVGV4dCkge1xuICAgICAgaWYgKCFkb20pIHsgZG9tID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobm9kZS50ZXh0KTsgfVxuICAgICAgZWxzZSBpZiAoZG9tLm5vZGVUeXBlICE9IDMpIHsgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUZXh0IG11c3QgYmUgcmVuZGVyZWQgYXMgYSBET00gdGV4dCBub2RlXCIpIH1cbiAgICB9IGVsc2UgaWYgKCFkb20pIHtcbigoYXNzaWduID0gRE9NU2VyaWFsaXplci5yZW5kZXJTcGVjKGRvY3VtZW50LCBub2RlLnR5cGUuc3BlYy50b0RPTShub2RlKSksIGRvbSA9IGFzc2lnbi5kb20sIGNvbnRlbnRET00gPSBhc3NpZ24uY29udGVudERPTSkpO1xuICAgIH1cbiAgICBpZiAoIWNvbnRlbnRET00gJiYgIW5vZGUuaXNUZXh0ICYmIGRvbS5ub2RlTmFtZSAhPSBcIkJSXCIpIHsgLy8gQ2hyb21lIGdldHMgY29uZnVzZWQgYnkgPGJyIGNvbnRlbnRlZGl0YWJsZT1mYWxzZT5cbiAgICAgIGlmICghZG9tLmhhc0F0dHJpYnV0ZShcImNvbnRlbnRlZGl0YWJsZVwiKSkgeyBkb20uY29udGVudEVkaXRhYmxlID0gZmFsc2U7IH1cbiAgICAgIGlmIChub2RlLnR5cGUuc3BlYy5kcmFnZ2FibGUpIHsgZG9tLmRyYWdnYWJsZSA9IHRydWU7IH1cbiAgICB9XG5cbiAgICB2YXIgbm9kZURPTSA9IGRvbTtcbiAgICBkb20gPSBhcHBseU91dGVyRGVjbyhkb20sIG91dGVyRGVjbywgbm9kZSk7XG5cbiAgICBpZiAoc3BlYylcbiAgICAgIHsgcmV0dXJuIGRlc2NPYmogPSBuZXcgQ3VzdG9tTm9kZVZpZXdEZXNjKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgY29udGVudERPTSwgbm9kZURPTSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGVjLCB2aWV3LCBwb3MgKyAxKSB9XG4gICAgZWxzZSBpZiAobm9kZS5pc1RleHQpXG4gICAgICB7IHJldHVybiBuZXcgVGV4dFZpZXdEZXNjKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgbm9kZURPTSwgdmlldykgfVxuICAgIGVsc2VcbiAgICAgIHsgcmV0dXJuIG5ldyBOb2RlVmlld0Rlc2MocGFyZW50LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCBjb250ZW50RE9NLCBub2RlRE9NLCB2aWV3LCBwb3MgKyAxKSB9XG4gIH07XG5cbiAgTm9kZVZpZXdEZXNjLnByb3RvdHlwZS5wYXJzZVJ1bGUgPSBmdW5jdGlvbiBwYXJzZVJ1bGUgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgLy8gRXhwZXJpbWVudGFsIGtsdWRnZSB0byBhbGxvdyBvcHQtaW4gcmUtcGFyc2luZyBvZiBub2Rlc1xuICAgIGlmICh0aGlzLm5vZGUudHlwZS5zcGVjLnJlcGFyc2VJblZpZXcpIHsgcmV0dXJuIG51bGwgfVxuICAgIC8vIEZJWE1FIHRoZSBhc3N1bXB0aW9uIHRoYXQgdGhpcyBjYW4gYWx3YXlzIHJldHVybiB0aGUgY3VycmVudFxuICAgIC8vIGF0dHJzIG1lYW5zIHRoYXQgaWYgdGhlIHVzZXIgc29tZWhvdyBtYW5hZ2VzIHRvIGNoYW5nZSB0aGVcbiAgICAvLyBhdHRycyBpbiB0aGUgZG9tLCB0aGF0IHdvbid0IGJlIHBpY2tlZCB1cC4gTm90IGVudGlyZWx5IHN1cmVcbiAgICAvLyB3aGV0aGVyIHRoaXMgaXMgYSBwcm9ibGVtXG4gICAgdmFyIHJ1bGUgPSB7bm9kZTogdGhpcy5ub2RlLnR5cGUubmFtZSwgYXR0cnM6IHRoaXMubm9kZS5hdHRyc307XG4gICAgaWYgKHRoaXMubm9kZS50eXBlLnNwZWMuY29kZSkgeyBydWxlLnByZXNlcnZlV2hpdGVzcGFjZSA9IFwiZnVsbFwiOyB9XG4gICAgaWYgKHRoaXMuY29udGVudERPTSAmJiAhdGhpcy5jb250ZW50TG9zdCkgeyBydWxlLmNvbnRlbnRFbGVtZW50ID0gdGhpcy5jb250ZW50RE9NOyB9XG4gICAgZWxzZSB7IHJ1bGUuZ2V0Q29udGVudCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMkMS5jb250ZW50RE9NID8gRnJhZ21lbnQuZW1wdHkgOiB0aGlzJDEubm9kZS5jb250ZW50OyB9OyB9XG4gICAgcmV0dXJuIHJ1bGVcbiAgfTtcblxuICBOb2RlVmlld0Rlc2MucHJvdG90eXBlLm1hdGNoZXNOb2RlID0gZnVuY3Rpb24gbWF0Y2hlc05vZGUgKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlydHkgPT0gTk9UX0RJUlRZICYmIG5vZGUuZXEodGhpcy5ub2RlKSAmJlxuICAgICAgc2FtZU91dGVyRGVjbyhvdXRlckRlY28sIHRoaXMub3V0ZXJEZWNvKSAmJiBpbm5lckRlY28uZXEodGhpcy5pbm5lckRlY28pXG4gIH07XG5cbiAgcHJvdG90eXBlQWNjZXNzb3JzJDMuc2l6ZS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLm5vZGUubm9kZVNpemUgfTtcblxuICBwcm90b3R5cGVBY2Nlc3NvcnMkMy5ib3JkZXIuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5ub2RlLmlzTGVhZiA/IDAgOiAxIH07XG5cbiAgLy8gU3luY3MgYHRoaXMuY2hpbGRyZW5gIHRvIG1hdGNoIGB0aGlzLm5vZGUuY29udGVudGAgYW5kIHRoZSBsb2NhbFxuICAvLyBkZWNvcmF0aW9ucywgcG9zc2libHkgaW50cm9kdWNpbmcgbmVzdGluZyBmb3IgbWFya3MuIFRoZW4sIGluIGFcbiAgLy8gc2VwYXJhdGUgc3RlcCwgc3luY3MgdGhlIERPTSBpbnNpZGUgYHRoaXMuY29udGVudERPTWAgdG9cbiAgLy8gYHRoaXMuY2hpbGRyZW5gLlxuICBOb2RlVmlld0Rlc2MucHJvdG90eXBlLnVwZGF0ZUNoaWxkcmVuID0gZnVuY3Rpb24gdXBkYXRlQ2hpbGRyZW4gKHZpZXcsIHBvcykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGlubGluZSA9IHRoaXMubm9kZS5pbmxpbmVDb250ZW50LCBvZmYgPSBwb3M7XG4gICAgdmFyIGNvbXBvc2l0aW9uID0gdmlldy5jb21wb3NpbmcgJiYgdGhpcy5sb2NhbENvbXBvc2l0aW9uSW5mbyh2aWV3LCBwb3MpO1xuICAgIHZhciBsb2NhbENvbXBvc2l0aW9uID0gY29tcG9zaXRpb24gJiYgY29tcG9zaXRpb24ucG9zID4gLTEgPyBjb21wb3NpdGlvbiA6IG51bGw7XG4gICAgdmFyIGNvbXBvc2l0aW9uSW5DaGlsZCA9IGNvbXBvc2l0aW9uICYmIGNvbXBvc2l0aW9uLnBvcyA8IDA7XG4gICAgdmFyIHVwZGF0ZXIgPSBuZXcgVmlld1RyZWVVcGRhdGVyKHRoaXMsIGxvY2FsQ29tcG9zaXRpb24gJiYgbG9jYWxDb21wb3NpdGlvbi5ub2RlKTtcbiAgICBpdGVyRGVjbyh0aGlzLm5vZGUsIHRoaXMuaW5uZXJEZWNvLCBmdW5jdGlvbiAod2lkZ2V0LCBpLCBpbnNpZGVOb2RlKSB7XG4gICAgICBpZiAod2lkZ2V0LnNwZWMubWFya3MpXG4gICAgICAgIHsgdXBkYXRlci5zeW5jVG9NYXJrcyh3aWRnZXQuc3BlYy5tYXJrcywgaW5saW5lLCB2aWV3KTsgfVxuICAgICAgZWxzZSBpZiAod2lkZ2V0LnR5cGUuc2lkZSA+PSAwICYmICFpbnNpZGVOb2RlKVxuICAgICAgICB7IHVwZGF0ZXIuc3luY1RvTWFya3MoaSA9PSB0aGlzJDEubm9kZS5jaGlsZENvdW50ID8gTWFyay5ub25lIDogdGhpcyQxLm5vZGUuY2hpbGQoaSkubWFya3MsIGlubGluZSwgdmlldyk7IH1cbiAgICAgIC8vIElmIHRoZSBuZXh0IG5vZGUgaXMgYSBkZXNjIG1hdGNoaW5nIHRoaXMgd2lkZ2V0LCByZXVzZSBpdCxcbiAgICAgIC8vIG90aGVyd2lzZSBpbnNlcnQgdGhlIHdpZGdldCBhcyBhIG5ldyB2aWV3IGRlc2MuXG4gICAgICB1cGRhdGVyLnBsYWNlV2lkZ2V0KHdpZGdldCwgdmlldywgb2ZmKTtcbiAgICB9LCBmdW5jdGlvbiAoY2hpbGQsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBpKSB7XG4gICAgICAvLyBNYWtlIHN1cmUgdGhlIHdyYXBwaW5nIG1hcmsgZGVzY3MgbWF0Y2ggdGhlIG5vZGUncyBtYXJrcy5cbiAgICAgIHVwZGF0ZXIuc3luY1RvTWFya3MoY2hpbGQubWFya3MsIGlubGluZSwgdmlldyk7XG4gICAgICAvLyBUcnkgc2V2ZXJhbCBzdHJhdGVnaWVzIGZvciBkcmF3aW5nIHRoaXMgbm9kZVxuICAgICAgdmFyIGNvbXBJbmRleDtcbiAgICAgIGlmICh1cGRhdGVyLmZpbmROb2RlTWF0Y2goY2hpbGQsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBpKSkgOyBlbHNlIGlmIChjb21wb3NpdGlvbkluQ2hpbGQgJiYgdmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbSA+IG9mZiAmJlxuICAgICAgICAgICAgICAgICB2aWV3LnN0YXRlLnNlbGVjdGlvbi50byA8IG9mZiArIGNoaWxkLm5vZGVTaXplICYmXG4gICAgICAgICAgICAgICAgIChjb21wSW5kZXggPSB1cGRhdGVyLmZpbmRJbmRleFdpdGhDaGlsZChjb21wb3NpdGlvbi5ub2RlKSkgPiAtMSAmJlxuICAgICAgICAgICAgICAgICB1cGRhdGVyLnVwZGF0ZU5vZGVBdChjaGlsZCwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGNvbXBJbmRleCwgdmlldykpIDsgZWxzZSBpZiAodXBkYXRlci51cGRhdGVOZXh0Tm9kZShjaGlsZCwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcsIGkpKSA7IGVsc2Uge1xuICAgICAgICAvLyBBZGQgaXQgYXMgYSBuZXcgdmlld1xuICAgICAgICB1cGRhdGVyLmFkZE5vZGUoY2hpbGQsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3LCBvZmYpO1xuICAgICAgfVxuICAgICAgb2ZmICs9IGNoaWxkLm5vZGVTaXplO1xuICAgIH0pO1xuICAgIC8vIERyb3AgYWxsIHJlbWFpbmluZyBkZXNjcyBhZnRlciB0aGUgY3VycmVudCBwb3NpdGlvbi5cbiAgICB1cGRhdGVyLnN5bmNUb01hcmtzKG5vdGhpbmcsIGlubGluZSwgdmlldyk7XG4gICAgaWYgKHRoaXMubm9kZS5pc1RleHRibG9jaykgeyB1cGRhdGVyLmFkZFRleHRibG9ja0hhY2tzKCk7IH1cbiAgICB1cGRhdGVyLmRlc3Ryb3lSZXN0KCk7XG5cbiAgICAvLyBTeW5jIHRoZSBET00gaWYgYW55dGhpbmcgY2hhbmdlZFxuICAgIGlmICh1cGRhdGVyLmNoYW5nZWQgfHwgdGhpcy5kaXJ0eSA9PSBDT05URU5UX0RJUlRZKSB7XG4gICAgICAvLyBNYXkgaGF2ZSB0byBwcm90ZWN0IGZvY3VzZWQgRE9NIGZyb20gYmVpbmcgY2hhbmdlZCBpZiBhIGNvbXBvc2l0aW9uIGlzIGFjdGl2ZVxuICAgICAgaWYgKGxvY2FsQ29tcG9zaXRpb24pIHsgdGhpcy5wcm90ZWN0TG9jYWxDb21wb3NpdGlvbih2aWV3LCBsb2NhbENvbXBvc2l0aW9uKTsgfVxuICAgICAgcmVuZGVyRGVzY3ModGhpcy5jb250ZW50RE9NLCB0aGlzLmNoaWxkcmVuLCB2aWV3KTtcbiAgICAgIGlmIChyZXN1bHQuaW9zKSB7IGlvc0hhY2tzKHRoaXMuZG9tKTsgfVxuICAgIH1cbiAgfTtcblxuICBOb2RlVmlld0Rlc2MucHJvdG90eXBlLmxvY2FsQ29tcG9zaXRpb25JbmZvID0gZnVuY3Rpb24gbG9jYWxDb21wb3NpdGlvbkluZm8gKHZpZXcsIHBvcykge1xuICAgIC8vIE9ubHkgZG8gc29tZXRoaW5nIGlmIGJvdGggdGhlIHNlbGVjdGlvbiBhbmQgYSBmb2N1c2VkIHRleHQgbm9kZVxuICAgIC8vIGFyZSBpbnNpZGUgb2YgdGhpcyBub2RlXG4gICAgdmFyIHJlZiA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgIHZhciBmcm9tID0gcmVmLmZyb207XG4gICAgdmFyIHRvID0gcmVmLnRvO1xuICAgIGlmICghKHZpZXcuc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbikgfHwgZnJvbSA8IHBvcyB8fCB0byA+IHBvcyArIHRoaXMubm9kZS5jb250ZW50LnNpemUpIHsgcmV0dXJuIH1cbiAgICB2YXIgc2VsID0gdmlldy5yb290LmdldFNlbGVjdGlvbigpO1xuICAgIHZhciB0ZXh0Tm9kZSA9IG5lYXJieVRleHROb2RlKHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCk7XG4gICAgaWYgKCF0ZXh0Tm9kZSB8fCAhdGhpcy5kb20uY29udGFpbnModGV4dE5vZGUucGFyZW50Tm9kZSkpIHsgcmV0dXJuIH1cblxuICAgIGlmICh0aGlzLm5vZGUuaW5saW5lQ29udGVudCkge1xuICAgICAgLy8gRmluZCB0aGUgdGV4dCBpbiB0aGUgZm9jdXNlZCBub2RlIGluIHRoZSBub2RlLCBzdG9wIGlmIGl0J3Mgbm90XG4gICAgICAvLyB0aGVyZSAobWF5IGhhdmUgYmVlbiBtb2RpZmllZCB0aHJvdWdoIG90aGVyIG1lYW5zLCBpbiB3aGljaFxuICAgICAgLy8gY2FzZSBpdCBzaG91bGQgb3ZlcndyaXR0ZW4pXG4gICAgICB2YXIgdGV4dCA9IHRleHROb2RlLm5vZGVWYWx1ZTtcbiAgICAgIHZhciB0ZXh0UG9zID0gZmluZFRleHRJbkZyYWdtZW50KHRoaXMubm9kZS5jb250ZW50LCB0ZXh0LCBmcm9tIC0gcG9zLCB0byAtIHBvcyk7XG4gICAgICByZXR1cm4gdGV4dFBvcyA8IDAgPyBudWxsIDoge25vZGU6IHRleHROb2RlLCBwb3M6IHRleHRQb3MsIHRleHQ6IHRleHR9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7bm9kZTogdGV4dE5vZGUsIHBvczogLTF9XG4gICAgfVxuICB9O1xuXG4gIE5vZGVWaWV3RGVzYy5wcm90b3R5cGUucHJvdGVjdExvY2FsQ29tcG9zaXRpb24gPSBmdW5jdGlvbiBwcm90ZWN0TG9jYWxDb21wb3NpdGlvbiAodmlldywgcmVmKSB7XG4gICAgdmFyIG5vZGUgPSByZWYubm9kZTtcbiAgICB2YXIgcG9zID0gcmVmLnBvcztcbiAgICB2YXIgdGV4dCA9IHJlZi50ZXh0O1xuXG4gICAgLy8gVGhlIG5vZGUgaXMgYWxyZWFkeSBwYXJ0IG9mIGEgbG9jYWwgdmlldyBkZXNjLCBsZWF2ZSBpdCB0aGVyZVxuICAgIGlmICh0aGlzLmdldERlc2Mobm9kZSkpIHsgcmV0dXJuIH1cblxuICAgIC8vIENyZWF0ZSBhIGNvbXBvc2l0aW9uIHZpZXcgZm9yIHRoZSBvcnBoYW5lZCBub2Rlc1xuICAgIHZhciB0b3BOb2RlID0gbm9kZTtcbiAgICBmb3IgKDs7IHRvcE5vZGUgPSB0b3BOb2RlLnBhcmVudE5vZGUpIHtcbiAgICAgIGlmICh0b3BOb2RlLnBhcmVudE5vZGUgPT0gdGhpcy5jb250ZW50RE9NKSB7IGJyZWFrIH1cbiAgICAgIHdoaWxlICh0b3BOb2RlLnByZXZpb3VzU2libGluZykgeyB0b3BOb2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodG9wTm9kZS5wcmV2aW91c1NpYmxpbmcpOyB9XG4gICAgICB3aGlsZSAodG9wTm9kZS5uZXh0U2libGluZykgeyB0b3BOb2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodG9wTm9kZS5uZXh0U2libGluZyk7IH1cbiAgICAgIGlmICh0b3BOb2RlLnBtVmlld0Rlc2MpIHsgdG9wTm9kZS5wbVZpZXdEZXNjID0gbnVsbDsgfVxuICAgIH1cbiAgICB2YXIgZGVzYyA9IG5ldyBDb21wb3NpdGlvblZpZXdEZXNjKHRoaXMsIHRvcE5vZGUsIG5vZGUsIHRleHQpO1xuICAgIHZpZXcuY29tcG9zaXRpb25Ob2Rlcy5wdXNoKGRlc2MpO1xuXG4gICAgLy8gUGF0Y2ggdXAgdGhpcy5jaGlsZHJlbiB0byBjb250YWluIHRoZSBjb21wb3NpdGlvbiB2aWV3XG4gICAgdGhpcy5jaGlsZHJlbiA9IHJlcGxhY2VOb2Rlcyh0aGlzLmNoaWxkcmVuLCBwb3MsIHBvcyArIHRleHQubGVuZ3RoLCB2aWV3LCBkZXNjKTtcbiAgfTtcblxuICAvLyA6IChOb2RlLCBbRGVjb3JhdGlvbl0sIERlY29yYXRpb25Tb3VyY2UsIEVkaXRvclZpZXcpIOKGkiBib29sXG4gIC8vIElmIHRoaXMgZGVzYyBiZSB1cGRhdGVkIHRvIG1hdGNoIHRoZSBnaXZlbiBub2RlIGRlY29yYXRpb24sXG4gIC8vIGRvIHNvIGFuZCByZXR1cm4gdHJ1ZS5cbiAgTm9kZVZpZXdEZXNjLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3KSB7XG4gICAgaWYgKHRoaXMuZGlydHkgPT0gTk9ERV9ESVJUWSB8fFxuICAgICAgICAhbm9kZS5zYW1lTWFya3VwKHRoaXMubm9kZSkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICB0aGlzLnVwZGF0ZUlubmVyKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3KTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9O1xuXG4gIE5vZGVWaWV3RGVzYy5wcm90b3R5cGUudXBkYXRlSW5uZXIgPSBmdW5jdGlvbiB1cGRhdGVJbm5lciAobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcpIHtcbiAgICB0aGlzLnVwZGF0ZU91dGVyRGVjbyhvdXRlckRlY28pO1xuICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgdGhpcy5pbm5lckRlY28gPSBpbm5lckRlY287XG4gICAgaWYgKHRoaXMuY29udGVudERPTSkgeyB0aGlzLnVwZGF0ZUNoaWxkcmVuKHZpZXcsIHRoaXMucG9zQXRTdGFydCk7IH1cbiAgICB0aGlzLmRpcnR5ID0gTk9UX0RJUlRZO1xuICB9O1xuXG4gIE5vZGVWaWV3RGVzYy5wcm90b3R5cGUudXBkYXRlT3V0ZXJEZWNvID0gZnVuY3Rpb24gdXBkYXRlT3V0ZXJEZWNvIChvdXRlckRlY28pIHtcbiAgICBpZiAoc2FtZU91dGVyRGVjbyhvdXRlckRlY28sIHRoaXMub3V0ZXJEZWNvKSkgeyByZXR1cm4gfVxuICAgIHZhciBuZWVkc1dyYXAgPSB0aGlzLm5vZGVET00ubm9kZVR5cGUgIT0gMTtcbiAgICB2YXIgb2xkRE9NID0gdGhpcy5kb207XG4gICAgdGhpcy5kb20gPSBwYXRjaE91dGVyRGVjbyh0aGlzLmRvbSwgdGhpcy5ub2RlRE9NLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcHV0ZU91dGVyRGVjbyh0aGlzLm91dGVyRGVjbywgdGhpcy5ub2RlLCBuZWVkc1dyYXApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcHV0ZU91dGVyRGVjbyhvdXRlckRlY28sIHRoaXMubm9kZSwgbmVlZHNXcmFwKSk7XG4gICAgaWYgKHRoaXMuZG9tICE9IG9sZERPTSkge1xuICAgICAgb2xkRE9NLnBtVmlld0Rlc2MgPSBudWxsO1xuICAgICAgdGhpcy5kb20ucG1WaWV3RGVzYyA9IHRoaXM7XG4gICAgfVxuICAgIHRoaXMub3V0ZXJEZWNvID0gb3V0ZXJEZWNvO1xuICB9O1xuXG4gIC8vIE1hcmsgdGhpcyBub2RlIGFzIGJlaW5nIHRoZSBzZWxlY3RlZCBub2RlLlxuICBOb2RlVmlld0Rlc2MucHJvdG90eXBlLnNlbGVjdE5vZGUgPSBmdW5jdGlvbiBzZWxlY3ROb2RlICgpIHtcbiAgICB0aGlzLm5vZGVET00uY2xhc3NMaXN0LmFkZChcIlByb3NlTWlycm9yLXNlbGVjdGVkbm9kZVwiKTtcbiAgICBpZiAodGhpcy5jb250ZW50RE9NIHx8ICF0aGlzLm5vZGUudHlwZS5zcGVjLmRyYWdnYWJsZSkgeyB0aGlzLmRvbS5kcmFnZ2FibGUgPSB0cnVlOyB9XG4gIH07XG5cbiAgLy8gUmVtb3ZlIHNlbGVjdGVkIG5vZGUgbWFya2luZyBmcm9tIHRoaXMgbm9kZS5cbiAgTm9kZVZpZXdEZXNjLnByb3RvdHlwZS5kZXNlbGVjdE5vZGUgPSBmdW5jdGlvbiBkZXNlbGVjdE5vZGUgKCkge1xuICAgIHRoaXMubm9kZURPTS5jbGFzc0xpc3QucmVtb3ZlKFwiUHJvc2VNaXJyb3Itc2VsZWN0ZWRub2RlXCIpO1xuICAgIGlmICh0aGlzLmNvbnRlbnRET00gfHwgIXRoaXMubm9kZS50eXBlLnNwZWMuZHJhZ2dhYmxlKSB7IHRoaXMuZG9tLnJlbW92ZUF0dHJpYnV0ZShcImRyYWdnYWJsZVwiKTsgfVxuICB9O1xuXG4gIHByb3RvdHlwZUFjY2Vzc29ycyQzLmRvbUF0b20uZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5ub2RlLmlzQXRvbSB9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBOb2RlVmlld0Rlc2MucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMkMyApO1xuXG4gIHJldHVybiBOb2RlVmlld0Rlc2M7XG59KFZpZXdEZXNjKSk7XG5cbi8vIENyZWF0ZSBhIHZpZXcgZGVzYyBmb3IgdGhlIHRvcC1sZXZlbCBkb2N1bWVudCBub2RlLCB0byBiZSBleHBvcnRlZFxuLy8gYW5kIHVzZWQgYnkgdGhlIHZpZXcgY2xhc3MuXG5mdW5jdGlvbiBkb2NWaWV3RGVzYyhkb2MsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBkb20sIHZpZXcpIHtcbiAgYXBwbHlPdXRlckRlY28oZG9tLCBvdXRlckRlY28sIGRvYyk7XG4gIHJldHVybiBuZXcgTm9kZVZpZXdEZXNjKG51bGwsIGRvYywgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgZG9tLCBkb20sIHZpZXcsIDApXG59XG5cbnZhciBUZXh0Vmlld0Rlc2MgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChOb2RlVmlld0Rlc2MpIHtcbiAgZnVuY3Rpb24gVGV4dFZpZXdEZXNjKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgbm9kZURPTSwgdmlldykge1xuICAgIE5vZGVWaWV3RGVzYy5jYWxsKHRoaXMsIHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgbnVsbCwgbm9kZURPTSwgdmlldyk7XG4gIH1cblxuICBpZiAoIE5vZGVWaWV3RGVzYyApIFRleHRWaWV3RGVzYy5fX3Byb3RvX18gPSBOb2RlVmlld0Rlc2M7XG4gIFRleHRWaWV3RGVzYy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBOb2RlVmlld0Rlc2MgJiYgTm9kZVZpZXdEZXNjLnByb3RvdHlwZSApO1xuICBUZXh0Vmlld0Rlc2MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVGV4dFZpZXdEZXNjO1xuXG4gIHZhciBwcm90b3R5cGVBY2Nlc3NvcnMkNCA9IHsgZG9tQXRvbTogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG4gIFRleHRWaWV3RGVzYy5wcm90b3R5cGUucGFyc2VSdWxlID0gZnVuY3Rpb24gcGFyc2VSdWxlICgpIHtcbiAgICB2YXIgc2tpcCA9IHRoaXMubm9kZURPTS5wYXJlbnROb2RlO1xuICAgIHdoaWxlIChza2lwICYmIHNraXAgIT0gdGhpcy5kb20gJiYgIXNraXAucG1Jc0RlY28pIHsgc2tpcCA9IHNraXAucGFyZW50Tm9kZTsgfVxuICAgIHJldHVybiB7c2tpcDogc2tpcCB8fCB0cnVlfVxuICB9O1xuXG4gIFRleHRWaWV3RGVzYy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlIChub2RlLCBvdXRlckRlY28sIF8sIHZpZXcpIHtcbiAgICBpZiAodGhpcy5kaXJ0eSA9PSBOT0RFX0RJUlRZIHx8ICh0aGlzLmRpcnR5ICE9IE5PVF9ESVJUWSAmJiAhdGhpcy5pblBhcmVudCgpKSB8fFxuICAgICAgICAhbm9kZS5zYW1lTWFya3VwKHRoaXMubm9kZSkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICB0aGlzLnVwZGF0ZU91dGVyRGVjbyhvdXRlckRlY28pO1xuICAgIGlmICgodGhpcy5kaXJ0eSAhPSBOT1RfRElSVFkgfHwgbm9kZS50ZXh0ICE9IHRoaXMubm9kZS50ZXh0KSAmJiBub2RlLnRleHQgIT0gdGhpcy5ub2RlRE9NLm5vZGVWYWx1ZSkge1xuICAgICAgdGhpcy5ub2RlRE9NLm5vZGVWYWx1ZSA9IG5vZGUudGV4dDtcbiAgICAgIGlmICh2aWV3LnRyYWNrV3JpdGVzID09IHRoaXMubm9kZURPTSkgeyB2aWV3LnRyYWNrV3JpdGVzID0gbnVsbDsgfVxuICAgIH1cbiAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgIHRoaXMuZGlydHkgPSBOT1RfRElSVFk7XG4gICAgcmV0dXJuIHRydWVcbiAgfTtcblxuICBUZXh0Vmlld0Rlc2MucHJvdG90eXBlLmluUGFyZW50ID0gZnVuY3Rpb24gaW5QYXJlbnQgKCkge1xuICAgIHZhciBwYXJlbnRET00gPSB0aGlzLnBhcmVudC5jb250ZW50RE9NO1xuICAgIGZvciAodmFyIG4gPSB0aGlzLm5vZGVET007IG47IG4gPSBuLnBhcmVudE5vZGUpIHsgaWYgKG4gPT0gcGFyZW50RE9NKSB7IHJldHVybiB0cnVlIH0gfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIFRleHRWaWV3RGVzYy5wcm90b3R5cGUuZG9tRnJvbVBvcyA9IGZ1bmN0aW9uIGRvbUZyb21Qb3MgKHBvcykge1xuICAgIHJldHVybiB7bm9kZTogdGhpcy5ub2RlRE9NLCBvZmZzZXQ6IHBvc31cbiAgfTtcblxuICBUZXh0Vmlld0Rlc2MucHJvdG90eXBlLmxvY2FsUG9zRnJvbURPTSA9IGZ1bmN0aW9uIGxvY2FsUG9zRnJvbURPTSAoZG9tLCBvZmZzZXQsIGJpYXMpIHtcbiAgICBpZiAoZG9tID09IHRoaXMubm9kZURPTSkgeyByZXR1cm4gdGhpcy5wb3NBdFN0YXJ0ICsgTWF0aC5taW4ob2Zmc2V0LCB0aGlzLm5vZGUudGV4dC5sZW5ndGgpIH1cbiAgICByZXR1cm4gTm9kZVZpZXdEZXNjLnByb3RvdHlwZS5sb2NhbFBvc0Zyb21ET00uY2FsbCh0aGlzLCBkb20sIG9mZnNldCwgYmlhcylcbiAgfTtcblxuICBUZXh0Vmlld0Rlc2MucHJvdG90eXBlLmlnbm9yZU11dGF0aW9uID0gZnVuY3Rpb24gaWdub3JlTXV0YXRpb24gKG11dGF0aW9uKSB7XG4gICAgcmV0dXJuIG11dGF0aW9uLnR5cGUgIT0gXCJjaGFyYWN0ZXJEYXRhXCIgJiYgbXV0YXRpb24udHlwZSAhPSBcInNlbGVjdGlvblwiXG4gIH07XG5cbiAgVGV4dFZpZXdEZXNjLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChmcm9tLCB0bywgdmlldykge1xuICAgIHZhciBub2RlID0gdGhpcy5ub2RlLmN1dChmcm9tLCB0byksIGRvbSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG5vZGUudGV4dCk7XG4gICAgcmV0dXJuIG5ldyBUZXh0Vmlld0Rlc2ModGhpcy5wYXJlbnQsIG5vZGUsIHRoaXMub3V0ZXJEZWNvLCB0aGlzLmlubmVyRGVjbywgZG9tLCBkb20sIHZpZXcpXG4gIH07XG5cbiAgVGV4dFZpZXdEZXNjLnByb3RvdHlwZS5tYXJrRGlydHkgPSBmdW5jdGlvbiBtYXJrRGlydHkgKGZyb20sIHRvKSB7XG4gICAgTm9kZVZpZXdEZXNjLnByb3RvdHlwZS5tYXJrRGlydHkuY2FsbCh0aGlzLCBmcm9tLCB0byk7XG4gICAgaWYgKHRoaXMuZG9tICE9IHRoaXMubm9kZURPTSAmJiAoZnJvbSA9PSAwIHx8IHRvID09IHRoaXMubm9kZURPTS5ub2RlVmFsdWUubGVuZ3RoKSlcbiAgICAgIHsgdGhpcy5kaXJ0eSA9IE5PREVfRElSVFk7IH1cbiAgfTtcblxuICBwcm90b3R5cGVBY2Nlc3NvcnMkNC5kb21BdG9tLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlIH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFRleHRWaWV3RGVzYy5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyQ0ICk7XG5cbiAgcmV0dXJuIFRleHRWaWV3RGVzYztcbn0oTm9kZVZpZXdEZXNjKSk7XG5cbi8vIEEgZHVtbXkgZGVzYyB1c2VkIHRvIHRhZyB0cmFpbGluZyBCUiBvciBJTUcgbm9kZXMgY3JlYXRlZCB0byB3b3JrXG4vLyBhcm91bmQgY29udGVudEVkaXRhYmxlIHRlcnJpYmxlbmVzcy5cbnZhciBUcmFpbGluZ0hhY2tWaWV3RGVzYyA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFZpZXdEZXNjKSB7XG4gIGZ1bmN0aW9uIFRyYWlsaW5nSGFja1ZpZXdEZXNjICgpIHtcbiAgICBWaWV3RGVzYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgaWYgKCBWaWV3RGVzYyApIFRyYWlsaW5nSGFja1ZpZXdEZXNjLl9fcHJvdG9fXyA9IFZpZXdEZXNjO1xuICBUcmFpbGluZ0hhY2tWaWV3RGVzYy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBWaWV3RGVzYyAmJiBWaWV3RGVzYy5wcm90b3R5cGUgKTtcbiAgVHJhaWxpbmdIYWNrVmlld0Rlc2MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVHJhaWxpbmdIYWNrVmlld0Rlc2M7XG5cbiAgdmFyIHByb3RvdHlwZUFjY2Vzc29ycyQ1ID0geyBkb21BdG9tOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGlnbm9yZUZvckNvb3JkczogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG4gIFRyYWlsaW5nSGFja1ZpZXdEZXNjLnByb3RvdHlwZS5wYXJzZVJ1bGUgPSBmdW5jdGlvbiBwYXJzZVJ1bGUgKCkgeyByZXR1cm4ge2lnbm9yZTogdHJ1ZX0gfTtcbiAgVHJhaWxpbmdIYWNrVmlld0Rlc2MucHJvdG90eXBlLm1hdGNoZXNIYWNrID0gZnVuY3Rpb24gbWF0Y2hlc0hhY2sgKG5vZGVOYW1lKSB7IHJldHVybiB0aGlzLmRpcnR5ID09IE5PVF9ESVJUWSAmJiB0aGlzLmRvbS5ub2RlTmFtZSA9PSBub2RlTmFtZSB9O1xuICBwcm90b3R5cGVBY2Nlc3NvcnMkNS5kb21BdG9tLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWUgfTtcbiAgcHJvdG90eXBlQWNjZXNzb3JzJDUuaWdub3JlRm9yQ29vcmRzLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZG9tLm5vZGVOYW1lID09IFwiSU1HXCIgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggVHJhaWxpbmdIYWNrVmlld0Rlc2MucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMkNSApO1xuXG4gIHJldHVybiBUcmFpbGluZ0hhY2tWaWV3RGVzYztcbn0oVmlld0Rlc2MpKTtcblxuLy8gQSBzZXBhcmF0ZSBzdWJjbGFzcyBpcyB1c2VkIGZvciBjdXN0b21pemVkIG5vZGUgdmlld3MsIHNvIHRoYXQgdGhlXG4vLyBleHRyYSBjaGVja3Mgb25seSBoYXZlIHRvIGJlIG1hZGUgZm9yIG5vZGVzIHRoYXQgYXJlIGFjdHVhbGx5XG4vLyBjdXN0b21pemVkLlxudmFyIEN1c3RvbU5vZGVWaWV3RGVzYyA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKE5vZGVWaWV3RGVzYykge1xuICBmdW5jdGlvbiBDdXN0b21Ob2RlVmlld0Rlc2MocGFyZW50LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCBjb250ZW50RE9NLCBub2RlRE9NLCBzcGVjLCB2aWV3LCBwb3MpIHtcbiAgICBOb2RlVmlld0Rlc2MuY2FsbCh0aGlzLCBwYXJlbnQsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBkb20sIGNvbnRlbnRET00sIG5vZGVET00sIHZpZXcsIHBvcyk7XG4gICAgdGhpcy5zcGVjID0gc3BlYztcbiAgfVxuXG4gIGlmICggTm9kZVZpZXdEZXNjICkgQ3VzdG9tTm9kZVZpZXdEZXNjLl9fcHJvdG9fXyA9IE5vZGVWaWV3RGVzYztcbiAgQ3VzdG9tTm9kZVZpZXdEZXNjLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE5vZGVWaWV3RGVzYyAmJiBOb2RlVmlld0Rlc2MucHJvdG90eXBlICk7XG4gIEN1c3RvbU5vZGVWaWV3RGVzYy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDdXN0b21Ob2RlVmlld0Rlc2M7XG5cbiAgLy8gQSBjdXN0b20gYHVwZGF0ZWAgbWV0aG9kIGdldHMgdG8gZGVjaWRlIHdoZXRoZXIgdGhlIHVwZGF0ZSBnb2VzXG4gIC8vIHRocm91Z2guIElmIGl0IGRvZXMsIGFuZCB0aGVyZSdzIGEgYGNvbnRlbnRET01gIG5vZGUsIG91ciBsb2dpY1xuICAvLyB1cGRhdGVzIHRoZSBjaGlsZHJlbi5cbiAgQ3VzdG9tTm9kZVZpZXdEZXNjLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3KSB7XG4gICAgaWYgKHRoaXMuZGlydHkgPT0gTk9ERV9ESVJUWSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIGlmICh0aGlzLnNwZWMudXBkYXRlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdGhpcy5zcGVjLnVwZGF0ZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbyk7XG4gICAgICBpZiAocmVzdWx0KSB7IHRoaXMudXBkYXRlSW5uZXIobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcpOyB9XG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfSBlbHNlIGlmICghdGhpcy5jb250ZW50RE9NICYmICFub2RlLmlzTGVhZikge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBOb2RlVmlld0Rlc2MucHJvdG90eXBlLnVwZGF0ZS5jYWxsKHRoaXMsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3KVxuICAgIH1cbiAgfTtcblxuICBDdXN0b21Ob2RlVmlld0Rlc2MucHJvdG90eXBlLnNlbGVjdE5vZGUgPSBmdW5jdGlvbiBzZWxlY3ROb2RlICgpIHtcbiAgICB0aGlzLnNwZWMuc2VsZWN0Tm9kZSA/IHRoaXMuc3BlYy5zZWxlY3ROb2RlKCkgOiBOb2RlVmlld0Rlc2MucHJvdG90eXBlLnNlbGVjdE5vZGUuY2FsbCh0aGlzKTtcbiAgfTtcblxuICBDdXN0b21Ob2RlVmlld0Rlc2MucHJvdG90eXBlLmRlc2VsZWN0Tm9kZSA9IGZ1bmN0aW9uIGRlc2VsZWN0Tm9kZSAoKSB7XG4gICAgdGhpcy5zcGVjLmRlc2VsZWN0Tm9kZSA/IHRoaXMuc3BlYy5kZXNlbGVjdE5vZGUoKSA6IE5vZGVWaWV3RGVzYy5wcm90b3R5cGUuZGVzZWxlY3ROb2RlLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgQ3VzdG9tTm9kZVZpZXdEZXNjLnByb3RvdHlwZS5zZXRTZWxlY3Rpb24gPSBmdW5jdGlvbiBzZXRTZWxlY3Rpb24gKGFuY2hvciwgaGVhZCwgcm9vdCwgZm9yY2UpIHtcbiAgICB0aGlzLnNwZWMuc2V0U2VsZWN0aW9uID8gdGhpcy5zcGVjLnNldFNlbGVjdGlvbihhbmNob3IsIGhlYWQsIHJvb3QpXG4gICAgICA6IE5vZGVWaWV3RGVzYy5wcm90b3R5cGUuc2V0U2VsZWN0aW9uLmNhbGwodGhpcywgYW5jaG9yLCBoZWFkLCByb290LCBmb3JjZSk7XG4gIH07XG5cbiAgQ3VzdG9tTm9kZVZpZXdEZXNjLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSAoKSB7XG4gICAgaWYgKHRoaXMuc3BlYy5kZXN0cm95KSB7IHRoaXMuc3BlYy5kZXN0cm95KCk7IH1cbiAgICBOb2RlVmlld0Rlc2MucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgfTtcblxuICBDdXN0b21Ob2RlVmlld0Rlc2MucHJvdG90eXBlLnN0b3BFdmVudCA9IGZ1bmN0aW9uIHN0b3BFdmVudCAoZXZlbnQpIHtcbiAgICByZXR1cm4gdGhpcy5zcGVjLnN0b3BFdmVudCA/IHRoaXMuc3BlYy5zdG9wRXZlbnQoZXZlbnQpIDogZmFsc2VcbiAgfTtcblxuICBDdXN0b21Ob2RlVmlld0Rlc2MucHJvdG90eXBlLmlnbm9yZU11dGF0aW9uID0gZnVuY3Rpb24gaWdub3JlTXV0YXRpb24gKG11dGF0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuc3BlYy5pZ25vcmVNdXRhdGlvbiA/IHRoaXMuc3BlYy5pZ25vcmVNdXRhdGlvbihtdXRhdGlvbikgOiBOb2RlVmlld0Rlc2MucHJvdG90eXBlLmlnbm9yZU11dGF0aW9uLmNhbGwodGhpcywgbXV0YXRpb24pXG4gIH07XG5cbiAgcmV0dXJuIEN1c3RvbU5vZGVWaWV3RGVzYztcbn0oTm9kZVZpZXdEZXNjKSk7XG5cbi8vIDogKGRvbS5Ob2RlLCBbVmlld0Rlc2NdKVxuLy8gU3luYyB0aGUgY29udGVudCBvZiB0aGUgZ2l2ZW4gRE9NIG5vZGUgd2l0aCB0aGUgbm9kZXMgYXNzb2NpYXRlZFxuLy8gd2l0aCB0aGUgZ2l2ZW4gYXJyYXkgb2YgdmlldyBkZXNjcywgcmVjdXJzaW5nIGludG8gbWFyayBkZXNjc1xuLy8gYmVjYXVzZSB0aGlzIHNob3VsZCBzeW5jIHRoZSBzdWJ0cmVlIGZvciBhIHdob2xlIG5vZGUgYXQgYSB0aW1lLlxuZnVuY3Rpb24gcmVuZGVyRGVzY3MocGFyZW50RE9NLCBkZXNjcywgdmlldykge1xuICB2YXIgZG9tID0gcGFyZW50RE9NLmZpcnN0Q2hpbGQsIHdyaXR0ZW4gPSBmYWxzZTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZXNjcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjID0gZGVzY3NbaV0sIGNoaWxkRE9NID0gZGVzYy5kb207XG4gICAgaWYgKGNoaWxkRE9NLnBhcmVudE5vZGUgPT0gcGFyZW50RE9NKSB7XG4gICAgICB3aGlsZSAoY2hpbGRET00gIT0gZG9tKSB7IGRvbSA9IHJtKGRvbSk7IHdyaXR0ZW4gPSB0cnVlOyB9XG4gICAgICBkb20gPSBkb20ubmV4dFNpYmxpbmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdyaXR0ZW4gPSB0cnVlO1xuICAgICAgcGFyZW50RE9NLmluc2VydEJlZm9yZShjaGlsZERPTSwgZG9tKTtcbiAgICB9XG4gICAgaWYgKGRlc2MgaW5zdGFuY2VvZiBNYXJrVmlld0Rlc2MpIHtcbiAgICAgIHZhciBwb3MgPSBkb20gPyBkb20ucHJldmlvdXNTaWJsaW5nIDogcGFyZW50RE9NLmxhc3RDaGlsZDtcbiAgICAgIHJlbmRlckRlc2NzKGRlc2MuY29udGVudERPTSwgZGVzYy5jaGlsZHJlbiwgdmlldyk7XG4gICAgICBkb20gPSBwb3MgPyBwb3MubmV4dFNpYmxpbmcgOiBwYXJlbnRET00uZmlyc3RDaGlsZDtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKGRvbSkgeyBkb20gPSBybShkb20pOyB3cml0dGVuID0gdHJ1ZTsgfVxuICBpZiAod3JpdHRlbiAmJiB2aWV3LnRyYWNrV3JpdGVzID09IHBhcmVudERPTSkgeyB2aWV3LnRyYWNrV3JpdGVzID0gbnVsbDsgfVxufVxuXG5mdW5jdGlvbiBPdXRlckRlY29MZXZlbChub2RlTmFtZSkge1xuICBpZiAobm9kZU5hbWUpIHsgdGhpcy5ub2RlTmFtZSA9IG5vZGVOYW1lOyB9XG59XG5PdXRlckRlY29MZXZlbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG52YXIgbm9EZWNvID0gW25ldyBPdXRlckRlY29MZXZlbF07XG5cbmZ1bmN0aW9uIGNvbXB1dGVPdXRlckRlY28ob3V0ZXJEZWNvLCBub2RlLCBuZWVkc1dyYXApIHtcbiAgaWYgKG91dGVyRGVjby5sZW5ndGggPT0gMCkgeyByZXR1cm4gbm9EZWNvIH1cblxuICB2YXIgdG9wID0gbmVlZHNXcmFwID8gbm9EZWNvWzBdIDogbmV3IE91dGVyRGVjb0xldmVsLCByZXN1bHQgPSBbdG9wXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG91dGVyRGVjby5sZW5ndGg7IGkrKykge1xuICAgIHZhciBhdHRycyA9IG91dGVyRGVjb1tpXS50eXBlLmF0dHJzO1xuICAgIGlmICghYXR0cnMpIHsgY29udGludWUgfVxuICAgIGlmIChhdHRycy5ub2RlTmFtZSlcbiAgICAgIHsgcmVzdWx0LnB1c2godG9wID0gbmV3IE91dGVyRGVjb0xldmVsKGF0dHJzLm5vZGVOYW1lKSk7IH1cblxuICAgIGZvciAodmFyIG5hbWUgaW4gYXR0cnMpIHtcbiAgICAgIHZhciB2YWwgPSBhdHRyc1tuYW1lXTtcbiAgICAgIGlmICh2YWwgPT0gbnVsbCkgeyBjb250aW51ZSB9XG4gICAgICBpZiAobmVlZHNXcmFwICYmIHJlc3VsdC5sZW5ndGggPT0gMSlcbiAgICAgICAgeyByZXN1bHQucHVzaCh0b3AgPSBuZXcgT3V0ZXJEZWNvTGV2ZWwobm9kZS5pc0lubGluZSA/IFwic3BhblwiIDogXCJkaXZcIikpOyB9XG4gICAgICBpZiAobmFtZSA9PSBcImNsYXNzXCIpIHsgdG9wLmNsYXNzID0gKHRvcC5jbGFzcyA/IHRvcC5jbGFzcyArIFwiIFwiIDogXCJcIikgKyB2YWw7IH1cbiAgICAgIGVsc2UgaWYgKG5hbWUgPT0gXCJzdHlsZVwiKSB7IHRvcC5zdHlsZSA9ICh0b3Auc3R5bGUgPyB0b3Auc3R5bGUgKyBcIjtcIiA6IFwiXCIpICsgdmFsOyB9XG4gICAgICBlbHNlIGlmIChuYW1lICE9IFwibm9kZU5hbWVcIikgeyB0b3BbbmFtZV0gPSB2YWw7IH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIHBhdGNoT3V0ZXJEZWNvKG91dGVyRE9NLCBub2RlRE9NLCBwcmV2Q29tcHV0ZWQsIGN1ckNvbXB1dGVkKSB7XG4gIC8vIFNob3J0Y3V0IGZvciB0cml2aWFsIGNhc2VcbiAgaWYgKHByZXZDb21wdXRlZCA9PSBub0RlY28gJiYgY3VyQ29tcHV0ZWQgPT0gbm9EZWNvKSB7IHJldHVybiBub2RlRE9NIH1cblxuICB2YXIgY3VyRE9NID0gbm9kZURPTTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdXJDb21wdXRlZC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZWNvID0gY3VyQ29tcHV0ZWRbaV0sIHByZXYgPSBwcmV2Q29tcHV0ZWRbaV07XG4gICAgaWYgKGkpIHtcbiAgICAgIHZhciBwYXJlbnQgPSAodm9pZCAwKTtcbiAgICAgIGlmIChwcmV2ICYmIHByZXYubm9kZU5hbWUgPT0gZGVjby5ub2RlTmFtZSAmJiBjdXJET00gIT0gb3V0ZXJET00gJiZcbiAgICAgICAgICAocGFyZW50ID0gY3VyRE9NLnBhcmVudE5vZGUpICYmIHBhcmVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT0gZGVjby5ub2RlTmFtZSkge1xuICAgICAgICBjdXJET00gPSBwYXJlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGRlY28ubm9kZU5hbWUpO1xuICAgICAgICBwYXJlbnQucG1Jc0RlY28gPSB0cnVlO1xuICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoY3VyRE9NKTtcbiAgICAgICAgcHJldiA9IG5vRGVjb1swXTtcbiAgICAgICAgY3VyRE9NID0gcGFyZW50O1xuICAgICAgfVxuICAgIH1cbiAgICBwYXRjaEF0dHJpYnV0ZXMoY3VyRE9NLCBwcmV2IHx8IG5vRGVjb1swXSwgZGVjbyk7XG4gIH1cbiAgcmV0dXJuIGN1ckRPTVxufVxuXG5mdW5jdGlvbiBwYXRjaEF0dHJpYnV0ZXMoZG9tLCBwcmV2LCBjdXIpIHtcbiAgZm9yICh2YXIgbmFtZSBpbiBwcmV2KVxuICAgIHsgaWYgKG5hbWUgIT0gXCJjbGFzc1wiICYmIG5hbWUgIT0gXCJzdHlsZVwiICYmIG5hbWUgIT0gXCJub2RlTmFtZVwiICYmICEobmFtZSBpbiBjdXIpKVxuICAgICAgeyBkb20ucmVtb3ZlQXR0cmlidXRlKG5hbWUpOyB9IH1cbiAgZm9yICh2YXIgbmFtZSQxIGluIGN1cilcbiAgICB7IGlmIChuYW1lJDEgIT0gXCJjbGFzc1wiICYmIG5hbWUkMSAhPSBcInN0eWxlXCIgJiYgbmFtZSQxICE9IFwibm9kZU5hbWVcIiAmJiBjdXJbbmFtZSQxXSAhPSBwcmV2W25hbWUkMV0pXG4gICAgICB7IGRvbS5zZXRBdHRyaWJ1dGUobmFtZSQxLCBjdXJbbmFtZSQxXSk7IH0gfVxuICBpZiAocHJldi5jbGFzcyAhPSBjdXIuY2xhc3MpIHtcbiAgICB2YXIgcHJldkxpc3QgPSBwcmV2LmNsYXNzID8gcHJldi5jbGFzcy5zcGxpdChcIiBcIikuZmlsdGVyKEJvb2xlYW4pIDogbm90aGluZztcbiAgICB2YXIgY3VyTGlzdCA9IGN1ci5jbGFzcyA/IGN1ci5jbGFzcy5zcGxpdChcIiBcIikuZmlsdGVyKEJvb2xlYW4pIDogbm90aGluZztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByZXZMaXN0Lmxlbmd0aDsgaSsrKSB7IGlmIChjdXJMaXN0LmluZGV4T2YocHJldkxpc3RbaV0pID09IC0xKVxuICAgICAgeyBkb20uY2xhc3NMaXN0LnJlbW92ZShwcmV2TGlzdFtpXSk7IH0gfVxuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGN1ckxpc3QubGVuZ3RoOyBpJDErKykgeyBpZiAocHJldkxpc3QuaW5kZXhPZihjdXJMaXN0W2kkMV0pID09IC0xKVxuICAgICAgeyBkb20uY2xhc3NMaXN0LmFkZChjdXJMaXN0W2kkMV0pOyB9IH1cbiAgfVxuICBpZiAocHJldi5zdHlsZSAhPSBjdXIuc3R5bGUpIHtcbiAgICBpZiAocHJldi5zdHlsZSkge1xuICAgICAgdmFyIHByb3AgPSAvXFxzKihbXFx3XFwtXFx4YTEtXFx1ZmZmZl0rKVxccyo6KD86XCIoPzpcXFxcLnxbXlwiXSkqXCJ8Jyg/OlxcXFwufFteJ10pKid8XFwoLio/XFwpfFteO10pKi9nLCBtO1xuICAgICAgd2hpbGUgKG0gPSBwcm9wLmV4ZWMocHJldi5zdHlsZSkpXG4gICAgICAgIHsgZG9tLnN0eWxlLnJlbW92ZVByb3BlcnR5KG1bMV0pOyB9XG4gICAgfVxuICAgIGlmIChjdXIuc3R5bGUpXG4gICAgICB7IGRvbS5zdHlsZS5jc3NUZXh0ICs9IGN1ci5zdHlsZTsgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5T3V0ZXJEZWNvKGRvbSwgZGVjbywgbm9kZSkge1xuICByZXR1cm4gcGF0Y2hPdXRlckRlY28oZG9tLCBkb20sIG5vRGVjbywgY29tcHV0ZU91dGVyRGVjbyhkZWNvLCBub2RlLCBkb20ubm9kZVR5cGUgIT0gMSkpXG59XG5cbi8vIDogKFtEZWNvcmF0aW9uXSwgW0RlY29yYXRpb25dKSDihpIgYm9vbFxuZnVuY3Rpb24gc2FtZU91dGVyRGVjbyhhLCBiKSB7XG4gIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aCkgeyByZXR1cm4gZmFsc2UgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHsgaWYgKCFhW2ldLnR5cGUuZXEoYltpXS50eXBlKSkgeyByZXR1cm4gZmFsc2UgfSB9XG4gIHJldHVybiB0cnVlXG59XG5cbi8vIFJlbW92ZSBhIERPTSBub2RlIGFuZCByZXR1cm4gaXRzIG5leHQgc2libGluZy5cbmZ1bmN0aW9uIHJtKGRvbSkge1xuICB2YXIgbmV4dCA9IGRvbS5uZXh0U2libGluZztcbiAgZG9tLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZG9tKTtcbiAgcmV0dXJuIG5leHRcbn1cblxuLy8gSGVscGVyIGNsYXNzIGZvciBpbmNyZW1lbnRhbGx5IHVwZGF0aW5nIGEgdHJlZSBvZiBtYXJrIGRlc2NzIGFuZFxuLy8gdGhlIHdpZGdldCBhbmQgbm9kZSBkZXNjcyBpbnNpZGUgb2YgdGhlbS5cbnZhciBWaWV3VHJlZVVwZGF0ZXIgPSBmdW5jdGlvbiBWaWV3VHJlZVVwZGF0ZXIodG9wLCBsb2NrZWROb2RlKSB7XG4gIHRoaXMudG9wID0gdG9wO1xuICB0aGlzLmxvY2sgPSBsb2NrZWROb2RlO1xuICAvLyBJbmRleCBpbnRvIGB0aGlzLnRvcGAncyBjaGlsZCBhcnJheSwgcmVwcmVzZW50cyB0aGUgY3VycmVudFxuICAvLyB1cGRhdGUgcG9zaXRpb24uXG4gIHRoaXMuaW5kZXggPSAwO1xuICAvLyBXaGVuIGVudGVyaW5nIGEgbWFyaywgdGhlIGN1cnJlbnQgdG9wIGFuZCBpbmRleCBhcmUgcHVzaGVkXG4gIC8vIG9udG8gdGhpcy5cbiAgdGhpcy5zdGFjayA9IFtdO1xuICAvLyBUcmFja3Mgd2hldGhlciBhbnl0aGluZyB3YXMgY2hhbmdlZFxuICB0aGlzLmNoYW5nZWQgPSBmYWxzZTtcblxuICB0aGlzLnByZU1hdGNoID0gcHJlTWF0Y2godG9wLm5vZGUuY29udGVudCwgdG9wLmNoaWxkcmVuKTtcbn07XG5cbi8vIERlc3Ryb3kgYW5kIHJlbW92ZSB0aGUgY2hpbGRyZW4gYmV0d2VlbiB0aGUgZ2l2ZW4gaW5kaWNlcyBpblxuLy8gYHRoaXMudG9wYC5cblZpZXdUcmVlVXBkYXRlci5wcm90b3R5cGUuZGVzdHJveUJldHdlZW4gPSBmdW5jdGlvbiBkZXN0cm95QmV0d2VlbiAoc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT0gZW5kKSB7IHJldHVybiB9XG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7IHRoaXMudG9wLmNoaWxkcmVuW2ldLmRlc3Ryb3koKTsgfVxuICB0aGlzLnRvcC5jaGlsZHJlbi5zcGxpY2Uoc3RhcnQsIGVuZCAtIHN0YXJ0KTtcbiAgdGhpcy5jaGFuZ2VkID0gdHJ1ZTtcbn07XG5cbi8vIERlc3Ryb3kgYWxsIHJlbWFpbmluZyBjaGlsZHJlbiBpbiBgdGhpcy50b3BgLlxuVmlld1RyZWVVcGRhdGVyLnByb3RvdHlwZS5kZXN0cm95UmVzdCA9IGZ1bmN0aW9uIGRlc3Ryb3lSZXN0ICgpIHtcbiAgdGhpcy5kZXN0cm95QmV0d2Vlbih0aGlzLmluZGV4LCB0aGlzLnRvcC5jaGlsZHJlbi5sZW5ndGgpO1xufTtcblxuLy8gOiAoW01hcmtdLCBFZGl0b3JWaWV3KVxuLy8gU3luYyB0aGUgY3VycmVudCBzdGFjayBvZiBtYXJrIGRlc2NzIHdpdGggdGhlIGdpdmVuIGFycmF5IG9mXG4vLyBtYXJrcywgcmV1c2luZyBleGlzdGluZyBtYXJrIGRlc2NzIHdoZW4gcG9zc2libGUuXG5WaWV3VHJlZVVwZGF0ZXIucHJvdG90eXBlLnN5bmNUb01hcmtzID0gZnVuY3Rpb24gc3luY1RvTWFya3MgKG1hcmtzLCBpbmxpbmUsIHZpZXcpIHtcbiAgdmFyIGtlZXAgPSAwLCBkZXB0aCA9IHRoaXMuc3RhY2subGVuZ3RoID4+IDE7XG4gIHZhciBtYXhLZWVwID0gTWF0aC5taW4oZGVwdGgsIG1hcmtzLmxlbmd0aCk7XG4gIHdoaWxlIChrZWVwIDwgbWF4S2VlcCAmJlxuICAgICAgICAgKGtlZXAgPT0gZGVwdGggLSAxID8gdGhpcy50b3AgOiB0aGlzLnN0YWNrWyhrZWVwICsgMSkgPDwgMV0pLm1hdGNoZXNNYXJrKG1hcmtzW2tlZXBdKSAmJiBtYXJrc1trZWVwXS50eXBlLnNwZWMuc3Bhbm5pbmcgIT09IGZhbHNlKVxuICAgIHsga2VlcCsrOyB9XG5cbiAgd2hpbGUgKGtlZXAgPCBkZXB0aCkge1xuICAgIHRoaXMuZGVzdHJveVJlc3QoKTtcbiAgICB0aGlzLnRvcC5kaXJ0eSA9IE5PVF9ESVJUWTtcbiAgICB0aGlzLmluZGV4ID0gdGhpcy5zdGFjay5wb3AoKTtcbiAgICB0aGlzLnRvcCA9IHRoaXMuc3RhY2sucG9wKCk7XG4gICAgZGVwdGgtLTtcbiAgfVxuICB3aGlsZSAoZGVwdGggPCBtYXJrcy5sZW5ndGgpIHtcbiAgICB0aGlzLnN0YWNrLnB1c2godGhpcy50b3AsIHRoaXMuaW5kZXggKyAxKTtcbiAgICB2YXIgZm91bmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5pbmRleDsgaSA8IE1hdGgubWluKHRoaXMuaW5kZXggKyAzLCB0aGlzLnRvcC5jaGlsZHJlbi5sZW5ndGgpOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLnRvcC5jaGlsZHJlbltpXS5tYXRjaGVzTWFyayhtYXJrc1tkZXB0aF0pKSB7IGZvdW5kID0gaTsgYnJlYWsgfVxuICAgIH1cbiAgICBpZiAoZm91bmQgPiAtMSkge1xuICAgICAgaWYgKGZvdW5kID4gdGhpcy5pbmRleCkge1xuICAgICAgICB0aGlzLmNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmRlc3Ryb3lCZXR3ZWVuKHRoaXMuaW5kZXgsIGZvdW5kKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudG9wID0gdGhpcy50b3AuY2hpbGRyZW5bdGhpcy5pbmRleF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBtYXJrRGVzYyA9IE1hcmtWaWV3RGVzYy5jcmVhdGUodGhpcy50b3AsIG1hcmtzW2RlcHRoXSwgaW5saW5lLCB2aWV3KTtcbiAgICAgIHRoaXMudG9wLmNoaWxkcmVuLnNwbGljZSh0aGlzLmluZGV4LCAwLCBtYXJrRGVzYyk7XG4gICAgICB0aGlzLnRvcCA9IG1hcmtEZXNjO1xuICAgICAgdGhpcy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5pbmRleCA9IDA7XG4gICAgZGVwdGgrKztcbiAgfVxufTtcblxuLy8gOiAoTm9kZSwgW0RlY29yYXRpb25dLCBEZWNvcmF0aW9uU291cmNlKSDihpIgYm9vbFxuLy8gVHJ5IHRvIGZpbmQgYSBub2RlIGRlc2MgbWF0Y2hpbmcgdGhlIGdpdmVuIGRhdGEuIFNraXAgb3ZlciBpdCBhbmRcbi8vIHJldHVybiB0cnVlIHdoZW4gc3VjY2Vzc2Z1bC5cblZpZXdUcmVlVXBkYXRlci5wcm90b3R5cGUuZmluZE5vZGVNYXRjaCA9IGZ1bmN0aW9uIGZpbmROb2RlTWF0Y2ggKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBpbmRleCkge1xuICB2YXIgY2hpbGRyZW4gPSB0aGlzLnRvcC5jaGlsZHJlbiwgZm91bmQgPSAtMTtcbiAgaWYgKGluZGV4ID49IHRoaXMucHJlTWF0Y2guaW5kZXgpIHtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5pbmRleDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7IGlmIChjaGlsZHJlbltpXS5tYXRjaGVzTm9kZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbykpIHtcbiAgICAgIGZvdW5kID0gaTtcbiAgICAgIGJyZWFrXG4gICAgfSB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSQxID0gdGhpcy5pbmRleCwgZSA9IE1hdGgubWluKGNoaWxkcmVuLmxlbmd0aCwgaSQxICsgMSk7IGkkMSA8IGU7IGkkMSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpJDFdO1xuICAgICAgaWYgKGNoaWxkLm1hdGNoZXNOb2RlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvKSAmJiAhdGhpcy5wcmVNYXRjaC5tYXRjaGVkLmhhcyhjaGlsZCkpIHtcbiAgICAgICAgZm91bmQgPSBpJDE7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChmb3VuZCA8IDApIHsgcmV0dXJuIGZhbHNlIH1cbiAgdGhpcy5kZXN0cm95QmV0d2Vlbih0aGlzLmluZGV4LCBmb3VuZCk7XG4gIHRoaXMuaW5kZXgrKztcbiAgcmV0dXJuIHRydWVcbn07XG5cblZpZXdUcmVlVXBkYXRlci5wcm90b3R5cGUudXBkYXRlTm9kZUF0ID0gZnVuY3Rpb24gdXBkYXRlTm9kZUF0IChub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgaW5kZXgsIHZpZXcpIHtcbiAgdmFyIGNoaWxkID0gdGhpcy50b3AuY2hpbGRyZW5baW5kZXhdO1xuICBpZiAoIWNoaWxkLnVwZGF0ZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldykpIHsgcmV0dXJuIGZhbHNlIH1cbiAgdGhpcy5kZXN0cm95QmV0d2Vlbih0aGlzLmluZGV4LCBpbmRleCk7XG4gIHRoaXMuaW5kZXggPSBpbmRleCArIDE7XG4gIHJldHVybiB0cnVlXG59O1xuXG5WaWV3VHJlZVVwZGF0ZXIucHJvdG90eXBlLmZpbmRJbmRleFdpdGhDaGlsZCA9IGZ1bmN0aW9uIGZpbmRJbmRleFdpdGhDaGlsZCAoZG9tTm9kZSkge1xuICBmb3IgKDs7KSB7XG4gICAgdmFyIHBhcmVudCA9IGRvbU5vZGUucGFyZW50Tm9kZTtcbiAgICBpZiAoIXBhcmVudCkgeyByZXR1cm4gLTEgfVxuICAgIGlmIChwYXJlbnQgPT0gdGhpcy50b3AuY29udGVudERPTSkge1xuICAgICAgdmFyIGRlc2MgPSBkb21Ob2RlLnBtVmlld0Rlc2M7XG4gICAgICBpZiAoZGVzYykgeyBmb3IgKHZhciBpID0gdGhpcy5pbmRleDsgaSA8IHRoaXMudG9wLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLnRvcC5jaGlsZHJlbltpXSA9PSBkZXNjKSB7IHJldHVybiBpIH1cbiAgICAgIH0gfVxuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIGRvbU5vZGUgPSBwYXJlbnQ7XG4gIH1cbn07XG5cbi8vIDogKE5vZGUsIFtEZWNvcmF0aW9uXSwgRGVjb3JhdGlvblNvdXJjZSwgRWRpdG9yVmlldywgRnJhZ21lbnQsIG51bWJlcikg4oaSIGJvb2xcbi8vIFRyeSB0byB1cGRhdGUgdGhlIG5leHQgbm9kZSwgaWYgYW55LCB0byB0aGUgZ2l2ZW4gZGF0YS4gQ2hlY2tzXG4vLyBwcmUtbWF0Y2hlcyB0byBhdm9pZCBvdmVyd3JpdGluZyBub2RlcyB0aGF0IGNvdWxkIHN0aWxsIGJlIHVzZWQuXG5WaWV3VHJlZVVwZGF0ZXIucHJvdG90eXBlLnVwZGF0ZU5leHROb2RlID0gZnVuY3Rpb24gdXBkYXRlTmV4dE5vZGUgKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3LCBpbmRleCkge1xuICBmb3IgKHZhciBpID0gdGhpcy5pbmRleDsgaSA8IHRoaXMudG9wLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5leHQgPSB0aGlzLnRvcC5jaGlsZHJlbltpXTtcbiAgICBpZiAobmV4dCBpbnN0YW5jZW9mIE5vZGVWaWV3RGVzYykge1xuICAgICAgdmFyIHByZU1hdGNoID0gdGhpcy5wcmVNYXRjaC5tYXRjaGVkLmdldChuZXh0KTtcbiAgICAgIGlmIChwcmVNYXRjaCAhPSBudWxsICYmIHByZU1hdGNoICE9IGluZGV4KSB7IHJldHVybiBmYWxzZSB9XG4gICAgICB2YXIgbmV4dERPTSA9IG5leHQuZG9tO1xuXG4gICAgICAvLyBDYW4ndCB1cGRhdGUgaWYgbmV4dERPTSBpcyBvciBjb250YWlucyB0aGlzLmxvY2ssIGV4Y2VwdCBpZlxuICAgICAgLy8gaXQncyBhIHRleHQgbm9kZSB3aG9zZSBjb250ZW50IGFscmVhZHkgbWF0Y2hlcyB0aGUgbmV3IHRleHRcbiAgICAgIC8vIGFuZCB3aG9zZSBkZWNvcmF0aW9ucyBtYXRjaCB0aGUgbmV3IG9uZXMuXG4gICAgICB2YXIgbG9ja2VkID0gdGhpcy5sb2NrICYmIChuZXh0RE9NID09IHRoaXMubG9jayB8fCBuZXh0RE9NLm5vZGVUeXBlID09IDEgJiYgbmV4dERPTS5jb250YWlucyh0aGlzLmxvY2sucGFyZW50Tm9kZSkpICYmXG4gICAgICAgICAgIShub2RlLmlzVGV4dCAmJiBuZXh0Lm5vZGUgJiYgbmV4dC5ub2RlLmlzVGV4dCAmJiBuZXh0Lm5vZGVET00ubm9kZVZhbHVlID09IG5vZGUudGV4dCAmJlxuICAgICAgICAgICAgbmV4dC5kaXJ0eSAhPSBOT0RFX0RJUlRZICYmIHNhbWVPdXRlckRlY28ob3V0ZXJEZWNvLCBuZXh0Lm91dGVyRGVjbykpO1xuICAgICAgaWYgKCFsb2NrZWQgJiYgbmV4dC51cGRhdGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcpKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveUJldHdlZW4odGhpcy5pbmRleCwgaSk7XG4gICAgICAgIGlmIChuZXh0LmRvbSAhPSBuZXh0RE9NKSB7IHRoaXMuY2hhbmdlZCA9IHRydWU7IH1cbiAgICAgICAgdGhpcy5pbmRleCsrO1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyA6IChOb2RlLCBbRGVjb3JhdGlvbl0sIERlY29yYXRpb25Tb3VyY2UsIEVkaXRvclZpZXcpXG4vLyBJbnNlcnQgdGhlIG5vZGUgYXMgYSBuZXdseSBjcmVhdGVkIG5vZGUgZGVzYy5cblZpZXdUcmVlVXBkYXRlci5wcm90b3R5cGUuYWRkTm9kZSA9IGZ1bmN0aW9uIGFkZE5vZGUgKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3LCBwb3MpIHtcbiAgdGhpcy50b3AuY2hpbGRyZW4uc3BsaWNlKHRoaXMuaW5kZXgrKywgMCwgTm9kZVZpZXdEZXNjLmNyZWF0ZSh0aGlzLnRvcCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcsIHBvcykpO1xuICB0aGlzLmNoYW5nZWQgPSB0cnVlO1xufTtcblxuVmlld1RyZWVVcGRhdGVyLnByb3RvdHlwZS5wbGFjZVdpZGdldCA9IGZ1bmN0aW9uIHBsYWNlV2lkZ2V0ICh3aWRnZXQsIHZpZXcsIHBvcykge1xuICB2YXIgbmV4dCA9IHRoaXMuaW5kZXggPCB0aGlzLnRvcC5jaGlsZHJlbi5sZW5ndGggPyB0aGlzLnRvcC5jaGlsZHJlblt0aGlzLmluZGV4XSA6IG51bGw7XG4gIGlmIChuZXh0ICYmIG5leHQubWF0Y2hlc1dpZGdldCh3aWRnZXQpICYmICh3aWRnZXQgPT0gbmV4dC53aWRnZXQgfHwgIW5leHQud2lkZ2V0LnR5cGUudG9ET00ucGFyZW50Tm9kZSkpIHtcbiAgICB0aGlzLmluZGV4Kys7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGRlc2MgPSBuZXcgV2lkZ2V0Vmlld0Rlc2ModGhpcy50b3AsIHdpZGdldCwgdmlldywgcG9zKTtcbiAgICB0aGlzLnRvcC5jaGlsZHJlbi5zcGxpY2UodGhpcy5pbmRleCsrLCAwLCBkZXNjKTtcbiAgICB0aGlzLmNoYW5nZWQgPSB0cnVlO1xuICB9XG59O1xuXG4vLyBNYWtlIHN1cmUgYSB0ZXh0YmxvY2sgbG9va3MgYW5kIGJlaGF2ZXMgY29ycmVjdGx5IGluXG4vLyBjb250ZW50RWRpdGFibGUuXG5WaWV3VHJlZVVwZGF0ZXIucHJvdG90eXBlLmFkZFRleHRibG9ja0hhY2tzID0gZnVuY3Rpb24gYWRkVGV4dGJsb2NrSGFja3MgKCkge1xuICB2YXIgbGFzdENoaWxkID0gdGhpcy50b3AuY2hpbGRyZW5bdGhpcy5pbmRleCAtIDFdO1xuICB3aGlsZSAobGFzdENoaWxkIGluc3RhbmNlb2YgTWFya1ZpZXdEZXNjKSB7IGxhc3RDaGlsZCA9IGxhc3RDaGlsZC5jaGlsZHJlbltsYXN0Q2hpbGQuY2hpbGRyZW4ubGVuZ3RoIC0gMV07IH1cblxuICBpZiAoIWxhc3RDaGlsZCB8fCAvLyBFbXB0eSB0ZXh0YmxvY2tcbiAgICAgICEobGFzdENoaWxkIGluc3RhbmNlb2YgVGV4dFZpZXdEZXNjKSB8fFxuICAgICAgL1xcbiQvLnRlc3QobGFzdENoaWxkLm5vZGUudGV4dCkpIHtcbiAgICAvLyBBdm9pZCBidWdzIGluIFNhZmFyaSdzIGN1cnNvciBkcmF3aW5nICgjMTE2NSkgYW5kIENocm9tZSdzIG1vdXNlIHNlbGVjdGlvbiAoIzExNTIpXG4gICAgaWYgKChyZXN1bHQuc2FmYXJpIHx8IHJlc3VsdC5jaHJvbWUpICYmIGxhc3RDaGlsZCAmJiBsYXN0Q2hpbGQuZG9tLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpXG4gICAgICB7IHRoaXMuYWRkSGFja05vZGUoXCJJTUdcIik7IH1cbiAgICB0aGlzLmFkZEhhY2tOb2RlKFwiQlJcIik7XG4gIH1cbn07XG5cblZpZXdUcmVlVXBkYXRlci5wcm90b3R5cGUuYWRkSGFja05vZGUgPSBmdW5jdGlvbiBhZGRIYWNrTm9kZSAobm9kZU5hbWUpIHtcbiAgaWYgKHRoaXMuaW5kZXggPCB0aGlzLnRvcC5jaGlsZHJlbi5sZW5ndGggJiYgdGhpcy50b3AuY2hpbGRyZW5bdGhpcy5pbmRleF0ubWF0Y2hlc0hhY2sobm9kZU5hbWUpKSB7XG4gICAgdGhpcy5pbmRleCsrO1xuICB9IGVsc2Uge1xuICAgIHZhciBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5vZGVOYW1lKTtcbiAgICBpZiAobm9kZU5hbWUgPT0gXCJJTUdcIikgeyBkb20uY2xhc3NOYW1lID0gXCJQcm9zZU1pcnJvci1zZXBhcmF0b3JcIjsgfVxuICAgIGlmIChub2RlTmFtZSA9PSBcIkJSXCIpIHsgZG9tLmNsYXNzTmFtZSA9IFwiUHJvc2VNaXJyb3ItdHJhaWxpbmdCcmVha1wiOyB9XG4gICAgdGhpcy50b3AuY2hpbGRyZW4uc3BsaWNlKHRoaXMuaW5kZXgrKywgMCwgbmV3IFRyYWlsaW5nSGFja1ZpZXdEZXNjKHRoaXMudG9wLCBub3RoaW5nLCBkb20sIG51bGwpKTtcbiAgICB0aGlzLmNoYW5nZWQgPSB0cnVlO1xuICB9XG59O1xuXG4vLyA6IChGcmFnbWVudCwgW1ZpZXdEZXNjXSkg4oaSIHtpbmRleDogbnVtYmVyLCBtYXRjaGVkOiBNYXA8Vmlld0Rlc2MsIG51bWJlcj59XG4vLyBJdGVyYXRlIGZyb20gdGhlIGVuZCBvZiB0aGUgZnJhZ21lbnQgYW5kIGFycmF5IG9mIGRlc2NzIHRvIGZpbmRcbi8vIGRpcmVjdGx5IG1hdGNoaW5nIG9uZXMsIGluIG9yZGVyIHRvIGF2b2lkIG92ZXJlYWdlcmx5IHJldXNpbmcgdGhvc2Vcbi8vIGZvciBvdGhlciBub2Rlcy4gUmV0dXJucyB0aGUgZnJhZ21lbnQgaW5kZXggb2YgdGhlIGZpcnN0IG5vZGUgdGhhdFxuLy8gaXMgcGFydCBvZiB0aGUgc2VxdWVuY2Ugb2YgbWF0Y2hlZCBub2RlcyBhdCB0aGUgZW5kIG9mIHRoZVxuLy8gZnJhZ21lbnQuXG5mdW5jdGlvbiBwcmVNYXRjaChmcmFnLCBkZXNjcykge1xuICB2YXIgZkkgPSBmcmFnLmNoaWxkQ291bnQsIGRJID0gZGVzY3MubGVuZ3RoLCBtYXRjaGVkID0gbmV3IE1hcDtcbiAgZm9yICg7IGZJID4gMCAmJiBkSSA+IDA7IGRJLS0pIHtcbiAgICB2YXIgZGVzYyA9IGRlc2NzW2RJIC0gMV0sIG5vZGUgPSBkZXNjLm5vZGU7XG4gICAgaWYgKCFub2RlKSB7IGNvbnRpbnVlIH1cbiAgICBpZiAobm9kZSAhPSBmcmFnLmNoaWxkKGZJIC0gMSkpIHsgYnJlYWsgfVxuICAgIC0tZkk7XG4gICAgbWF0Y2hlZC5zZXQoZGVzYywgZkkpO1xuICB9XG4gIHJldHVybiB7aW5kZXg6IGZJLCBtYXRjaGVkOiBtYXRjaGVkfVxufVxuXG5mdW5jdGlvbiBjb21wYXJlU2lkZShhLCBiKSB7IHJldHVybiBhLnR5cGUuc2lkZSAtIGIudHlwZS5zaWRlIH1cblxuLy8gOiAoVmlld0Rlc2MsIERlY29yYXRpb25Tb3VyY2UsIChEZWNvcmF0aW9uLCBudW1iZXIpLCAoTm9kZSwgW0RlY29yYXRpb25dLCBEZWNvcmF0aW9uU291cmNlLCBudW1iZXIpKVxuLy8gVGhpcyBmdW5jdGlvbiBhYnN0cmFjdHMgaXRlcmF0aW5nIG92ZXIgdGhlIG5vZGVzIGFuZCBkZWNvcmF0aW9ucyBpblxuLy8gYSBmcmFnbWVudC4gQ2FsbHMgYG9uTm9kZWAgZm9yIGVhY2ggbm9kZSwgd2l0aCBpdHMgbG9jYWwgYW5kIGNoaWxkXG4vLyBkZWNvcmF0aW9ucy4gU3BsaXRzIHRleHQgbm9kZXMgd2hlbiB0aGVyZSBpcyBhIGRlY29yYXRpb24gc3RhcnRpbmdcbi8vIG9yIGVuZGluZyBpbnNpZGUgb2YgdGhlbS4gQ2FsbHMgYG9uV2lkZ2V0YCBmb3IgZWFjaCB3aWRnZXQuXG5mdW5jdGlvbiBpdGVyRGVjbyhwYXJlbnQsIGRlY28sIG9uV2lkZ2V0LCBvbk5vZGUpIHtcbiAgdmFyIGxvY2FscyA9IGRlY28ubG9jYWxzKHBhcmVudCksIG9mZnNldCA9IDA7XG4gIC8vIFNpbXBsZSwgY2hlYXAgdmFyaWFudCBmb3Igd2hlbiB0aGVyZSBhcmUgbm8gbG9jYWwgZGVjb3JhdGlvbnNcbiAgaWYgKGxvY2Fscy5sZW5ndGggPT0gMCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyZW50LmNoaWxkQ291bnQ7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gcGFyZW50LmNoaWxkKGkpO1xuICAgICAgb25Ob2RlKGNoaWxkLCBsb2NhbHMsIGRlY28uZm9yQ2hpbGQob2Zmc2V0LCBjaGlsZCksIGkpO1xuICAgICAgb2Zmc2V0ICs9IGNoaWxkLm5vZGVTaXplO1xuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBkZWNvSW5kZXggPSAwLCBhY3RpdmUgPSBbXSwgcmVzdE5vZGUgPSBudWxsO1xuICBmb3IgKHZhciBwYXJlbnRJbmRleCA9IDA7Oykge1xuICAgIGlmIChkZWNvSW5kZXggPCBsb2NhbHMubGVuZ3RoICYmIGxvY2Fsc1tkZWNvSW5kZXhdLnRvID09IG9mZnNldCkge1xuICAgICAgdmFyIHdpZGdldCA9IGxvY2Fsc1tkZWNvSW5kZXgrK10sIHdpZGdldHMgPSAodm9pZCAwKTtcbiAgICAgIHdoaWxlIChkZWNvSW5kZXggPCBsb2NhbHMubGVuZ3RoICYmIGxvY2Fsc1tkZWNvSW5kZXhdLnRvID09IG9mZnNldClcbiAgICAgICAgeyAod2lkZ2V0cyB8fCAod2lkZ2V0cyA9IFt3aWRnZXRdKSkucHVzaChsb2NhbHNbZGVjb0luZGV4KytdKTsgfVxuICAgICAgaWYgKHdpZGdldHMpIHtcbiAgICAgICAgd2lkZ2V0cy5zb3J0KGNvbXBhcmVTaWRlKTtcbiAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgd2lkZ2V0cy5sZW5ndGg7IGkkMSsrKSB7IG9uV2lkZ2V0KHdpZGdldHNbaSQxXSwgcGFyZW50SW5kZXgsICEhcmVzdE5vZGUpOyB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvbldpZGdldCh3aWRnZXQsIHBhcmVudEluZGV4LCAhIXJlc3ROb2RlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2hpbGQkMSA9ICh2b2lkIDApLCBpbmRleCA9ICh2b2lkIDApO1xuICAgIGlmIChyZXN0Tm9kZSkge1xuICAgICAgaW5kZXggPSAtMTtcbiAgICAgIGNoaWxkJDEgPSByZXN0Tm9kZTtcbiAgICAgIHJlc3ROb2RlID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKHBhcmVudEluZGV4IDwgcGFyZW50LmNoaWxkQ291bnQpIHtcbiAgICAgIGluZGV4ID0gcGFyZW50SW5kZXg7XG4gICAgICBjaGlsZCQxID0gcGFyZW50LmNoaWxkKHBhcmVudEluZGV4KyspO1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVha1xuICAgIH1cblxuICAgIGZvciAodmFyIGkkMiA9IDA7IGkkMiA8IGFjdGl2ZS5sZW5ndGg7IGkkMisrKSB7IGlmIChhY3RpdmVbaSQyXS50byA8PSBvZmZzZXQpIHsgYWN0aXZlLnNwbGljZShpJDItLSwgMSk7IH0gfVxuICAgIHdoaWxlIChkZWNvSW5kZXggPCBsb2NhbHMubGVuZ3RoICYmIGxvY2Fsc1tkZWNvSW5kZXhdLmZyb20gPD0gb2Zmc2V0ICYmIGxvY2Fsc1tkZWNvSW5kZXhdLnRvID4gb2Zmc2V0KVxuICAgICAgeyBhY3RpdmUucHVzaChsb2NhbHNbZGVjb0luZGV4KytdKTsgfVxuXG4gICAgdmFyIGVuZCA9IG9mZnNldCArIGNoaWxkJDEubm9kZVNpemU7XG4gICAgaWYgKGNoaWxkJDEuaXNUZXh0KSB7XG4gICAgICB2YXIgY3V0QXQgPSBlbmQ7XG4gICAgICBpZiAoZGVjb0luZGV4IDwgbG9jYWxzLmxlbmd0aCAmJiBsb2NhbHNbZGVjb0luZGV4XS5mcm9tIDwgY3V0QXQpIHsgY3V0QXQgPSBsb2NhbHNbZGVjb0luZGV4XS5mcm9tOyB9XG4gICAgICBmb3IgKHZhciBpJDMgPSAwOyBpJDMgPCBhY3RpdmUubGVuZ3RoOyBpJDMrKykgeyBpZiAoYWN0aXZlW2kkM10udG8gPCBjdXRBdCkgeyBjdXRBdCA9IGFjdGl2ZVtpJDNdLnRvOyB9IH1cbiAgICAgIGlmIChjdXRBdCA8IGVuZCkge1xuICAgICAgICByZXN0Tm9kZSA9IGNoaWxkJDEuY3V0KGN1dEF0IC0gb2Zmc2V0KTtcbiAgICAgICAgY2hpbGQkMSA9IGNoaWxkJDEuY3V0KDAsIGN1dEF0IC0gb2Zmc2V0KTtcbiAgICAgICAgZW5kID0gY3V0QXQ7XG4gICAgICAgIGluZGV4ID0gLTE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG91dGVyRGVjbyA9ICFhY3RpdmUubGVuZ3RoID8gbm90aGluZ1xuICAgICAgICA6IGNoaWxkJDEuaXNJbmxpbmUgJiYgIWNoaWxkJDEuaXNMZWFmID8gYWN0aXZlLmZpbHRlcihmdW5jdGlvbiAoZCkgeyByZXR1cm4gIWQuaW5saW5lOyB9KVxuICAgICAgICA6IGFjdGl2ZS5zbGljZSgpO1xuICAgIG9uTm9kZShjaGlsZCQxLCBvdXRlckRlY28sIGRlY28uZm9yQ2hpbGQob2Zmc2V0LCBjaGlsZCQxKSwgaW5kZXgpO1xuICAgIG9mZnNldCA9IGVuZDtcbiAgfVxufVxuXG4vLyBMaXN0IG1hcmtlcnMgaW4gTW9iaWxlIFNhZmFyaSB3aWxsIG15c3RlcmlvdXNseSBkaXNhcHBlYXJcbi8vIHNvbWV0aW1lcy4gVGhpcyB3b3JrcyBhcm91bmQgdGhhdC5cbmZ1bmN0aW9uIGlvc0hhY2tzKGRvbSkge1xuICBpZiAoZG9tLm5vZGVOYW1lID09IFwiVUxcIiB8fCBkb20ubm9kZU5hbWUgPT0gXCJPTFwiKSB7XG4gICAgdmFyIG9sZENTUyA9IGRvbS5zdHlsZS5jc3NUZXh0O1xuICAgIGRvbS5zdHlsZS5jc3NUZXh0ID0gb2xkQ1NTICsgXCI7IGxpc3Qtc3R5bGU6IHNxdWFyZSAhaW1wb3J0YW50XCI7XG4gICAgd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9tKS5saXN0U3R5bGU7XG4gICAgZG9tLnN0eWxlLmNzc1RleHQgPSBvbGRDU1M7XG4gIH1cbn1cblxuZnVuY3Rpb24gbmVhcmJ5VGV4dE5vZGUobm9kZSwgb2Zmc2V0KSB7XG4gIGZvciAoOzspIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAzKSB7IHJldHVybiBub2RlIH1cbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAxICYmIG9mZnNldCA+IDApIHtcbiAgICAgIGlmIChub2RlLmNoaWxkTm9kZXMubGVuZ3RoID4gb2Zmc2V0ICYmIG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdLm5vZGVUeXBlID09IDMpXG4gICAgICAgIHsgcmV0dXJuIG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdIH1cbiAgICAgIG5vZGUgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV07XG4gICAgICBvZmZzZXQgPSBub2RlU2l6ZShub2RlKTtcbiAgICB9IGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSAmJiBvZmZzZXQgPCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICBub2RlID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxufVxuXG4vLyBGaW5kIGEgcGllY2Ugb2YgdGV4dCBpbiBhbiBpbmxpbmUgZnJhZ21lbnQsIG92ZXJsYXBwaW5nIGZyb20tdG9cbmZ1bmN0aW9uIGZpbmRUZXh0SW5GcmFnbWVudChmcmFnLCB0ZXh0LCBmcm9tLCB0bykge1xuICBmb3IgKHZhciBpID0gMCwgcG9zID0gMDsgaSA8IGZyYWcuY2hpbGRDb3VudCAmJiBwb3MgPD0gdG87KSB7XG4gICAgdmFyIGNoaWxkID0gZnJhZy5jaGlsZChpKyspLCBjaGlsZFN0YXJ0ID0gcG9zO1xuICAgIHBvcyArPSBjaGlsZC5ub2RlU2l6ZTtcbiAgICBpZiAoIWNoaWxkLmlzVGV4dCkgeyBjb250aW51ZSB9XG4gICAgdmFyIHN0ciA9IGNoaWxkLnRleHQ7XG4gICAgd2hpbGUgKGkgPCBmcmFnLmNoaWxkQ291bnQpIHtcbiAgICAgIHZhciBuZXh0ID0gZnJhZy5jaGlsZChpKyspO1xuICAgICAgcG9zICs9IG5leHQubm9kZVNpemU7XG4gICAgICBpZiAoIW5leHQuaXNUZXh0KSB7IGJyZWFrIH1cbiAgICAgIHN0ciArPSBuZXh0LnRleHQ7XG4gICAgfVxuICAgIGlmIChwb3MgPj0gZnJvbSkge1xuICAgICAgdmFyIGZvdW5kID0gc3RyLmxhc3RJbmRleE9mKHRleHQsIHRvIC0gY2hpbGRTdGFydCk7XG4gICAgICBpZiAoZm91bmQgPj0gMCAmJiBmb3VuZCArIHRleHQubGVuZ3RoICsgY2hpbGRTdGFydCA+PSBmcm9tKVxuICAgICAgICB7IHJldHVybiBjaGlsZFN0YXJ0ICsgZm91bmQgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gLTFcbn1cblxuLy8gUmVwbGFjZSByYW5nZSBmcm9tLXRvIGluIGFuIGFycmF5IG9mIHZpZXcgZGVzY3Mgd2l0aCByZXBsYWNlbWVudFxuLy8gKG1heSBiZSBudWxsIHRvIGp1c3QgZGVsZXRlKS4gVGhpcyBnb2VzIHZlcnkgbXVjaCBhZ2FpbnN0IHRoZSBncmFpblxuLy8gb2YgdGhlIHJlc3Qgb2YgdGhpcyBjb2RlLCB3aGljaCB0ZW5kcyB0byBjcmVhdGUgbm9kZXMgd2l0aCB0aGVcbi8vIHJpZ2h0IHNoYXBlIGluIG9uZSBnbywgcmF0aGVyIHRoYW4gbWVzc2luZyB3aXRoIHRoZW0gYWZ0ZXJcbi8vIGNyZWF0aW9uLCBidXQgaXMgbmVjZXNzYXJ5IGluIHRoZSBjb21wb3NpdGlvbiBoYWNrLlxuZnVuY3Rpb24gcmVwbGFjZU5vZGVzKG5vZGVzLCBmcm9tLCB0bywgdmlldywgcmVwbGFjZW1lbnQpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgb2ZmID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNoaWxkID0gbm9kZXNbaV0sIHN0YXJ0ID0gb2ZmLCBlbmQgPSBvZmYgKz0gY2hpbGQuc2l6ZTtcbiAgICBpZiAoc3RhcnQgPj0gdG8gfHwgZW5kIDw9IGZyb20pIHtcbiAgICAgIHJlc3VsdC5wdXNoKGNoaWxkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHN0YXJ0IDwgZnJvbSkgeyByZXN1bHQucHVzaChjaGlsZC5zbGljZSgwLCBmcm9tIC0gc3RhcnQsIHZpZXcpKTsgfVxuICAgICAgaWYgKHJlcGxhY2VtZW50KSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHJlcGxhY2VtZW50KTtcbiAgICAgICAgcmVwbGFjZW1lbnQgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGVuZCA+IHRvKSB7IHJlc3VsdC5wdXNoKGNoaWxkLnNsaWNlKHRvIC0gc3RhcnQsIGNoaWxkLnNpemUsIHZpZXcpKTsgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbkZyb21ET00odmlldywgb3JpZ2luKSB7XG4gIHZhciBkb21TZWwgPSB2aWV3LnJvb3QuZ2V0U2VsZWN0aW9uKCksIGRvYyA9IHZpZXcuc3RhdGUuZG9jO1xuICBpZiAoIWRvbVNlbC5mb2N1c05vZGUpIHsgcmV0dXJuIG51bGwgfVxuICB2YXIgbmVhcmVzdERlc2MgPSB2aWV3LmRvY1ZpZXcubmVhcmVzdERlc2MoZG9tU2VsLmZvY3VzTm9kZSksIGluV2lkZ2V0ID0gbmVhcmVzdERlc2MgJiYgbmVhcmVzdERlc2Muc2l6ZSA9PSAwO1xuICB2YXIgaGVhZCA9IHZpZXcuZG9jVmlldy5wb3NGcm9tRE9NKGRvbVNlbC5mb2N1c05vZGUsIGRvbVNlbC5mb2N1c09mZnNldCk7XG4gIGlmIChoZWFkIDwgMCkgeyByZXR1cm4gbnVsbCB9XG4gIHZhciAkaGVhZCA9IGRvYy5yZXNvbHZlKGhlYWQpLCAkYW5jaG9yLCBzZWxlY3Rpb247XG4gIGlmIChzZWxlY3Rpb25Db2xsYXBzZWQoZG9tU2VsKSkge1xuICAgICRhbmNob3IgPSAkaGVhZDtcbiAgICB3aGlsZSAobmVhcmVzdERlc2MgJiYgIW5lYXJlc3REZXNjLm5vZGUpIHsgbmVhcmVzdERlc2MgPSBuZWFyZXN0RGVzYy5wYXJlbnQ7IH1cbiAgICBpZiAobmVhcmVzdERlc2MgJiYgbmVhcmVzdERlc2Mubm9kZS5pc0F0b20gJiYgTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUobmVhcmVzdERlc2Mubm9kZSkgJiYgbmVhcmVzdERlc2MucGFyZW50XG4gICAgICAgICYmICEobmVhcmVzdERlc2Mubm9kZS5pc0lubGluZSAmJiBpc09uRWRnZShkb21TZWwuZm9jdXNOb2RlLCBkb21TZWwuZm9jdXNPZmZzZXQsIG5lYXJlc3REZXNjLmRvbSkpKSB7XG4gICAgICB2YXIgcG9zID0gbmVhcmVzdERlc2MucG9zQmVmb3JlO1xuICAgICAgc2VsZWN0aW9uID0gbmV3IE5vZGVTZWxlY3Rpb24oaGVhZCA9PSBwb3MgPyAkaGVhZCA6IGRvYy5yZXNvbHZlKHBvcykpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYW5jaG9yID0gdmlldy5kb2NWaWV3LnBvc0Zyb21ET00oZG9tU2VsLmFuY2hvck5vZGUsIGRvbVNlbC5hbmNob3JPZmZzZXQpO1xuICAgIGlmIChhbmNob3IgPCAwKSB7IHJldHVybiBudWxsIH1cbiAgICAkYW5jaG9yID0gZG9jLnJlc29sdmUoYW5jaG9yKTtcbiAgfVxuXG4gIGlmICghc2VsZWN0aW9uKSB7XG4gICAgdmFyIGJpYXMgPSBvcmlnaW4gPT0gXCJwb2ludGVyXCIgfHwgKHZpZXcuc3RhdGUuc2VsZWN0aW9uLmhlYWQgPCAkaGVhZC5wb3MgJiYgIWluV2lkZ2V0KSA/IDEgOiAtMTtcbiAgICBzZWxlY3Rpb24gPSBzZWxlY3Rpb25CZXR3ZWVuKHZpZXcsICRhbmNob3IsICRoZWFkLCBiaWFzKTtcbiAgfVxuICByZXR1cm4gc2VsZWN0aW9uXG59XG5cbmZ1bmN0aW9uIGVkaXRvck93bnNTZWxlY3Rpb24odmlldykge1xuICByZXR1cm4gdmlldy5lZGl0YWJsZSA/IHZpZXcuaGFzRm9jdXMoKSA6XG4gICAgaGFzU2VsZWN0aW9uKHZpZXcpICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5jb250YWlucyh2aWV3LmRvbSlcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uVG9ET00odmlldywgZm9yY2UpIHtcbiAgdmFyIHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICBzeW5jTm9kZVNlbGVjdGlvbih2aWV3LCBzZWwpO1xuXG4gIGlmICghZWRpdG9yT3duc1NlbGVjdGlvbih2aWV3KSkgeyByZXR1cm4gfVxuXG4gIGlmICghZm9yY2UgJiYgdmlldy5tb3VzZURvd24gJiYgdmlldy5tb3VzZURvd24uYWxsb3dEZWZhdWx0KSB7XG4gICAgdmlldy5tb3VzZURvd24uZGVsYXllZFNlbGVjdGlvblN5bmMgPSB0cnVlO1xuICAgIHZpZXcuZG9tT2JzZXJ2ZXIuc2V0Q3VyU2VsZWN0aW9uKCk7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2aWV3LmRvbU9ic2VydmVyLmRpc2Nvbm5lY3RTZWxlY3Rpb24oKTtcblxuICBpZiAodmlldy5jdXJzb3JXcmFwcGVyKSB7XG4gICAgc2VsZWN0Q3Vyc29yV3JhcHBlcih2aWV3KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgYW5jaG9yID0gc2VsLmFuY2hvcjtcbiAgICB2YXIgaGVhZCA9IHNlbC5oZWFkO1xuICAgIHZhciByZXNldEVkaXRhYmxlRnJvbSwgcmVzZXRFZGl0YWJsZVRvO1xuICAgIGlmIChicm9rZW5TZWxlY3RCZXR3ZWVuVW5lZGl0YWJsZSAmJiAhKHNlbCBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24pKSB7XG4gICAgICBpZiAoIXNlbC4kZnJvbS5wYXJlbnQuaW5saW5lQ29udGVudClcbiAgICAgICAgeyByZXNldEVkaXRhYmxlRnJvbSA9IHRlbXBvcmFyaWx5RWRpdGFibGVOZWFyKHZpZXcsIHNlbC5mcm9tKTsgfVxuICAgICAgaWYgKCFzZWwuZW1wdHkgJiYgIXNlbC4kZnJvbS5wYXJlbnQuaW5saW5lQ29udGVudClcbiAgICAgICAgeyByZXNldEVkaXRhYmxlVG8gPSB0ZW1wb3JhcmlseUVkaXRhYmxlTmVhcih2aWV3LCBzZWwudG8pOyB9XG4gICAgfVxuICAgIHZpZXcuZG9jVmlldy5zZXRTZWxlY3Rpb24oYW5jaG9yLCBoZWFkLCB2aWV3LnJvb3QsIGZvcmNlKTtcbiAgICBpZiAoYnJva2VuU2VsZWN0QmV0d2VlblVuZWRpdGFibGUpIHtcbiAgICAgIGlmIChyZXNldEVkaXRhYmxlRnJvbSkgeyByZXNldEVkaXRhYmxlKHJlc2V0RWRpdGFibGVGcm9tKTsgfVxuICAgICAgaWYgKHJlc2V0RWRpdGFibGVUbykgeyByZXNldEVkaXRhYmxlKHJlc2V0RWRpdGFibGVUbyk7IH1cbiAgICB9XG4gICAgaWYgKHNlbC52aXNpYmxlKSB7XG4gICAgICB2aWV3LmRvbS5jbGFzc0xpc3QucmVtb3ZlKFwiUHJvc2VNaXJyb3ItaGlkZXNlbGVjdGlvblwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmlldy5kb20uY2xhc3NMaXN0LmFkZChcIlByb3NlTWlycm9yLWhpZGVzZWxlY3Rpb25cIik7XG4gICAgICBpZiAoXCJvbnNlbGVjdGlvbmNoYW5nZVwiIGluIGRvY3VtZW50KSB7IHJlbW92ZUNsYXNzT25TZWxlY3Rpb25DaGFuZ2Uodmlldyk7IH1cbiAgICB9XG4gIH1cblxuICB2aWV3LmRvbU9ic2VydmVyLnNldEN1clNlbGVjdGlvbigpO1xuICB2aWV3LmRvbU9ic2VydmVyLmNvbm5lY3RTZWxlY3Rpb24oKTtcbn1cblxuLy8gS2x1ZGdlIHRvIHdvcmsgYXJvdW5kIFdlYmtpdCBub3QgYWxsb3dpbmcgYSBzZWxlY3Rpb24gdG8gc3RhcnQvZW5kXG4vLyBiZXR3ZWVuIG5vbi1lZGl0YWJsZSBibG9jayBub2Rlcy4gV2UgYnJpZWZseSBtYWtlIHNvbWV0aGluZ1xuLy8gZWRpdGFibGUsIHNldCB0aGUgc2VsZWN0aW9uLCB0aGVuIHNldCBpdCB1bmVkaXRhYmxlIGFnYWluLlxuXG52YXIgYnJva2VuU2VsZWN0QmV0d2VlblVuZWRpdGFibGUgPSByZXN1bHQuc2FmYXJpIHx8IHJlc3VsdC5jaHJvbWUgJiYgcmVzdWx0LmNocm9tZV92ZXJzaW9uIDwgNjM7XG5cbmZ1bmN0aW9uIHRlbXBvcmFyaWx5RWRpdGFibGVOZWFyKHZpZXcsIHBvcykge1xuICB2YXIgcmVmID0gdmlldy5kb2NWaWV3LmRvbUZyb21Qb3MocG9zLCAwKTtcbiAgdmFyIG5vZGUgPSByZWYubm9kZTtcbiAgdmFyIG9mZnNldCA9IHJlZi5vZmZzZXQ7XG4gIHZhciBhZnRlciA9IG9mZnNldCA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPyBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XSA6IG51bGw7XG4gIHZhciBiZWZvcmUgPSBvZmZzZXQgPyBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV0gOiBudWxsO1xuICBpZiAocmVzdWx0LnNhZmFyaSAmJiBhZnRlciAmJiBhZnRlci5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKSB7IHJldHVybiBzZXRFZGl0YWJsZShhZnRlcikgfVxuICBpZiAoKCFhZnRlciB8fCBhZnRlci5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKSAmJiAoIWJlZm9yZSB8fCBiZWZvcmUuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIikpIHtcbiAgICBpZiAoYWZ0ZXIpIHsgcmV0dXJuIHNldEVkaXRhYmxlKGFmdGVyKSB9XG4gICAgZWxzZSBpZiAoYmVmb3JlKSB7IHJldHVybiBzZXRFZGl0YWJsZShiZWZvcmUpIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRFZGl0YWJsZShlbGVtZW50KSB7XG4gIGVsZW1lbnQuY29udGVudEVkaXRhYmxlID0gXCJ0cnVlXCI7XG4gIGlmIChyZXN1bHQuc2FmYXJpICYmIGVsZW1lbnQuZHJhZ2dhYmxlKSB7IGVsZW1lbnQuZHJhZ2dhYmxlID0gZmFsc2U7IGVsZW1lbnQud2FzRHJhZ2dhYmxlID0gdHJ1ZTsgfVxuICByZXR1cm4gZWxlbWVudFxufVxuXG5mdW5jdGlvbiByZXNldEVkaXRhYmxlKGVsZW1lbnQpIHtcbiAgZWxlbWVudC5jb250ZW50RWRpdGFibGUgPSBcImZhbHNlXCI7XG4gIGlmIChlbGVtZW50Lndhc0RyYWdnYWJsZSkgeyBlbGVtZW50LmRyYWdnYWJsZSA9IHRydWU7IGVsZW1lbnQud2FzRHJhZ2dhYmxlID0gbnVsbDsgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVDbGFzc09uU2VsZWN0aW9uQ2hhbmdlKHZpZXcpIHtcbiAgdmFyIGRvYyA9IHZpZXcuZG9tLm93bmVyRG9jdW1lbnQ7XG4gIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKFwic2VsZWN0aW9uY2hhbmdlXCIsIHZpZXcuaGlkZVNlbGVjdGlvbkd1YXJkKTtcbiAgdmFyIGRvbVNlbCA9IHZpZXcucm9vdC5nZXRTZWxlY3Rpb24oKTtcbiAgdmFyIG5vZGUgPSBkb21TZWwuYW5jaG9yTm9kZSwgb2Zmc2V0ID0gZG9tU2VsLmFuY2hvck9mZnNldDtcbiAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoXCJzZWxlY3Rpb25jaGFuZ2VcIiwgdmlldy5oaWRlU2VsZWN0aW9uR3VhcmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGRvbVNlbC5hbmNob3JOb2RlICE9IG5vZGUgfHwgZG9tU2VsLmFuY2hvck9mZnNldCAhPSBvZmZzZXQpIHtcbiAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKFwic2VsZWN0aW9uY2hhbmdlXCIsIHZpZXcuaGlkZVNlbGVjdGlvbkd1YXJkKTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWVkaXRvck93bnNTZWxlY3Rpb24odmlldykgfHwgdmlldy5zdGF0ZS5zZWxlY3Rpb24udmlzaWJsZSlcbiAgICAgICAgICB7IHZpZXcuZG9tLmNsYXNzTGlzdC5yZW1vdmUoXCJQcm9zZU1pcnJvci1oaWRlc2VsZWN0aW9uXCIpOyB9XG4gICAgICB9LCAyMCk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0Q3Vyc29yV3JhcHBlcih2aWV3KSB7XG4gIHZhciBkb21TZWwgPSB2aWV3LnJvb3QuZ2V0U2VsZWN0aW9uKCksIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgdmFyIG5vZGUgPSB2aWV3LmN1cnNvcldyYXBwZXIuZG9tLCBpbWcgPSBub2RlLm5vZGVOYW1lID09IFwiSU1HXCI7XG4gIGlmIChpbWcpIHsgcmFuZ2Uuc2V0RW5kKG5vZGUucGFyZW50Tm9kZSwgZG9tSW5kZXgobm9kZSkgKyAxKTsgfVxuICBlbHNlIHsgcmFuZ2Uuc2V0RW5kKG5vZGUsIDApOyB9XG4gIHJhbmdlLmNvbGxhcHNlKGZhbHNlKTtcbiAgZG9tU2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICBkb21TZWwuYWRkUmFuZ2UocmFuZ2UpO1xuICAvLyBLbHVkZ2UgdG8ga2lsbCAnY29udHJvbCBzZWxlY3Rpb24nIGluIElFMTEgd2hlbiBzZWxlY3RpbmcgYW5cbiAgLy8gaW52aXNpYmxlIGN1cnNvciB3cmFwcGVyLCBzaW5jZSB0aGF0IHdvdWxkIHJlc3VsdCBpbiB0aG9zZSB3ZWlyZFxuICAvLyByZXNpemUgaGFuZGxlcyBhbmQgYSBzZWxlY3Rpb24gdGhhdCBjb25zaWRlcnMgdGhlIGFic29sdXRlbHlcbiAgLy8gcG9zaXRpb25lZCB3cmFwcGVyLCByYXRoZXIgdGhhbiB0aGUgcm9vdCBlZGl0YWJsZSBub2RlLCB0aGVcbiAgLy8gZm9jdXNlZCBlbGVtZW50LlxuICBpZiAoIWltZyAmJiAhdmlldy5zdGF0ZS5zZWxlY3Rpb24udmlzaWJsZSAmJiByZXN1bHQuaWUgJiYgcmVzdWx0LmllX3ZlcnNpb24gPD0gMTEpIHtcbiAgICBub2RlLmRpc2FibGVkID0gdHJ1ZTtcbiAgICBub2RlLmRpc2FibGVkID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3luY05vZGVTZWxlY3Rpb24odmlldywgc2VsKSB7XG4gIGlmIChzZWwgaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uKSB7XG4gICAgdmFyIGRlc2MgPSB2aWV3LmRvY1ZpZXcuZGVzY0F0KHNlbC5mcm9tKTtcbiAgICBpZiAoZGVzYyAhPSB2aWV3Lmxhc3RTZWxlY3RlZFZpZXdEZXNjKSB7XG4gICAgICBjbGVhck5vZGVTZWxlY3Rpb24odmlldyk7XG4gICAgICBpZiAoZGVzYykgeyBkZXNjLnNlbGVjdE5vZGUoKTsgfVxuICAgICAgdmlldy5sYXN0U2VsZWN0ZWRWaWV3RGVzYyA9IGRlc2M7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNsZWFyTm9kZVNlbGVjdGlvbih2aWV3KTtcbiAgfVxufVxuXG4vLyBDbGVhciBhbGwgRE9NIHN0YXRlZnVsbmVzcyBvZiB0aGUgbGFzdCBub2RlIHNlbGVjdGlvbi5cbmZ1bmN0aW9uIGNsZWFyTm9kZVNlbGVjdGlvbih2aWV3KSB7XG4gIGlmICh2aWV3Lmxhc3RTZWxlY3RlZFZpZXdEZXNjKSB7XG4gICAgaWYgKHZpZXcubGFzdFNlbGVjdGVkVmlld0Rlc2MucGFyZW50KVxuICAgICAgeyB2aWV3Lmxhc3RTZWxlY3RlZFZpZXdEZXNjLmRlc2VsZWN0Tm9kZSgpOyB9XG4gICAgdmlldy5sYXN0U2VsZWN0ZWRWaWV3RGVzYyA9IG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uQmV0d2Vlbih2aWV3LCAkYW5jaG9yLCAkaGVhZCwgYmlhcykge1xuICByZXR1cm4gdmlldy5zb21lUHJvcChcImNyZWF0ZVNlbGVjdGlvbkJldHdlZW5cIiwgZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGYodmlldywgJGFuY2hvciwgJGhlYWQpOyB9KVxuICAgIHx8IFRleHRTZWxlY3Rpb24uYmV0d2VlbigkYW5jaG9yLCAkaGVhZCwgYmlhcylcbn1cblxuZnVuY3Rpb24gaGFzRm9jdXNBbmRTZWxlY3Rpb24odmlldykge1xuICBpZiAodmlldy5lZGl0YWJsZSAmJiB2aWV3LnJvb3QuYWN0aXZlRWxlbWVudCAhPSB2aWV3LmRvbSkgeyByZXR1cm4gZmFsc2UgfVxuICByZXR1cm4gaGFzU2VsZWN0aW9uKHZpZXcpXG59XG5cbmZ1bmN0aW9uIGhhc1NlbGVjdGlvbih2aWV3KSB7XG4gIHZhciBzZWwgPSB2aWV3LnJvb3QuZ2V0U2VsZWN0aW9uKCk7XG4gIGlmICghc2VsLmFuY2hvck5vZGUpIHsgcmV0dXJuIGZhbHNlIH1cbiAgdHJ5IHtcbiAgICAvLyBGaXJlZm94IHdpbGwgcmFpc2UgJ3Blcm1pc3Npb24gZGVuaWVkJyBlcnJvcnMgd2hlbiBhY2Nlc3NpbmdcbiAgICAvLyBwcm9wZXJ0aWVzIG9mIGBzZWwuYW5jaG9yTm9kZWAgd2hlbiBpdCdzIGluIGEgZ2VuZXJhdGVkIENTU1xuICAgIC8vIGVsZW1lbnQuXG4gICAgcmV0dXJuIHZpZXcuZG9tLmNvbnRhaW5zKHNlbC5hbmNob3JOb2RlLm5vZGVUeXBlID09IDMgPyBzZWwuYW5jaG9yTm9kZS5wYXJlbnROb2RlIDogc2VsLmFuY2hvck5vZGUpICYmXG4gICAgICAodmlldy5lZGl0YWJsZSB8fCB2aWV3LmRvbS5jb250YWlucyhzZWwuZm9jdXNOb2RlLm5vZGVUeXBlID09IDMgPyBzZWwuZm9jdXNOb2RlLnBhcmVudE5vZGUgOiBzZWwuZm9jdXNOb2RlKSlcbiAgfSBjYXRjaChfKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24gYW5jaG9ySW5SaWdodFBsYWNlKHZpZXcpIHtcbiAgdmFyIGFuY2hvckRPTSA9IHZpZXcuZG9jVmlldy5kb21Gcm9tUG9zKHZpZXcuc3RhdGUuc2VsZWN0aW9uLmFuY2hvciwgMCk7XG4gIHZhciBkb21TZWwgPSB2aWV3LnJvb3QuZ2V0U2VsZWN0aW9uKCk7XG4gIHJldHVybiBpc0VxdWl2YWxlbnRQb3NpdGlvbihhbmNob3JET00ubm9kZSwgYW5jaG9yRE9NLm9mZnNldCwgZG9tU2VsLmFuY2hvck5vZGUsIGRvbVNlbC5hbmNob3JPZmZzZXQpXG59XG5cbmZ1bmN0aW9uIG1vdmVTZWxlY3Rpb25CbG9jayhzdGF0ZSwgZGlyKSB7XG4gIHZhciByZWYgPSBzdGF0ZS5zZWxlY3Rpb247XG4gIHZhciAkYW5jaG9yID0gcmVmLiRhbmNob3I7XG4gIHZhciAkaGVhZCA9IHJlZi4kaGVhZDtcbiAgdmFyICRzaWRlID0gZGlyID4gMCA/ICRhbmNob3IubWF4KCRoZWFkKSA6ICRhbmNob3IubWluKCRoZWFkKTtcbiAgdmFyICRzdGFydCA9ICEkc2lkZS5wYXJlbnQuaW5saW5lQ29udGVudCA/ICRzaWRlIDogJHNpZGUuZGVwdGggPyBzdGF0ZS5kb2MucmVzb2x2ZShkaXIgPiAwID8gJHNpZGUuYWZ0ZXIoKSA6ICRzaWRlLmJlZm9yZSgpKSA6IG51bGw7XG4gIHJldHVybiAkc3RhcnQgJiYgU2VsZWN0aW9uLmZpbmRGcm9tKCRzdGFydCwgZGlyKVxufVxuXG5mdW5jdGlvbiBhcHBseSh2aWV3LCBzZWwpIHtcbiAgdmlldy5kaXNwYXRjaCh2aWV3LnN0YXRlLnRyLnNldFNlbGVjdGlvbihzZWwpLnNjcm9sbEludG9WaWV3KCkpO1xuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBzZWxlY3RIb3Jpem9udGFsbHkodmlldywgZGlyLCBtb2RzKSB7XG4gIHZhciBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgaWYgKHNlbCBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24pIHtcbiAgICBpZiAoIXNlbC5lbXB0eSB8fCBtb2RzLmluZGV4T2YoXCJzXCIpID4gLTEpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH0gZWxzZSBpZiAodmlldy5lbmRPZlRleHRibG9jayhkaXIgPiAwID8gXCJyaWdodFwiIDogXCJsZWZ0XCIpKSB7XG4gICAgICB2YXIgbmV4dCA9IG1vdmVTZWxlY3Rpb25CbG9jayh2aWV3LnN0YXRlLCBkaXIpO1xuICAgICAgaWYgKG5leHQgJiYgKG5leHQgaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uKSkgeyByZXR1cm4gYXBwbHkodmlldywgbmV4dCkgfVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSBlbHNlIGlmICghKHJlc3VsdC5tYWMgJiYgbW9kcy5pbmRleE9mKFwibVwiKSA+IC0xKSkge1xuICAgICAgdmFyICRoZWFkID0gc2VsLiRoZWFkLCBub2RlID0gJGhlYWQudGV4dE9mZnNldCA/IG51bGwgOiBkaXIgPCAwID8gJGhlYWQubm9kZUJlZm9yZSA6ICRoZWFkLm5vZGVBZnRlciwgZGVzYztcbiAgICAgIGlmICghbm9kZSB8fCBub2RlLmlzVGV4dCkgeyByZXR1cm4gZmFsc2UgfVxuICAgICAgdmFyIG5vZGVQb3MgPSBkaXIgPCAwID8gJGhlYWQucG9zIC0gbm9kZS5ub2RlU2l6ZSA6ICRoZWFkLnBvcztcbiAgICAgIGlmICghKG5vZGUuaXNBdG9tIHx8IChkZXNjID0gdmlldy5kb2NWaWV3LmRlc2NBdChub2RlUG9zKSkgJiYgIWRlc2MuY29udGVudERPTSkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAgIGlmIChOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShub2RlKSkge1xuICAgICAgICByZXR1cm4gYXBwbHkodmlldywgbmV3IE5vZGVTZWxlY3Rpb24oZGlyIDwgMCA/IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoJGhlYWQucG9zIC0gbm9kZS5ub2RlU2l6ZSkgOiAkaGVhZCkpXG4gICAgICB9IGVsc2UgaWYgKHJlc3VsdC53ZWJraXQpIHtcbiAgICAgICAgLy8gQ2hyb21lIGFuZCBTYWZhcmkgd2lsbCBpbnRyb2R1Y2UgZXh0cmEgcG9pbnRsZXNzIGN1cnNvclxuICAgICAgICAvLyBwb3NpdGlvbnMgYXJvdW5kIGlubGluZSB1bmVkaXRhYmxlIG5vZGVzLCBzbyB3ZSBoYXZlIHRvXG4gICAgICAgIC8vIHRha2Ugb3ZlciBhbmQgbW92ZSB0aGUgY3Vyc29yIHBhc3QgdGhlbSAoIzkzNylcbiAgICAgICAgcmV0dXJuIGFwcGx5KHZpZXcsIG5ldyBUZXh0U2VsZWN0aW9uKHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoZGlyIDwgMCA/IG5vZGVQb3MgOiBub2RlUG9zICsgbm9kZS5ub2RlU2l6ZSkpKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHNlbCBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24gJiYgc2VsLm5vZGUuaXNJbmxpbmUpIHtcbiAgICByZXR1cm4gYXBwbHkodmlldywgbmV3IFRleHRTZWxlY3Rpb24oZGlyID4gMCA/IHNlbC4kdG8gOiBzZWwuJGZyb20pKVxuICB9IGVsc2Uge1xuICAgIHZhciBuZXh0JDEgPSBtb3ZlU2VsZWN0aW9uQmxvY2sodmlldy5zdGF0ZSwgZGlyKTtcbiAgICBpZiAobmV4dCQxKSB7IHJldHVybiBhcHBseSh2aWV3LCBuZXh0JDEpIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBub2RlTGVuKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT0gMyA/IG5vZGUubm9kZVZhbHVlLmxlbmd0aCA6IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGhcbn1cblxuZnVuY3Rpb24gaXNJZ25vcmFibGUoZG9tKSB7XG4gIHZhciBkZXNjID0gZG9tLnBtVmlld0Rlc2M7XG4gIHJldHVybiBkZXNjICYmIGRlc2Muc2l6ZSA9PSAwICYmIChkb20ubmV4dFNpYmxpbmcgfHwgZG9tLm5vZGVOYW1lICE9IFwiQlJcIilcbn1cblxuLy8gTWFrZSBzdXJlIHRoZSBjdXJzb3IgaXNuJ3QgZGlyZWN0bHkgYWZ0ZXIgb25lIG9yIG1vcmUgaWdub3JlZFxuLy8gbm9kZXMsIHdoaWNoIHdpbGwgY29uZnVzZSB0aGUgYnJvd3NlcidzIGN1cnNvciBtb3Rpb24gbG9naWMuXG5mdW5jdGlvbiBza2lwSWdub3JlZE5vZGVzTGVmdCh2aWV3KSB7XG4gIHZhciBzZWwgPSB2aWV3LnJvb3QuZ2V0U2VsZWN0aW9uKCk7XG4gIHZhciBub2RlID0gc2VsLmZvY3VzTm9kZSwgb2Zmc2V0ID0gc2VsLmZvY3VzT2Zmc2V0O1xuICBpZiAoIW5vZGUpIHsgcmV0dXJuIH1cbiAgdmFyIG1vdmVOb2RlLCBtb3ZlT2Zmc2V0LCBmb3JjZSA9IGZhbHNlO1xuICAvLyBHZWNrbyB3aWxsIGRvIG9kZCB0aGluZ3Mgd2hlbiB0aGUgc2VsZWN0aW9uIGlzIGRpcmVjdGx5IGluIGZyb250XG4gIC8vIG9mIGEgbm9uLWVkaXRhYmxlIG5vZGUsIHNvIGluIHRoYXQgY2FzZSwgbW92ZSBpdCBpbnRvIHRoZSBuZXh0XG4gIC8vIG5vZGUgaWYgcG9zc2libGUuIElzc3VlIHByb3NlbWlycm9yL3Byb3NlbWlycm9yIzgzMi5cbiAgaWYgKHJlc3VsdC5nZWNrbyAmJiBub2RlLm5vZGVUeXBlID09IDEgJiYgb2Zmc2V0IDwgbm9kZUxlbihub2RlKSAmJiBpc0lnbm9yYWJsZShub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XSkpIHsgZm9yY2UgPSB0cnVlOyB9XG4gIGZvciAoOzspIHtcbiAgICBpZiAob2Zmc2V0ID4gMCkge1xuICAgICAgaWYgKG5vZGUubm9kZVR5cGUgIT0gMSkge1xuICAgICAgICBicmVha1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGJlZm9yZSA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXTtcbiAgICAgICAgaWYgKGlzSWdub3JhYmxlKGJlZm9yZSkpIHtcbiAgICAgICAgICBtb3ZlTm9kZSA9IG5vZGU7XG4gICAgICAgICAgbW92ZU9mZnNldCA9IC0tb2Zmc2V0O1xuICAgICAgICB9IGVsc2UgaWYgKGJlZm9yZS5ub2RlVHlwZSA9PSAzKSB7XG4gICAgICAgICAgbm9kZSA9IGJlZm9yZTtcbiAgICAgICAgICBvZmZzZXQgPSBub2RlLm5vZGVWYWx1ZS5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7IGJyZWFrIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzQmxvY2tOb2RlKG5vZGUpKSB7XG4gICAgICBicmVha1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcHJldiA9IG5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgd2hpbGUgKHByZXYgJiYgaXNJZ25vcmFibGUocHJldikpIHtcbiAgICAgICAgbW92ZU5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgIG1vdmVPZmZzZXQgPSBkb21JbmRleChwcmV2KTtcbiAgICAgICAgcHJldiA9IHByZXYucHJldmlvdXNTaWJsaW5nO1xuICAgICAgfVxuICAgICAgaWYgKCFwcmV2KSB7XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmIChub2RlID09IHZpZXcuZG9tKSB7IGJyZWFrIH1cbiAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUgPSBwcmV2O1xuICAgICAgICBvZmZzZXQgPSBub2RlTGVuKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoZm9yY2UpIHsgc2V0U2VsRm9jdXModmlldywgc2VsLCBub2RlLCBvZmZzZXQpOyB9XG4gIGVsc2UgaWYgKG1vdmVOb2RlKSB7IHNldFNlbEZvY3VzKHZpZXcsIHNlbCwgbW92ZU5vZGUsIG1vdmVPZmZzZXQpOyB9XG59XG5cbi8vIE1ha2Ugc3VyZSB0aGUgY3Vyc29yIGlzbid0IGRpcmVjdGx5IGJlZm9yZSBvbmUgb3IgbW9yZSBpZ25vcmVkXG4vLyBub2Rlcy5cbmZ1bmN0aW9uIHNraXBJZ25vcmVkTm9kZXNSaWdodCh2aWV3KSB7XG4gIHZhciBzZWwgPSB2aWV3LnJvb3QuZ2V0U2VsZWN0aW9uKCk7XG4gIHZhciBub2RlID0gc2VsLmZvY3VzTm9kZSwgb2Zmc2V0ID0gc2VsLmZvY3VzT2Zmc2V0O1xuICBpZiAoIW5vZGUpIHsgcmV0dXJuIH1cbiAgdmFyIGxlbiA9IG5vZGVMZW4obm9kZSk7XG4gIHZhciBtb3ZlTm9kZSwgbW92ZU9mZnNldDtcbiAgZm9yICg7Oykge1xuICAgIGlmIChvZmZzZXQgPCBsZW4pIHtcbiAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9IDEpIHsgYnJlYWsgfVxuICAgICAgdmFyIGFmdGVyID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICBpZiAoaXNJZ25vcmFibGUoYWZ0ZXIpKSB7XG4gICAgICAgIG1vdmVOb2RlID0gbm9kZTtcbiAgICAgICAgbW92ZU9mZnNldCA9ICsrb2Zmc2V0O1xuICAgICAgfVxuICAgICAgZWxzZSB7IGJyZWFrIH1cbiAgICB9IGVsc2UgaWYgKGlzQmxvY2tOb2RlKG5vZGUpKSB7XG4gICAgICBicmVha1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbmV4dCA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICB3aGlsZSAobmV4dCAmJiBpc0lnbm9yYWJsZShuZXh0KSkge1xuICAgICAgICBtb3ZlTm9kZSA9IG5leHQucGFyZW50Tm9kZTtcbiAgICAgICAgbW92ZU9mZnNldCA9IGRvbUluZGV4KG5leHQpICsgMTtcbiAgICAgICAgbmV4dCA9IG5leHQubmV4dFNpYmxpbmc7XG4gICAgICB9XG4gICAgICBpZiAoIW5leHQpIHtcbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKG5vZGUgPT0gdmlldy5kb20pIHsgYnJlYWsgfVxuICAgICAgICBvZmZzZXQgPSBsZW4gPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZSA9IG5leHQ7XG4gICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIGxlbiA9IG5vZGVMZW4obm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChtb3ZlTm9kZSkgeyBzZXRTZWxGb2N1cyh2aWV3LCBzZWwsIG1vdmVOb2RlLCBtb3ZlT2Zmc2V0KTsgfVxufVxuXG5mdW5jdGlvbiBpc0Jsb2NrTm9kZShkb20pIHtcbiAgdmFyIGRlc2MgPSBkb20ucG1WaWV3RGVzYztcbiAgcmV0dXJuIGRlc2MgJiYgZGVzYy5ub2RlICYmIGRlc2Mubm9kZS5pc0Jsb2NrXG59XG5cbmZ1bmN0aW9uIHNldFNlbEZvY3VzKHZpZXcsIHNlbCwgbm9kZSwgb2Zmc2V0KSB7XG4gIGlmIChzZWxlY3Rpb25Db2xsYXBzZWQoc2VsKSkge1xuICAgIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgcmFuZ2Uuc2V0RW5kKG5vZGUsIG9mZnNldCk7XG4gICAgcmFuZ2Uuc2V0U3RhcnQobm9kZSwgb2Zmc2V0KTtcbiAgICBzZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgc2VsLmFkZFJhbmdlKHJhbmdlKTtcbiAgfSBlbHNlIGlmIChzZWwuZXh0ZW5kKSB7XG4gICAgc2VsLmV4dGVuZChub2RlLCBvZmZzZXQpO1xuICB9XG4gIHZpZXcuZG9tT2JzZXJ2ZXIuc2V0Q3VyU2VsZWN0aW9uKCk7XG4gIHZhciBzdGF0ZSA9IHZpZXcuc3RhdGU7XG4gIC8vIElmIG5vIHN0YXRlIHVwZGF0ZSBlbmRzIHVwIGhhcHBlbmluZywgcmVzZXQgdGhlIHNlbGVjdGlvbi5cbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHZpZXcuc3RhdGUgPT0gc3RhdGUpIHsgc2VsZWN0aW9uVG9ET00odmlldyk7IH1cbiAgfSwgNTApO1xufVxuXG4vLyA6IChFZGl0b3JTdGF0ZSwgbnVtYmVyKVxuLy8gQ2hlY2sgd2hldGhlciB2ZXJ0aWNhbCBzZWxlY3Rpb24gbW90aW9uIHdvdWxkIGludm9sdmUgbm9kZVxuLy8gc2VsZWN0aW9ucy4gSWYgc28sIGFwcGx5IGl0IChpZiBub3QsIHRoZSByZXN1bHQgaXMgbGVmdCB0byB0aGVcbi8vIGJyb3dzZXIpXG5mdW5jdGlvbiBzZWxlY3RWZXJ0aWNhbGx5KHZpZXcsIGRpciwgbW9kcykge1xuICB2YXIgc2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gIGlmIChzZWwgaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uICYmICFzZWwuZW1wdHkgfHwgbW9kcy5pbmRleE9mKFwic1wiKSA+IC0xKSB7IHJldHVybiBmYWxzZSB9XG4gIGlmIChyZXN1bHQubWFjICYmIG1vZHMuaW5kZXhPZihcIm1cIikgPiAtMSkgeyByZXR1cm4gZmFsc2UgfVxuICB2YXIgJGZyb20gPSBzZWwuJGZyb207XG4gIHZhciAkdG8gPSBzZWwuJHRvO1xuXG4gIGlmICghJGZyb20ucGFyZW50LmlubGluZUNvbnRlbnQgfHwgdmlldy5lbmRPZlRleHRibG9jayhkaXIgPCAwID8gXCJ1cFwiIDogXCJkb3duXCIpKSB7XG4gICAgdmFyIG5leHQgPSBtb3ZlU2VsZWN0aW9uQmxvY2sodmlldy5zdGF0ZSwgZGlyKTtcbiAgICBpZiAobmV4dCAmJiAobmV4dCBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24pKVxuICAgICAgeyByZXR1cm4gYXBwbHkodmlldywgbmV4dCkgfVxuICB9XG4gIGlmICghJGZyb20ucGFyZW50LmlubGluZUNvbnRlbnQpIHtcbiAgICB2YXIgc2lkZSA9IGRpciA8IDAgPyAkZnJvbSA6ICR0bztcbiAgICB2YXIgYmV5b25kID0gc2VsIGluc3RhbmNlb2YgQWxsU2VsZWN0aW9uID8gU2VsZWN0aW9uLm5lYXIoc2lkZSwgZGlyKSA6IFNlbGVjdGlvbi5maW5kRnJvbShzaWRlLCBkaXIpO1xuICAgIHJldHVybiBiZXlvbmQgPyBhcHBseSh2aWV3LCBiZXlvbmQpIDogZmFsc2VcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gc3RvcE5hdGl2ZUhvcml6b250YWxEZWxldGUodmlldywgZGlyKSB7XG4gIGlmICghKHZpZXcuc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbikpIHsgcmV0dXJuIHRydWUgfVxuICB2YXIgcmVmID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gIHZhciAkaGVhZCA9IHJlZi4kaGVhZDtcbiAgdmFyICRhbmNob3IgPSByZWYuJGFuY2hvcjtcbiAgdmFyIGVtcHR5ID0gcmVmLmVtcHR5O1xuICBpZiAoISRoZWFkLnNhbWVQYXJlbnQoJGFuY2hvcikpIHsgcmV0dXJuIHRydWUgfVxuICBpZiAoIWVtcHR5KSB7IHJldHVybiBmYWxzZSB9XG4gIGlmICh2aWV3LmVuZE9mVGV4dGJsb2NrKGRpciA+IDAgPyBcImZvcndhcmRcIiA6IFwiYmFja3dhcmRcIikpIHsgcmV0dXJuIHRydWUgfVxuICB2YXIgbmV4dE5vZGUgPSAhJGhlYWQudGV4dE9mZnNldCAmJiAoZGlyIDwgMCA/ICRoZWFkLm5vZGVCZWZvcmUgOiAkaGVhZC5ub2RlQWZ0ZXIpO1xuICBpZiAobmV4dE5vZGUgJiYgIW5leHROb2RlLmlzVGV4dCkge1xuICAgIHZhciB0ciA9IHZpZXcuc3RhdGUudHI7XG4gICAgaWYgKGRpciA8IDApIHsgdHIuZGVsZXRlKCRoZWFkLnBvcyAtIG5leHROb2RlLm5vZGVTaXplLCAkaGVhZC5wb3MpOyB9XG4gICAgZWxzZSB7IHRyLmRlbGV0ZSgkaGVhZC5wb3MsICRoZWFkLnBvcyArIG5leHROb2RlLm5vZGVTaXplKTsgfVxuICAgIHZpZXcuZGlzcGF0Y2godHIpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIHN3aXRjaEVkaXRhYmxlKHZpZXcsIG5vZGUsIHN0YXRlKSB7XG4gIHZpZXcuZG9tT2JzZXJ2ZXIuc3RvcCgpO1xuICBub2RlLmNvbnRlbnRFZGl0YWJsZSA9IHN0YXRlO1xuICB2aWV3LmRvbU9ic2VydmVyLnN0YXJ0KCk7XG59XG5cbi8vIElzc3VlICM4NjcgLyAjMTA5MCAvIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTkwMzgyMVxuLy8gSW4gd2hpY2ggU2FmYXJpIChhbmQgYXQgc29tZSBwb2ludCBpbiB0aGUgcGFzdCwgQ2hyb21lKSBkb2VzIHJlYWxseVxuLy8gd3JvbmcgdGhpbmdzIHdoZW4gdGhlIGRvd24gYXJyb3cgaXMgcHJlc3NlZCB3aGVuIHRoZSBjdXJzb3IgaXNcbi8vIGRpcmVjdGx5IGF0IHRoZSBzdGFydCBvZiBhIHRleHRibG9jayBhbmQgaGFzIGFuIHVuZWRpdGFibGUgbm9kZVxuLy8gYWZ0ZXIgaXRcbmZ1bmN0aW9uIHNhZmFyaURvd25BcnJvd0J1Zyh2aWV3KSB7XG4gIGlmICghcmVzdWx0LnNhZmFyaSB8fCB2aWV3LnN0YXRlLnNlbGVjdGlvbi4kaGVhZC5wYXJlbnRPZmZzZXQgPiAwKSB7IHJldHVybiB9XG4gIHZhciByZWYgPSB2aWV3LnJvb3QuZ2V0U2VsZWN0aW9uKCk7XG4gIHZhciBmb2N1c05vZGUgPSByZWYuZm9jdXNOb2RlO1xuICB2YXIgZm9jdXNPZmZzZXQgPSByZWYuZm9jdXNPZmZzZXQ7XG4gIGlmIChmb2N1c05vZGUgJiYgZm9jdXNOb2RlLm5vZGVUeXBlID09IDEgJiYgZm9jdXNPZmZzZXQgPT0gMCAmJlxuICAgICAgZm9jdXNOb2RlLmZpcnN0Q2hpbGQgJiYgZm9jdXNOb2RlLmZpcnN0Q2hpbGQuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIikge1xuICAgIHZhciBjaGlsZCA9IGZvY3VzTm9kZS5maXJzdENoaWxkO1xuICAgIHN3aXRjaEVkaXRhYmxlKHZpZXcsIGNoaWxkLCB0cnVlKTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN3aXRjaEVkaXRhYmxlKHZpZXcsIGNoaWxkLCBmYWxzZSk7IH0sIDIwKTtcbiAgfVxufVxuXG4vLyBBIGJhY2tkcm9wIGtleSBtYXBwaW5nIHVzZWQgdG8gbWFrZSBzdXJlIHdlIGFsd2F5cyBzdXBwcmVzcyBrZXlzXG4vLyB0aGF0IGhhdmUgYSBkYW5nZXJvdXMgZGVmYXVsdCBlZmZlY3QsIGV2ZW4gaWYgdGhlIGNvbW1hbmRzIHRoZXkgYXJlXG4vLyBib3VuZCB0byByZXR1cm4gZmFsc2UsIGFuZCB0byBtYWtlIHN1cmUgdGhhdCBjdXJzb3ItbW90aW9uIGtleXNcbi8vIGZpbmQgYSBjdXJzb3IgKGFzIG9wcG9zZWQgdG8gYSBub2RlIHNlbGVjdGlvbikgd2hlbiBwcmVzc2VkLiBGb3Jcbi8vIGN1cnNvci1tb3Rpb24ga2V5cywgdGhlIGNvZGUgaW4gdGhlIGhhbmRsZXJzIGFsc28gdGFrZXMgY2FyZSBvZlxuLy8gYmxvY2sgc2VsZWN0aW9ucy5cblxuZnVuY3Rpb24gZ2V0TW9kcyhldmVudCkge1xuICB2YXIgcmVzdWx0ID0gXCJcIjtcbiAgaWYgKGV2ZW50LmN0cmxLZXkpIHsgcmVzdWx0ICs9IFwiY1wiOyB9XG4gIGlmIChldmVudC5tZXRhS2V5KSB7IHJlc3VsdCArPSBcIm1cIjsgfVxuICBpZiAoZXZlbnQuYWx0S2V5KSB7IHJlc3VsdCArPSBcImFcIjsgfVxuICBpZiAoZXZlbnQuc2hpZnRLZXkpIHsgcmVzdWx0ICs9IFwic1wiOyB9XG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gY2FwdHVyZUtleURvd24odmlldywgZXZlbnQpIHtcbiAgdmFyIGNvZGUgPSBldmVudC5rZXlDb2RlLCBtb2RzID0gZ2V0TW9kcyhldmVudCk7XG4gIGlmIChjb2RlID09IDggfHwgKHJlc3VsdC5tYWMgJiYgY29kZSA9PSA3MiAmJiBtb2RzID09IFwiY1wiKSkgeyAvLyBCYWNrc3BhY2UsIEN0cmwtaCBvbiBNYWNcbiAgICByZXR1cm4gc3RvcE5hdGl2ZUhvcml6b250YWxEZWxldGUodmlldywgLTEpIHx8IHNraXBJZ25vcmVkTm9kZXNMZWZ0KHZpZXcpXG4gIH0gZWxzZSBpZiAoY29kZSA9PSA0NiB8fCAocmVzdWx0Lm1hYyAmJiBjb2RlID09IDY4ICYmIG1vZHMgPT0gXCJjXCIpKSB7IC8vIERlbGV0ZSwgQ3RybC1kIG9uIE1hY1xuICAgIHJldHVybiBzdG9wTmF0aXZlSG9yaXpvbnRhbERlbGV0ZSh2aWV3LCAxKSB8fCBza2lwSWdub3JlZE5vZGVzUmlnaHQodmlldylcbiAgfSBlbHNlIGlmIChjb2RlID09IDEzIHx8IGNvZGUgPT0gMjcpIHsgLy8gRW50ZXIsIEVzY1xuICAgIHJldHVybiB0cnVlXG4gIH0gZWxzZSBpZiAoY29kZSA9PSAzNykgeyAvLyBMZWZ0IGFycm93XG4gICAgcmV0dXJuIHNlbGVjdEhvcml6b250YWxseSh2aWV3LCAtMSwgbW9kcykgfHwgc2tpcElnbm9yZWROb2Rlc0xlZnQodmlldylcbiAgfSBlbHNlIGlmIChjb2RlID09IDM5KSB7IC8vIFJpZ2h0IGFycm93XG4gICAgcmV0dXJuIHNlbGVjdEhvcml6b250YWxseSh2aWV3LCAxLCBtb2RzKSB8fCBza2lwSWdub3JlZE5vZGVzUmlnaHQodmlldylcbiAgfSBlbHNlIGlmIChjb2RlID09IDM4KSB7IC8vIFVwIGFycm93XG4gICAgcmV0dXJuIHNlbGVjdFZlcnRpY2FsbHkodmlldywgLTEsIG1vZHMpIHx8IHNraXBJZ25vcmVkTm9kZXNMZWZ0KHZpZXcpXG4gIH0gZWxzZSBpZiAoY29kZSA9PSA0MCkgeyAvLyBEb3duIGFycm93XG4gICAgcmV0dXJuIHNhZmFyaURvd25BcnJvd0J1Zyh2aWV3KSB8fCBzZWxlY3RWZXJ0aWNhbGx5KHZpZXcsIDEsIG1vZHMpIHx8IHNraXBJZ25vcmVkTm9kZXNSaWdodCh2aWV3KVxuICB9IGVsc2UgaWYgKG1vZHMgPT0gKHJlc3VsdC5tYWMgPyBcIm1cIiA6IFwiY1wiKSAmJlxuICAgICAgICAgICAgIChjb2RlID09IDY2IHx8IGNvZGUgPT0gNzMgfHwgY29kZSA9PSA4OSB8fCBjb2RlID09IDkwKSkgeyAvLyBNb2QtW2JpeXpdXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLy8gTm90ZSB0aGF0IGFsbCByZWZlcmVuY2luZyBhbmQgcGFyc2luZyBpcyBkb25lIHdpdGggdGhlXG4vLyBzdGFydC1vZi1vcGVyYXRpb24gc2VsZWN0aW9uIGFuZCBkb2N1bWVudCwgc2luY2UgdGhhdCdzIHRoZSBvbmVcbi8vIHRoYXQgdGhlIERPTSByZXByZXNlbnRzLiBJZiBhbnkgY2hhbmdlcyBjYW1lIGluIGluIHRoZSBtZWFudGltZSxcbi8vIHRoZSBtb2RpZmljYXRpb24gaXMgbWFwcGVkIG92ZXIgdGhvc2UgYmVmb3JlIGl0IGlzIGFwcGxpZWQsIGluXG4vLyByZWFkRE9NQ2hhbmdlLlxuXG5mdW5jdGlvbiBwYXJzZUJldHdlZW4odmlldywgZnJvbV8sIHRvXykge1xuICB2YXIgcmVmID0gdmlldy5kb2NWaWV3LnBhcnNlUmFuZ2UoZnJvbV8sIHRvXyk7XG4gIHZhciBwYXJlbnQgPSByZWYubm9kZTtcbiAgdmFyIGZyb21PZmZzZXQgPSByZWYuZnJvbU9mZnNldDtcbiAgdmFyIHRvT2Zmc2V0ID0gcmVmLnRvT2Zmc2V0O1xuICB2YXIgZnJvbSA9IHJlZi5mcm9tO1xuICB2YXIgdG8gPSByZWYudG87XG5cbiAgdmFyIGRvbVNlbCA9IHZpZXcucm9vdC5nZXRTZWxlY3Rpb24oKSwgZmluZCA9IG51bGwsIGFuY2hvciA9IGRvbVNlbC5hbmNob3JOb2RlO1xuICBpZiAoYW5jaG9yICYmIHZpZXcuZG9tLmNvbnRhaW5zKGFuY2hvci5ub2RlVHlwZSA9PSAxID8gYW5jaG9yIDogYW5jaG9yLnBhcmVudE5vZGUpKSB7XG4gICAgZmluZCA9IFt7bm9kZTogYW5jaG9yLCBvZmZzZXQ6IGRvbVNlbC5hbmNob3JPZmZzZXR9XTtcbiAgICBpZiAoIXNlbGVjdGlvbkNvbGxhcHNlZChkb21TZWwpKVxuICAgICAgeyBmaW5kLnB1c2goe25vZGU6IGRvbVNlbC5mb2N1c05vZGUsIG9mZnNldDogZG9tU2VsLmZvY3VzT2Zmc2V0fSk7IH1cbiAgfVxuICAvLyBXb3JrIGFyb3VuZCBpc3N1ZSBpbiBDaHJvbWUgd2hlcmUgYmFja3NwYWNpbmcgc29tZXRpbWVzIHJlcGxhY2VzXG4gIC8vIHRoZSBkZWxldGVkIGNvbnRlbnQgd2l0aCBhIHJhbmRvbSBCUiBub2RlIChpc3N1ZXMgIzc5OSwgIzgzMSlcbiAgaWYgKHJlc3VsdC5jaHJvbWUgJiYgdmlldy5sYXN0S2V5Q29kZSA9PT0gOCkge1xuICAgIGZvciAodmFyIG9mZiA9IHRvT2Zmc2V0OyBvZmYgPiBmcm9tT2Zmc2V0OyBvZmYtLSkge1xuICAgICAgdmFyIG5vZGUgPSBwYXJlbnQuY2hpbGROb2Rlc1tvZmYgLSAxXSwgZGVzYyA9IG5vZGUucG1WaWV3RGVzYztcbiAgICAgIGlmIChub2RlLm5vZGVOYW1lID09IFwiQlJcIiAmJiAhZGVzYykgeyB0b09mZnNldCA9IG9mZjsgYnJlYWsgfVxuICAgICAgaWYgKCFkZXNjIHx8IGRlc2Muc2l6ZSkgeyBicmVhayB9XG4gICAgfVxuICB9XG4gIHZhciBzdGFydERvYyA9IHZpZXcuc3RhdGUuZG9jO1xuICB2YXIgcGFyc2VyID0gdmlldy5zb21lUHJvcChcImRvbVBhcnNlclwiKSB8fCBET01QYXJzZXIuZnJvbVNjaGVtYSh2aWV3LnN0YXRlLnNjaGVtYSk7XG4gIHZhciAkZnJvbSA9IHN0YXJ0RG9jLnJlc29sdmUoZnJvbSk7XG5cbiAgdmFyIHNlbCA9IG51bGwsIGRvYyA9IHBhcnNlci5wYXJzZShwYXJlbnQsIHtcbiAgICB0b3BOb2RlOiAkZnJvbS5wYXJlbnQsXG4gICAgdG9wTWF0Y2g6ICRmcm9tLnBhcmVudC5jb250ZW50TWF0Y2hBdCgkZnJvbS5pbmRleCgpKSxcbiAgICB0b3BPcGVuOiB0cnVlLFxuICAgIGZyb206IGZyb21PZmZzZXQsXG4gICAgdG86IHRvT2Zmc2V0LFxuICAgIHByZXNlcnZlV2hpdGVzcGFjZTogJGZyb20ucGFyZW50LnR5cGUuc3BlYy5jb2RlID8gXCJmdWxsXCIgOiB0cnVlLFxuICAgIGVkaXRhYmxlQ29udGVudDogdHJ1ZSxcbiAgICBmaW5kUG9zaXRpb25zOiBmaW5kLFxuICAgIHJ1bGVGcm9tTm9kZTogcnVsZUZyb21Ob2RlLFxuICAgIGNvbnRleHQ6ICRmcm9tXG4gIH0pO1xuICBpZiAoZmluZCAmJiBmaW5kWzBdLnBvcyAhPSBudWxsKSB7XG4gICAgdmFyIGFuY2hvciQxID0gZmluZFswXS5wb3MsIGhlYWQgPSBmaW5kWzFdICYmIGZpbmRbMV0ucG9zO1xuICAgIGlmIChoZWFkID09IG51bGwpIHsgaGVhZCA9IGFuY2hvciQxOyB9XG4gICAgc2VsID0ge2FuY2hvcjogYW5jaG9yJDEgKyBmcm9tLCBoZWFkOiBoZWFkICsgZnJvbX07XG4gIH1cbiAgcmV0dXJuIHtkb2M6IGRvYywgc2VsOiBzZWwsIGZyb206IGZyb20sIHRvOiB0b31cbn1cblxuZnVuY3Rpb24gcnVsZUZyb21Ob2RlKGRvbSkge1xuICB2YXIgZGVzYyA9IGRvbS5wbVZpZXdEZXNjO1xuICBpZiAoZGVzYykge1xuICAgIHJldHVybiBkZXNjLnBhcnNlUnVsZSgpXG4gIH0gZWxzZSBpZiAoZG9tLm5vZGVOYW1lID09IFwiQlJcIiAmJiBkb20ucGFyZW50Tm9kZSkge1xuICAgIC8vIFNhZmFyaSByZXBsYWNlcyB0aGUgbGlzdCBpdGVtIG9yIHRhYmxlIGNlbGwgd2l0aCBhIEJSXG4gICAgLy8gZGlyZWN0bHkgaW4gdGhlIGxpc3Qgbm9kZSAoPyEpIGlmIHlvdSBkZWxldGUgdGhlIGxhc3RcbiAgICAvLyBjaGFyYWN0ZXIgaW4gYSBsaXN0IGl0ZW0gb3IgdGFibGUgY2VsbCAoIzcwOCwgIzg2MilcbiAgICBpZiAocmVzdWx0LnNhZmFyaSAmJiAvXih1bHxvbCkkL2kudGVzdChkb20ucGFyZW50Tm9kZS5ub2RlTmFtZSkpIHtcbiAgICAgIHZhciBza2lwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHNraXAuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpXCIpKTtcbiAgICAgIHJldHVybiB7c2tpcDogc2tpcH1cbiAgICB9IGVsc2UgaWYgKGRvbS5wYXJlbnROb2RlLmxhc3RDaGlsZCA9PSBkb20gfHwgcmVzdWx0LnNhZmFyaSAmJiAvXih0cnx0YWJsZSkkL2kudGVzdChkb20ucGFyZW50Tm9kZS5ub2RlTmFtZSkpIHtcbiAgICAgIHJldHVybiB7aWdub3JlOiB0cnVlfVxuICAgIH1cbiAgfSBlbHNlIGlmIChkb20ubm9kZU5hbWUgPT0gXCJJTUdcIiAmJiBkb20uZ2V0QXR0cmlidXRlKFwibWFyay1wbGFjZWhvbGRlclwiKSkge1xuICAgIHJldHVybiB7aWdub3JlOiB0cnVlfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlYWRET01DaGFuZ2UodmlldywgZnJvbSwgdG8sIHR5cGVPdmVyLCBhZGRlZE5vZGVzKSB7XG4gIGlmIChmcm9tIDwgMCkge1xuICAgIHZhciBvcmlnaW4gPSB2aWV3Lmxhc3RTZWxlY3Rpb25UaW1lID4gRGF0ZS5ub3coKSAtIDUwID8gdmlldy5sYXN0U2VsZWN0aW9uT3JpZ2luIDogbnVsbDtcbiAgICB2YXIgbmV3U2VsID0gc2VsZWN0aW9uRnJvbURPTSh2aWV3LCBvcmlnaW4pO1xuICAgIGlmIChuZXdTZWwgJiYgIXZpZXcuc3RhdGUuc2VsZWN0aW9uLmVxKG5ld1NlbCkpIHtcbiAgICAgIHZhciB0ciQxID0gdmlldy5zdGF0ZS50ci5zZXRTZWxlY3Rpb24obmV3U2VsKTtcbiAgICAgIGlmIChvcmlnaW4gPT0gXCJwb2ludGVyXCIpIHsgdHIkMS5zZXRNZXRhKFwicG9pbnRlclwiLCB0cnVlKTsgfVxuICAgICAgZWxzZSBpZiAob3JpZ2luID09IFwia2V5XCIpIHsgdHIkMS5zY3JvbGxJbnRvVmlldygpOyB9XG4gICAgICB2aWV3LmRpc3BhdGNoKHRyJDEpO1xuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciAkYmVmb3JlID0gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZShmcm9tKTtcbiAgdmFyIHNoYXJlZCA9ICRiZWZvcmUuc2hhcmVkRGVwdGgodG8pO1xuICBmcm9tID0gJGJlZm9yZS5iZWZvcmUoc2hhcmVkICsgMSk7XG4gIHRvID0gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZSh0bykuYWZ0ZXIoc2hhcmVkICsgMSk7XG5cbiAgdmFyIHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICB2YXIgcGFyc2UgPSBwYXJzZUJldHdlZW4odmlldywgZnJvbSwgdG8pO1xuICAvLyBDaHJvbWUgc29tZXRpbWVzIGxlYXZlcyB0aGUgY3Vyc29yIGJlZm9yZSB0aGUgaW5zZXJ0ZWQgdGV4dCB3aGVuXG4gIC8vIGNvbXBvc2luZyBhZnRlciBhIGN1cnNvciB3cmFwcGVyLiBUaGlzIG1vdmVzIGl0IGZvcndhcmQuXG4gIGlmIChyZXN1bHQuY2hyb21lICYmIHZpZXcuY3Vyc29yV3JhcHBlciAmJiBwYXJzZS5zZWwgJiYgcGFyc2Uuc2VsLmFuY2hvciA9PSB2aWV3LmN1cnNvcldyYXBwZXIuZGVjby5mcm9tKSB7XG4gICAgdmFyIHRleHQgPSB2aWV3LmN1cnNvcldyYXBwZXIuZGVjby50eXBlLnRvRE9NLm5leHRTaWJsaW5nO1xuICAgIHZhciBzaXplID0gdGV4dCAmJiB0ZXh0Lm5vZGVWYWx1ZSA/IHRleHQubm9kZVZhbHVlLmxlbmd0aCA6IDE7XG4gICAgcGFyc2Uuc2VsID0ge2FuY2hvcjogcGFyc2Uuc2VsLmFuY2hvciArIHNpemUsIGhlYWQ6IHBhcnNlLnNlbC5hbmNob3IgKyBzaXplfTtcbiAgfVxuXG4gIHZhciBkb2MgPSB2aWV3LnN0YXRlLmRvYywgY29tcGFyZSA9IGRvYy5zbGljZShwYXJzZS5mcm9tLCBwYXJzZS50byk7XG4gIHZhciBwcmVmZXJyZWRQb3MsIHByZWZlcnJlZFNpZGU7XG4gIC8vIFByZWZlciBhbmNob3JpbmcgdG8gZW5kIHdoZW4gQmFja3NwYWNlIGlzIHByZXNzZWRcbiAgaWYgKHZpZXcubGFzdEtleUNvZGUgPT09IDggJiYgRGF0ZS5ub3coKSAtIDEwMCA8IHZpZXcubGFzdEtleUNvZGVUaW1lKSB7XG4gICAgcHJlZmVycmVkUG9zID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24udG87XG4gICAgcHJlZmVycmVkU2lkZSA9IFwiZW5kXCI7XG4gIH0gZWxzZSB7XG4gICAgcHJlZmVycmVkUG9zID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbTtcbiAgICBwcmVmZXJyZWRTaWRlID0gXCJzdGFydFwiO1xuICB9XG4gIHZpZXcubGFzdEtleUNvZGUgPSBudWxsO1xuXG4gIHZhciBjaGFuZ2UgPSBmaW5kRGlmZihjb21wYXJlLmNvbnRlbnQsIHBhcnNlLmRvYy5jb250ZW50LCBwYXJzZS5mcm9tLCBwcmVmZXJyZWRQb3MsIHByZWZlcnJlZFNpZGUpO1xuICBpZiAoIWNoYW5nZSkge1xuICAgIGlmICh0eXBlT3ZlciAmJiBzZWwgaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uICYmICFzZWwuZW1wdHkgJiYgc2VsLiRoZWFkLnNhbWVQYXJlbnQoc2VsLiRhbmNob3IpICYmXG4gICAgICAgICF2aWV3LmNvbXBvc2luZyAmJiAhKHBhcnNlLnNlbCAmJiBwYXJzZS5zZWwuYW5jaG9yICE9IHBhcnNlLnNlbC5oZWFkKSkge1xuICAgICAgY2hhbmdlID0ge3N0YXJ0OiBzZWwuZnJvbSwgZW5kQTogc2VsLnRvLCBlbmRCOiBzZWwudG99O1xuICAgIH0gZWxzZSBpZiAoKHJlc3VsdC5pb3MgJiYgdmlldy5sYXN0SU9TRW50ZXIgPiBEYXRlLm5vdygpIC0gMjI1IHx8IHJlc3VsdC5hbmRyb2lkKSAmJlxuICAgICAgICAgICAgICAgYWRkZWROb2Rlcy5zb21lKGZ1bmN0aW9uIChuKSB7IHJldHVybiBuLm5vZGVOYW1lID09IFwiRElWXCIgfHwgbi5ub2RlTmFtZSA9PSBcIlBcIjsgfSkgJiZcbiAgICAgICAgICAgICAgIHZpZXcuc29tZVByb3AoXCJoYW5kbGVLZXlEb3duXCIsIGZ1bmN0aW9uIChmKSB7IHJldHVybiBmKHZpZXcsIGtleUV2ZW50KDEzLCBcIkVudGVyXCIpKTsgfSkpIHtcbiAgICAgIHZpZXcubGFzdElPU0VudGVyID0gMDtcbiAgICAgIHJldHVyblxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocGFyc2Uuc2VsKSB7XG4gICAgICAgIHZhciBzZWwkMSA9IHJlc29sdmVTZWxlY3Rpb24odmlldywgdmlldy5zdGF0ZS5kb2MsIHBhcnNlLnNlbCk7XG4gICAgICAgIGlmIChzZWwkMSAmJiAhc2VsJDEuZXEodmlldy5zdGF0ZS5zZWxlY3Rpb24pKSB7IHZpZXcuZGlzcGF0Y2godmlldy5zdGF0ZS50ci5zZXRTZWxlY3Rpb24oc2VsJDEpKTsgfVxuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG4gIHZpZXcuZG9tQ2hhbmdlQ291bnQrKztcbiAgLy8gSGFuZGxlIHRoZSBjYXNlIHdoZXJlIG92ZXJ3cml0aW5nIGEgc2VsZWN0aW9uIGJ5IHR5cGluZyBtYXRjaGVzXG4gIC8vIHRoZSBzdGFydCBvciBlbmQgb2YgdGhlIHNlbGVjdGVkIGNvbnRlbnQsIGNyZWF0aW5nIGEgY2hhbmdlXG4gIC8vIHRoYXQncyBzbWFsbGVyIHRoYW4gd2hhdCB3YXMgYWN0dWFsbHkgb3ZlcndyaXR0ZW4uXG4gIGlmICh2aWV3LnN0YXRlLnNlbGVjdGlvbi5mcm9tIDwgdmlldy5zdGF0ZS5zZWxlY3Rpb24udG8gJiZcbiAgICAgIGNoYW5nZS5zdGFydCA9PSBjaGFuZ2UuZW5kQiAmJlxuICAgICAgdmlldy5zdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uKSB7XG4gICAgaWYgKGNoYW5nZS5zdGFydCA+IHZpZXcuc3RhdGUuc2VsZWN0aW9uLmZyb20gJiYgY2hhbmdlLnN0YXJ0IDw9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLmZyb20gKyAyKSB7XG4gICAgICBjaGFuZ2Uuc3RhcnQgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi5mcm9tO1xuICAgIH0gZWxzZSBpZiAoY2hhbmdlLmVuZEEgPCB2aWV3LnN0YXRlLnNlbGVjdGlvbi50byAmJiBjaGFuZ2UuZW5kQSA+PSB2aWV3LnN0YXRlLnNlbGVjdGlvbi50byAtIDIpIHtcbiAgICAgIGNoYW5nZS5lbmRCICs9ICh2aWV3LnN0YXRlLnNlbGVjdGlvbi50byAtIGNoYW5nZS5lbmRBKTtcbiAgICAgIGNoYW5nZS5lbmRBID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24udG87XG4gICAgfVxuICB9XG5cbiAgLy8gSUUxMSB3aWxsIGluc2VydCBhIG5vbi1icmVha2luZyBzcGFjZSBfYWhlYWRfIG9mIHRoZSBzcGFjZSBhZnRlclxuICAvLyB0aGUgY3Vyc29yIHNwYWNlIHdoZW4gYWRkaW5nIGEgc3BhY2UgYmVmb3JlIGFub3RoZXIgc3BhY2UuIFdoZW5cbiAgLy8gdGhhdCBoYXBwZW5lZCwgYWRqdXN0IHRoZSBjaGFuZ2UgdG8gY292ZXIgdGhlIHNwYWNlIGluc3RlYWQuXG4gIGlmIChyZXN1bHQuaWUgJiYgcmVzdWx0LmllX3ZlcnNpb24gPD0gMTEgJiYgY2hhbmdlLmVuZEIgPT0gY2hhbmdlLnN0YXJ0ICsgMSAmJlxuICAgICAgY2hhbmdlLmVuZEEgPT0gY2hhbmdlLnN0YXJ0ICYmIGNoYW5nZS5zdGFydCA+IHBhcnNlLmZyb20gJiZcbiAgICAgIHBhcnNlLmRvYy50ZXh0QmV0d2VlbihjaGFuZ2Uuc3RhcnQgLSBwYXJzZS5mcm9tIC0gMSwgY2hhbmdlLnN0YXJ0IC0gcGFyc2UuZnJvbSArIDEpID09IFwiIFxcdTAwYTBcIikge1xuICAgIGNoYW5nZS5zdGFydC0tO1xuICAgIGNoYW5nZS5lbmRBLS07XG4gICAgY2hhbmdlLmVuZEItLTtcbiAgfVxuXG4gIHZhciAkZnJvbSA9IHBhcnNlLmRvYy5yZXNvbHZlTm9DYWNoZShjaGFuZ2Uuc3RhcnQgLSBwYXJzZS5mcm9tKTtcbiAgdmFyICR0byA9IHBhcnNlLmRvYy5yZXNvbHZlTm9DYWNoZShjaGFuZ2UuZW5kQiAtIHBhcnNlLmZyb20pO1xuICB2YXIgaW5saW5lQ2hhbmdlID0gJGZyb20uc2FtZVBhcmVudCgkdG8pICYmICRmcm9tLnBhcmVudC5pbmxpbmVDb250ZW50O1xuICB2YXIgbmV4dFNlbDtcbiAgLy8gSWYgdGhpcyBsb29rcyBsaWtlIHRoZSBlZmZlY3Qgb2YgcHJlc3NpbmcgRW50ZXIgKG9yIHdhcyByZWNvcmRlZFxuICAvLyBhcyBiZWluZyBhbiBpT1MgZW50ZXIgcHJlc3MpLCBqdXN0IGRpc3BhdGNoIGFuIEVudGVyIGtleSBpbnN0ZWFkLlxuICBpZiAoKChyZXN1bHQuaW9zICYmIHZpZXcubGFzdElPU0VudGVyID4gRGF0ZS5ub3coKSAtIDIyNSAmJlxuICAgICAgICAoIWlubGluZUNoYW5nZSB8fCBhZGRlZE5vZGVzLnNvbWUoZnVuY3Rpb24gKG4pIHsgcmV0dXJuIG4ubm9kZU5hbWUgPT0gXCJESVZcIiB8fCBuLm5vZGVOYW1lID09IFwiUFwiOyB9KSkpIHx8XG4gICAgICAgKCFpbmxpbmVDaGFuZ2UgJiYgJGZyb20ucG9zIDwgcGFyc2UuZG9jLmNvbnRlbnQuc2l6ZSAmJlxuICAgICAgICAobmV4dFNlbCA9IFNlbGVjdGlvbi5maW5kRnJvbShwYXJzZS5kb2MucmVzb2x2ZSgkZnJvbS5wb3MgKyAxKSwgMSwgdHJ1ZSkpICYmXG4gICAgICAgIG5leHRTZWwuaGVhZCA9PSAkdG8ucG9zKSkgJiZcbiAgICAgIHZpZXcuc29tZVByb3AoXCJoYW5kbGVLZXlEb3duXCIsIGZ1bmN0aW9uIChmKSB7IHJldHVybiBmKHZpZXcsIGtleUV2ZW50KDEzLCBcIkVudGVyXCIpKTsgfSkpIHtcbiAgICB2aWV3Lmxhc3RJT1NFbnRlciA9IDA7XG4gICAgcmV0dXJuXG4gIH1cbiAgLy8gU2FtZSBmb3IgYmFja3NwYWNlXG4gIGlmICh2aWV3LnN0YXRlLnNlbGVjdGlvbi5hbmNob3IgPiBjaGFuZ2Uuc3RhcnQgJiZcbiAgICAgIGxvb2tzTGlrZUpvaW4oZG9jLCBjaGFuZ2Uuc3RhcnQsIGNoYW5nZS5lbmRBLCAkZnJvbSwgJHRvKSAmJlxuICAgICAgdmlldy5zb21lUHJvcChcImhhbmRsZUtleURvd25cIiwgZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGYodmlldywga2V5RXZlbnQoOCwgXCJCYWNrc3BhY2VcIikpOyB9KSkge1xuICAgIGlmIChyZXN1bHQuYW5kcm9pZCAmJiByZXN1bHQuY2hyb21lKSB7IHZpZXcuZG9tT2JzZXJ2ZXIuc3VwcHJlc3NTZWxlY3Rpb25VcGRhdGVzKCk7IH0gLy8gIzgyMFxuICAgIHJldHVyblxuICB9XG5cbiAgLy8gQ2hyb21lIEFuZHJvaWQgd2lsbCBvY2Nhc2lvbmFsbHksIGR1cmluZyBjb21wb3NpdGlvbiwgZGVsZXRlIHRoZVxuICAvLyBlbnRpcmUgY29tcG9zaXRpb24gYW5kIHRoZW4gaW1tZWRpYXRlbHkgaW5zZXJ0IGl0IGFnYWluLiBUaGlzIGlzXG4gIC8vIHVzZWQgdG8gZGV0ZWN0IHRoYXQgc2l0dWF0aW9uLlxuICBpZiAocmVzdWx0LmNocm9tZSAmJiByZXN1bHQuYW5kcm9pZCAmJiBjaGFuZ2UudG9CID09IGNoYW5nZS5mcm9tKVxuICAgIHsgdmlldy5sYXN0QW5kcm9pZERlbGV0ZSA9IERhdGUubm93KCk7IH1cblxuICAvLyBUaGlzIHRyaWVzIHRvIGRldGVjdCBBbmRyb2lkIHZpcnR1YWwga2V5Ym9hcmRcbiAgLy8gZW50ZXItYW5kLXBpY2stc3VnZ2VzdGlvbiBhY3Rpb24uIFRoYXQgc29tZXRpbWVzIChzZWUgaXNzdWVcbiAgLy8gIzEwNTkpIGZpcnN0IGZpcmVzIGEgRE9NIG11dGF0aW9uLCBiZWZvcmUgbW92aW5nIHRoZSBzZWxlY3Rpb24gdG9cbiAgLy8gdGhlIG5ld2x5IGNyZWF0ZWQgYmxvY2suIEFuZCB0aGVuLCBiZWNhdXNlIFByb3NlTWlycm9yIGNsZWFucyB1cFxuICAvLyB0aGUgRE9NIHNlbGVjdGlvbiwgaXQgZ2l2ZXMgdXAgbW92aW5nIHRoZSBzZWxlY3Rpb24gZW50aXJlbHksXG4gIC8vIGxlYXZpbmcgdGhlIGN1cnNvciBpbiB0aGUgd3JvbmcgcGxhY2UuIFdoZW4gdGhhdCBoYXBwZW5zLCB3ZSBkcm9wXG4gIC8vIHRoZSBuZXcgcGFyYWdyYXBoIGZyb20gdGhlIGluaXRpYWwgY2hhbmdlLCBhbmQgZmlyZSBhIHNpbXVsYXRlZFxuICAvLyBlbnRlciBrZXkgYWZ0ZXJ3YXJkcy5cbiAgaWYgKHJlc3VsdC5hbmRyb2lkICYmICFpbmxpbmVDaGFuZ2UgJiYgJGZyb20uc3RhcnQoKSAhPSAkdG8uc3RhcnQoKSAmJiAkdG8ucGFyZW50T2Zmc2V0ID09IDAgJiYgJGZyb20uZGVwdGggPT0gJHRvLmRlcHRoICYmXG4gICAgICBwYXJzZS5zZWwgJiYgcGFyc2Uuc2VsLmFuY2hvciA9PSBwYXJzZS5zZWwuaGVhZCAmJiBwYXJzZS5zZWwuaGVhZCA9PSBjaGFuZ2UuZW5kQSkge1xuICAgIGNoYW5nZS5lbmRCIC09IDI7XG4gICAgJHRvID0gcGFyc2UuZG9jLnJlc29sdmVOb0NhY2hlKGNoYW5nZS5lbmRCIC0gcGFyc2UuZnJvbSk7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlS2V5RG93blwiLCBmdW5jdGlvbiAoZikgeyByZXR1cm4gZih2aWV3LCBrZXlFdmVudCgxMywgXCJFbnRlclwiKSk7IH0pO1xuICAgIH0sIDIwKTtcbiAgfVxuXG4gIHZhciBjaEZyb20gPSBjaGFuZ2Uuc3RhcnQsIGNoVG8gPSBjaGFuZ2UuZW5kQTtcblxuICB2YXIgdHIsIHN0b3JlZE1hcmtzLCBtYXJrQ2hhbmdlLCAkZnJvbTE7XG4gIGlmIChpbmxpbmVDaGFuZ2UpIHtcbiAgICBpZiAoJGZyb20ucG9zID09ICR0by5wb3MpIHsgLy8gRGVsZXRpb25cbiAgICAgIC8vIElFMTEgc29tZXRpbWVzIHdlaXJkbHkgbW92ZXMgdGhlIERPTSBzZWxlY3Rpb24gYXJvdW5kIGFmdGVyXG4gICAgICAvLyBiYWNrc3BhY2luZyBvdXQgdGhlIGZpcnN0IGVsZW1lbnQgaW4gYSB0ZXh0YmxvY2tcbiAgICAgIGlmIChyZXN1bHQuaWUgJiYgcmVzdWx0LmllX3ZlcnNpb24gPD0gMTEgJiYgJGZyb20ucGFyZW50T2Zmc2V0ID09IDApIHtcbiAgICAgICAgdmlldy5kb21PYnNlcnZlci5zdXBwcmVzc1NlbGVjdGlvblVwZGF0ZXMoKTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBzZWxlY3Rpb25Ub0RPTSh2aWV3KTsgfSwgMjApO1xuICAgICAgfVxuICAgICAgdHIgPSB2aWV3LnN0YXRlLnRyLmRlbGV0ZShjaEZyb20sIGNoVG8pO1xuICAgICAgc3RvcmVkTWFya3MgPSBkb2MucmVzb2x2ZShjaGFuZ2Uuc3RhcnQpLm1hcmtzQWNyb3NzKGRvYy5yZXNvbHZlKGNoYW5nZS5lbmRBKSk7XG4gICAgfSBlbHNlIGlmICggLy8gQWRkaW5nIG9yIHJlbW92aW5nIGEgbWFya1xuICAgICAgY2hhbmdlLmVuZEEgPT0gY2hhbmdlLmVuZEIgJiYgKCRmcm9tMSA9IGRvYy5yZXNvbHZlKGNoYW5nZS5zdGFydCkpICYmXG4gICAgICAobWFya0NoYW5nZSA9IGlzTWFya0NoYW5nZSgkZnJvbS5wYXJlbnQuY29udGVudC5jdXQoJGZyb20ucGFyZW50T2Zmc2V0LCAkdG8ucGFyZW50T2Zmc2V0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRmcm9tMS5wYXJlbnQuY29udGVudC5jdXQoJGZyb20xLnBhcmVudE9mZnNldCwgY2hhbmdlLmVuZEEgLSAkZnJvbTEuc3RhcnQoKSkpKVxuICAgICkge1xuICAgICAgdHIgPSB2aWV3LnN0YXRlLnRyO1xuICAgICAgaWYgKG1hcmtDaGFuZ2UudHlwZSA9PSBcImFkZFwiKSB7IHRyLmFkZE1hcmsoY2hGcm9tLCBjaFRvLCBtYXJrQ2hhbmdlLm1hcmspOyB9XG4gICAgICBlbHNlIHsgdHIucmVtb3ZlTWFyayhjaEZyb20sIGNoVG8sIG1hcmtDaGFuZ2UubWFyayk7IH1cbiAgICB9IGVsc2UgaWYgKCRmcm9tLnBhcmVudC5jaGlsZCgkZnJvbS5pbmRleCgpKS5pc1RleHQgJiYgJGZyb20uaW5kZXgoKSA9PSAkdG8uaW5kZXgoKSAtICgkdG8udGV4dE9mZnNldCA/IDAgOiAxKSkge1xuICAgICAgLy8gQm90aCBwb3NpdGlvbnMgaW4gdGhlIHNhbWUgdGV4dCBub2RlIC0tIHNpbXBseSBpbnNlcnQgdGV4dFxuICAgICAgdmFyIHRleHQkMSA9ICRmcm9tLnBhcmVudC50ZXh0QmV0d2VlbigkZnJvbS5wYXJlbnRPZmZzZXQsICR0by5wYXJlbnRPZmZzZXQpO1xuICAgICAgaWYgKHZpZXcuc29tZVByb3AoXCJoYW5kbGVUZXh0SW5wdXRcIiwgZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGYodmlldywgY2hGcm9tLCBjaFRvLCB0ZXh0JDEpOyB9KSkgeyByZXR1cm4gfVxuICAgICAgdHIgPSB2aWV3LnN0YXRlLnRyLmluc2VydFRleHQodGV4dCQxLCBjaEZyb20sIGNoVG8pO1xuICAgIH1cbiAgfVxuXG4gIGlmICghdHIpXG4gICAgeyB0ciA9IHZpZXcuc3RhdGUudHIucmVwbGFjZShjaEZyb20sIGNoVG8sIHBhcnNlLmRvYy5zbGljZShjaGFuZ2Uuc3RhcnQgLSBwYXJzZS5mcm9tLCBjaGFuZ2UuZW5kQiAtIHBhcnNlLmZyb20pKTsgfVxuICBpZiAocGFyc2Uuc2VsKSB7XG4gICAgdmFyIHNlbCQyID0gcmVzb2x2ZVNlbGVjdGlvbih2aWV3LCB0ci5kb2MsIHBhcnNlLnNlbCk7XG4gICAgLy8gQ2hyb21lIEFuZHJvaWQgd2lsbCBzb21ldGltZXMsIGR1cmluZyBjb21wb3NpdGlvbiwgcmVwb3J0IHRoZVxuICAgIC8vIHNlbGVjdGlvbiBpbiB0aGUgd3JvbmcgcGxhY2UuIElmIGl0IGxvb2tzIGxpa2UgdGhhdCBpc1xuICAgIC8vIGhhcHBlbmluZywgZG9uJ3QgdXBkYXRlIHRoZSBzZWxlY3Rpb24uXG4gICAgLy8gRWRnZSBqdXN0IGRvZXNuJ3QgbW92ZSB0aGUgY3Vyc29yIGZvcndhcmQgd2hlbiB5b3Ugc3RhcnQgdHlwaW5nXG4gICAgLy8gaW4gYW4gZW1wdHkgYmxvY2sgb3IgYmV0d2VlbiBiciBub2Rlcy5cbiAgICBpZiAoc2VsJDIgJiYgIShyZXN1bHQuY2hyb21lICYmIHJlc3VsdC5hbmRyb2lkICYmIHZpZXcuY29tcG9zaW5nICYmIHNlbCQyLmVtcHR5ICYmXG4gICAgICAgICAgICAgICAgIChjaGFuZ2Uuc3RhcnQgIT0gY2hhbmdlLmVuZEIgfHwgdmlldy5sYXN0QW5kcm9pZERlbGV0ZSA8IERhdGUubm93KCkgLSAxMDApICYmXG4gICAgICAgICAgICAgICAgIChzZWwkMi5oZWFkID09IGNoRnJvbSB8fCBzZWwkMi5oZWFkID09IHRyLm1hcHBpbmcubWFwKGNoVG8pIC0gMSkgfHxcbiAgICAgICAgICAgICAgICAgcmVzdWx0LmllICYmIHNlbCQyLmVtcHR5ICYmIHNlbCQyLmhlYWQgPT0gY2hGcm9tKSlcbiAgICAgIHsgdHIuc2V0U2VsZWN0aW9uKHNlbCQyKTsgfVxuICB9XG4gIGlmIChzdG9yZWRNYXJrcykgeyB0ci5lbnN1cmVNYXJrcyhzdG9yZWRNYXJrcyk7IH1cbiAgdmlldy5kaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVNlbGVjdGlvbih2aWV3LCBkb2MsIHBhcnNlZFNlbCkge1xuICBpZiAoTWF0aC5tYXgocGFyc2VkU2VsLmFuY2hvciwgcGFyc2VkU2VsLmhlYWQpID4gZG9jLmNvbnRlbnQuc2l6ZSkgeyByZXR1cm4gbnVsbCB9XG4gIHJldHVybiBzZWxlY3Rpb25CZXR3ZWVuKHZpZXcsIGRvYy5yZXNvbHZlKHBhcnNlZFNlbC5hbmNob3IpLCBkb2MucmVzb2x2ZShwYXJzZWRTZWwuaGVhZCkpXG59XG5cbi8vIDogKEZyYWdtZW50LCBGcmFnbWVudCkg4oaSID97bWFyazogTWFyaywgdHlwZTogc3RyaW5nfVxuLy8gR2l2ZW4gdHdvIHNhbWUtbGVuZ3RoLCBub24tZW1wdHkgZnJhZ21lbnRzIG9mIGlubGluZSBjb250ZW50LFxuLy8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGZpcnN0IGNvdWxkIGJlIGNyZWF0ZWQgZnJvbSB0aGUgc2Vjb25kIGJ5XG4vLyByZW1vdmluZyBvciBhZGRpbmcgYSBzaW5nbGUgbWFyayB0eXBlLlxuZnVuY3Rpb24gaXNNYXJrQ2hhbmdlKGN1ciwgcHJldikge1xuICB2YXIgY3VyTWFya3MgPSBjdXIuZmlyc3RDaGlsZC5tYXJrcywgcHJldk1hcmtzID0gcHJldi5maXJzdENoaWxkLm1hcmtzO1xuICB2YXIgYWRkZWQgPSBjdXJNYXJrcywgcmVtb3ZlZCA9IHByZXZNYXJrcywgdHlwZSwgbWFyaywgdXBkYXRlO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByZXZNYXJrcy5sZW5ndGg7IGkrKykgeyBhZGRlZCA9IHByZXZNYXJrc1tpXS5yZW1vdmVGcm9tU2V0KGFkZGVkKTsgfVxuICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjdXJNYXJrcy5sZW5ndGg7IGkkMSsrKSB7IHJlbW92ZWQgPSBjdXJNYXJrc1tpJDFdLnJlbW92ZUZyb21TZXQocmVtb3ZlZCk7IH1cbiAgaWYgKGFkZGVkLmxlbmd0aCA9PSAxICYmIHJlbW92ZWQubGVuZ3RoID09IDApIHtcbiAgICBtYXJrID0gYWRkZWRbMF07XG4gICAgdHlwZSA9IFwiYWRkXCI7XG4gICAgdXBkYXRlID0gZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUubWFyayhtYXJrLmFkZFRvU2V0KG5vZGUubWFya3MpKTsgfTtcbiAgfSBlbHNlIGlmIChhZGRlZC5sZW5ndGggPT0gMCAmJiByZW1vdmVkLmxlbmd0aCA9PSAxKSB7XG4gICAgbWFyayA9IHJlbW92ZWRbMF07XG4gICAgdHlwZSA9IFwicmVtb3ZlXCI7XG4gICAgdXBkYXRlID0gZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUubWFyayhtYXJrLnJlbW92ZUZyb21TZXQobm9kZS5tYXJrcykpOyB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsXG4gIH1cbiAgdmFyIHVwZGF0ZWQgPSBbXTtcbiAgZm9yICh2YXIgaSQyID0gMDsgaSQyIDwgcHJldi5jaGlsZENvdW50OyBpJDIrKykgeyB1cGRhdGVkLnB1c2godXBkYXRlKHByZXYuY2hpbGQoaSQyKSkpOyB9XG4gIGlmIChGcmFnbWVudC5mcm9tKHVwZGF0ZWQpLmVxKGN1cikpIHsgcmV0dXJuIHttYXJrOiBtYXJrLCB0eXBlOiB0eXBlfSB9XG59XG5cbmZ1bmN0aW9uIGxvb2tzTGlrZUpvaW4ob2xkLCBzdGFydCwgZW5kLCAkbmV3U3RhcnQsICRuZXdFbmQpIHtcbiAgaWYgKCEkbmV3U3RhcnQucGFyZW50LmlzVGV4dGJsb2NrIHx8XG4gICAgICAvLyBUaGUgY29udGVudCBtdXN0IGhhdmUgc2hydW5rXG4gICAgICBlbmQgLSBzdGFydCA8PSAkbmV3RW5kLnBvcyAtICRuZXdTdGFydC5wb3MgfHxcbiAgICAgIC8vIG5ld0VuZCBtdXN0IHBvaW50IGRpcmVjdGx5IGF0IG9yIGFmdGVyIHRoZSBlbmQgb2YgdGhlIGJsb2NrIHRoYXQgbmV3U3RhcnQgcG9pbnRzIGludG9cbiAgICAgIHNraXBDbG9zaW5nQW5kT3BlbmluZygkbmV3U3RhcnQsIHRydWUsIGZhbHNlKSA8ICRuZXdFbmQucG9zKVxuICAgIHsgcmV0dXJuIGZhbHNlIH1cblxuICB2YXIgJHN0YXJ0ID0gb2xkLnJlc29sdmUoc3RhcnQpO1xuICAvLyBTdGFydCBtdXN0IGJlIGF0IHRoZSBlbmQgb2YgYSBibG9ja1xuICBpZiAoJHN0YXJ0LnBhcmVudE9mZnNldCA8ICRzdGFydC5wYXJlbnQuY29udGVudC5zaXplIHx8ICEkc3RhcnQucGFyZW50LmlzVGV4dGJsb2NrKVxuICAgIHsgcmV0dXJuIGZhbHNlIH1cbiAgdmFyICRuZXh0ID0gb2xkLnJlc29sdmUoc2tpcENsb3NpbmdBbmRPcGVuaW5nKCRzdGFydCwgdHJ1ZSwgdHJ1ZSkpO1xuICAvLyBUaGUgbmV4dCB0ZXh0YmxvY2sgbXVzdCBzdGFydCBiZWZvcmUgZW5kIGFuZCBlbmQgbmVhciBpdFxuICBpZiAoISRuZXh0LnBhcmVudC5pc1RleHRibG9jayB8fCAkbmV4dC5wb3MgPiBlbmQgfHxcbiAgICAgIHNraXBDbG9zaW5nQW5kT3BlbmluZygkbmV4dCwgdHJ1ZSwgZmFsc2UpIDwgZW5kKVxuICAgIHsgcmV0dXJuIGZhbHNlIH1cblxuICAvLyBUaGUgZnJhZ21lbnRzIGFmdGVyIHRoZSBqb2luIHBvaW50IG11c3QgbWF0Y2hcbiAgcmV0dXJuICRuZXdTdGFydC5wYXJlbnQuY29udGVudC5jdXQoJG5ld1N0YXJ0LnBhcmVudE9mZnNldCkuZXEoJG5leHQucGFyZW50LmNvbnRlbnQpXG59XG5cbmZ1bmN0aW9uIHNraXBDbG9zaW5nQW5kT3BlbmluZygkcG9zLCBmcm9tRW5kLCBtYXlPcGVuKSB7XG4gIHZhciBkZXB0aCA9ICRwb3MuZGVwdGgsIGVuZCA9IGZyb21FbmQgPyAkcG9zLmVuZCgpIDogJHBvcy5wb3M7XG4gIHdoaWxlIChkZXB0aCA+IDAgJiYgKGZyb21FbmQgfHwgJHBvcy5pbmRleEFmdGVyKGRlcHRoKSA9PSAkcG9zLm5vZGUoZGVwdGgpLmNoaWxkQ291bnQpKSB7XG4gICAgZGVwdGgtLTtcbiAgICBlbmQrKztcbiAgICBmcm9tRW5kID0gZmFsc2U7XG4gIH1cbiAgaWYgKG1heU9wZW4pIHtcbiAgICB2YXIgbmV4dCA9ICRwb3Mubm9kZShkZXB0aCkubWF5YmVDaGlsZCgkcG9zLmluZGV4QWZ0ZXIoZGVwdGgpKTtcbiAgICB3aGlsZSAobmV4dCAmJiAhbmV4dC5pc0xlYWYpIHtcbiAgICAgIG5leHQgPSBuZXh0LmZpcnN0Q2hpbGQ7XG4gICAgICBlbmQrKztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVuZFxufVxuXG5mdW5jdGlvbiBmaW5kRGlmZihhLCBiLCBwb3MsIHByZWZlcnJlZFBvcywgcHJlZmVycmVkU2lkZSkge1xuICB2YXIgc3RhcnQgPSBhLmZpbmREaWZmU3RhcnQoYiwgcG9zKTtcbiAgaWYgKHN0YXJ0ID09IG51bGwpIHsgcmV0dXJuIG51bGwgfVxuICB2YXIgcmVmID0gYS5maW5kRGlmZkVuZChiLCBwb3MgKyBhLnNpemUsIHBvcyArIGIuc2l6ZSk7XG4gIHZhciBlbmRBID0gcmVmLmE7XG4gIHZhciBlbmRCID0gcmVmLmI7XG4gIGlmIChwcmVmZXJyZWRTaWRlID09IFwiZW5kXCIpIHtcbiAgICB2YXIgYWRqdXN0ID0gTWF0aC5tYXgoMCwgc3RhcnQgLSBNYXRoLm1pbihlbmRBLCBlbmRCKSk7XG4gICAgcHJlZmVycmVkUG9zIC09IGVuZEEgKyBhZGp1c3QgLSBzdGFydDtcbiAgfVxuICBpZiAoZW5kQSA8IHN0YXJ0ICYmIGEuc2l6ZSA8IGIuc2l6ZSkge1xuICAgIHZhciBtb3ZlID0gcHJlZmVycmVkUG9zIDw9IHN0YXJ0ICYmIHByZWZlcnJlZFBvcyA+PSBlbmRBID8gc3RhcnQgLSBwcmVmZXJyZWRQb3MgOiAwO1xuICAgIHN0YXJ0IC09IG1vdmU7XG4gICAgZW5kQiA9IHN0YXJ0ICsgKGVuZEIgLSBlbmRBKTtcbiAgICBlbmRBID0gc3RhcnQ7XG4gIH0gZWxzZSBpZiAoZW5kQiA8IHN0YXJ0KSB7XG4gICAgdmFyIG1vdmUkMSA9IHByZWZlcnJlZFBvcyA8PSBzdGFydCAmJiBwcmVmZXJyZWRQb3MgPj0gZW5kQiA/IHN0YXJ0IC0gcHJlZmVycmVkUG9zIDogMDtcbiAgICBzdGFydCAtPSBtb3ZlJDE7XG4gICAgZW5kQSA9IHN0YXJ0ICsgKGVuZEEgLSBlbmRCKTtcbiAgICBlbmRCID0gc3RhcnQ7XG4gIH1cbiAgcmV0dXJuIHtzdGFydDogc3RhcnQsIGVuZEE6IGVuZEEsIGVuZEI6IGVuZEJ9XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZUZvckNsaXBib2FyZCh2aWV3LCBzbGljZSkge1xuICB2YXIgY29udGV4dCA9IFtdO1xuICB2YXIgY29udGVudCA9IHNsaWNlLmNvbnRlbnQ7XG4gIHZhciBvcGVuU3RhcnQgPSBzbGljZS5vcGVuU3RhcnQ7XG4gIHZhciBvcGVuRW5kID0gc2xpY2Uub3BlbkVuZDtcbiAgd2hpbGUgKG9wZW5TdGFydCA+IDEgJiYgb3BlbkVuZCA+IDEgJiYgY29udGVudC5jaGlsZENvdW50ID09IDEgJiYgY29udGVudC5maXJzdENoaWxkLmNoaWxkQ291bnQgPT0gMSkge1xuICAgIG9wZW5TdGFydC0tO1xuICAgIG9wZW5FbmQtLTtcbiAgICB2YXIgbm9kZSA9IGNvbnRlbnQuZmlyc3RDaGlsZDtcbiAgICBjb250ZXh0LnB1c2gobm9kZS50eXBlLm5hbWUsIG5vZGUuYXR0cnMgIT0gbm9kZS50eXBlLmRlZmF1bHRBdHRycyA/IG5vZGUuYXR0cnMgOiBudWxsKTtcbiAgICBjb250ZW50ID0gbm9kZS5jb250ZW50O1xuICB9XG5cbiAgdmFyIHNlcmlhbGl6ZXIgPSB2aWV3LnNvbWVQcm9wKFwiY2xpcGJvYXJkU2VyaWFsaXplclwiKSB8fCBET01TZXJpYWxpemVyLmZyb21TY2hlbWEodmlldy5zdGF0ZS5zY2hlbWEpO1xuICB2YXIgZG9jID0gZGV0YWNoZWREb2MoKSwgd3JhcCA9IGRvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICB3cmFwLmFwcGVuZENoaWxkKHNlcmlhbGl6ZXIuc2VyaWFsaXplRnJhZ21lbnQoY29udGVudCwge2RvY3VtZW50OiBkb2N9KSk7XG5cbiAgdmFyIGZpcnN0Q2hpbGQgPSB3cmFwLmZpcnN0Q2hpbGQsIG5lZWRzV3JhcDtcbiAgd2hpbGUgKGZpcnN0Q2hpbGQgJiYgZmlyc3RDaGlsZC5ub2RlVHlwZSA9PSAxICYmIChuZWVkc1dyYXAgPSB3cmFwTWFwW2ZpcnN0Q2hpbGQubm9kZU5hbWUudG9Mb3dlckNhc2UoKV0pKSB7XG4gICAgZm9yICh2YXIgaSA9IG5lZWRzV3JhcC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIHdyYXBwZXIgPSBkb2MuY3JlYXRlRWxlbWVudChuZWVkc1dyYXBbaV0pO1xuICAgICAgd2hpbGUgKHdyYXAuZmlyc3RDaGlsZCkgeyB3cmFwcGVyLmFwcGVuZENoaWxkKHdyYXAuZmlyc3RDaGlsZCk7IH1cbiAgICAgIHdyYXAuYXBwZW5kQ2hpbGQod3JhcHBlcik7XG4gICAgICBpZiAobmVlZHNXcmFwW2ldICE9IFwidGJvZHlcIikge1xuICAgICAgICBvcGVuU3RhcnQrKztcbiAgICAgICAgb3BlbkVuZCsrO1xuICAgICAgfVxuICAgIH1cbiAgICBmaXJzdENoaWxkID0gd3JhcC5maXJzdENoaWxkO1xuICB9XG5cbiAgaWYgKGZpcnN0Q2hpbGQgJiYgZmlyc3RDaGlsZC5ub2RlVHlwZSA9PSAxKVxuICAgIHsgZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXBtLXNsaWNlXCIsIChvcGVuU3RhcnQgKyBcIiBcIiArIG9wZW5FbmQgKyBcIiBcIiArIChKU09OLnN0cmluZ2lmeShjb250ZXh0KSkpKTsgfVxuXG4gIHZhciB0ZXh0ID0gdmlldy5zb21lUHJvcChcImNsaXBib2FyZFRleHRTZXJpYWxpemVyXCIsIGZ1bmN0aW9uIChmKSB7IHJldHVybiBmKHNsaWNlKTsgfSkgfHxcbiAgICAgIHNsaWNlLmNvbnRlbnQudGV4dEJldHdlZW4oMCwgc2xpY2UuY29udGVudC5zaXplLCBcIlxcblxcblwiKTtcblxuICByZXR1cm4ge2RvbTogd3JhcCwgdGV4dDogdGV4dH1cbn1cblxuLy8gOiAoRWRpdG9yVmlldywgc3RyaW5nLCBzdHJpbmcsID9ib29sLCBSZXNvbHZlZFBvcykg4oaSID9TbGljZVxuLy8gUmVhZCBhIHNsaWNlIG9mIGNvbnRlbnQgZnJvbSB0aGUgY2xpcGJvYXJkIChvciBkcm9wIGRhdGEpLlxuZnVuY3Rpb24gcGFyc2VGcm9tQ2xpcGJvYXJkKHZpZXcsIHRleHQsIGh0bWwsIHBsYWluVGV4dCwgJGNvbnRleHQpIHtcbiAgdmFyIGRvbSwgaW5Db2RlID0gJGNvbnRleHQucGFyZW50LnR5cGUuc3BlYy5jb2RlLCBzbGljZTtcbiAgaWYgKCFodG1sICYmICF0ZXh0KSB7IHJldHVybiBudWxsIH1cbiAgdmFyIGFzVGV4dCA9IHRleHQgJiYgKHBsYWluVGV4dCB8fCBpbkNvZGUgfHwgIWh0bWwpO1xuICBpZiAoYXNUZXh0KSB7XG4gICAgdmlldy5zb21lUHJvcChcInRyYW5zZm9ybVBhc3RlZFRleHRcIiwgZnVuY3Rpb24gKGYpIHsgdGV4dCA9IGYodGV4dCwgaW5Db2RlIHx8IHBsYWluVGV4dCk7IH0pO1xuICAgIGlmIChpbkNvZGUpIHsgcmV0dXJuIHRleHQgPyBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbSh2aWV3LnN0YXRlLnNjaGVtYS50ZXh0KHRleHQucmVwbGFjZSgvXFxyXFxuPy9nLCBcIlxcblwiKSkpLCAwLCAwKSA6IFNsaWNlLmVtcHR5IH1cbiAgICB2YXIgcGFyc2VkID0gdmlldy5zb21lUHJvcChcImNsaXBib2FyZFRleHRQYXJzZXJcIiwgZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGYodGV4dCwgJGNvbnRleHQsIHBsYWluVGV4dCk7IH0pO1xuICAgIGlmIChwYXJzZWQpIHtcbiAgICAgIHNsaWNlID0gcGFyc2VkO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbWFya3MgPSAkY29udGV4dC5tYXJrcygpO1xuICAgICAgdmFyIHJlZiA9IHZpZXcuc3RhdGU7XG4gICAgICB2YXIgc2NoZW1hID0gcmVmLnNjaGVtYTtcbiAgICAgIHZhciBzZXJpYWxpemVyID0gRE9NU2VyaWFsaXplci5mcm9tU2NoZW1hKHNjaGVtYSk7XG4gICAgICBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdGV4dC5zcGxpdCgvKD86XFxyXFxuP3xcXG4pKy8pLmZvckVhY2goZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgIHZhciBwID0gZG9tLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJwXCIpKTtcbiAgICAgICAgaWYgKGJsb2NrKSB7IHAuYXBwZW5kQ2hpbGQoc2VyaWFsaXplci5zZXJpYWxpemVOb2RlKHNjaGVtYS50ZXh0KGJsb2NrLCBtYXJrcykpKTsgfVxuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZpZXcuc29tZVByb3AoXCJ0cmFuc2Zvcm1QYXN0ZWRIVE1MXCIsIGZ1bmN0aW9uIChmKSB7IGh0bWwgPSBmKGh0bWwpOyB9KTtcbiAgICBkb20gPSByZWFkSFRNTChodG1sKTtcbiAgICBpZiAocmVzdWx0LndlYmtpdCkgeyByZXN0b3JlUmVwbGFjZWRTcGFjZXMoZG9tKTsgfVxuICB9XG5cbiAgdmFyIGNvbnRleHROb2RlID0gZG9tICYmIGRvbS5xdWVyeVNlbGVjdG9yKFwiW2RhdGEtcG0tc2xpY2VdXCIpO1xuICB2YXIgc2xpY2VEYXRhID0gY29udGV4dE5vZGUgJiYgL14oXFxkKykgKFxcZCspICguKikvLmV4ZWMoY29udGV4dE5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1wbS1zbGljZVwiKSk7XG4gIGlmICghc2xpY2UpIHtcbiAgICB2YXIgcGFyc2VyID0gdmlldy5zb21lUHJvcChcImNsaXBib2FyZFBhcnNlclwiKSB8fCB2aWV3LnNvbWVQcm9wKFwiZG9tUGFyc2VyXCIpIHx8IERPTVBhcnNlci5mcm9tU2NoZW1hKHZpZXcuc3RhdGUuc2NoZW1hKTtcbiAgICBzbGljZSA9IHBhcnNlci5wYXJzZVNsaWNlKGRvbSwge3ByZXNlcnZlV2hpdGVzcGFjZTogISEoYXNUZXh0IHx8IHNsaWNlRGF0YSksIGNvbnRleHQ6ICRjb250ZXh0fSk7XG4gIH1cbiAgaWYgKHNsaWNlRGF0YSkge1xuICAgIHNsaWNlID0gYWRkQ29udGV4dChjbG9zZVNsaWNlKHNsaWNlLCArc2xpY2VEYXRhWzFdLCArc2xpY2VEYXRhWzJdKSwgc2xpY2VEYXRhWzNdKTtcbiAgfSBlbHNlIHsgLy8gSFRNTCB3YXNuJ3QgY3JlYXRlZCBieSBQcm9zZU1pcnJvci4gTWFrZSBzdXJlIHRvcC1sZXZlbCBzaWJsaW5ncyBhcmUgY29oZXJlbnRcbiAgICBzbGljZSA9IFNsaWNlLm1heE9wZW4obm9ybWFsaXplU2libGluZ3Moc2xpY2UuY29udGVudCwgJGNvbnRleHQpLCB0cnVlKTtcbiAgICBpZiAoc2xpY2Uub3BlblN0YXJ0IHx8IHNsaWNlLm9wZW5FbmQpIHtcbiAgICAgIHZhciBvcGVuU3RhcnQgPSAwLCBvcGVuRW5kID0gMDtcbiAgICAgIGZvciAodmFyIG5vZGUgPSBzbGljZS5jb250ZW50LmZpcnN0Q2hpbGQ7IG9wZW5TdGFydCA8IHNsaWNlLm9wZW5TdGFydCAmJiAhbm9kZS50eXBlLnNwZWMuaXNvbGF0aW5nO1xuICAgICAgICAgICBvcGVuU3RhcnQrKywgbm9kZSA9IG5vZGUuZmlyc3RDaGlsZCkge31cbiAgICAgIGZvciAodmFyIG5vZGUkMSA9IHNsaWNlLmNvbnRlbnQubGFzdENoaWxkOyBvcGVuRW5kIDwgc2xpY2Uub3BlbkVuZCAmJiAhbm9kZSQxLnR5cGUuc3BlYy5pc29sYXRpbmc7XG4gICAgICAgICAgIG9wZW5FbmQrKywgbm9kZSQxID0gbm9kZSQxLmxhc3RDaGlsZCkge31cbiAgICAgIHNsaWNlID0gY2xvc2VTbGljZShzbGljZSwgb3BlblN0YXJ0LCBvcGVuRW5kKTtcbiAgICB9XG4gIH1cblxuICB2aWV3LnNvbWVQcm9wKFwidHJhbnNmb3JtUGFzdGVkXCIsIGZ1bmN0aW9uIChmKSB7IHNsaWNlID0gZihzbGljZSk7IH0pO1xuICByZXR1cm4gc2xpY2Vcbn1cblxuLy8gVGFrZXMgYSBzbGljZSBwYXJzZWQgd2l0aCBwYXJzZVNsaWNlLCB3aGljaCBtZWFucyB0aGVyZSBoYXNuJ3QgYmVlblxuLy8gYW55IGNvbnRlbnQtZXhwcmVzc2lvbiBjaGVja2luZyBkb25lIG9uIHRoZSB0b3Agbm9kZXMsIHRyaWVzIHRvXG4vLyBmaW5kIGEgcGFyZW50IG5vZGUgaW4gdGhlIGN1cnJlbnQgY29udGV4dCB0aGF0IG1pZ2h0IGZpdCB0aGUgbm9kZXMsXG4vLyBhbmQgaWYgc3VjY2Vzc2Z1bCwgcmVidWlsZHMgdGhlIHNsaWNlIHNvIHRoYXQgaXQgZml0cyBpbnRvIHRoYXQgcGFyZW50LlxuLy9cbi8vIFRoaXMgYWRkcmVzc2VzIHRoZSBwcm9ibGVtIHRoYXQgVHJhbnNmb3JtLnJlcGxhY2UgZXhwZWN0cyBhXG4vLyBjb2hlcmVudCBzbGljZSwgYW5kIHdpbGwgZmFpbCB0byBwbGFjZSBhIHNldCBvZiBzaWJsaW5ncyB0aGF0IGRvbid0XG4vLyBmaXQgYW55d2hlcmUgaW4gdGhlIHNjaGVtYS5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNpYmxpbmdzKGZyYWdtZW50LCAkY29udGV4dCkge1xuICBpZiAoZnJhZ21lbnQuY2hpbGRDb3VudCA8IDIpIHsgcmV0dXJuIGZyYWdtZW50IH1cbiAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGQgKSB7XG4gICAgdmFyIHBhcmVudCA9ICRjb250ZXh0Lm5vZGUoZCk7XG4gICAgdmFyIG1hdGNoID0gcGFyZW50LmNvbnRlbnRNYXRjaEF0KCRjb250ZXh0LmluZGV4KGQpKTtcbiAgICB2YXIgbGFzdFdyYXAgPSAodm9pZCAwKSwgcmVzdWx0ID0gW107XG4gICAgZnJhZ21lbnQuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgaWYgKCFyZXN1bHQpIHsgcmV0dXJuIH1cbiAgICAgIHZhciB3cmFwID0gbWF0Y2guZmluZFdyYXBwaW5nKG5vZGUudHlwZSksIGluTGFzdDtcbiAgICAgIGlmICghd3JhcCkgeyByZXR1cm4gcmVzdWx0ID0gbnVsbCB9XG4gICAgICBpZiAoaW5MYXN0ID0gcmVzdWx0Lmxlbmd0aCAmJiBsYXN0V3JhcC5sZW5ndGggJiYgYWRkVG9TaWJsaW5nKHdyYXAsIGxhc3RXcmFwLCBub2RlLCByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdLCAwKSkge1xuICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdID0gaW5MYXN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGgpIHsgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSA9IGNsb3NlUmlnaHQocmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSwgbGFzdFdyYXAubGVuZ3RoKTsgfVxuICAgICAgICB2YXIgd3JhcHBlZCA9IHdpdGhXcmFwcGVycyhub2RlLCB3cmFwKTtcbiAgICAgICAgcmVzdWx0LnB1c2god3JhcHBlZCk7XG4gICAgICAgIG1hdGNoID0gbWF0Y2gubWF0Y2hUeXBlKHdyYXBwZWQudHlwZSwgd3JhcHBlZC5hdHRycyk7XG4gICAgICAgIGxhc3RXcmFwID0gd3JhcDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAocmVzdWx0KSB7IHJldHVybiB7IHY6IEZyYWdtZW50LmZyb20ocmVzdWx0KSB9IH1cbiAgfTtcblxuICBmb3IgKHZhciBkID0gJGNvbnRleHQuZGVwdGg7IGQgPj0gMDsgZC0tKSB7XG4gICAgdmFyIHJldHVybmVkID0gbG9vcCggZCApO1xuXG4gICAgaWYgKCByZXR1cm5lZCApIHJldHVybiByZXR1cm5lZC52O1xuICB9XG4gIHJldHVybiBmcmFnbWVudFxufVxuXG5mdW5jdGlvbiB3aXRoV3JhcHBlcnMobm9kZSwgd3JhcCwgZnJvbSkge1xuICBpZiAoIGZyb20gPT09IHZvaWQgMCApIGZyb20gPSAwO1xuXG4gIGZvciAodmFyIGkgPSB3cmFwLmxlbmd0aCAtIDE7IGkgPj0gZnJvbTsgaS0tKVxuICAgIHsgbm9kZSA9IHdyYXBbaV0uY3JlYXRlKG51bGwsIEZyYWdtZW50LmZyb20obm9kZSkpOyB9XG4gIHJldHVybiBub2RlXG59XG5cbi8vIFVzZWQgdG8gZ3JvdXAgYWRqYWNlbnQgbm9kZXMgd3JhcHBlZCBpbiBzaW1pbGFyIHBhcmVudHMgYnlcbi8vIG5vcm1hbGl6ZVNpYmxpbmdzIGludG8gdGhlIHNhbWUgcGFyZW50IG5vZGVcbmZ1bmN0aW9uIGFkZFRvU2libGluZyh3cmFwLCBsYXN0V3JhcCwgbm9kZSwgc2libGluZywgZGVwdGgpIHtcbiAgaWYgKGRlcHRoIDwgd3JhcC5sZW5ndGggJiYgZGVwdGggPCBsYXN0V3JhcC5sZW5ndGggJiYgd3JhcFtkZXB0aF0gPT0gbGFzdFdyYXBbZGVwdGhdKSB7XG4gICAgdmFyIGlubmVyID0gYWRkVG9TaWJsaW5nKHdyYXAsIGxhc3RXcmFwLCBub2RlLCBzaWJsaW5nLmxhc3RDaGlsZCwgZGVwdGggKyAxKTtcbiAgICBpZiAoaW5uZXIpIHsgcmV0dXJuIHNpYmxpbmcuY29weShzaWJsaW5nLmNvbnRlbnQucmVwbGFjZUNoaWxkKHNpYmxpbmcuY2hpbGRDb3VudCAtIDEsIGlubmVyKSkgfVxuICAgIHZhciBtYXRjaCA9IHNpYmxpbmcuY29udGVudE1hdGNoQXQoc2libGluZy5jaGlsZENvdW50KTtcbiAgICBpZiAobWF0Y2gubWF0Y2hUeXBlKGRlcHRoID09IHdyYXAubGVuZ3RoIC0gMSA/IG5vZGUudHlwZSA6IHdyYXBbZGVwdGggKyAxXSkpXG4gICAgICB7IHJldHVybiBzaWJsaW5nLmNvcHkoc2libGluZy5jb250ZW50LmFwcGVuZChGcmFnbWVudC5mcm9tKHdpdGhXcmFwcGVycyhub2RlLCB3cmFwLCBkZXB0aCArIDEpKSkpIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjbG9zZVJpZ2h0KG5vZGUsIGRlcHRoKSB7XG4gIGlmIChkZXB0aCA9PSAwKSB7IHJldHVybiBub2RlIH1cbiAgdmFyIGZyYWdtZW50ID0gbm9kZS5jb250ZW50LnJlcGxhY2VDaGlsZChub2RlLmNoaWxkQ291bnQgLSAxLCBjbG9zZVJpZ2h0KG5vZGUubGFzdENoaWxkLCBkZXB0aCAtIDEpKTtcbiAgdmFyIGZpbGwgPSBub2RlLmNvbnRlbnRNYXRjaEF0KG5vZGUuY2hpbGRDb3VudCkuZmlsbEJlZm9yZShGcmFnbWVudC5lbXB0eSwgdHJ1ZSk7XG4gIHJldHVybiBub2RlLmNvcHkoZnJhZ21lbnQuYXBwZW5kKGZpbGwpKVxufVxuXG5mdW5jdGlvbiBjbG9zZVJhbmdlKGZyYWdtZW50LCBzaWRlLCBmcm9tLCB0bywgZGVwdGgsIG9wZW5FbmQpIHtcbiAgdmFyIG5vZGUgPSBzaWRlIDwgMCA/IGZyYWdtZW50LmZpcnN0Q2hpbGQgOiBmcmFnbWVudC5sYXN0Q2hpbGQsIGlubmVyID0gbm9kZS5jb250ZW50O1xuICBpZiAoZGVwdGggPCB0byAtIDEpIHsgaW5uZXIgPSBjbG9zZVJhbmdlKGlubmVyLCBzaWRlLCBmcm9tLCB0bywgZGVwdGggKyAxLCBvcGVuRW5kKTsgfVxuICBpZiAoZGVwdGggPj0gZnJvbSlcbiAgICB7IGlubmVyID0gc2lkZSA8IDAgPyBub2RlLmNvbnRlbnRNYXRjaEF0KDApLmZpbGxCZWZvcmUoaW5uZXIsIGZyYWdtZW50LmNoaWxkQ291bnQgPiAxIHx8IG9wZW5FbmQgPD0gZGVwdGgpLmFwcGVuZChpbm5lcilcbiAgICAgIDogaW5uZXIuYXBwZW5kKG5vZGUuY29udGVudE1hdGNoQXQobm9kZS5jaGlsZENvdW50KS5maWxsQmVmb3JlKEZyYWdtZW50LmVtcHR5LCB0cnVlKSk7IH1cbiAgcmV0dXJuIGZyYWdtZW50LnJlcGxhY2VDaGlsZChzaWRlIDwgMCA/IDAgOiBmcmFnbWVudC5jaGlsZENvdW50IC0gMSwgbm9kZS5jb3B5KGlubmVyKSlcbn1cblxuZnVuY3Rpb24gY2xvc2VTbGljZShzbGljZSwgb3BlblN0YXJ0LCBvcGVuRW5kKSB7XG4gIGlmIChvcGVuU3RhcnQgPCBzbGljZS5vcGVuU3RhcnQpXG4gICAgeyBzbGljZSA9IG5ldyBTbGljZShjbG9zZVJhbmdlKHNsaWNlLmNvbnRlbnQsIC0xLCBvcGVuU3RhcnQsIHNsaWNlLm9wZW5TdGFydCwgMCwgc2xpY2Uub3BlbkVuZCksIG9wZW5TdGFydCwgc2xpY2Uub3BlbkVuZCk7IH1cbiAgaWYgKG9wZW5FbmQgPCBzbGljZS5vcGVuRW5kKVxuICAgIHsgc2xpY2UgPSBuZXcgU2xpY2UoY2xvc2VSYW5nZShzbGljZS5jb250ZW50LCAxLCBvcGVuRW5kLCBzbGljZS5vcGVuRW5kLCAwLCAwKSwgc2xpY2Uub3BlblN0YXJ0LCBvcGVuRW5kKTsgfVxuICByZXR1cm4gc2xpY2Vcbn1cblxuLy8gVHJpY2sgZnJvbSBqUXVlcnkgLS0gc29tZSBlbGVtZW50cyBtdXN0IGJlIHdyYXBwZWQgaW4gb3RoZXJcbi8vIGVsZW1lbnRzIGZvciBpbm5lckhUTUwgdG8gd29yay4gSS5lLiBpZiB5b3UgZG8gYGRpdi5pbm5lckhUTUwgPVxuLy8gXCI8dGQ+Li48L3RkPlwiYCB0aGUgdGFibGUgY2VsbHMgYXJlIGlnbm9yZWQuXG52YXIgd3JhcE1hcCA9IHtcbiAgdGhlYWQ6IFtcInRhYmxlXCJdLFxuICB0Ym9keTogW1widGFibGVcIl0sXG4gIHRmb290OiBbXCJ0YWJsZVwiXSxcbiAgY2FwdGlvbjogW1widGFibGVcIl0sXG4gIGNvbGdyb3VwOiBbXCJ0YWJsZVwiXSxcbiAgY29sOiBbXCJ0YWJsZVwiLCBcImNvbGdyb3VwXCJdLFxuICB0cjogW1widGFibGVcIiwgXCJ0Ym9keVwiXSxcbiAgdGQ6IFtcInRhYmxlXCIsIFwidGJvZHlcIiwgXCJ0clwiXSxcbiAgdGg6IFtcInRhYmxlXCIsIFwidGJvZHlcIiwgXCJ0clwiXVxufTtcblxudmFyIF9kZXRhY2hlZERvYyA9IG51bGw7XG5mdW5jdGlvbiBkZXRhY2hlZERvYygpIHtcbiAgcmV0dXJuIF9kZXRhY2hlZERvYyB8fCAoX2RldGFjaGVkRG9jID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KFwidGl0bGVcIikpXG59XG5cbmZ1bmN0aW9uIHJlYWRIVE1MKGh0bWwpIHtcbiAgdmFyIG1ldGFzID0gL14oXFxzKjxtZXRhIFtePl0qPikqLy5leGVjKGh0bWwpO1xuICBpZiAobWV0YXMpIHsgaHRtbCA9IGh0bWwuc2xpY2UobWV0YXNbMF0ubGVuZ3RoKTsgfVxuICB2YXIgZWx0ID0gZGV0YWNoZWREb2MoKS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICB2YXIgZmlyc3RUYWcgPSAvPChbYS16XVtePlxcc10rKS9pLmV4ZWMoaHRtbCksIHdyYXA7XG4gIGlmICh3cmFwID0gZmlyc3RUYWcgJiYgd3JhcE1hcFtmaXJzdFRhZ1sxXS50b0xvd2VyQ2FzZSgpXSlcbiAgICB7IGh0bWwgPSB3cmFwLm1hcChmdW5jdGlvbiAobikgeyByZXR1cm4gXCI8XCIgKyBuICsgXCI+XCI7IH0pLmpvaW4oXCJcIikgKyBodG1sICsgd3JhcC5tYXAoZnVuY3Rpb24gKG4pIHsgcmV0dXJuIFwiPC9cIiArIG4gKyBcIj5cIjsgfSkucmV2ZXJzZSgpLmpvaW4oXCJcIik7IH1cbiAgZWx0LmlubmVySFRNTCA9IGh0bWw7XG4gIGlmICh3cmFwKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgd3JhcC5sZW5ndGg7IGkrKykgeyBlbHQgPSBlbHQucXVlcnlTZWxlY3Rvcih3cmFwW2ldKSB8fCBlbHQ7IH0gfVxuICByZXR1cm4gZWx0XG59XG5cbi8vIFdlYmtpdCBicm93c2VycyBkbyBzb21lIGhhcmQtdG8tcHJlZGljdCByZXBsYWNlbWVudCBvZiByZWd1bGFyXG4vLyBzcGFjZXMgd2l0aCBub24tYnJlYWtpbmcgc3BhY2VzIHdoZW4gcHV0dGluZyBjb250ZW50IG9uIHRoZVxuLy8gY2xpcGJvYXJkLiBUaGlzIHRyaWVzIHRvIGNvbnZlcnQgc3VjaCBub24tYnJlYWtpbmcgc3BhY2VzICh3aGljaFxuLy8gd2lsbCBiZSB3cmFwcGVkIGluIGEgcGxhaW4gc3BhbiBvbiBDaHJvbWUsIGEgc3BhbiB3aXRoIGNsYXNzXG4vLyBBcHBsZS1jb252ZXJ0ZWQtc3BhY2Ugb24gU2FmYXJpKSBiYWNrIHRvIHJlZ3VsYXIgc3BhY2VzLlxuZnVuY3Rpb24gcmVzdG9yZVJlcGxhY2VkU3BhY2VzKGRvbSkge1xuICB2YXIgbm9kZXMgPSBkb20ucXVlcnlTZWxlY3RvckFsbChyZXN1bHQuY2hyb21lID8gXCJzcGFuOm5vdChbY2xhc3NdKTpub3QoW3N0eWxlXSlcIiA6IFwic3Bhbi5BcHBsZS1jb252ZXJ0ZWQtc3BhY2VcIik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgIGlmIChub2RlLmNoaWxkTm9kZXMubGVuZ3RoID09IDEgJiYgbm9kZS50ZXh0Q29udGVudCA9PSBcIlxcdTAwYTBcIiAmJiBub2RlLnBhcmVudE5vZGUpXG4gICAgICB7IG5vZGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoZG9tLm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCIgXCIpLCBub2RlKTsgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZENvbnRleHQoc2xpY2UsIGNvbnRleHQpIHtcbiAgaWYgKCFzbGljZS5zaXplKSB7IHJldHVybiBzbGljZSB9XG4gIHZhciBzY2hlbWEgPSBzbGljZS5jb250ZW50LmZpcnN0Q2hpbGQudHlwZS5zY2hlbWEsIGFycmF5O1xuICB0cnkgeyBhcnJheSA9IEpTT04ucGFyc2UoY29udGV4dCk7IH1cbiAgY2F0Y2goZSkgeyByZXR1cm4gc2xpY2UgfVxuICB2YXIgY29udGVudCA9IHNsaWNlLmNvbnRlbnQ7XG4gIHZhciBvcGVuU3RhcnQgPSBzbGljZS5vcGVuU3RhcnQ7XG4gIHZhciBvcGVuRW5kID0gc2xpY2Uub3BlbkVuZDtcbiAgZm9yICh2YXIgaSA9IGFycmF5Lmxlbmd0aCAtIDI7IGkgPj0gMDsgaSAtPSAyKSB7XG4gICAgdmFyIHR5cGUgPSBzY2hlbWEubm9kZXNbYXJyYXlbaV1dO1xuICAgIGlmICghdHlwZSB8fCB0eXBlLmhhc1JlcXVpcmVkQXR0cnMoKSkgeyBicmVhayB9XG4gICAgY29udGVudCA9IEZyYWdtZW50LmZyb20odHlwZS5jcmVhdGUoYXJyYXlbaSArIDFdLCBjb250ZW50KSk7XG4gICAgb3BlblN0YXJ0Kys7IG9wZW5FbmQrKztcbiAgfVxuICByZXR1cm4gbmV3IFNsaWNlKGNvbnRlbnQsIG9wZW5TdGFydCwgb3BlbkVuZClcbn1cblxudmFyIG9ic2VydmVPcHRpb25zID0ge1xuICBjaGlsZExpc3Q6IHRydWUsXG4gIGNoYXJhY3RlckRhdGE6IHRydWUsXG4gIGNoYXJhY3RlckRhdGFPbGRWYWx1ZTogdHJ1ZSxcbiAgYXR0cmlidXRlczogdHJ1ZSxcbiAgYXR0cmlidXRlT2xkVmFsdWU6IHRydWUsXG4gIHN1YnRyZWU6IHRydWVcbn07XG4vLyBJRTExIGhhcyB2ZXJ5IGJyb2tlbiBtdXRhdGlvbiBvYnNlcnZlcnMsIHNvIHdlIGFsc28gbGlzdGVuIHRvIERPTUNoYXJhY3RlckRhdGFNb2RpZmllZFxudmFyIHVzZUNoYXJEYXRhID0gcmVzdWx0LmllICYmIHJlc3VsdC5pZV92ZXJzaW9uIDw9IDExO1xuXG52YXIgU2VsZWN0aW9uU3RhdGUgPSBmdW5jdGlvbiBTZWxlY3Rpb25TdGF0ZSgpIHtcbiAgdGhpcy5hbmNob3JOb2RlID0gdGhpcy5hbmNob3JPZmZzZXQgPSB0aGlzLmZvY3VzTm9kZSA9IHRoaXMuZm9jdXNPZmZzZXQgPSBudWxsO1xufTtcblxuU2VsZWN0aW9uU3RhdGUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldCAoc2VsKSB7XG4gIHRoaXMuYW5jaG9yTm9kZSA9IHNlbC5hbmNob3JOb2RlOyB0aGlzLmFuY2hvck9mZnNldCA9IHNlbC5hbmNob3JPZmZzZXQ7XG4gIHRoaXMuZm9jdXNOb2RlID0gc2VsLmZvY3VzTm9kZTsgdGhpcy5mb2N1c09mZnNldCA9IHNlbC5mb2N1c09mZnNldDtcbn07XG5cblNlbGVjdGlvblN0YXRlLnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIGVxIChzZWwpIHtcbiAgcmV0dXJuIHNlbC5hbmNob3JOb2RlID09IHRoaXMuYW5jaG9yTm9kZSAmJiBzZWwuYW5jaG9yT2Zmc2V0ID09IHRoaXMuYW5jaG9yT2Zmc2V0ICYmXG4gICAgc2VsLmZvY3VzTm9kZSA9PSB0aGlzLmZvY3VzTm9kZSAmJiBzZWwuZm9jdXNPZmZzZXQgPT0gdGhpcy5mb2N1c09mZnNldFxufTtcblxudmFyIERPTU9ic2VydmVyID0gZnVuY3Rpb24gRE9NT2JzZXJ2ZXIodmlldywgaGFuZGxlRE9NQ2hhbmdlKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHRoaXMudmlldyA9IHZpZXc7XG4gIHRoaXMuaGFuZGxlRE9NQ2hhbmdlID0gaGFuZGxlRE9NQ2hhbmdlO1xuICB0aGlzLnF1ZXVlID0gW107XG4gIHRoaXMuZmx1c2hpbmdTb29uID0gLTE7XG4gIHRoaXMub2JzZXJ2ZXIgPSB3aW5kb3cuTXV0YXRpb25PYnNlcnZlciAmJlxuICAgIG5ldyB3aW5kb3cuTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbiAobXV0YXRpb25zKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG11dGF0aW9ucy5sZW5ndGg7IGkrKykgeyB0aGlzJDEucXVldWUucHVzaChtdXRhdGlvbnNbaV0pOyB9XG4gICAgICAvLyBJRTExIHdpbGwgc29tZXRpbWVzIChvbiBiYWNrc3BhY2luZyBvdXQgYSBzaW5nbGUgY2hhcmFjdGVyXG4gICAgICAvLyB0ZXh0IG5vZGUgYWZ0ZXIgYSBCUiBub2RlKSBjYWxsIHRoZSBvYnNlcnZlciBjYWxsYmFja1xuICAgICAgLy8gYmVmb3JlIGFjdHVhbGx5IHVwZGF0aW5nIHRoZSBET00sIHdoaWNoIHdpbGwgY2F1c2VcbiAgICAgIC8vIFByb3NlTWlycm9yIHRvIG1pc3MgdGhlIGNoYW5nZSAoc2VlICM5MzApXG4gICAgICBpZiAocmVzdWx0LmllICYmIHJlc3VsdC5pZV92ZXJzaW9uIDw9IDExICYmIG11dGF0aW9ucy5zb21lKFxuICAgICAgICBmdW5jdGlvbiAobSkgeyByZXR1cm4gbS50eXBlID09IFwiY2hpbGRMaXN0XCIgJiYgbS5yZW1vdmVkTm9kZXMubGVuZ3RoIHx8XG4gICAgICAgICAgICAgbS50eXBlID09IFwiY2hhcmFjdGVyRGF0YVwiICYmIG0ub2xkVmFsdWUubGVuZ3RoID4gbS50YXJnZXQubm9kZVZhbHVlLmxlbmd0aDsgfSkpXG4gICAgICAgIHsgdGhpcyQxLmZsdXNoU29vbigpOyB9XG4gICAgICBlbHNlXG4gICAgICAgIHsgdGhpcyQxLmZsdXNoKCk7IH1cbiAgICB9KTtcbiAgdGhpcy5jdXJyZW50U2VsZWN0aW9uID0gbmV3IFNlbGVjdGlvblN0YXRlO1xuICBpZiAodXNlQ2hhckRhdGEpIHtcbiAgICB0aGlzLm9uQ2hhckRhdGEgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcyQxLnF1ZXVlLnB1c2goe3RhcmdldDogZS50YXJnZXQsIHR5cGU6IFwiY2hhcmFjdGVyRGF0YVwiLCBvbGRWYWx1ZTogZS5wcmV2VmFsdWV9KTtcbiAgICAgIHRoaXMkMS5mbHVzaFNvb24oKTtcbiAgICB9O1xuICB9XG4gIHRoaXMub25TZWxlY3Rpb25DaGFuZ2UgPSB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlLmJpbmQodGhpcyk7XG4gIHRoaXMuc3VwcHJlc3NpbmdTZWxlY3Rpb25VcGRhdGVzID0gZmFsc2U7XG59O1xuXG5ET01PYnNlcnZlci5wcm90b3R5cGUuZmx1c2hTb29uID0gZnVuY3Rpb24gZmx1c2hTb29uICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAodGhpcy5mbHVzaGluZ1Nvb24gPCAwKVxuICAgIHsgdGhpcy5mbHVzaGluZ1Nvb24gPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHRoaXMkMS5mbHVzaGluZ1Nvb24gPSAtMTsgdGhpcyQxLmZsdXNoKCk7IH0sIDIwKTsgfVxufTtcblxuRE9NT2JzZXJ2ZXIucHJvdG90eXBlLmZvcmNlRmx1c2ggPSBmdW5jdGlvbiBmb3JjZUZsdXNoICgpIHtcbiAgaWYgKHRoaXMuZmx1c2hpbmdTb29uID4gLTEpIHtcbiAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuZmx1c2hpbmdTb29uKTtcbiAgICB0aGlzLmZsdXNoaW5nU29vbiA9IC0xO1xuICAgIHRoaXMuZmx1c2goKTtcbiAgfVxufTtcblxuRE9NT2JzZXJ2ZXIucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gc3RhcnQgKCkge1xuICBpZiAodGhpcy5vYnNlcnZlcilcbiAgICB7IHRoaXMub2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLnZpZXcuZG9tLCBvYnNlcnZlT3B0aW9ucyk7IH1cbiAgaWYgKHVzZUNoYXJEYXRhKVxuICAgIHsgdGhpcy52aWV3LmRvbS5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ2hhcmFjdGVyRGF0YU1vZGlmaWVkXCIsIHRoaXMub25DaGFyRGF0YSk7IH1cbiAgdGhpcy5jb25uZWN0U2VsZWN0aW9uKCk7XG59O1xuXG5ET01PYnNlcnZlci5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uIHN0b3AgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmICh0aGlzLm9ic2VydmVyKSB7XG4gICAgdmFyIHRha2UgPSB0aGlzLm9ic2VydmVyLnRha2VSZWNvcmRzKCk7XG4gICAgaWYgKHRha2UubGVuZ3RoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRha2UubGVuZ3RoOyBpKyspIHsgdGhpcy5xdWV1ZS5wdXNoKHRha2VbaV0pOyB9XG4gICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzJDEuZmx1c2goKTsgfSwgMjApO1xuICAgIH1cbiAgICB0aGlzLm9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgfVxuICBpZiAodXNlQ2hhckRhdGEpIHsgdGhpcy52aWV3LmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NQ2hhcmFjdGVyRGF0YU1vZGlmaWVkXCIsIHRoaXMub25DaGFyRGF0YSk7IH1cbiAgdGhpcy5kaXNjb25uZWN0U2VsZWN0aW9uKCk7XG59O1xuXG5ET01PYnNlcnZlci5wcm90b3R5cGUuY29ubmVjdFNlbGVjdGlvbiA9IGZ1bmN0aW9uIGNvbm5lY3RTZWxlY3Rpb24gKCkge1xuICB0aGlzLnZpZXcuZG9tLm93bmVyRG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInNlbGVjdGlvbmNoYW5nZVwiLCB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlKTtcbn07XG5cbkRPTU9ic2VydmVyLnByb3RvdHlwZS5kaXNjb25uZWN0U2VsZWN0aW9uID0gZnVuY3Rpb24gZGlzY29ubmVjdFNlbGVjdGlvbiAoKSB7XG4gIHRoaXMudmlldy5kb20ub3duZXJEb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwic2VsZWN0aW9uY2hhbmdlXCIsIHRoaXMub25TZWxlY3Rpb25DaGFuZ2UpO1xufTtcblxuRE9NT2JzZXJ2ZXIucHJvdG90eXBlLnN1cHByZXNzU2VsZWN0aW9uVXBkYXRlcyA9IGZ1bmN0aW9uIHN1cHByZXNzU2VsZWN0aW9uVXBkYXRlcyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdGhpcy5zdXBwcmVzc2luZ1NlbGVjdGlvblVwZGF0ZXMgPSB0cnVlO1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMkMS5zdXBwcmVzc2luZ1NlbGVjdGlvblVwZGF0ZXMgPSBmYWxzZTsgfSwgNTApO1xufTtcblxuRE9NT2JzZXJ2ZXIucHJvdG90eXBlLm9uU2VsZWN0aW9uQ2hhbmdlID0gZnVuY3Rpb24gb25TZWxlY3Rpb25DaGFuZ2UgKCkge1xuICBpZiAoIWhhc0ZvY3VzQW5kU2VsZWN0aW9uKHRoaXMudmlldykpIHsgcmV0dXJuIH1cbiAgaWYgKHRoaXMuc3VwcHJlc3NpbmdTZWxlY3Rpb25VcGRhdGVzKSB7IHJldHVybiBzZWxlY3Rpb25Ub0RPTSh0aGlzLnZpZXcpIH1cbiAgLy8gRGVsZXRpb25zIG9uIElFMTEgZmlyZSB0aGVpciBldmVudHMgaW4gdGhlIHdyb25nIG9yZGVyLCBnaXZpbmdcbiAgLy8gdXMgYSBzZWxlY3Rpb24gY2hhbmdlIGV2ZW50IGJlZm9yZSB0aGUgRE9NIGNoYW5nZXMgYXJlXG4gIC8vIHJlcG9ydGVkLlxuICBpZiAocmVzdWx0LmllICYmIHJlc3VsdC5pZV92ZXJzaW9uIDw9IDExICYmICF0aGlzLnZpZXcuc3RhdGUuc2VsZWN0aW9uLmVtcHR5KSB7XG4gICAgdmFyIHNlbCA9IHRoaXMudmlldy5yb290LmdldFNlbGVjdGlvbigpO1xuICAgIC8vIFNlbGVjdGlvbi5pc0NvbGxhcHNlZCBpc24ndCByZWxpYWJsZSBvbiBJRVxuICAgIGlmIChzZWwuZm9jdXNOb2RlICYmIGlzRXF1aXZhbGVudFBvc2l0aW9uKHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCwgc2VsLmFuY2hvck5vZGUsIHNlbC5hbmNob3JPZmZzZXQpKVxuICAgICAgeyByZXR1cm4gdGhpcy5mbHVzaFNvb24oKSB9XG4gIH1cbiAgdGhpcy5mbHVzaCgpO1xufTtcblxuRE9NT2JzZXJ2ZXIucHJvdG90eXBlLnNldEN1clNlbGVjdGlvbiA9IGZ1bmN0aW9uIHNldEN1clNlbGVjdGlvbiAoKSB7XG4gIHRoaXMuY3VycmVudFNlbGVjdGlvbi5zZXQodGhpcy52aWV3LnJvb3QuZ2V0U2VsZWN0aW9uKCkpO1xufTtcblxuRE9NT2JzZXJ2ZXIucHJvdG90eXBlLmlnbm9yZVNlbGVjdGlvbkNoYW5nZSA9IGZ1bmN0aW9uIGlnbm9yZVNlbGVjdGlvbkNoYW5nZSAoc2VsKSB7XG4gIGlmIChzZWwucmFuZ2VDb3VudCA9PSAwKSB7IHJldHVybiB0cnVlIH1cbiAgdmFyIGNvbnRhaW5lciA9IHNlbC5nZXRSYW5nZUF0KDApLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyO1xuICB2YXIgZGVzYyA9IHRoaXMudmlldy5kb2NWaWV3Lm5lYXJlc3REZXNjKGNvbnRhaW5lcik7XG4gIGlmIChkZXNjICYmIGRlc2MuaWdub3JlTXV0YXRpb24oe3R5cGU6IFwic2VsZWN0aW9uXCIsIHRhcmdldDogY29udGFpbmVyLm5vZGVUeXBlID09IDMgPyBjb250YWluZXIucGFyZW50Tm9kZSA6IGNvbnRhaW5lcn0pKSB7XG4gICAgdGhpcy5zZXRDdXJTZWxlY3Rpb24oKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG59O1xuXG5ET01PYnNlcnZlci5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiBmbHVzaCAoKSB7XG4gIGlmICghdGhpcy52aWV3LmRvY1ZpZXcgfHwgdGhpcy5mbHVzaGluZ1Nvb24gPiAtMSkgeyByZXR1cm4gfVxuICB2YXIgbXV0YXRpb25zID0gdGhpcy5vYnNlcnZlciA/IHRoaXMub2JzZXJ2ZXIudGFrZVJlY29yZHMoKSA6IFtdO1xuICBpZiAodGhpcy5xdWV1ZS5sZW5ndGgpIHtcbiAgICBtdXRhdGlvbnMgPSB0aGlzLnF1ZXVlLmNvbmNhdChtdXRhdGlvbnMpO1xuICAgIHRoaXMucXVldWUubGVuZ3RoID0gMDtcbiAgfVxuXG4gIHZhciBzZWwgPSB0aGlzLnZpZXcucm9vdC5nZXRTZWxlY3Rpb24oKTtcbiAgdmFyIG5ld1NlbCA9ICF0aGlzLnN1cHByZXNzaW5nU2VsZWN0aW9uVXBkYXRlcyAmJiAhdGhpcy5jdXJyZW50U2VsZWN0aW9uLmVxKHNlbCkgJiYgaGFzU2VsZWN0aW9uKHRoaXMudmlldykgJiYgIXRoaXMuaWdub3JlU2VsZWN0aW9uQ2hhbmdlKHNlbCk7XG5cbiAgdmFyIGZyb20gPSAtMSwgdG8gPSAtMSwgdHlwZU92ZXIgPSBmYWxzZSwgYWRkZWQgPSBbXTtcbiAgaWYgKHRoaXMudmlldy5lZGl0YWJsZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXV0YXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcmVzdWx0JDEgPSB0aGlzLnJlZ2lzdGVyTXV0YXRpb24obXV0YXRpb25zW2ldLCBhZGRlZCk7XG4gICAgICBpZiAocmVzdWx0JDEpIHtcbiAgICAgICAgZnJvbSA9IGZyb20gPCAwID8gcmVzdWx0JDEuZnJvbSA6IE1hdGgubWluKHJlc3VsdCQxLmZyb20sIGZyb20pO1xuICAgICAgICB0byA9IHRvIDwgMCA/IHJlc3VsdCQxLnRvIDogTWF0aC5tYXgocmVzdWx0JDEudG8sIHRvKTtcbiAgICAgICAgaWYgKHJlc3VsdCQxLnR5cGVPdmVyKSB7IHR5cGVPdmVyID0gdHJ1ZTsgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChyZXN1bHQuZ2Vja28gJiYgYWRkZWQubGVuZ3RoID4gMSkge1xuICAgIHZhciBicnMgPSBhZGRlZC5maWx0ZXIoZnVuY3Rpb24gKG4pIHsgcmV0dXJuIG4ubm9kZU5hbWUgPT0gXCJCUlwiOyB9KTtcbiAgICBpZiAoYnJzLmxlbmd0aCA9PSAyKSB7XG4gICAgICB2YXIgYSA9IGJyc1swXTtcbiAgICAgICAgdmFyIGIgPSBicnNbMV07XG4gICAgICBpZiAoYS5wYXJlbnROb2RlICYmIGEucGFyZW50Tm9kZS5wYXJlbnROb2RlID09IGIucGFyZW50Tm9kZSkgeyBiLnJlbW92ZSgpOyB9XG4gICAgICBlbHNlIHsgYS5yZW1vdmUoKTsgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChmcm9tID4gLTEgfHwgbmV3U2VsKSB7XG4gICAgaWYgKGZyb20gPiAtMSkge1xuICAgICAgdGhpcy52aWV3LmRvY1ZpZXcubWFya0RpcnR5KGZyb20sIHRvKTtcbiAgICAgIGNoZWNrQ1NTKHRoaXMudmlldyk7XG4gICAgfVxuICAgIHRoaXMuaGFuZGxlRE9NQ2hhbmdlKGZyb20sIHRvLCB0eXBlT3ZlciwgYWRkZWQpO1xuICAgIGlmICh0aGlzLnZpZXcuZG9jVmlldy5kaXJ0eSkgeyB0aGlzLnZpZXcudXBkYXRlU3RhdGUodGhpcy52aWV3LnN0YXRlKTsgfVxuICAgIGVsc2UgaWYgKCF0aGlzLmN1cnJlbnRTZWxlY3Rpb24uZXEoc2VsKSkgeyBzZWxlY3Rpb25Ub0RPTSh0aGlzLnZpZXcpOyB9XG4gICAgdGhpcy5jdXJyZW50U2VsZWN0aW9uLnNldChzZWwpO1xuICB9XG59O1xuXG5ET01PYnNlcnZlci5wcm90b3R5cGUucmVnaXN0ZXJNdXRhdGlvbiA9IGZ1bmN0aW9uIHJlZ2lzdGVyTXV0YXRpb24gKG11dCwgYWRkZWQpIHtcbiAgLy8gSWdub3JlIG11dGF0aW9ucyBpbnNpZGUgbm9kZXMgdGhhdCB3ZXJlIGFscmVhZHkgbm90ZWQgYXMgaW5zZXJ0ZWRcbiAgaWYgKGFkZGVkLmluZGV4T2YobXV0LnRhcmdldCkgPiAtMSkgeyByZXR1cm4gbnVsbCB9XG4gIHZhciBkZXNjID0gdGhpcy52aWV3LmRvY1ZpZXcubmVhcmVzdERlc2MobXV0LnRhcmdldCk7XG4gIGlmIChtdXQudHlwZSA9PSBcImF0dHJpYnV0ZXNcIiAmJlxuICAgICAgKGRlc2MgPT0gdGhpcy52aWV3LmRvY1ZpZXcgfHwgbXV0LmF0dHJpYnV0ZU5hbWUgPT0gXCJjb250ZW50ZWRpdGFibGVcIiB8fFxuICAgICAgIC8vIEZpcmVmb3ggc29tZXRpbWVzIGZpcmVzIHNwdXJpb3VzIGV2ZW50cyBmb3IgbnVsbC9lbXB0eSBzdHlsZXNcbiAgICAgICAobXV0LmF0dHJpYnV0ZU5hbWUgPT0gXCJzdHlsZVwiICYmICFtdXQub2xkVmFsdWUgJiYgIW11dC50YXJnZXQuZ2V0QXR0cmlidXRlKFwic3R5bGVcIikpKSlcbiAgICB7IHJldHVybiBudWxsIH1cbiAgaWYgKCFkZXNjIHx8IGRlc2MuaWdub3JlTXV0YXRpb24obXV0KSkgeyByZXR1cm4gbnVsbCB9XG5cbiAgaWYgKG11dC50eXBlID09IFwiY2hpbGRMaXN0XCIpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG11dC5hZGRlZE5vZGVzLmxlbmd0aDsgaSsrKSB7IGFkZGVkLnB1c2gobXV0LmFkZGVkTm9kZXNbaV0pOyB9XG4gICAgaWYgKGRlc2MuY29udGVudERPTSAmJiBkZXNjLmNvbnRlbnRET00gIT0gZGVzYy5kb20gJiYgIWRlc2MuY29udGVudERPTS5jb250YWlucyhtdXQudGFyZ2V0KSlcbiAgICAgIHsgcmV0dXJuIHtmcm9tOiBkZXNjLnBvc0JlZm9yZSwgdG86IGRlc2MucG9zQWZ0ZXJ9IH1cbiAgICB2YXIgcHJldiA9IG11dC5wcmV2aW91c1NpYmxpbmcsIG5leHQgPSBtdXQubmV4dFNpYmxpbmc7XG4gICAgaWYgKHJlc3VsdC5pZSAmJiByZXN1bHQuaWVfdmVyc2lvbiA8PSAxMSAmJiBtdXQuYWRkZWROb2Rlcy5sZW5ndGgpIHtcbiAgICAgIC8vIElFMTEgZ2l2ZXMgdXMgaW5jb3JyZWN0IG5leHQvcHJldiBzaWJsaW5ncyBmb3Igc29tZVxuICAgICAgLy8gaW5zZXJ0aW9ucywgc28gaWYgdGhlcmUgYXJlIGFkZGVkIG5vZGVzLCByZWNvbXB1dGUgdGhvc2VcbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IG11dC5hZGRlZE5vZGVzLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgdmFyIHJlZiA9IG11dC5hZGRlZE5vZGVzW2kkMV07XG4gICAgICAgICAgdmFyIHByZXZpb3VzU2libGluZyA9IHJlZi5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgdmFyIG5leHRTaWJsaW5nID0gcmVmLm5leHRTaWJsaW5nO1xuICAgICAgICBpZiAoIXByZXZpb3VzU2libGluZyB8fCBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKG11dC5hZGRlZE5vZGVzLCBwcmV2aW91c1NpYmxpbmcpIDwgMCkgeyBwcmV2ID0gcHJldmlvdXNTaWJsaW5nOyB9XG4gICAgICAgIGlmICghbmV4dFNpYmxpbmcgfHwgQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChtdXQuYWRkZWROb2RlcywgbmV4dFNpYmxpbmcpIDwgMCkgeyBuZXh0ID0gbmV4dFNpYmxpbmc7IH1cbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGZyb21PZmZzZXQgPSBwcmV2ICYmIHByZXYucGFyZW50Tm9kZSA9PSBtdXQudGFyZ2V0XG4gICAgICAgID8gZG9tSW5kZXgocHJldikgKyAxIDogMDtcbiAgICB2YXIgZnJvbSA9IGRlc2MubG9jYWxQb3NGcm9tRE9NKG11dC50YXJnZXQsIGZyb21PZmZzZXQsIC0xKTtcbiAgICB2YXIgdG9PZmZzZXQgPSBuZXh0ICYmIG5leHQucGFyZW50Tm9kZSA9PSBtdXQudGFyZ2V0XG4gICAgICAgID8gZG9tSW5kZXgobmV4dCkgOiBtdXQudGFyZ2V0LmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgIHZhciB0byA9IGRlc2MubG9jYWxQb3NGcm9tRE9NKG11dC50YXJnZXQsIHRvT2Zmc2V0LCAxKTtcbiAgICByZXR1cm4ge2Zyb206IGZyb20sIHRvOiB0b31cbiAgfSBlbHNlIGlmIChtdXQudHlwZSA9PSBcImF0dHJpYnV0ZXNcIikge1xuICAgIHJldHVybiB7ZnJvbTogZGVzYy5wb3NBdFN0YXJ0IC0gZGVzYy5ib3JkZXIsIHRvOiBkZXNjLnBvc0F0RW5kICsgZGVzYy5ib3JkZXJ9XG4gIH0gZWxzZSB7IC8vIFwiY2hhcmFjdGVyRGF0YVwiXG4gICAgcmV0dXJuIHtcbiAgICAgIGZyb206IGRlc2MucG9zQXRTdGFydCxcbiAgICAgIHRvOiBkZXNjLnBvc0F0RW5kLFxuICAgICAgLy8gQW4gZXZlbnQgd2FzIGdlbmVyYXRlZCBmb3IgYSB0ZXh0IGNoYW5nZSB0aGF0IGRpZG4ndCBjaGFuZ2VcbiAgICAgIC8vIGFueSB0ZXh0LiBNYXJrIHRoZSBkb20gY2hhbmdlIHRvIGZhbGwgYmFjayB0byBhc3N1bWluZyB0aGVcbiAgICAgIC8vIHNlbGVjdGlvbiB3YXMgdHlwZWQgb3ZlciB3aXRoIGFuIGlkZW50aWNhbCB2YWx1ZSBpZiBpdCBjYW4ndFxuICAgICAgLy8gZmluZCBhbm90aGVyIGNoYW5nZS5cbiAgICAgIHR5cGVPdmVyOiBtdXQudGFyZ2V0Lm5vZGVWYWx1ZSA9PSBtdXQub2xkVmFsdWVcbiAgICB9XG4gIH1cbn07XG5cbnZhciBjc3NDaGVja2VkID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGNoZWNrQ1NTKHZpZXcpIHtcbiAgaWYgKGNzc0NoZWNrZWQpIHsgcmV0dXJuIH1cbiAgY3NzQ2hlY2tlZCA9IHRydWU7XG4gIGlmIChnZXRDb21wdXRlZFN0eWxlKHZpZXcuZG9tKS53aGl0ZVNwYWNlID09IFwibm9ybWFsXCIpXG4gICAgeyBjb25zb2xlW1wid2FyblwiXShcIlByb3NlTWlycm9yIGV4cGVjdHMgdGhlIENTUyB3aGl0ZS1zcGFjZSBwcm9wZXJ0eSB0byBiZSBzZXQsIHByZWZlcmFibHkgdG8gJ3ByZS13cmFwJy4gSXQgaXMgcmVjb21tZW5kZWQgdG8gbG9hZCBzdHlsZS9wcm9zZW1pcnJvci5jc3MgZnJvbSB0aGUgcHJvc2VtaXJyb3ItdmlldyBwYWNrYWdlLlwiKTsgfVxufVxuXG4vLyBBIGNvbGxlY3Rpb24gb2YgRE9NIGV2ZW50cyB0aGF0IG9jY3VyIHdpdGhpbiB0aGUgZWRpdG9yLCBhbmQgY2FsbGJhY2sgZnVuY3Rpb25zXG4vLyB0byBpbnZva2Ugd2hlbiB0aGUgZXZlbnQgZmlyZXMuXG52YXIgaGFuZGxlcnMgPSB7fSwgZWRpdEhhbmRsZXJzID0ge307XG5cbmZ1bmN0aW9uIGluaXRJbnB1dCh2aWV3KSB7XG4gIHZpZXcuc2hpZnRLZXkgPSBmYWxzZTtcbiAgdmlldy5tb3VzZURvd24gPSBudWxsO1xuICB2aWV3Lmxhc3RLZXlDb2RlID0gbnVsbDtcbiAgdmlldy5sYXN0S2V5Q29kZVRpbWUgPSAwO1xuICB2aWV3Lmxhc3RDbGljayA9IHt0aW1lOiAwLCB4OiAwLCB5OiAwLCB0eXBlOiBcIlwifTtcbiAgdmlldy5sYXN0U2VsZWN0aW9uT3JpZ2luID0gbnVsbDtcbiAgdmlldy5sYXN0U2VsZWN0aW9uVGltZSA9IDA7XG5cbiAgdmlldy5sYXN0SU9TRW50ZXIgPSAwO1xuICB2aWV3Lmxhc3RJT1NFbnRlckZhbGxiYWNrVGltZW91dCA9IG51bGw7XG4gIHZpZXcubGFzdEFuZHJvaWREZWxldGUgPSAwO1xuXG4gIHZpZXcuY29tcG9zaW5nID0gZmFsc2U7XG4gIHZpZXcuY29tcG9zaW5nVGltZW91dCA9IG51bGw7XG4gIHZpZXcuY29tcG9zaXRpb25Ob2RlcyA9IFtdO1xuICB2aWV3LmNvbXBvc2l0aW9uRW5kZWRBdCA9IC0yZTg7XG5cbiAgdmlldy5kb21PYnNlcnZlciA9IG5ldyBET01PYnNlcnZlcih2aWV3LCBmdW5jdGlvbiAoZnJvbSwgdG8sIHR5cGVPdmVyLCBhZGRlZCkgeyByZXR1cm4gcmVhZERPTUNoYW5nZSh2aWV3LCBmcm9tLCB0bywgdHlwZU92ZXIsIGFkZGVkKTsgfSk7XG4gIHZpZXcuZG9tT2JzZXJ2ZXIuc3RhcnQoKTtcbiAgLy8gVXNlZCBieSBoYWNrcyBsaWtlIHRoZSBiZWZvcmVpbnB1dCBoYW5kbGVyIHRvIGNoZWNrIHdoZXRoZXIgYW55dGhpbmcgaGFwcGVuZWQgaW4gdGhlIERPTVxuICB2aWV3LmRvbUNoYW5nZUNvdW50ID0gMDtcblxuICB2aWV3LmV2ZW50SGFuZGxlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2YXIgbG9vcCA9IGZ1bmN0aW9uICggZXZlbnQgKSB7XG4gICAgdmFyIGhhbmRsZXIgPSBoYW5kbGVyc1tldmVudF07XG4gICAgdmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgdmlldy5ldmVudEhhbmRsZXJzW2V2ZW50XSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKGV2ZW50QmVsb25nc1RvVmlldyh2aWV3LCBldmVudCkgJiYgIXJ1bkN1c3RvbUhhbmRsZXIodmlldywgZXZlbnQpICYmXG4gICAgICAgICAgKHZpZXcuZWRpdGFibGUgfHwgIShldmVudC50eXBlIGluIGVkaXRIYW5kbGVycykpKVxuICAgICAgICB7IGhhbmRsZXIodmlldywgZXZlbnQpOyB9XG4gICAgfSk7XG4gIH07XG5cbiAgZm9yICh2YXIgZXZlbnQgaW4gaGFuZGxlcnMpIGxvb3AoIGV2ZW50ICk7XG4gIC8vIE9uIFNhZmFyaSwgZm9yIHJlYXNvbnMgYmV5b25kIG15IHVuZGVyc3RhbmRpbmcsIGFkZGluZyBhbiBpbnB1dFxuICAvLyBldmVudCBoYW5kbGVyIG1ha2VzIGFuIGlzc3VlIHdoZXJlIHRoZSBjb21wb3NpdGlvbiB2YW5pc2hlcyB3aGVuXG4gIC8vIHlvdSBwcmVzcyBlbnRlciBnbyBhd2F5LlxuICBpZiAocmVzdWx0LnNhZmFyaSkgeyB2aWV3LmRvbS5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfSk7IH1cblxuICBlbnN1cmVMaXN0ZW5lcnModmlldyk7XG59XG5cbmZ1bmN0aW9uIHNldFNlbGVjdGlvbk9yaWdpbih2aWV3LCBvcmlnaW4pIHtcbiAgdmlldy5sYXN0U2VsZWN0aW9uT3JpZ2luID0gb3JpZ2luO1xuICB2aWV3Lmxhc3RTZWxlY3Rpb25UaW1lID0gRGF0ZS5ub3coKTtcbn1cblxuZnVuY3Rpb24gZGVzdHJveUlucHV0KHZpZXcpIHtcbiAgdmlldy5kb21PYnNlcnZlci5zdG9wKCk7XG4gIGZvciAodmFyIHR5cGUgaW4gdmlldy5ldmVudEhhbmRsZXJzKVxuICAgIHsgdmlldy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCB2aWV3LmV2ZW50SGFuZGxlcnNbdHlwZV0pOyB9XG4gIGNsZWFyVGltZW91dCh2aWV3LmNvbXBvc2luZ1RpbWVvdXQpO1xuICBjbGVhclRpbWVvdXQodmlldy5sYXN0SU9TRW50ZXJGYWxsYmFja1RpbWVvdXQpO1xufVxuXG5mdW5jdGlvbiBlbnN1cmVMaXN0ZW5lcnModmlldykge1xuICB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlRE9NRXZlbnRzXCIsIGZ1bmN0aW9uIChjdXJyZW50SGFuZGxlcnMpIHtcbiAgICBmb3IgKHZhciB0eXBlIGluIGN1cnJlbnRIYW5kbGVycykgeyBpZiAoIXZpZXcuZXZlbnRIYW5kbGVyc1t0eXBlXSlcbiAgICAgIHsgdmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCB2aWV3LmV2ZW50SGFuZGxlcnNbdHlwZV0gPSBmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIHJ1bkN1c3RvbUhhbmRsZXIodmlldywgZXZlbnQpOyB9KTsgfSB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBydW5DdXN0b21IYW5kbGVyKHZpZXcsIGV2ZW50KSB7XG4gIHJldHVybiB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlRE9NRXZlbnRzXCIsIGZ1bmN0aW9uIChoYW5kbGVycykge1xuICAgIHZhciBoYW5kbGVyID0gaGFuZGxlcnNbZXZlbnQudHlwZV07XG4gICAgcmV0dXJuIGhhbmRsZXIgPyBoYW5kbGVyKHZpZXcsIGV2ZW50KSB8fCBldmVudC5kZWZhdWx0UHJldmVudGVkIDogZmFsc2VcbiAgfSlcbn1cblxuZnVuY3Rpb24gZXZlbnRCZWxvbmdzVG9WaWV3KHZpZXcsIGV2ZW50KSB7XG4gIGlmICghZXZlbnQuYnViYmxlcykgeyByZXR1cm4gdHJ1ZSB9XG4gIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSB7IHJldHVybiBmYWxzZSB9XG4gIGZvciAodmFyIG5vZGUgPSBldmVudC50YXJnZXQ7IG5vZGUgIT0gdmlldy5kb207IG5vZGUgPSBub2RlLnBhcmVudE5vZGUpXG4gICAgeyBpZiAoIW5vZGUgfHwgbm9kZS5ub2RlVHlwZSA9PSAxMSB8fFxuICAgICAgICAobm9kZS5wbVZpZXdEZXNjICYmIG5vZGUucG1WaWV3RGVzYy5zdG9wRXZlbnQoZXZlbnQpKSlcbiAgICAgIHsgcmV0dXJuIGZhbHNlIH0gfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBkaXNwYXRjaEV2ZW50KHZpZXcsIGV2ZW50KSB7XG4gIGlmICghcnVuQ3VzdG9tSGFuZGxlcih2aWV3LCBldmVudCkgJiYgaGFuZGxlcnNbZXZlbnQudHlwZV0gJiZcbiAgICAgICh2aWV3LmVkaXRhYmxlIHx8ICEoZXZlbnQudHlwZSBpbiBlZGl0SGFuZGxlcnMpKSlcbiAgICB7IGhhbmRsZXJzW2V2ZW50LnR5cGVdKHZpZXcsIGV2ZW50KTsgfVxufVxuXG5lZGl0SGFuZGxlcnMua2V5ZG93biA9IGZ1bmN0aW9uICh2aWV3LCBldmVudCkge1xuICB2aWV3LnNoaWZ0S2V5ID0gZXZlbnQua2V5Q29kZSA9PSAxNiB8fCBldmVudC5zaGlmdEtleTtcbiAgaWYgKGluT3JOZWFyQ29tcG9zaXRpb24odmlldywgZXZlbnQpKSB7IHJldHVybiB9XG4gIGlmIChldmVudC5rZXlDb2RlICE9IDIyOSkgeyB2aWV3LmRvbU9ic2VydmVyLmZvcmNlRmx1c2goKTsgfVxuICB2aWV3Lmxhc3RLZXlDb2RlID0gZXZlbnQua2V5Q29kZTtcbiAgdmlldy5sYXN0S2V5Q29kZVRpbWUgPSBEYXRlLm5vdygpO1xuICAvLyBPbiBpT1MsIGlmIHdlIHByZXZlbnREZWZhdWx0IGVudGVyIGtleSBwcmVzc2VzLCB0aGUgdmlydHVhbFxuICAvLyBrZXlib2FyZCBnZXRzIGNvbmZ1c2VkLiBTbyB0aGUgaGFjayBoZXJlIGlzIHRvIHNldCBhIGZsYWcgdGhhdFxuICAvLyBtYWtlcyB0aGUgRE9NIGNoYW5nZSBjb2RlIHJlY29nbml6ZSB0aGF0IHdoYXQganVzdCBoYXBwZW5zIHNob3VsZFxuICAvLyBiZSByZXBsYWNlZCBieSB3aGF0ZXZlciB0aGUgRW50ZXIga2V5IGhhbmRsZXJzIGRvLlxuICBpZiAocmVzdWx0LmlvcyAmJiBldmVudC5rZXlDb2RlID09IDEzICYmICFldmVudC5jdHJsS2V5ICYmICFldmVudC5hbHRLZXkgJiYgIWV2ZW50Lm1ldGFLZXkpIHtcbiAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICB2aWV3Lmxhc3RJT1NFbnRlciA9IG5vdztcbiAgICB2aWV3Lmxhc3RJT1NFbnRlckZhbGxiYWNrVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHZpZXcubGFzdElPU0VudGVyID09IG5vdykge1xuICAgICAgICB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlS2V5RG93blwiLCBmdW5jdGlvbiAoZikgeyByZXR1cm4gZih2aWV3LCBrZXlFdmVudCgxMywgXCJFbnRlclwiKSk7IH0pO1xuICAgICAgICB2aWV3Lmxhc3RJT1NFbnRlciA9IDA7XG4gICAgICB9XG4gICAgfSwgMjAwKTtcbiAgfSBlbHNlIGlmICh2aWV3LnNvbWVQcm9wKFwiaGFuZGxlS2V5RG93blwiLCBmdW5jdGlvbiAoZikgeyByZXR1cm4gZih2aWV3LCBldmVudCk7IH0pIHx8IGNhcHR1cmVLZXlEb3duKHZpZXcsIGV2ZW50KSkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH0gZWxzZSB7XG4gICAgc2V0U2VsZWN0aW9uT3JpZ2luKHZpZXcsIFwia2V5XCIpO1xuICB9XG59O1xuXG5lZGl0SGFuZGxlcnMua2V5dXAgPSBmdW5jdGlvbiAodmlldywgZSkge1xuICBpZiAoZS5rZXlDb2RlID09IDE2KSB7IHZpZXcuc2hpZnRLZXkgPSBmYWxzZTsgfVxufTtcblxuZWRpdEhhbmRsZXJzLmtleXByZXNzID0gZnVuY3Rpb24gKHZpZXcsIGV2ZW50KSB7XG4gIGlmIChpbk9yTmVhckNvbXBvc2l0aW9uKHZpZXcsIGV2ZW50KSB8fCAhZXZlbnQuY2hhckNvZGUgfHxcbiAgICAgIGV2ZW50LmN0cmxLZXkgJiYgIWV2ZW50LmFsdEtleSB8fCByZXN1bHQubWFjICYmIGV2ZW50Lm1ldGFLZXkpIHsgcmV0dXJuIH1cblxuICBpZiAodmlldy5zb21lUHJvcChcImhhbmRsZUtleVByZXNzXCIsIGZ1bmN0aW9uIChmKSB7IHJldHVybiBmKHZpZXcsIGV2ZW50KTsgfSkpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICBpZiAoIShzZWwgaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uKSB8fCAhc2VsLiRmcm9tLnNhbWVQYXJlbnQoc2VsLiR0bykpIHtcbiAgICB2YXIgdGV4dCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoZXZlbnQuY2hhckNvZGUpO1xuICAgIGlmICghdmlldy5zb21lUHJvcChcImhhbmRsZVRleHRJbnB1dFwiLCBmdW5jdGlvbiAoZikgeyByZXR1cm4gZih2aWV3LCBzZWwuJGZyb20ucG9zLCBzZWwuJHRvLnBvcywgdGV4dCk7IH0pKVxuICAgICAgeyB2aWV3LmRpc3BhdGNoKHZpZXcuc3RhdGUudHIuaW5zZXJ0VGV4dCh0ZXh0KS5zY3JvbGxJbnRvVmlldygpKTsgfVxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGV2ZW50Q29vcmRzKGV2ZW50KSB7IHJldHVybiB7bGVmdDogZXZlbnQuY2xpZW50WCwgdG9wOiBldmVudC5jbGllbnRZfSB9XG5cbmZ1bmN0aW9uIGlzTmVhcihldmVudCwgY2xpY2spIHtcbiAgdmFyIGR4ID0gY2xpY2sueCAtIGV2ZW50LmNsaWVudFgsIGR5ID0gY2xpY2sueSAtIGV2ZW50LmNsaWVudFk7XG4gIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeSA8IDEwMFxufVxuXG5mdW5jdGlvbiBydW5IYW5kbGVyT25Db250ZXh0KHZpZXcsIHByb3BOYW1lLCBwb3MsIGluc2lkZSwgZXZlbnQpIHtcbiAgaWYgKGluc2lkZSA9PSAtMSkgeyByZXR1cm4gZmFsc2UgfVxuICB2YXIgJHBvcyA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoaW5zaWRlKTtcbiAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGkgKSB7XG4gICAgaWYgKHZpZXcuc29tZVByb3AocHJvcE5hbWUsIGZ1bmN0aW9uIChmKSB7IHJldHVybiBpID4gJHBvcy5kZXB0aCA/IGYodmlldywgcG9zLCAkcG9zLm5vZGVBZnRlciwgJHBvcy5iZWZvcmUoaSksIGV2ZW50LCB0cnVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZih2aWV3LCBwb3MsICRwb3Mubm9kZShpKSwgJHBvcy5iZWZvcmUoaSksIGV2ZW50LCBmYWxzZSk7IH0pKVxuICAgICAgeyByZXR1cm4geyB2OiB0cnVlIH0gfVxuICB9O1xuXG4gIGZvciAodmFyIGkgPSAkcG9zLmRlcHRoICsgMTsgaSA+IDA7IGktLSkge1xuICAgIHZhciByZXR1cm5lZCA9IGxvb3AoIGkgKTtcblxuICAgIGlmICggcmV0dXJuZWQgKSByZXR1cm4gcmV0dXJuZWQudjtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gdXBkYXRlU2VsZWN0aW9uKHZpZXcsIHNlbGVjdGlvbiwgb3JpZ2luKSB7XG4gIGlmICghdmlldy5mb2N1c2VkKSB7IHZpZXcuZm9jdXMoKTsgfVxuICB2YXIgdHIgPSB2aWV3LnN0YXRlLnRyLnNldFNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICBpZiAob3JpZ2luID09IFwicG9pbnRlclwiKSB7IHRyLnNldE1ldGEoXCJwb2ludGVyXCIsIHRydWUpOyB9XG4gIHZpZXcuZGlzcGF0Y2godHIpO1xufVxuXG5mdW5jdGlvbiBzZWxlY3RDbGlja2VkTGVhZih2aWV3LCBpbnNpZGUpIHtcbiAgaWYgKGluc2lkZSA9PSAtMSkgeyByZXR1cm4gZmFsc2UgfVxuICB2YXIgJHBvcyA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoaW5zaWRlKSwgbm9kZSA9ICRwb3Mubm9kZUFmdGVyO1xuICBpZiAobm9kZSAmJiBub2RlLmlzQXRvbSAmJiBOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShub2RlKSkge1xuICAgIHVwZGF0ZVNlbGVjdGlvbih2aWV3LCBuZXcgTm9kZVNlbGVjdGlvbigkcG9zKSwgXCJwb2ludGVyXCIpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIHNlbGVjdENsaWNrZWROb2RlKHZpZXcsIGluc2lkZSkge1xuICBpZiAoaW5zaWRlID09IC0xKSB7IHJldHVybiBmYWxzZSB9XG4gIHZhciBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbiwgc2VsZWN0ZWROb2RlLCBzZWxlY3RBdDtcbiAgaWYgKHNlbCBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24pIHsgc2VsZWN0ZWROb2RlID0gc2VsLm5vZGU7IH1cblxuICB2YXIgJHBvcyA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoaW5zaWRlKTtcbiAgZm9yICh2YXIgaSA9ICRwb3MuZGVwdGggKyAxOyBpID4gMDsgaS0tKSB7XG4gICAgdmFyIG5vZGUgPSBpID4gJHBvcy5kZXB0aCA/ICRwb3Mubm9kZUFmdGVyIDogJHBvcy5ub2RlKGkpO1xuICAgIGlmIChOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShub2RlKSkge1xuICAgICAgaWYgKHNlbGVjdGVkTm9kZSAmJiBzZWwuJGZyb20uZGVwdGggPiAwICYmXG4gICAgICAgICAgaSA+PSBzZWwuJGZyb20uZGVwdGggJiYgJHBvcy5iZWZvcmUoc2VsLiRmcm9tLmRlcHRoICsgMSkgPT0gc2VsLiRmcm9tLnBvcylcbiAgICAgICAgeyBzZWxlY3RBdCA9ICRwb3MuYmVmb3JlKHNlbC4kZnJvbS5kZXB0aCk7IH1cbiAgICAgIGVsc2VcbiAgICAgICAgeyBzZWxlY3RBdCA9ICRwb3MuYmVmb3JlKGkpOyB9XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmIChzZWxlY3RBdCAhPSBudWxsKSB7XG4gICAgdXBkYXRlU2VsZWN0aW9uKHZpZXcsIE5vZGVTZWxlY3Rpb24uY3JlYXRlKHZpZXcuc3RhdGUuZG9jLCBzZWxlY3RBdCksIFwicG9pbnRlclwiKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVNpbmdsZUNsaWNrKHZpZXcsIHBvcywgaW5zaWRlLCBldmVudCwgc2VsZWN0Tm9kZSkge1xuICByZXR1cm4gcnVuSGFuZGxlck9uQ29udGV4dCh2aWV3LCBcImhhbmRsZUNsaWNrT25cIiwgcG9zLCBpbnNpZGUsIGV2ZW50KSB8fFxuICAgIHZpZXcuc29tZVByb3AoXCJoYW5kbGVDbGlja1wiLCBmdW5jdGlvbiAoZikgeyByZXR1cm4gZih2aWV3LCBwb3MsIGV2ZW50KTsgfSkgfHxcbiAgICAoc2VsZWN0Tm9kZSA/IHNlbGVjdENsaWNrZWROb2RlKHZpZXcsIGluc2lkZSkgOiBzZWxlY3RDbGlja2VkTGVhZih2aWV3LCBpbnNpZGUpKVxufVxuXG5mdW5jdGlvbiBoYW5kbGVEb3VibGVDbGljayh2aWV3LCBwb3MsIGluc2lkZSwgZXZlbnQpIHtcbiAgcmV0dXJuIHJ1bkhhbmRsZXJPbkNvbnRleHQodmlldywgXCJoYW5kbGVEb3VibGVDbGlja09uXCIsIHBvcywgaW5zaWRlLCBldmVudCkgfHxcbiAgICB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlRG91YmxlQ2xpY2tcIiwgZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGYodmlldywgcG9zLCBldmVudCk7IH0pXG59XG5cbmZ1bmN0aW9uIGhhbmRsZVRyaXBsZUNsaWNrKHZpZXcsIHBvcywgaW5zaWRlLCBldmVudCkge1xuICByZXR1cm4gcnVuSGFuZGxlck9uQ29udGV4dCh2aWV3LCBcImhhbmRsZVRyaXBsZUNsaWNrT25cIiwgcG9zLCBpbnNpZGUsIGV2ZW50KSB8fFxuICAgIHZpZXcuc29tZVByb3AoXCJoYW5kbGVUcmlwbGVDbGlja1wiLCBmdW5jdGlvbiAoZikgeyByZXR1cm4gZih2aWV3LCBwb3MsIGV2ZW50KTsgfSkgfHxcbiAgICBkZWZhdWx0VHJpcGxlQ2xpY2sodmlldywgaW5zaWRlLCBldmVudClcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFRyaXBsZUNsaWNrKHZpZXcsIGluc2lkZSwgZXZlbnQpIHtcbiAgaWYgKGV2ZW50LmJ1dHRvbiAhPSAwKSB7IHJldHVybiBmYWxzZSB9XG4gIHZhciBkb2MgPSB2aWV3LnN0YXRlLmRvYztcbiAgaWYgKGluc2lkZSA9PSAtMSkge1xuICAgIGlmIChkb2MuaW5saW5lQ29udGVudCkge1xuICAgICAgdXBkYXRlU2VsZWN0aW9uKHZpZXcsIFRleHRTZWxlY3Rpb24uY3JlYXRlKGRvYywgMCwgZG9jLmNvbnRlbnQuc2l6ZSksIFwicG9pbnRlclwiKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgdmFyICRwb3MgPSBkb2MucmVzb2x2ZShpbnNpZGUpO1xuICBmb3IgKHZhciBpID0gJHBvcy5kZXB0aCArIDE7IGkgPiAwOyBpLS0pIHtcbiAgICB2YXIgbm9kZSA9IGkgPiAkcG9zLmRlcHRoID8gJHBvcy5ub2RlQWZ0ZXIgOiAkcG9zLm5vZGUoaSk7XG4gICAgdmFyIG5vZGVQb3MgPSAkcG9zLmJlZm9yZShpKTtcbiAgICBpZiAobm9kZS5pbmxpbmVDb250ZW50KVxuICAgICAgeyB1cGRhdGVTZWxlY3Rpb24odmlldywgVGV4dFNlbGVjdGlvbi5jcmVhdGUoZG9jLCBub2RlUG9zICsgMSwgbm9kZVBvcyArIDEgKyBub2RlLmNvbnRlbnQuc2l6ZSksIFwicG9pbnRlclwiKTsgfVxuICAgIGVsc2UgaWYgKE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKG5vZGUpKVxuICAgICAgeyB1cGRhdGVTZWxlY3Rpb24odmlldywgTm9kZVNlbGVjdGlvbi5jcmVhdGUoZG9jLCBub2RlUG9zKSwgXCJwb2ludGVyXCIpOyB9XG4gICAgZWxzZVxuICAgICAgeyBjb250aW51ZSB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxufVxuXG5mdW5jdGlvbiBmb3JjZURPTUZsdXNoKHZpZXcpIHtcbiAgcmV0dXJuIGVuZENvbXBvc2l0aW9uKHZpZXcpXG59XG5cbnZhciBzZWxlY3ROb2RlTW9kaWZpZXIgPSByZXN1bHQubWFjID8gXCJtZXRhS2V5XCIgOiBcImN0cmxLZXlcIjtcblxuaGFuZGxlcnMubW91c2Vkb3duID0gZnVuY3Rpb24gKHZpZXcsIGV2ZW50KSB7XG4gIHZpZXcuc2hpZnRLZXkgPSBldmVudC5zaGlmdEtleTtcbiAgdmFyIGZsdXNoZWQgPSBmb3JjZURPTUZsdXNoKHZpZXcpO1xuICB2YXIgbm93ID0gRGF0ZS5ub3coKSwgdHlwZSA9IFwic2luZ2xlQ2xpY2tcIjtcbiAgaWYgKG5vdyAtIHZpZXcubGFzdENsaWNrLnRpbWUgPCA1MDAgJiYgaXNOZWFyKGV2ZW50LCB2aWV3Lmxhc3RDbGljaykgJiYgIWV2ZW50W3NlbGVjdE5vZGVNb2RpZmllcl0pIHtcbiAgICBpZiAodmlldy5sYXN0Q2xpY2sudHlwZSA9PSBcInNpbmdsZUNsaWNrXCIpIHsgdHlwZSA9IFwiZG91YmxlQ2xpY2tcIjsgfVxuICAgIGVsc2UgaWYgKHZpZXcubGFzdENsaWNrLnR5cGUgPT0gXCJkb3VibGVDbGlja1wiKSB7IHR5cGUgPSBcInRyaXBsZUNsaWNrXCI7IH1cbiAgfVxuICB2aWV3Lmxhc3RDbGljayA9IHt0aW1lOiBub3csIHg6IGV2ZW50LmNsaWVudFgsIHk6IGV2ZW50LmNsaWVudFksIHR5cGU6IHR5cGV9O1xuXG4gIHZhciBwb3MgPSB2aWV3LnBvc0F0Q29vcmRzKGV2ZW50Q29vcmRzKGV2ZW50KSk7XG4gIGlmICghcG9zKSB7IHJldHVybiB9XG5cbiAgaWYgKHR5cGUgPT0gXCJzaW5nbGVDbGlja1wiKSB7XG4gICAgaWYgKHZpZXcubW91c2VEb3duKSB7IHZpZXcubW91c2VEb3duLmRvbmUoKTsgfVxuICAgIHZpZXcubW91c2VEb3duID0gbmV3IE1vdXNlRG93bih2aWV3LCBwb3MsIGV2ZW50LCBmbHVzaGVkKTtcbiAgfSBlbHNlIGlmICgodHlwZSA9PSBcImRvdWJsZUNsaWNrXCIgPyBoYW5kbGVEb3VibGVDbGljayA6IGhhbmRsZVRyaXBsZUNsaWNrKSh2aWV3LCBwb3MucG9zLCBwb3MuaW5zaWRlLCBldmVudCkpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9IGVsc2Uge1xuICAgIHNldFNlbGVjdGlvbk9yaWdpbih2aWV3LCBcInBvaW50ZXJcIik7XG4gIH1cbn07XG5cbnZhciBNb3VzZURvd24gPSBmdW5jdGlvbiBNb3VzZURvd24odmlldywgcG9zLCBldmVudCwgZmx1c2hlZCkge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB0aGlzLnZpZXcgPSB2aWV3O1xuICB0aGlzLnN0YXJ0RG9jID0gdmlldy5zdGF0ZS5kb2M7XG4gIHRoaXMucG9zID0gcG9zO1xuICB0aGlzLmV2ZW50ID0gZXZlbnQ7XG4gIHRoaXMuZmx1c2hlZCA9IGZsdXNoZWQ7XG4gIHRoaXMuc2VsZWN0Tm9kZSA9IGV2ZW50W3NlbGVjdE5vZGVNb2RpZmllcl07XG4gIHRoaXMuYWxsb3dEZWZhdWx0ID0gZXZlbnQuc2hpZnRLZXk7XG4gIHRoaXMuZGVsYXllZFNlbGVjdGlvblN5bmMgPSBmYWxzZTtcblxuICB2YXIgdGFyZ2V0Tm9kZSwgdGFyZ2V0UG9zO1xuICBpZiAocG9zLmluc2lkZSA+IC0xKSB7XG4gICAgdGFyZ2V0Tm9kZSA9IHZpZXcuc3RhdGUuZG9jLm5vZGVBdChwb3MuaW5zaWRlKTtcbiAgICB0YXJnZXRQb3MgPSBwb3MuaW5zaWRlO1xuICB9IGVsc2Uge1xuICAgIHZhciAkcG9zID0gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZShwb3MucG9zKTtcbiAgICB0YXJnZXROb2RlID0gJHBvcy5wYXJlbnQ7XG4gICAgdGFyZ2V0UG9zID0gJHBvcy5kZXB0aCA/ICRwb3MuYmVmb3JlKCkgOiAwO1xuICB9XG5cbiAgdGhpcy5taWdodERyYWcgPSBudWxsO1xuXG4gIHZhciB0YXJnZXQgPSBmbHVzaGVkID8gbnVsbCA6IGV2ZW50LnRhcmdldDtcbiAgdmFyIHRhcmdldERlc2MgPSB0YXJnZXQgPyB2aWV3LmRvY1ZpZXcubmVhcmVzdERlc2ModGFyZ2V0LCB0cnVlKSA6IG51bGw7XG4gIHRoaXMudGFyZ2V0ID0gdGFyZ2V0RGVzYyA/IHRhcmdldERlc2MuZG9tIDogbnVsbDtcblxuICB2YXIgcmVmID0gdmlldy5zdGF0ZTtcbiAgdmFyIHNlbGVjdGlvbiA9IHJlZi5zZWxlY3Rpb247XG4gIGlmIChldmVudC5idXR0b24gPT0gMCAmJlxuICAgICAgdGFyZ2V0Tm9kZS50eXBlLnNwZWMuZHJhZ2dhYmxlICYmIHRhcmdldE5vZGUudHlwZS5zcGVjLnNlbGVjdGFibGUgIT09IGZhbHNlIHx8XG4gICAgICBzZWxlY3Rpb24gaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uICYmIHNlbGVjdGlvbi5mcm9tIDw9IHRhcmdldFBvcyAmJiBzZWxlY3Rpb24udG8gPiB0YXJnZXRQb3MpXG4gICAgeyB0aGlzLm1pZ2h0RHJhZyA9IHtub2RlOiB0YXJnZXROb2RlLFxuICAgICAgICAgICAgICAgICAgICAgIHBvczogdGFyZ2V0UG9zLFxuICAgICAgICAgICAgICAgICAgICAgIGFkZEF0dHI6IHRoaXMudGFyZ2V0ICYmICF0aGlzLnRhcmdldC5kcmFnZ2FibGUsXG4gICAgICAgICAgICAgICAgICAgICAgc2V0VW5lZGl0YWJsZTogdGhpcy50YXJnZXQgJiYgcmVzdWx0LmdlY2tvICYmICF0aGlzLnRhcmdldC5oYXNBdHRyaWJ1dGUoXCJjb250ZW50RWRpdGFibGVcIil9OyB9XG5cbiAgaWYgKHRoaXMudGFyZ2V0ICYmIHRoaXMubWlnaHREcmFnICYmICh0aGlzLm1pZ2h0RHJhZy5hZGRBdHRyIHx8IHRoaXMubWlnaHREcmFnLnNldFVuZWRpdGFibGUpKSB7XG4gICAgdGhpcy52aWV3LmRvbU9ic2VydmVyLnN0b3AoKTtcbiAgICBpZiAodGhpcy5taWdodERyYWcuYWRkQXR0cikgeyB0aGlzLnRhcmdldC5kcmFnZ2FibGUgPSB0cnVlOyB9XG4gICAgaWYgKHRoaXMubWlnaHREcmFnLnNldFVuZWRpdGFibGUpXG4gICAgICB7IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcyQxLnZpZXcubW91c2VEb3duID09IHRoaXMkMSkgeyB0aGlzJDEudGFyZ2V0LnNldEF0dHJpYnV0ZShcImNvbnRlbnRFZGl0YWJsZVwiLCBcImZhbHNlXCIpOyB9XG4gICAgICB9LCAyMCk7IH1cbiAgICB0aGlzLnZpZXcuZG9tT2JzZXJ2ZXIuc3RhcnQoKTtcbiAgfVxuXG4gIHZpZXcucm9vdC5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLnVwID0gdGhpcy51cC5iaW5kKHRoaXMpKTtcbiAgdmlldy5yb290LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5tb3ZlID0gdGhpcy5tb3ZlLmJpbmQodGhpcykpO1xuICBzZXRTZWxlY3Rpb25PcmlnaW4odmlldywgXCJwb2ludGVyXCIpO1xufTtcblxuTW91c2VEb3duLnByb3RvdHlwZS5kb25lID0gZnVuY3Rpb24gZG9uZSAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdGhpcy52aWV3LnJvb3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy51cCk7XG4gIHRoaXMudmlldy5yb290LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5tb3ZlKTtcbiAgaWYgKHRoaXMubWlnaHREcmFnICYmIHRoaXMudGFyZ2V0KSB7XG4gICAgdGhpcy52aWV3LmRvbU9ic2VydmVyLnN0b3AoKTtcbiAgICBpZiAodGhpcy5taWdodERyYWcuYWRkQXR0cikgeyB0aGlzLnRhcmdldC5yZW1vdmVBdHRyaWJ1dGUoXCJkcmFnZ2FibGVcIik7IH1cbiAgICBpZiAodGhpcy5taWdodERyYWcuc2V0VW5lZGl0YWJsZSkgeyB0aGlzLnRhcmdldC5yZW1vdmVBdHRyaWJ1dGUoXCJjb250ZW50RWRpdGFibGVcIik7IH1cbiAgICB0aGlzLnZpZXcuZG9tT2JzZXJ2ZXIuc3RhcnQoKTtcbiAgfVxuICBpZiAodGhpcy5kZWxheWVkU2VsZWN0aW9uU3luYykgeyBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlbGVjdGlvblRvRE9NKHRoaXMkMS52aWV3KTsgfSk7IH1cbiAgdGhpcy52aWV3Lm1vdXNlRG93biA9IG51bGw7XG59O1xuXG5Nb3VzZURvd24ucHJvdG90eXBlLnVwID0gZnVuY3Rpb24gdXAgKGV2ZW50KSB7XG4gIHRoaXMuZG9uZSgpO1xuXG4gIGlmICghdGhpcy52aWV3LmRvbS5jb250YWlucyhldmVudC50YXJnZXQubm9kZVR5cGUgPT0gMyA/IGV2ZW50LnRhcmdldC5wYXJlbnROb2RlIDogZXZlbnQudGFyZ2V0KSlcbiAgICB7IHJldHVybiB9XG5cbiAgdmFyIHBvcyA9IHRoaXMucG9zO1xuICBpZiAodGhpcy52aWV3LnN0YXRlLmRvYyAhPSB0aGlzLnN0YXJ0RG9jKSB7IHBvcyA9IHRoaXMudmlldy5wb3NBdENvb3JkcyhldmVudENvb3JkcyhldmVudCkpOyB9XG5cbiAgaWYgKHRoaXMuYWxsb3dEZWZhdWx0IHx8ICFwb3MpIHtcbiAgICBzZXRTZWxlY3Rpb25PcmlnaW4odGhpcy52aWV3LCBcInBvaW50ZXJcIik7XG4gIH0gZWxzZSBpZiAoaGFuZGxlU2luZ2xlQ2xpY2sodGhpcy52aWV3LCBwb3MucG9zLCBwb3MuaW5zaWRlLCBldmVudCwgdGhpcy5zZWxlY3ROb2RlKSkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH0gZWxzZSBpZiAoZXZlbnQuYnV0dG9uID09IDAgJiZcbiAgICAgICAgICAgICAodGhpcy5mbHVzaGVkIHx8XG4gICAgICAgICAgICAgIC8vIFNhZmFyaSBpZ25vcmVzIGNsaWNrcyBvbiBkcmFnZ2FibGUgZWxlbWVudHNcbiAgICAgICAgICAgICAgKHJlc3VsdC5zYWZhcmkgJiYgdGhpcy5taWdodERyYWcgJiYgIXRoaXMubWlnaHREcmFnLm5vZGUuaXNBdG9tKSB8fFxuICAgICAgICAgICAgICAvLyBDaHJvbWUgd2lsbCBzb21ldGltZXMgdHJlYXQgYSBub2RlIHNlbGVjdGlvbiBhcyBhXG4gICAgICAgICAgICAgIC8vIGN1cnNvciwgYnV0IHN0aWxsIHJlcG9ydCB0aGF0IHRoZSBub2RlIGlzIHNlbGVjdGVkXG4gICAgICAgICAgICAgIC8vIHdoZW4gYXNrZWQgdGhyb3VnaCBnZXRTZWxlY3Rpb24uIFlvdSdsbCB0aGVuIGdldCBhXG4gICAgICAgICAgICAgIC8vIHNpdHVhdGlvbiB3aGVyZSBjbGlja2luZyBhdCB0aGUgcG9pbnQgd2hlcmUgdGhhdFxuICAgICAgICAgICAgICAvLyAoaGlkZGVuKSBjdXJzb3IgaXMgZG9lc24ndCBjaGFuZ2UgdGhlIHNlbGVjdGlvbiwgYW5kXG4gICAgICAgICAgICAgIC8vIHRodXMgZG9lc24ndCBnZXQgYSByZWFjdGlvbiBmcm9tIFByb3NlTWlycm9yLiBUaGlzXG4gICAgICAgICAgICAgIC8vIHdvcmtzIGFyb3VuZCB0aGF0LlxuICAgICAgICAgICAgICAocmVzdWx0LmNocm9tZSAmJiAhKHRoaXMudmlldy5zdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uKSAmJlxuICAgICAgICAgICAgICAgTWF0aC5taW4oTWF0aC5hYnMocG9zLnBvcyAtIHRoaXMudmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbSksXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmFicyhwb3MucG9zIC0gdGhpcy52aWV3LnN0YXRlLnNlbGVjdGlvbi50bykpIDw9IDIpKSkge1xuICAgIHVwZGF0ZVNlbGVjdGlvbih0aGlzLnZpZXcsIFNlbGVjdGlvbi5uZWFyKHRoaXMudmlldy5zdGF0ZS5kb2MucmVzb2x2ZShwb3MucG9zKSksIFwicG9pbnRlclwiKTtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9IGVsc2Uge1xuICAgIHNldFNlbGVjdGlvbk9yaWdpbih0aGlzLnZpZXcsIFwicG9pbnRlclwiKTtcbiAgfVxufTtcblxuTW91c2VEb3duLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24gbW92ZSAoZXZlbnQpIHtcbiAgaWYgKCF0aGlzLmFsbG93RGVmYXVsdCAmJiAoTWF0aC5hYnModGhpcy5ldmVudC54IC0gZXZlbnQuY2xpZW50WCkgPiA0IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguYWJzKHRoaXMuZXZlbnQueSAtIGV2ZW50LmNsaWVudFkpID4gNCkpXG4gICAgeyB0aGlzLmFsbG93RGVmYXVsdCA9IHRydWU7IH1cbiAgc2V0U2VsZWN0aW9uT3JpZ2luKHRoaXMudmlldywgXCJwb2ludGVyXCIpO1xuICBpZiAoZXZlbnQuYnV0dG9ucyA9PSAwKSB7IHRoaXMuZG9uZSgpOyB9XG59O1xuXG5oYW5kbGVycy50b3VjaGRvd24gPSBmdW5jdGlvbiAodmlldykge1xuICBmb3JjZURPTUZsdXNoKHZpZXcpO1xuICBzZXRTZWxlY3Rpb25PcmlnaW4odmlldywgXCJwb2ludGVyXCIpO1xufTtcblxuaGFuZGxlcnMuY29udGV4dG1lbnUgPSBmdW5jdGlvbiAodmlldykgeyByZXR1cm4gZm9yY2VET01GbHVzaCh2aWV3KTsgfTtcblxuZnVuY3Rpb24gaW5Pck5lYXJDb21wb3NpdGlvbih2aWV3LCBldmVudCkge1xuICBpZiAodmlldy5jb21wb3NpbmcpIHsgcmV0dXJuIHRydWUgfVxuICAvLyBTZWUgaHR0cHM6Ly93d3cuc3R1bS5kZS8yMDE2LzA2LzI0L2hhbmRsaW5nLWltZS1ldmVudHMtaW4tamF2YXNjcmlwdC8uXG4gIC8vIE9uIEphcGFuZXNlIGlucHV0IG1ldGhvZCBlZGl0b3JzIChJTUVzKSwgdGhlIEVudGVyIGtleSBpcyB1c2VkIHRvIGNvbmZpcm0gY2hhcmFjdGVyXG4gIC8vIHNlbGVjdGlvbi4gT24gU2FmYXJpLCB3aGVuIEVudGVyIGlzIHByZXNzZWQsIGNvbXBvc2l0aW9uZW5kIGFuZCBrZXlkb3duIGV2ZW50cyBhcmVcbiAgLy8gZW1pdHRlZC4gVGhlIGtleWRvd24gZXZlbnQgdHJpZ2dlcnMgbmV3bGluZSBpbnNlcnRpb24sIHdoaWNoIHdlIGRvbid0IHdhbnQuXG4gIC8vIFRoaXMgbWV0aG9kIHJldHVybnMgdHJ1ZSBpZiB0aGUga2V5ZG93biBldmVudCBzaG91bGQgYmUgaWdub3JlZC5cbiAgLy8gV2Ugb25seSBpZ25vcmUgaXQgb25jZSwgYXMgcHJlc3NpbmcgRW50ZXIgYSBzZWNvbmQgdGltZSAqc2hvdWxkKiBpbnNlcnQgYSBuZXdsaW5lLlxuICAvLyBGdXJ0aGVybW9yZSwgdGhlIGtleWRvd24gZXZlbnQgdGltZXN0YW1wIG11c3QgYmUgY2xvc2UgdG8gdGhlIGNvbXBvc2l0aW9uRW5kZWRBdCB0aW1lc3RhbXAuXG4gIC8vIFRoaXMgZ3VhcmRzIGFnYWluc3QgdGhlIGNhc2Ugd2hlcmUgY29tcG9zaXRpb25lbmQgaXMgdHJpZ2dlcmVkIHdpdGhvdXQgdGhlIGtleWJvYXJkXG4gIC8vIChlLmcuIGNoYXJhY3RlciBjb25maXJtYXRpb24gbWF5IGJlIGRvbmUgd2l0aCB0aGUgbW91c2UpLCBhbmQga2V5ZG93biBpcyB0cmlnZ2VyZWRcbiAgLy8gYWZ0ZXJ3YXJkcy0gd2Ugd291bGRuJ3Qgd2FudCB0byBpZ25vcmUgdGhlIGtleWRvd24gZXZlbnQgaW4gdGhpcyBjYXNlLlxuICBpZiAocmVzdWx0LnNhZmFyaSAmJiBNYXRoLmFicyhldmVudC50aW1lU3RhbXAgLSB2aWV3LmNvbXBvc2l0aW9uRW5kZWRBdCkgPCA1MDApIHtcbiAgICB2aWV3LmNvbXBvc2l0aW9uRW5kZWRBdCA9IC0yZTg7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLy8gRHJvcCBhY3RpdmUgY29tcG9zaXRpb24gYWZ0ZXIgNSBzZWNvbmRzIG9mIGluYWN0aXZpdHkgb24gQW5kcm9pZFxudmFyIHRpbWVvdXRDb21wb3NpdGlvbiA9IHJlc3VsdC5hbmRyb2lkID8gNTAwMCA6IC0xO1xuXG5lZGl0SGFuZGxlcnMuY29tcG9zaXRpb25zdGFydCA9IGVkaXRIYW5kbGVycy5jb21wb3NpdGlvbnVwZGF0ZSA9IGZ1bmN0aW9uICh2aWV3KSB7XG4gIGlmICghdmlldy5jb21wb3NpbmcpIHtcbiAgICB2aWV3LmRvbU9ic2VydmVyLmZsdXNoKCk7XG4gICAgdmFyIHN0YXRlID0gdmlldy5zdGF0ZTtcbiAgICB2YXIgJHBvcyA9IHN0YXRlLnNlbGVjdGlvbi4kZnJvbTtcbiAgICBpZiAoc3RhdGUuc2VsZWN0aW9uLmVtcHR5ICYmXG4gICAgICAgIChzdGF0ZS5zdG9yZWRNYXJrcyB8fFxuICAgICAgICAgKCEkcG9zLnRleHRPZmZzZXQgJiYgJHBvcy5wYXJlbnRPZmZzZXQgJiYgJHBvcy5ub2RlQmVmb3JlLm1hcmtzLnNvbWUoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0udHlwZS5zcGVjLmluY2x1c2l2ZSA9PT0gZmFsc2U7IH0pKSkpIHtcbiAgICAgIC8vIE5lZWQgdG8gd3JhcCB0aGUgY3Vyc29yIGluIG1hcmsgbm9kZXMgZGlmZmVyZW50IGZyb20gdGhlIG9uZXMgaW4gdGhlIERPTSBjb250ZXh0XG4gICAgICB2aWV3Lm1hcmtDdXJzb3IgPSB2aWV3LnN0YXRlLnN0b3JlZE1hcmtzIHx8ICRwb3MubWFya3MoKTtcbiAgICAgIGVuZENvbXBvc2l0aW9uKHZpZXcsIHRydWUpO1xuICAgICAgdmlldy5tYXJrQ3Vyc29yID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgZW5kQ29tcG9zaXRpb24odmlldyk7XG4gICAgICAvLyBJbiBmaXJlZm94LCBpZiB0aGUgY3Vyc29yIGlzIGFmdGVyIGJ1dCBvdXRzaWRlIGEgbWFya2VkIG5vZGUsXG4gICAgICAvLyB0aGUgaW5zZXJ0ZWQgdGV4dCB3b24ndCBpbmhlcml0IHRoZSBtYXJrcy4gU28gdGhpcyBtb3ZlcyBpdFxuICAgICAgLy8gaW5zaWRlIGlmIG5lY2Vzc2FyeS5cbiAgICAgIGlmIChyZXN1bHQuZ2Vja28gJiYgc3RhdGUuc2VsZWN0aW9uLmVtcHR5ICYmICRwb3MucGFyZW50T2Zmc2V0ICYmICEkcG9zLnRleHRPZmZzZXQgJiYgJHBvcy5ub2RlQmVmb3JlLm1hcmtzLmxlbmd0aCkge1xuICAgICAgICB2YXIgc2VsID0gdmlldy5yb290LmdldFNlbGVjdGlvbigpO1xuICAgICAgICBmb3IgKHZhciBub2RlID0gc2VsLmZvY3VzTm9kZSwgb2Zmc2V0ID0gc2VsLmZvY3VzT2Zmc2V0OyBub2RlICYmIG5vZGUubm9kZVR5cGUgPT0gMSAmJiBvZmZzZXQgIT0gMDspIHtcbiAgICAgICAgICB2YXIgYmVmb3JlID0gb2Zmc2V0IDwgMCA/IG5vZGUubGFzdENoaWxkIDogbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICAgIGlmICghYmVmb3JlKSB7IGJyZWFrIH1cbiAgICAgICAgICBpZiAoYmVmb3JlLm5vZGVUeXBlID09IDMpIHtcbiAgICAgICAgICAgIHNlbC5jb2xsYXBzZShiZWZvcmUsIGJlZm9yZS5ub2RlVmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUgPSBiZWZvcmU7XG4gICAgICAgICAgICBvZmZzZXQgPSAtMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdmlldy5jb21wb3NpbmcgPSB0cnVlO1xuICB9XG4gIHNjaGVkdWxlQ29tcG9zZUVuZCh2aWV3LCB0aW1lb3V0Q29tcG9zaXRpb24pO1xufTtcblxuZWRpdEhhbmRsZXJzLmNvbXBvc2l0aW9uZW5kID0gZnVuY3Rpb24gKHZpZXcsIGV2ZW50KSB7XG4gIGlmICh2aWV3LmNvbXBvc2luZykge1xuICAgIHZpZXcuY29tcG9zaW5nID0gZmFsc2U7XG4gICAgdmlldy5jb21wb3NpdGlvbkVuZGVkQXQgPSBldmVudC50aW1lU3RhbXA7XG4gICAgc2NoZWR1bGVDb21wb3NlRW5kKHZpZXcsIDIwKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gc2NoZWR1bGVDb21wb3NlRW5kKHZpZXcsIGRlbGF5KSB7XG4gIGNsZWFyVGltZW91dCh2aWV3LmNvbXBvc2luZ1RpbWVvdXQpO1xuICBpZiAoZGVsYXkgPiAtMSkgeyB2aWV3LmNvbXBvc2luZ1RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVuZENvbXBvc2l0aW9uKHZpZXcpOyB9LCBkZWxheSk7IH1cbn1cblxuZnVuY3Rpb24gY2xlYXJDb21wb3NpdGlvbih2aWV3KSB7XG4gIGlmICh2aWV3LmNvbXBvc2luZykge1xuICAgIHZpZXcuY29tcG9zaW5nID0gZmFsc2U7XG4gICAgdmlldy5jb21wb3NpdGlvbkVuZGVkQXQgPSB0aW1lc3RhbXBGcm9tQ3VzdG9tRXZlbnQoKTtcbiAgfVxuICB3aGlsZSAodmlldy5jb21wb3NpdGlvbk5vZGVzLmxlbmd0aCA+IDApIHsgdmlldy5jb21wb3NpdGlvbk5vZGVzLnBvcCgpLm1hcmtQYXJlbnRzRGlydHkoKTsgfVxufVxuXG5mdW5jdGlvbiB0aW1lc3RhbXBGcm9tQ3VzdG9tRXZlbnQoKSB7XG4gIHZhciBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiRXZlbnRcIik7XG4gIGV2ZW50LmluaXRFdmVudChcImV2ZW50XCIsIHRydWUsIHRydWUpO1xuICByZXR1cm4gZXZlbnQudGltZVN0YW1wXG59XG5cbmZ1bmN0aW9uIGVuZENvbXBvc2l0aW9uKHZpZXcsIGZvcmNlVXBkYXRlKSB7XG4gIHZpZXcuZG9tT2JzZXJ2ZXIuZm9yY2VGbHVzaCgpO1xuICBjbGVhckNvbXBvc2l0aW9uKHZpZXcpO1xuICBpZiAoZm9yY2VVcGRhdGUgfHwgdmlldy5kb2NWaWV3LmRpcnR5KSB7XG4gICAgdmFyIHNlbCA9IHNlbGVjdGlvbkZyb21ET00odmlldyk7XG4gICAgaWYgKHNlbCAmJiAhc2VsLmVxKHZpZXcuc3RhdGUuc2VsZWN0aW9uKSkgeyB2aWV3LmRpc3BhdGNoKHZpZXcuc3RhdGUudHIuc2V0U2VsZWN0aW9uKHNlbCkpOyB9XG4gICAgZWxzZSB7IHZpZXcudXBkYXRlU3RhdGUodmlldy5zdGF0ZSk7IH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBjYXB0dXJlQ29weSh2aWV3LCBkb20pIHtcbiAgLy8gVGhlIGV4dHJhIHdyYXBwZXIgaXMgc29tZWhvdyBuZWNlc3Nhcnkgb24gSUUvRWRnZSB0byBwcmV2ZW50IHRoZVxuICAvLyBjb250ZW50IGZyb20gYmVpbmcgbWFuZ2xlZCB3aGVuIGl0IGlzIHB1dCBvbnRvIHRoZSBjbGlwYm9hcmRcbiAgaWYgKCF2aWV3LmRvbS5wYXJlbnROb2RlKSB7IHJldHVybiB9XG4gIHZhciB3cmFwID0gdmlldy5kb20ucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcbiAgd3JhcC5hcHBlbmRDaGlsZChkb20pO1xuICB3cmFwLnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOiBmaXhlZDsgbGVmdDogLTEwMDAwcHg7IHRvcDogMTBweFwiO1xuICB2YXIgc2VsID0gZ2V0U2VsZWN0aW9uKCksIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgcmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKGRvbSk7XG4gIC8vIERvbmUgYmVjYXVzZSBJRSB3aWxsIGZpcmUgYSBzZWxlY3Rpb25jaGFuZ2UgbW92aW5nIHRoZSBzZWxlY3Rpb25cbiAgLy8gdG8gaXRzIHN0YXJ0IHdoZW4gcmVtb3ZlQWxsUmFuZ2VzIGlzIGNhbGxlZCBhbmQgdGhlIGVkaXRvciBzdGlsbFxuICAvLyBoYXMgZm9jdXMgKHdoaWNoIHdpbGwgbWVzcyB1cCB0aGUgZWRpdG9yJ3Mgc2VsZWN0aW9uIHN0YXRlKS5cbiAgdmlldy5kb20uYmx1cigpO1xuICBzZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gIHNlbC5hZGRSYW5nZShyYW5nZSk7XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGlmICh3cmFwLnBhcmVudE5vZGUpIHsgd3JhcC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHdyYXApOyB9XG4gICAgdmlldy5mb2N1cygpO1xuICB9LCA1MCk7XG59XG5cbi8vIFRoaXMgaXMgdmVyeSBjcnVkZSwgYnV0IHVuZm9ydHVuYXRlbHkgYm90aCB0aGVzZSBicm93c2VycyBfcHJldGVuZF9cbi8vIHRoYXQgdGhleSBoYXZlIGEgY2xpcGJvYXJkIEFQSeKAlGFsbCB0aGUgb2JqZWN0cyBhbmQgbWV0aG9kcyBhcmVcbi8vIHRoZXJlLCB0aGV5IGp1c3QgZG9uJ3Qgd29yaywgYW5kIHRoZXkgYXJlIGhhcmQgdG8gdGVzdC5cbnZhciBicm9rZW5DbGlwYm9hcmRBUEkgPSAocmVzdWx0LmllICYmIHJlc3VsdC5pZV92ZXJzaW9uIDwgMTUpIHx8XG4gICAgICAocmVzdWx0LmlvcyAmJiByZXN1bHQud2Via2l0X3ZlcnNpb24gPCA2MDQpO1xuXG5oYW5kbGVycy5jb3B5ID0gZWRpdEhhbmRsZXJzLmN1dCA9IGZ1bmN0aW9uICh2aWV3LCBlKSB7XG4gIHZhciBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbiwgY3V0ID0gZS50eXBlID09IFwiY3V0XCI7XG4gIGlmIChzZWwuZW1wdHkpIHsgcmV0dXJuIH1cblxuICAvLyBJRSBhbmQgRWRnZSdzIGNsaXBib2FyZCBpbnRlcmZhY2UgaXMgY29tcGxldGVseSBicm9rZW5cbiAgdmFyIGRhdGEgPSBicm9rZW5DbGlwYm9hcmRBUEkgPyBudWxsIDogZS5jbGlwYm9hcmREYXRhO1xuICB2YXIgc2xpY2UgPSBzZWwuY29udGVudCgpO1xuICB2YXIgcmVmID0gc2VyaWFsaXplRm9yQ2xpcGJvYXJkKHZpZXcsIHNsaWNlKTtcbiAgdmFyIGRvbSA9IHJlZi5kb207XG4gIHZhciB0ZXh0ID0gcmVmLnRleHQ7XG4gIGlmIChkYXRhKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGRhdGEuY2xlYXJEYXRhKCk7XG4gICAgZGF0YS5zZXREYXRhKFwidGV4dC9odG1sXCIsIGRvbS5pbm5lckhUTUwpO1xuICAgIGRhdGEuc2V0RGF0YShcInRleHQvcGxhaW5cIiwgdGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgY2FwdHVyZUNvcHkodmlldywgZG9tKTtcbiAgfVxuICBpZiAoY3V0KSB7IHZpZXcuZGlzcGF0Y2godmlldy5zdGF0ZS50ci5kZWxldGVTZWxlY3Rpb24oKS5zY3JvbGxJbnRvVmlldygpLnNldE1ldGEoXCJ1aUV2ZW50XCIsIFwiY3V0XCIpKTsgfVxufTtcblxuZnVuY3Rpb24gc2xpY2VTaW5nbGVOb2RlKHNsaWNlKSB7XG4gIHJldHVybiBzbGljZS5vcGVuU3RhcnQgPT0gMCAmJiBzbGljZS5vcGVuRW5kID09IDAgJiYgc2xpY2UuY29udGVudC5jaGlsZENvdW50ID09IDEgPyBzbGljZS5jb250ZW50LmZpcnN0Q2hpbGQgOiBudWxsXG59XG5cbmZ1bmN0aW9uIGNhcHR1cmVQYXN0ZSh2aWV3LCBlKSB7XG4gIGlmICghdmlldy5kb20ucGFyZW50Tm9kZSkgeyByZXR1cm4gfVxuICB2YXIgcGxhaW5UZXh0ID0gdmlldy5zaGlmdEtleSB8fCB2aWV3LnN0YXRlLnNlbGVjdGlvbi4kZnJvbS5wYXJlbnQudHlwZS5zcGVjLmNvZGU7XG4gIHZhciB0YXJnZXQgPSB2aWV3LmRvbS5wYXJlbnROb2RlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQocGxhaW5UZXh0ID8gXCJ0ZXh0YXJlYVwiIDogXCJkaXZcIikpO1xuICBpZiAoIXBsYWluVGV4dCkgeyB0YXJnZXQuY29udGVudEVkaXRhYmxlID0gXCJ0cnVlXCI7IH1cbiAgdGFyZ2V0LnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOiBmaXhlZDsgbGVmdDogLTEwMDAwcHg7IHRvcDogMTBweFwiO1xuICB0YXJnZXQuZm9jdXMoKTtcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgdmlldy5mb2N1cygpO1xuICAgIGlmICh0YXJnZXQucGFyZW50Tm9kZSkgeyB0YXJnZXQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0YXJnZXQpOyB9XG4gICAgaWYgKHBsYWluVGV4dCkgeyBkb1Bhc3RlKHZpZXcsIHRhcmdldC52YWx1ZSwgbnVsbCwgZSk7IH1cbiAgICBlbHNlIHsgZG9QYXN0ZSh2aWV3LCB0YXJnZXQudGV4dENvbnRlbnQsIHRhcmdldC5pbm5lckhUTUwsIGUpOyB9XG4gIH0sIDUwKTtcbn1cblxuZnVuY3Rpb24gZG9QYXN0ZSh2aWV3LCB0ZXh0LCBodG1sLCBlKSB7XG4gIHZhciBzbGljZSA9IHBhcnNlRnJvbUNsaXBib2FyZCh2aWV3LCB0ZXh0LCBodG1sLCB2aWV3LnNoaWZ0S2V5LCB2aWV3LnN0YXRlLnNlbGVjdGlvbi4kZnJvbSk7XG4gIGlmICh2aWV3LnNvbWVQcm9wKFwiaGFuZGxlUGFzdGVcIiwgZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGYodmlldywgZSwgc2xpY2UgfHwgU2xpY2UuZW1wdHkpOyB9KSkgeyByZXR1cm4gdHJ1ZSB9XG4gIGlmICghc2xpY2UpIHsgcmV0dXJuIGZhbHNlIH1cblxuICB2YXIgc2luZ2xlTm9kZSA9IHNsaWNlU2luZ2xlTm9kZShzbGljZSk7XG4gIHZhciB0ciA9IHNpbmdsZU5vZGUgPyB2aWV3LnN0YXRlLnRyLnJlcGxhY2VTZWxlY3Rpb25XaXRoKHNpbmdsZU5vZGUsIHZpZXcuc2hpZnRLZXkpIDogdmlldy5zdGF0ZS50ci5yZXBsYWNlU2VsZWN0aW9uKHNsaWNlKTtcbiAgdmlldy5kaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpLnNldE1ldGEoXCJwYXN0ZVwiLCB0cnVlKS5zZXRNZXRhKFwidWlFdmVudFwiLCBcInBhc3RlXCIpKTtcbiAgcmV0dXJuIHRydWVcbn1cblxuZWRpdEhhbmRsZXJzLnBhc3RlID0gZnVuY3Rpb24gKHZpZXcsIGUpIHtcbiAgdmFyIGRhdGEgPSBicm9rZW5DbGlwYm9hcmRBUEkgPyBudWxsIDogZS5jbGlwYm9hcmREYXRhO1xuICBpZiAoZGF0YSAmJiBkb1Bhc3RlKHZpZXcsIGRhdGEuZ2V0RGF0YShcInRleHQvcGxhaW5cIiksIGRhdGEuZ2V0RGF0YShcInRleHQvaHRtbFwiKSwgZSkpIHsgZS5wcmV2ZW50RGVmYXVsdCgpOyB9XG4gIGVsc2UgeyBjYXB0dXJlUGFzdGUodmlldywgZSk7IH1cbn07XG5cbnZhciBEcmFnZ2luZyA9IGZ1bmN0aW9uIERyYWdnaW5nKHNsaWNlLCBtb3ZlKSB7XG4gIHRoaXMuc2xpY2UgPSBzbGljZTtcbiAgdGhpcy5tb3ZlID0gbW92ZTtcbn07XG5cbnZhciBkcmFnQ29weU1vZGlmaWVyID0gcmVzdWx0Lm1hYyA/IFwiYWx0S2V5XCIgOiBcImN0cmxLZXlcIjtcblxuaGFuZGxlcnMuZHJhZ3N0YXJ0ID0gZnVuY3Rpb24gKHZpZXcsIGUpIHtcbiAgdmFyIG1vdXNlRG93biA9IHZpZXcubW91c2VEb3duO1xuICBpZiAobW91c2VEb3duKSB7IG1vdXNlRG93bi5kb25lKCk7IH1cbiAgaWYgKCFlLmRhdGFUcmFuc2ZlcikgeyByZXR1cm4gfVxuXG4gIHZhciBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgdmFyIHBvcyA9IHNlbC5lbXB0eSA/IG51bGwgOiB2aWV3LnBvc0F0Q29vcmRzKGV2ZW50Q29vcmRzKGUpKTtcbiAgaWYgKHBvcyAmJiBwb3MucG9zID49IHNlbC5mcm9tICYmIHBvcy5wb3MgPD0gKHNlbCBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24gPyBzZWwudG8gLSAxOiBzZWwudG8pKSA7IGVsc2UgaWYgKG1vdXNlRG93biAmJiBtb3VzZURvd24ubWlnaHREcmFnKSB7XG4gICAgdmlldy5kaXNwYXRjaCh2aWV3LnN0YXRlLnRyLnNldFNlbGVjdGlvbihOb2RlU2VsZWN0aW9uLmNyZWF0ZSh2aWV3LnN0YXRlLmRvYywgbW91c2VEb3duLm1pZ2h0RHJhZy5wb3MpKSk7XG4gIH0gZWxzZSBpZiAoZS50YXJnZXQgJiYgZS50YXJnZXQubm9kZVR5cGUgPT0gMSkge1xuICAgIHZhciBkZXNjID0gdmlldy5kb2NWaWV3Lm5lYXJlc3REZXNjKGUudGFyZ2V0LCB0cnVlKTtcbiAgICBpZiAoZGVzYyAmJiBkZXNjLm5vZGUudHlwZS5zcGVjLmRyYWdnYWJsZSAmJiBkZXNjICE9IHZpZXcuZG9jVmlldylcbiAgICAgIHsgdmlldy5kaXNwYXRjaCh2aWV3LnN0YXRlLnRyLnNldFNlbGVjdGlvbihOb2RlU2VsZWN0aW9uLmNyZWF0ZSh2aWV3LnN0YXRlLmRvYywgZGVzYy5wb3NCZWZvcmUpKSk7IH1cbiAgfVxuICB2YXIgc2xpY2UgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi5jb250ZW50KCk7XG4gIHZhciByZWYgPSBzZXJpYWxpemVGb3JDbGlwYm9hcmQodmlldywgc2xpY2UpO1xuICB2YXIgZG9tID0gcmVmLmRvbTtcbiAgdmFyIHRleHQgPSByZWYudGV4dDtcbiAgZS5kYXRhVHJhbnNmZXIuY2xlYXJEYXRhKCk7XG4gIGUuZGF0YVRyYW5zZmVyLnNldERhdGEoYnJva2VuQ2xpcGJvYXJkQVBJID8gXCJUZXh0XCIgOiBcInRleHQvaHRtbFwiLCBkb20uaW5uZXJIVE1MKTtcbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9Qcm9zZU1pcnJvci9wcm9zZW1pcnJvci9pc3N1ZXMvMTE1NlxuICBlLmRhdGFUcmFuc2Zlci5lZmZlY3RBbGxvd2VkID0gXCJjb3B5TW92ZVwiO1xuICBpZiAoIWJyb2tlbkNsaXBib2FyZEFQSSkgeyBlLmRhdGFUcmFuc2Zlci5zZXREYXRhKFwidGV4dC9wbGFpblwiLCB0ZXh0KTsgfVxuICB2aWV3LmRyYWdnaW5nID0gbmV3IERyYWdnaW5nKHNsaWNlLCAhZVtkcmFnQ29weU1vZGlmaWVyXSk7XG59O1xuXG5oYW5kbGVycy5kcmFnZW5kID0gZnVuY3Rpb24gKHZpZXcpIHtcbiAgdmFyIGRyYWdnaW5nID0gdmlldy5kcmFnZ2luZztcbiAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGlmICh2aWV3LmRyYWdnaW5nID09IGRyYWdnaW5nKSAgeyB2aWV3LmRyYWdnaW5nID0gbnVsbDsgfVxuICB9LCA1MCk7XG59O1xuXG5lZGl0SGFuZGxlcnMuZHJhZ292ZXIgPSBlZGl0SGFuZGxlcnMuZHJhZ2VudGVyID0gZnVuY3Rpb24gKF8sIGUpIHsgcmV0dXJuIGUucHJldmVudERlZmF1bHQoKTsgfTtcblxuZWRpdEhhbmRsZXJzLmRyb3AgPSBmdW5jdGlvbiAodmlldywgZSkge1xuICB2YXIgZHJhZ2dpbmcgPSB2aWV3LmRyYWdnaW5nO1xuICB2aWV3LmRyYWdnaW5nID0gbnVsbDtcblxuICBpZiAoIWUuZGF0YVRyYW5zZmVyKSB7IHJldHVybiB9XG5cbiAgdmFyIGV2ZW50UG9zID0gdmlldy5wb3NBdENvb3JkcyhldmVudENvb3JkcyhlKSk7XG4gIGlmICghZXZlbnRQb3MpIHsgcmV0dXJuIH1cbiAgdmFyICRtb3VzZSA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoZXZlbnRQb3MucG9zKTtcbiAgaWYgKCEkbW91c2UpIHsgcmV0dXJuIH1cbiAgdmFyIHNsaWNlID0gZHJhZ2dpbmcgJiYgZHJhZ2dpbmcuc2xpY2U7XG4gIGlmIChzbGljZSkge1xuICAgIHZpZXcuc29tZVByb3AoXCJ0cmFuc2Zvcm1QYXN0ZWRcIiwgZnVuY3Rpb24gKGYpIHsgc2xpY2UgPSBmKHNsaWNlKTsgfSk7XG4gIH0gZWxzZSB7XG4gICAgc2xpY2UgPSBwYXJzZUZyb21DbGlwYm9hcmQodmlldywgZS5kYXRhVHJhbnNmZXIuZ2V0RGF0YShicm9rZW5DbGlwYm9hcmRBUEkgPyBcIlRleHRcIiA6IFwidGV4dC9wbGFpblwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicm9rZW5DbGlwYm9hcmRBUEkgPyBudWxsIDogZS5kYXRhVHJhbnNmZXIuZ2V0RGF0YShcInRleHQvaHRtbFwiKSwgZmFsc2UsICRtb3VzZSk7XG4gIH1cbiAgdmFyIG1vdmUgPSBkcmFnZ2luZyAmJiAhZVtkcmFnQ29weU1vZGlmaWVyXTtcbiAgaWYgKHZpZXcuc29tZVByb3AoXCJoYW5kbGVEcm9wXCIsIGZ1bmN0aW9uIChmKSB7IHJldHVybiBmKHZpZXcsIGUsIHNsaWNlIHx8IFNsaWNlLmVtcHR5LCBtb3ZlKTsgfSkpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKCFzbGljZSkgeyByZXR1cm4gfVxuXG4gIGUucHJldmVudERlZmF1bHQoKTtcbiAgdmFyIGluc2VydFBvcyA9IHNsaWNlID8gZHJvcFBvaW50KHZpZXcuc3RhdGUuZG9jLCAkbW91c2UucG9zLCBzbGljZSkgOiAkbW91c2UucG9zO1xuICBpZiAoaW5zZXJ0UG9zID09IG51bGwpIHsgaW5zZXJ0UG9zID0gJG1vdXNlLnBvczsgfVxuXG4gIHZhciB0ciA9IHZpZXcuc3RhdGUudHI7XG4gIGlmIChtb3ZlKSB7IHRyLmRlbGV0ZVNlbGVjdGlvbigpOyB9XG5cbiAgdmFyIHBvcyA9IHRyLm1hcHBpbmcubWFwKGluc2VydFBvcyk7XG4gIHZhciBpc05vZGUgPSBzbGljZS5vcGVuU3RhcnQgPT0gMCAmJiBzbGljZS5vcGVuRW5kID09IDAgJiYgc2xpY2UuY29udGVudC5jaGlsZENvdW50ID09IDE7XG4gIHZhciBiZWZvcmVJbnNlcnQgPSB0ci5kb2M7XG4gIGlmIChpc05vZGUpXG4gICAgeyB0ci5yZXBsYWNlUmFuZ2VXaXRoKHBvcywgcG9zLCBzbGljZS5jb250ZW50LmZpcnN0Q2hpbGQpOyB9XG4gIGVsc2VcbiAgICB7IHRyLnJlcGxhY2VSYW5nZShwb3MsIHBvcywgc2xpY2UpOyB9XG4gIGlmICh0ci5kb2MuZXEoYmVmb3JlSW5zZXJ0KSkgeyByZXR1cm4gfVxuXG4gIHZhciAkcG9zID0gdHIuZG9jLnJlc29sdmUocG9zKTtcbiAgaWYgKGlzTm9kZSAmJiBOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShzbGljZS5jb250ZW50LmZpcnN0Q2hpbGQpICYmXG4gICAgICAkcG9zLm5vZGVBZnRlciAmJiAkcG9zLm5vZGVBZnRlci5zYW1lTWFya3VwKHNsaWNlLmNvbnRlbnQuZmlyc3RDaGlsZCkpIHtcbiAgICB0ci5zZXRTZWxlY3Rpb24obmV3IE5vZGVTZWxlY3Rpb24oJHBvcykpO1xuICB9IGVsc2Uge1xuICAgIHZhciBlbmQgPSB0ci5tYXBwaW5nLm1hcChpbnNlcnRQb3MpO1xuICAgIHRyLm1hcHBpbmcubWFwc1t0ci5tYXBwaW5nLm1hcHMubGVuZ3RoIC0gMV0uZm9yRWFjaChmdW5jdGlvbiAoX2Zyb20sIF90bywgX25ld0Zyb20sIG5ld1RvKSB7IHJldHVybiBlbmQgPSBuZXdUbzsgfSk7XG4gICAgdHIuc2V0U2VsZWN0aW9uKHNlbGVjdGlvbkJldHdlZW4odmlldywgJHBvcywgdHIuZG9jLnJlc29sdmUoZW5kKSkpO1xuICB9XG4gIHZpZXcuZm9jdXMoKTtcbiAgdmlldy5kaXNwYXRjaCh0ci5zZXRNZXRhKFwidWlFdmVudFwiLCBcImRyb3BcIikpO1xufTtcblxuaGFuZGxlcnMuZm9jdXMgPSBmdW5jdGlvbiAodmlldykge1xuICBpZiAoIXZpZXcuZm9jdXNlZCkge1xuICAgIHZpZXcuZG9tT2JzZXJ2ZXIuc3RvcCgpO1xuICAgIHZpZXcuZG9tLmNsYXNzTGlzdC5hZGQoXCJQcm9zZU1pcnJvci1mb2N1c2VkXCIpO1xuICAgIHZpZXcuZG9tT2JzZXJ2ZXIuc3RhcnQoKTtcbiAgICB2aWV3LmZvY3VzZWQgPSB0cnVlO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHZpZXcuZG9jVmlldyAmJiB2aWV3Lmhhc0ZvY3VzKCkgJiYgIXZpZXcuZG9tT2JzZXJ2ZXIuY3VycmVudFNlbGVjdGlvbi5lcSh2aWV3LnJvb3QuZ2V0U2VsZWN0aW9uKCkpKVxuICAgICAgICB7IHNlbGVjdGlvblRvRE9NKHZpZXcpOyB9XG4gICAgfSwgMjApO1xuICB9XG59O1xuXG5oYW5kbGVycy5ibHVyID0gZnVuY3Rpb24gKHZpZXcsIGUpIHtcbiAgaWYgKHZpZXcuZm9jdXNlZCkge1xuICAgIHZpZXcuZG9tT2JzZXJ2ZXIuc3RvcCgpO1xuICAgIHZpZXcuZG9tLmNsYXNzTGlzdC5yZW1vdmUoXCJQcm9zZU1pcnJvci1mb2N1c2VkXCIpO1xuICAgIHZpZXcuZG9tT2JzZXJ2ZXIuc3RhcnQoKTtcbiAgICBpZiAoZS5yZWxhdGVkVGFyZ2V0ICYmIHZpZXcuZG9tLmNvbnRhaW5zKGUucmVsYXRlZFRhcmdldCkpXG4gICAgICB7IHZpZXcuZG9tT2JzZXJ2ZXIuY3VycmVudFNlbGVjdGlvbi5zZXQoe30pOyB9XG4gICAgdmlldy5mb2N1c2VkID0gZmFsc2U7XG4gIH1cbn07XG5cbmhhbmRsZXJzLmJlZm9yZWlucHV0ID0gZnVuY3Rpb24gKHZpZXcsIGV2ZW50KSB7XG4gIC8vIFdlIHNob3VsZCBwcm9iYWJseSBkbyBtb3JlIHdpdGggYmVmb3JlaW5wdXQgZXZlbnRzLCBidXQgc3VwcG9ydFxuICAvLyBpcyBzbyBzcG90dHkgdGhhdCBJJ20gc3RpbGwgd2FpdGluZyB0byBzZWUgd2hlcmUgdGhleSBhcmUgZ29pbmcuXG5cbiAgLy8gVmVyeSBzcGVjaWZpYyBoYWNrIHRvIGRlYWwgd2l0aCBiYWNrc3BhY2Ugc29tZXRpbWVzIGZhaWxpbmcgb25cbiAgLy8gQ2hyb21lIEFuZHJvaWQgd2hlbiBhZnRlciBhbiB1bmVkaXRhYmxlIG5vZGUuXG4gIGlmIChyZXN1bHQuY2hyb21lICYmIHJlc3VsdC5hbmRyb2lkICYmIGV2ZW50LmlucHV0VHlwZSA9PSBcImRlbGV0ZUNvbnRlbnRCYWNrd2FyZFwiKSB7XG4gICAgdmFyIGRvbUNoYW5nZUNvdW50ID0gdmlldy5kb21DaGFuZ2VDb3VudDtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh2aWV3LmRvbUNoYW5nZUNvdW50ICE9IGRvbUNoYW5nZUNvdW50KSB7IHJldHVybiB9IC8vIEV2ZW50IGFscmVhZHkgaGFkIHNvbWUgZWZmZWN0XG4gICAgICAvLyBUaGlzIGJ1ZyB0ZW5kcyB0byBjbG9zZSB0aGUgdmlydHVhbCBrZXlib2FyZCwgc28gd2UgcmVmb2N1c1xuICAgICAgdmlldy5kb20uYmx1cigpO1xuICAgICAgdmlldy5mb2N1cygpO1xuICAgICAgaWYgKHZpZXcuc29tZVByb3AoXCJoYW5kbGVLZXlEb3duXCIsIGZ1bmN0aW9uIChmKSB7IHJldHVybiBmKHZpZXcsIGtleUV2ZW50KDgsIFwiQmFja3NwYWNlXCIpKTsgfSkpIHsgcmV0dXJuIH1cbiAgICAgIHZhciByZWYgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICAgIHZhciAkY3Vyc29yID0gcmVmLiRjdXJzb3I7XG4gICAgICAvLyBDcnVkZSBhcHByb3hpbWF0aW9uIG9mIGJhY2tzcGFjZSBiZWhhdmlvciB3aGVuIG5vIGNvbW1hbmQgaGFuZGxlZCBpdFxuICAgICAgaWYgKCRjdXJzb3IgJiYgJGN1cnNvci5wb3MgPiAwKSB7IHZpZXcuZGlzcGF0Y2godmlldy5zdGF0ZS50ci5kZWxldGUoJGN1cnNvci5wb3MgLSAxLCAkY3Vyc29yLnBvcykuc2Nyb2xsSW50b1ZpZXcoKSk7IH1cbiAgICB9LCA1MCk7XG4gIH1cbn07XG5cbi8vIE1ha2Ugc3VyZSBhbGwgaGFuZGxlcnMgZ2V0IHJlZ2lzdGVyZWRcbmZvciAodmFyIHByb3AgaW4gZWRpdEhhbmRsZXJzKSB7IGhhbmRsZXJzW3Byb3BdID0gZWRpdEhhbmRsZXJzW3Byb3BdOyB9XG5cbmZ1bmN0aW9uIGNvbXBhcmVPYmpzKGEsIGIpIHtcbiAgaWYgKGEgPT0gYikgeyByZXR1cm4gdHJ1ZSB9XG4gIGZvciAodmFyIHAgaW4gYSkgeyBpZiAoYVtwXSAhPT0gYltwXSkgeyByZXR1cm4gZmFsc2UgfSB9XG4gIGZvciAodmFyIHAkMSBpbiBiKSB7IGlmICghKHAkMSBpbiBhKSkgeyByZXR1cm4gZmFsc2UgfSB9XG4gIHJldHVybiB0cnVlXG59XG5cbnZhciBXaWRnZXRUeXBlID0gZnVuY3Rpb24gV2lkZ2V0VHlwZSh0b0RPTSwgc3BlYykge1xuICB0aGlzLnNwZWMgPSBzcGVjIHx8IG5vU3BlYztcbiAgdGhpcy5zaWRlID0gdGhpcy5zcGVjLnNpZGUgfHwgMDtcbiAgdGhpcy50b0RPTSA9IHRvRE9NO1xufTtcblxuV2lkZ2V0VHlwZS5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gbWFwIChtYXBwaW5nLCBzcGFuLCBvZmZzZXQsIG9sZE9mZnNldCkge1xuICB2YXIgcmVmID0gbWFwcGluZy5tYXBSZXN1bHQoc3Bhbi5mcm9tICsgb2xkT2Zmc2V0LCB0aGlzLnNpZGUgPCAwID8gLTEgOiAxKTtcbiAgICB2YXIgcG9zID0gcmVmLnBvcztcbiAgICB2YXIgZGVsZXRlZCA9IHJlZi5kZWxldGVkO1xuICByZXR1cm4gZGVsZXRlZCA/IG51bGwgOiBuZXcgRGVjb3JhdGlvbihwb3MgLSBvZmZzZXQsIHBvcyAtIG9mZnNldCwgdGhpcylcbn07XG5cbldpZGdldFR5cGUucHJvdG90eXBlLnZhbGlkID0gZnVuY3Rpb24gdmFsaWQgKCkgeyByZXR1cm4gdHJ1ZSB9O1xuXG5XaWRnZXRUeXBlLnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIGVxIChvdGhlcikge1xuICByZXR1cm4gdGhpcyA9PSBvdGhlciB8fFxuICAgIChvdGhlciBpbnN0YW5jZW9mIFdpZGdldFR5cGUgJiZcbiAgICAgKHRoaXMuc3BlYy5rZXkgJiYgdGhpcy5zcGVjLmtleSA9PSBvdGhlci5zcGVjLmtleSB8fFxuICAgICAgdGhpcy50b0RPTSA9PSBvdGhlci50b0RPTSAmJiBjb21wYXJlT2Jqcyh0aGlzLnNwZWMsIG90aGVyLnNwZWMpKSlcbn07XG5cbnZhciBJbmxpbmVUeXBlID0gZnVuY3Rpb24gSW5saW5lVHlwZShhdHRycywgc3BlYykge1xuICB0aGlzLnNwZWMgPSBzcGVjIHx8IG5vU3BlYztcbiAgdGhpcy5hdHRycyA9IGF0dHJzO1xufTtcblxuSW5saW5lVHlwZS5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gbWFwIChtYXBwaW5nLCBzcGFuLCBvZmZzZXQsIG9sZE9mZnNldCkge1xuICB2YXIgZnJvbSA9IG1hcHBpbmcubWFwKHNwYW4uZnJvbSArIG9sZE9mZnNldCwgdGhpcy5zcGVjLmluY2x1c2l2ZVN0YXJ0ID8gLTEgOiAxKSAtIG9mZnNldDtcbiAgdmFyIHRvID0gbWFwcGluZy5tYXAoc3Bhbi50byArIG9sZE9mZnNldCwgdGhpcy5zcGVjLmluY2x1c2l2ZUVuZCA/IDEgOiAtMSkgLSBvZmZzZXQ7XG4gIHJldHVybiBmcm9tID49IHRvID8gbnVsbCA6IG5ldyBEZWNvcmF0aW9uKGZyb20sIHRvLCB0aGlzKVxufTtcblxuSW5saW5lVHlwZS5wcm90b3R5cGUudmFsaWQgPSBmdW5jdGlvbiB2YWxpZCAoXywgc3BhbikgeyByZXR1cm4gc3Bhbi5mcm9tIDwgc3Bhbi50byB9O1xuXG5JbmxpbmVUeXBlLnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIGVxIChvdGhlcikge1xuICByZXR1cm4gdGhpcyA9PSBvdGhlciB8fFxuICAgIChvdGhlciBpbnN0YW5jZW9mIElubGluZVR5cGUgJiYgY29tcGFyZU9ianModGhpcy5hdHRycywgb3RoZXIuYXR0cnMpICYmXG4gICAgIGNvbXBhcmVPYmpzKHRoaXMuc3BlYywgb3RoZXIuc3BlYykpXG59O1xuXG5JbmxpbmVUeXBlLmlzID0gZnVuY3Rpb24gaXMgKHNwYW4pIHsgcmV0dXJuIHNwYW4udHlwZSBpbnN0YW5jZW9mIElubGluZVR5cGUgfTtcblxudmFyIE5vZGVUeXBlID0gZnVuY3Rpb24gTm9kZVR5cGUoYXR0cnMsIHNwZWMpIHtcbiAgdGhpcy5zcGVjID0gc3BlYyB8fCBub1NwZWM7XG4gIHRoaXMuYXR0cnMgPSBhdHRycztcbn07XG5cbk5vZGVUeXBlLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiBtYXAgKG1hcHBpbmcsIHNwYW4sIG9mZnNldCwgb2xkT2Zmc2V0KSB7XG4gIHZhciBmcm9tID0gbWFwcGluZy5tYXBSZXN1bHQoc3Bhbi5mcm9tICsgb2xkT2Zmc2V0LCAxKTtcbiAgaWYgKGZyb20uZGVsZXRlZCkgeyByZXR1cm4gbnVsbCB9XG4gIHZhciB0byA9IG1hcHBpbmcubWFwUmVzdWx0KHNwYW4udG8gKyBvbGRPZmZzZXQsIC0xKTtcbiAgaWYgKHRvLmRlbGV0ZWQgfHwgdG8ucG9zIDw9IGZyb20ucG9zKSB7IHJldHVybiBudWxsIH1cbiAgcmV0dXJuIG5ldyBEZWNvcmF0aW9uKGZyb20ucG9zIC0gb2Zmc2V0LCB0by5wb3MgLSBvZmZzZXQsIHRoaXMpXG59O1xuXG5Ob2RlVHlwZS5wcm90b3R5cGUudmFsaWQgPSBmdW5jdGlvbiB2YWxpZCAobm9kZSwgc3Bhbikge1xuICB2YXIgcmVmID0gbm9kZS5jb250ZW50LmZpbmRJbmRleChzcGFuLmZyb20pO1xuICAgIHZhciBpbmRleCA9IHJlZi5pbmRleDtcbiAgICB2YXIgb2Zmc2V0ID0gcmVmLm9mZnNldDtcbiAgICB2YXIgY2hpbGQ7XG4gIHJldHVybiBvZmZzZXQgPT0gc3Bhbi5mcm9tICYmICEoY2hpbGQgPSBub2RlLmNoaWxkKGluZGV4KSkuaXNUZXh0ICYmIG9mZnNldCArIGNoaWxkLm5vZGVTaXplID09IHNwYW4udG9cbn07XG5cbk5vZGVUeXBlLnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIGVxIChvdGhlcikge1xuICByZXR1cm4gdGhpcyA9PSBvdGhlciB8fFxuICAgIChvdGhlciBpbnN0YW5jZW9mIE5vZGVUeXBlICYmIGNvbXBhcmVPYmpzKHRoaXMuYXR0cnMsIG90aGVyLmF0dHJzKSAmJlxuICAgICBjb21wYXJlT2Jqcyh0aGlzLnNwZWMsIG90aGVyLnNwZWMpKVxufTtcblxuLy8gOjotIERlY29yYXRpb24gb2JqZWN0cyBjYW4gYmUgcHJvdmlkZWQgdG8gdGhlIHZpZXcgdGhyb3VnaCB0aGVcbi8vIFtgZGVjb3JhdGlvbnNgIHByb3BdKCN2aWV3LkVkaXRvclByb3BzLmRlY29yYXRpb25zKS4gVGhleSBjb21lIGluXG4vLyBzZXZlcmFsIHZhcmlhbnRz4oCUc2VlIHRoZSBzdGF0aWMgbWVtYmVycyBvZiB0aGlzIGNsYXNzIGZvciBkZXRhaWxzLlxudmFyIERlY29yYXRpb24gPSBmdW5jdGlvbiBEZWNvcmF0aW9uKGZyb20sIHRvLCB0eXBlKSB7XG4gIC8vIDo6IG51bWJlclxuICAvLyBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIGRlY29yYXRpb24uXG4gIHRoaXMuZnJvbSA9IGZyb207XG4gIC8vIDo6IG51bWJlclxuICAvLyBUaGUgZW5kIHBvc2l0aW9uLiBXaWxsIGJlIHRoZSBzYW1lIGFzIGBmcm9tYCBmb3IgW3dpZGdldFxuICAvLyBkZWNvcmF0aW9uc10oI3ZpZXcuRGVjb3JhdGlvbl53aWRnZXQpLlxuICB0aGlzLnRvID0gdG87XG4gIHRoaXMudHlwZSA9IHR5cGU7XG59O1xuXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzJDEgPSB7IHNwZWM6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0saW5saW5lOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbkRlY29yYXRpb24ucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5IChmcm9tLCB0bykge1xuICByZXR1cm4gbmV3IERlY29yYXRpb24oZnJvbSwgdG8sIHRoaXMudHlwZSlcbn07XG5cbkRlY29yYXRpb24ucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gZXEgKG90aGVyLCBvZmZzZXQpIHtcbiAgICBpZiAoIG9mZnNldCA9PT0gdm9pZCAwICkgb2Zmc2V0ID0gMDtcblxuICByZXR1cm4gdGhpcy50eXBlLmVxKG90aGVyLnR5cGUpICYmIHRoaXMuZnJvbSArIG9mZnNldCA9PSBvdGhlci5mcm9tICYmIHRoaXMudG8gKyBvZmZzZXQgPT0gb3RoZXIudG9cbn07XG5cbkRlY29yYXRpb24ucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIG1hcCAobWFwcGluZywgb2Zmc2V0LCBvbGRPZmZzZXQpIHtcbiAgcmV0dXJuIHRoaXMudHlwZS5tYXAobWFwcGluZywgdGhpcywgb2Zmc2V0LCBvbGRPZmZzZXQpXG59O1xuXG4vLyA6OiAobnVtYmVyLCB1bmlvbjwodmlldzogRWRpdG9yVmlldywgZ2V0UG9zOiAoKSDihpIgbnVtYmVyKSDihpIgZG9tLk5vZGUsIGRvbS5Ob2RlPiwgP09iamVjdCkg4oaSIERlY29yYXRpb25cbi8vIENyZWF0ZXMgYSB3aWRnZXQgZGVjb3JhdGlvbiwgd2hpY2ggaXMgYSBET00gbm9kZSB0aGF0J3Mgc2hvd24gaW5cbi8vIHRoZSBkb2N1bWVudCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uIEl0IGlzIHJlY29tbWVuZGVkIHRoYXQgeW91XG4vLyBkZWxheSByZW5kZXJpbmcgdGhlIHdpZGdldCBieSBwYXNzaW5nIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlXG4vLyBjYWxsZWQgd2hlbiB0aGUgd2lkZ2V0IGlzIGFjdHVhbGx5IGRyYXduIGluIGEgdmlldywgYnV0IHlvdSBjYW5cbi8vIGFsc28gZGlyZWN0bHkgcGFzcyBhIERPTSBub2RlLiBgZ2V0UG9zYCBjYW4gYmUgdXNlZCB0byBmaW5kIHRoZVxuLy8gd2lkZ2V0J3MgY3VycmVudCBkb2N1bWVudCBwb3NpdGlvbi5cbi8vXG4vLyBzcGVjOjotIFRoZXNlIG9wdGlvbnMgYXJlIHN1cHBvcnRlZDpcbi8vXG4vLyAgIHNpZGU6OiA/bnVtYmVyXG4vLyAgIENvbnRyb2xzIHdoaWNoIHNpZGUgb2YgdGhlIGRvY3VtZW50IHBvc2l0aW9uIHRoaXMgd2lkZ2V0IGlzXG4vLyAgIGFzc29jaWF0ZWQgd2l0aC4gV2hlbiBuZWdhdGl2ZSwgaXQgaXMgZHJhd24gYmVmb3JlIGEgY3Vyc29yXG4vLyAgIGF0IGl0cyBwb3NpdGlvbiwgYW5kIGNvbnRlbnQgaW5zZXJ0ZWQgYXQgdGhhdCBwb3NpdGlvbiBlbmRzXG4vLyAgIHVwIGFmdGVyIHRoZSB3aWRnZXQuIFdoZW4gemVybyAodGhlIGRlZmF1bHQpIG9yIHBvc2l0aXZlLCB0aGVcbi8vICAgd2lkZ2V0IGlzIGRyYXduIGFmdGVyIHRoZSBjdXJzb3IgYW5kIGNvbnRlbnQgaW5zZXJ0ZWQgdGhlcmVcbi8vICAgZW5kcyB1cCBiZWZvcmUgdGhlIHdpZGdldC5cbi8vXG4vLyAgIFdoZW4gdGhlcmUgYXJlIG11bHRpcGxlIHdpZGdldHMgYXQgYSBnaXZlbiBwb3NpdGlvbiwgdGhlaXJcbi8vICAgYHNpZGVgIHZhbHVlcyBkZXRlcm1pbmUgdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgYXBwZWFyLiBUaG9zZVxuLy8gICB3aXRoIGxvd2VyIHZhbHVlcyBhcHBlYXIgZmlyc3QuIFRoZSBvcmRlcmluZyBvZiB3aWRnZXRzIHdpdGhcbi8vICAgdGhlIHNhbWUgYHNpZGVgIHZhbHVlIGlzIHVuc3BlY2lmaWVkLlxuLy9cbi8vICAgV2hlbiBgbWFya3NgIGlzIG51bGwsIGBzaWRlYCBhbHNvIGRldGVybWluZXMgdGhlIG1hcmtzIHRoYXRcbi8vICAgdGhlIHdpZGdldCBpcyB3cmFwcGVkIGlu4oCUdGhvc2Ugb2YgdGhlIG5vZGUgYmVmb3JlIHdoZW5cbi8vICAgbmVnYXRpdmUsIHRob3NlIG9mIHRoZSBub2RlIGFmdGVyIHdoZW4gcG9zaXRpdmUuXG4vL1xuLy8gICBtYXJrczo6ID9bTWFya11cbi8vICAgVGhlIHByZWNpc2Ugc2V0IG9mIG1hcmtzIHRvIGRyYXcgYXJvdW5kIHRoZSB3aWRnZXQuXG4vL1xuLy8gICBzdG9wRXZlbnQ6OiA/KGV2ZW50OiBkb20uRXZlbnQpIOKGkiBib29sXG4vLyAgIENhbiBiZSB1c2VkIHRvIGNvbnRyb2wgd2hpY2ggRE9NIGV2ZW50cywgd2hlbiB0aGV5IGJ1YmJsZSBvdXRcbi8vICAgb2YgdGhpcyB3aWRnZXQsIHRoZSBlZGl0b3IgdmlldyBzaG91bGQgaWdub3JlLlxuLy9cbi8vICAgaWdub3JlU2VsZWN0aW9uOjogP2Jvb2xcbi8vICAgV2hlbiBzZXQgKGRlZmF1bHRzIHRvIGZhbHNlKSwgc2VsZWN0aW9uIGNoYW5nZXMgaW5zaWRlIHRoZVxuLy8gICB3aWRnZXQgYXJlIGlnbm9yZWQsIGFuZCBkb24ndCBjYXVzZSBQcm9zZU1pcnJvciB0byB0cnkgYW5kXG4vLyAgIHJlLXN5bmMgdGhlIHNlbGVjdGlvbiB3aXRoIGl0cyBzZWxlY3Rpb24gc3RhdGUuXG4vL1xuLy8gICBrZXk6OiA/c3RyaW5nXG4vLyAgIFdoZW4gY29tcGFyaW5nIGRlY29yYXRpb25zIG9mIHRoaXMgdHlwZSAoaW4gb3JkZXIgdG8gZGVjaWRlXG4vLyAgIHdoZXRoZXIgaXQgbmVlZHMgdG8gYmUgcmVkcmF3biksIFByb3NlTWlycm9yIHdpbGwgYnkgZGVmYXVsdFxuLy8gICBjb21wYXJlIHRoZSB3aWRnZXQgRE9NIG5vZGUgYnkgaWRlbnRpdHkuIElmIHlvdSBwYXNzIGEga2V5LFxuLy8gICB0aGF0IGtleSB3aWxsIGJlIGNvbXBhcmVkIGluc3RlYWQsIHdoaWNoIGNhbiBiZSB1c2VmdWwgd2hlblxuLy8gICB5b3UgZ2VuZXJhdGUgZGVjb3JhdGlvbnMgb24gdGhlIGZseSBhbmQgZG9uJ3Qgd2FudCB0byBzdG9yZVxuLy8gICBhbmQgcmV1c2UgRE9NIG5vZGVzLiBNYWtlIHN1cmUgdGhhdCBhbnkgd2lkZ2V0cyB3aXRoIHRoZSBzYW1lXG4vLyAgIGtleSBhcmUgaW50ZXJjaGFuZ2VhYmxl4oCUaWYgd2lkZ2V0cyBkaWZmZXIgaW4sIGZvciBleGFtcGxlLFxuLy8gICB0aGUgYmVoYXZpb3Igb2Ygc29tZSBldmVudCBoYW5kbGVyLCB0aGV5IHNob3VsZCBnZXRcbi8vICAgZGlmZmVyZW50IGtleXMuXG5EZWNvcmF0aW9uLndpZGdldCA9IGZ1bmN0aW9uIHdpZGdldCAocG9zLCB0b0RPTSwgc3BlYykge1xuICByZXR1cm4gbmV3IERlY29yYXRpb24ocG9zLCBwb3MsIG5ldyBXaWRnZXRUeXBlKHRvRE9NLCBzcGVjKSlcbn07XG5cbi8vIDo6IChudW1iZXIsIG51bWJlciwgRGVjb3JhdGlvbkF0dHJzLCA/T2JqZWN0KSDihpIgRGVjb3JhdGlvblxuLy8gQ3JlYXRlcyBhbiBpbmxpbmUgZGVjb3JhdGlvbiwgd2hpY2ggYWRkcyB0aGUgZ2l2ZW4gYXR0cmlidXRlcyB0b1xuLy8gZWFjaCBpbmxpbmUgbm9kZSBiZXR3ZWVuIGBmcm9tYCBhbmQgYHRvYC5cbi8vXG4vLyBzcGVjOjotIFRoZXNlIG9wdGlvbnMgYXJlIHJlY29nbml6ZWQ6XG4vL1xuLy8gICBpbmNsdXNpdmVTdGFydDo6ID9ib29sXG4vLyAgIERldGVybWluZXMgaG93IHRoZSBsZWZ0IHNpZGUgb2YgdGhlIGRlY29yYXRpb24gaXNcbi8vICAgW21hcHBlZF0oI3RyYW5zZm9ybS5Qb3NpdGlvbl9NYXBwaW5nKSB3aGVuIGNvbnRlbnQgaXNcbi8vICAgaW5zZXJ0ZWQgZGlyZWN0bHkgYXQgdGhhdCBwb3NpdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGRlY29yYXRpb25cbi8vICAgd29uJ3QgaW5jbHVkZSB0aGUgbmV3IGNvbnRlbnQsIGJ1dCB5b3UgY2FuIHNldCB0aGlzIHRvIGB0cnVlYFxuLy8gICB0byBtYWtlIGl0IGluY2x1c2l2ZS5cbi8vXG4vLyAgIGluY2x1c2l2ZUVuZDo6ID9ib29sXG4vLyAgIERldGVybWluZXMgaG93IHRoZSByaWdodCBzaWRlIG9mIHRoZSBkZWNvcmF0aW9uIGlzIG1hcHBlZC5cbi8vICAgU2VlXG4vLyAgIFtgaW5jbHVzaXZlU3RhcnRgXSgjdmlldy5EZWNvcmF0aW9uXmlubGluZV5zcGVjLmluY2x1c2l2ZVN0YXJ0KS5cbkRlY29yYXRpb24uaW5saW5lID0gZnVuY3Rpb24gaW5saW5lIChmcm9tLCB0bywgYXR0cnMsIHNwZWMpIHtcbiAgcmV0dXJuIG5ldyBEZWNvcmF0aW9uKGZyb20sIHRvLCBuZXcgSW5saW5lVHlwZShhdHRycywgc3BlYykpXG59O1xuXG4vLyA6OiAobnVtYmVyLCBudW1iZXIsIERlY29yYXRpb25BdHRycywgP09iamVjdCkg4oaSIERlY29yYXRpb25cbi8vIENyZWF0ZXMgYSBub2RlIGRlY29yYXRpb24uIGBmcm9tYCBhbmQgYHRvYCBzaG91bGQgcG9pbnQgcHJlY2lzZWx5XG4vLyBiZWZvcmUgYW5kIGFmdGVyIGEgbm9kZSBpbiB0aGUgZG9jdW1lbnQuIFRoYXQgbm9kZSwgYW5kIG9ubHkgdGhhdFxuLy8gbm9kZSwgd2lsbCByZWNlaXZlIHRoZSBnaXZlbiBhdHRyaWJ1dGVzLlxuLy9cbi8vIHNwZWM6Oi1cbi8vXG4vLyBPcHRpb25hbCBpbmZvcm1hdGlvbiB0byBzdG9yZSB3aXRoIHRoZSBkZWNvcmF0aW9uLiBJdFxuLy8gaXMgYWxzbyB1c2VkIHdoZW4gY29tcGFyaW5nIGRlY29yYXRvcnMgZm9yIGVxdWFsaXR5LlxuRGVjb3JhdGlvbi5ub2RlID0gZnVuY3Rpb24gbm9kZSAoZnJvbSwgdG8sIGF0dHJzLCBzcGVjKSB7XG4gIHJldHVybiBuZXcgRGVjb3JhdGlvbihmcm9tLCB0bywgbmV3IE5vZGVUeXBlKGF0dHJzLCBzcGVjKSlcbn07XG5cbi8vIDo6IE9iamVjdFxuLy8gVGhlIHNwZWMgcHJvdmlkZWQgd2hlbiBjcmVhdGluZyB0aGlzIGRlY29yYXRpb24uIENhbiBiZSB1c2VmdWxcbi8vIGlmIHlvdSd2ZSBzdG9yZWQgZXh0cmEgaW5mb3JtYXRpb24gaW4gdGhhdCBvYmplY3QuXG5wcm90b3R5cGVBY2Nlc3NvcnMkMS5zcGVjLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudHlwZS5zcGVjIH07XG5cbnByb3RvdHlwZUFjY2Vzc29ycyQxLmlubGluZS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnR5cGUgaW5zdGFuY2VvZiBJbmxpbmVUeXBlIH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBEZWNvcmF0aW9uLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzJDEgKTtcblxuLy8gRGVjb3JhdGlvbkF0dHJzOjogaW50ZXJmYWNlXG4vLyBBIHNldCBvZiBhdHRyaWJ1dGVzIHRvIGFkZCB0byBhIGRlY29yYXRlZCBub2RlLiBNb3N0IHByb3BlcnRpZXNcbi8vIHNpbXBseSBkaXJlY3RseSBjb3JyZXNwb25kIHRvIERPTSBhdHRyaWJ1dGVzIG9mIHRoZSBzYW1lIG5hbWUsXG4vLyB3aGljaCB3aWxsIGJlIHNldCB0byB0aGUgcHJvcGVydHkncyB2YWx1ZS4gVGhlc2UgYXJlIGV4Y2VwdGlvbnM6XG4vL1xuLy8gICBjbGFzczo6ID9zdHJpbmdcbi8vICAgQSBDU1MgY2xhc3MgbmFtZSBvciBhIHNwYWNlLXNlcGFyYXRlZCBzZXQgb2YgY2xhc3MgbmFtZXMgdG8gYmVcbi8vICAgX2FkZGVkXyB0byB0aGUgY2xhc3NlcyB0aGF0IHRoZSBub2RlIGFscmVhZHkgaGFkLlxuLy9cbi8vICAgc3R5bGU6OiA/c3RyaW5nXG4vLyAgIEEgc3RyaW5nIG9mIENTUyB0byBiZSBfYWRkZWRfIHRvIHRoZSBub2RlJ3MgZXhpc3RpbmcgYHN0eWxlYCBwcm9wZXJ0eS5cbi8vXG4vLyAgIG5vZGVOYW1lOjogP3N0cmluZ1xuLy8gICBXaGVuIG5vbi1udWxsLCB0aGUgdGFyZ2V0IG5vZGUgaXMgd3JhcHBlZCBpbiBhIERPTSBlbGVtZW50IG9mXG4vLyAgIHRoaXMgdHlwZSAoYW5kIHRoZSBvdGhlciBhdHRyaWJ1dGVzIGFyZSBhcHBsaWVkIHRvIHRoaXMgZWxlbWVudCkuXG5cbnZhciBub25lID0gW10sIG5vU3BlYyA9IHt9O1xuXG4vLyA6OiBjbGFzcyBleHRlbmRzIERlY29yYXRpb25Tb3VyY2Vcbi8vIEEgY29sbGVjdGlvbiBvZiBbZGVjb3JhdGlvbnNdKCN2aWV3LkRlY29yYXRpb24pLCBvcmdhbml6ZWQgaW5cbi8vIHN1Y2ggYSB3YXkgdGhhdCB0aGUgZHJhd2luZyBhbGdvcml0aG0gY2FuIGVmZmljaWVudGx5IHVzZSBhbmRcbi8vIGNvbXBhcmUgdGhlbS4gVGhpcyBpcyBhIHBlcnNpc3RlbnQgZGF0YSBzdHJ1Y3R1cmXigJRpdCBpcyBub3Rcbi8vIG1vZGlmaWVkLCB1cGRhdGVzIGNyZWF0ZSBhIG5ldyB2YWx1ZS5cbnZhciBEZWNvcmF0aW9uU2V0ID0gZnVuY3Rpb24gRGVjb3JhdGlvblNldChsb2NhbCwgY2hpbGRyZW4pIHtcbiAgdGhpcy5sb2NhbCA9IGxvY2FsICYmIGxvY2FsLmxlbmd0aCA/IGxvY2FsIDogbm9uZTtcbiAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCA/IGNoaWxkcmVuIDogbm9uZTtcbn07XG5cbi8vIDo6IChOb2RlLCBbRGVjb3JhdGlvbl0pIOKGkiBEZWNvcmF0aW9uU2V0XG4vLyBDcmVhdGUgYSBzZXQgb2YgZGVjb3JhdGlvbnMsIHVzaW5nIHRoZSBzdHJ1Y3R1cmUgb2YgdGhlIGdpdmVuXG4vLyBkb2N1bWVudC5cbkRlY29yYXRpb25TZXQuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlIChkb2MsIGRlY29yYXRpb25zKSB7XG4gIHJldHVybiBkZWNvcmF0aW9ucy5sZW5ndGggPyBidWlsZFRyZWUoZGVjb3JhdGlvbnMsIGRvYywgMCwgbm9TcGVjKSA6IGVtcHR5XG59O1xuXG4vLyA6OiAoP251bWJlciwgP251bWJlciwgPyhzcGVjOiBPYmplY3QpIOKGkiBib29sKSDihpIgW0RlY29yYXRpb25dXG4vLyBGaW5kIGFsbCBkZWNvcmF0aW9ucyBpbiB0aGlzIHNldCB3aGljaCB0b3VjaCB0aGUgZ2l2ZW4gcmFuZ2Vcbi8vIChpbmNsdWRpbmcgZGVjb3JhdGlvbnMgdGhhdCBzdGFydCBvciBlbmQgZGlyZWN0bHkgYXQgdGhlXG4vLyBib3VuZGFyaWVzKSBhbmQgbWF0Y2ggdGhlIGdpdmVuIHByZWRpY2F0ZSBvbiB0aGVpciBzcGVjLiBXaGVuXG4vLyBgc3RhcnRgIGFuZCBgZW5kYCBhcmUgb21pdHRlZCwgYWxsIGRlY29yYXRpb25zIGluIHRoZSBzZXQgYXJlXG4vLyBjb25zaWRlcmVkLiBXaGVuIGBwcmVkaWNhdGVgIGlzbid0IGdpdmVuLCBhbGwgZGVjb3JhdGlvbnMgYXJlXG4vLyBhc3N1bWVkIHRvIG1hdGNoLlxuRGVjb3JhdGlvblNldC5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIGZpbmQgKHN0YXJ0LCBlbmQsIHByZWRpY2F0ZSkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHRoaXMuZmluZElubmVyKHN0YXJ0ID09IG51bGwgPyAwIDogc3RhcnQsIGVuZCA9PSBudWxsID8gMWU5IDogZW5kLCByZXN1bHQsIDAsIHByZWRpY2F0ZSk7XG4gIHJldHVybiByZXN1bHRcbn07XG5cbkRlY29yYXRpb25TZXQucHJvdG90eXBlLmZpbmRJbm5lciA9IGZ1bmN0aW9uIGZpbmRJbm5lciAoc3RhcnQsIGVuZCwgcmVzdWx0LCBvZmZzZXQsIHByZWRpY2F0ZSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubG9jYWwubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc3BhbiA9IHRoaXMubG9jYWxbaV07XG4gICAgaWYgKHNwYW4uZnJvbSA8PSBlbmQgJiYgc3Bhbi50byA+PSBzdGFydCAmJiAoIXByZWRpY2F0ZSB8fCBwcmVkaWNhdGUoc3Bhbi5zcGVjKSkpXG4gICAgICB7IHJlc3VsdC5wdXNoKHNwYW4uY29weShzcGFuLmZyb20gKyBvZmZzZXQsIHNwYW4udG8gKyBvZmZzZXQpKTsgfVxuICB9XG4gIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpJDEgKz0gMykge1xuICAgIGlmICh0aGlzLmNoaWxkcmVuW2kkMV0gPCBlbmQgJiYgdGhpcy5jaGlsZHJlbltpJDEgKyAxXSA+IHN0YXJ0KSB7XG4gICAgICB2YXIgY2hpbGRPZmYgPSB0aGlzLmNoaWxkcmVuW2kkMV0gKyAxO1xuICAgICAgdGhpcy5jaGlsZHJlbltpJDEgKyAyXS5maW5kSW5uZXIoc3RhcnQgLSBjaGlsZE9mZiwgZW5kIC0gY2hpbGRPZmYsIHJlc3VsdCwgb2Zmc2V0ICsgY2hpbGRPZmYsIHByZWRpY2F0ZSk7XG4gICAgfVxuICB9XG59O1xuXG4vLyA6OiAoTWFwcGluZywgTm9kZSwgP09iamVjdCkg4oaSIERlY29yYXRpb25TZXRcbi8vIE1hcCB0aGUgc2V0IG9mIGRlY29yYXRpb25zIGluIHJlc3BvbnNlIHRvIGEgY2hhbmdlIGluIHRoZVxuLy8gZG9jdW1lbnQuXG4vL1xuLy8gb3B0aW9uczo6LSBBbiBvcHRpb25hbCBzZXQgb2Ygb3B0aW9ucy5cbi8vXG4vLyAgIG9uUmVtb3ZlOjogPyhkZWNvcmF0aW9uU3BlYzogT2JqZWN0KVxuLy8gICBXaGVuIGdpdmVuLCB0aGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoIGRlY29yYXRpb25cbi8vICAgdGhhdCBnZXRzIGRyb3BwZWQgYXMgYSByZXN1bHQgb2YgdGhlIG1hcHBpbmcsIHBhc3NpbmcgdGhlXG4vLyAgIHNwZWMgb2YgdGhhdCBkZWNvcmF0aW9uLlxuRGVjb3JhdGlvblNldC5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gbWFwIChtYXBwaW5nLCBkb2MsIG9wdGlvbnMpIHtcbiAgaWYgKHRoaXMgPT0gZW1wdHkgfHwgbWFwcGluZy5tYXBzLmxlbmd0aCA9PSAwKSB7IHJldHVybiB0aGlzIH1cbiAgcmV0dXJuIHRoaXMubWFwSW5uZXIobWFwcGluZywgZG9jLCAwLCAwLCBvcHRpb25zIHx8IG5vU3BlYylcbn07XG5cbkRlY29yYXRpb25TZXQucHJvdG90eXBlLm1hcElubmVyID0gZnVuY3Rpb24gbWFwSW5uZXIgKG1hcHBpbmcsIG5vZGUsIG9mZnNldCwgb2xkT2Zmc2V0LCBvcHRpb25zKSB7XG4gIHZhciBuZXdMb2NhbDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxvY2FsLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG1hcHBlZCA9IHRoaXMubG9jYWxbaV0ubWFwKG1hcHBpbmcsIG9mZnNldCwgb2xkT2Zmc2V0KTtcbiAgICBpZiAobWFwcGVkICYmIG1hcHBlZC50eXBlLnZhbGlkKG5vZGUsIG1hcHBlZCkpIHsgKG5ld0xvY2FsIHx8IChuZXdMb2NhbCA9IFtdKSkucHVzaChtYXBwZWQpOyB9XG4gICAgZWxzZSBpZiAob3B0aW9ucy5vblJlbW92ZSkgeyBvcHRpb25zLm9uUmVtb3ZlKHRoaXMubG9jYWxbaV0uc3BlYyk7IH1cbiAgfVxuXG4gIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aClcbiAgICB7IHJldHVybiBtYXBDaGlsZHJlbih0aGlzLmNoaWxkcmVuLCBuZXdMb2NhbCwgbWFwcGluZywgbm9kZSwgb2Zmc2V0LCBvbGRPZmZzZXQsIG9wdGlvbnMpIH1cbiAgZWxzZVxuICAgIHsgcmV0dXJuIG5ld0xvY2FsID8gbmV3IERlY29yYXRpb25TZXQobmV3TG9jYWwuc29ydChieVBvcykpIDogZW1wdHkgfVxufTtcblxuLy8gOjogKE5vZGUsIFtEZWNvcmF0aW9uXSkg4oaSIERlY29yYXRpb25TZXRcbi8vIEFkZCB0aGUgZ2l2ZW4gYXJyYXkgb2YgZGVjb3JhdGlvbnMgdG8gdGhlIG9uZXMgaW4gdGhlIHNldCxcbi8vIHByb2R1Y2luZyBhIG5ldyBzZXQuIE5lZWRzIGFjY2VzcyB0byB0aGUgY3VycmVudCBkb2N1bWVudCB0b1xuLy8gY3JlYXRlIHRoZSBhcHByb3ByaWF0ZSB0cmVlIHN0cnVjdHVyZS5cbkRlY29yYXRpb25TZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoZG9jLCBkZWNvcmF0aW9ucykge1xuICBpZiAoIWRlY29yYXRpb25zLmxlbmd0aCkgeyByZXR1cm4gdGhpcyB9XG4gIGlmICh0aGlzID09IGVtcHR5KSB7IHJldHVybiBEZWNvcmF0aW9uU2V0LmNyZWF0ZShkb2MsIGRlY29yYXRpb25zKSB9XG4gIHJldHVybiB0aGlzLmFkZElubmVyKGRvYywgZGVjb3JhdGlvbnMsIDApXG59O1xuXG5EZWNvcmF0aW9uU2V0LnByb3RvdHlwZS5hZGRJbm5lciA9IGZ1bmN0aW9uIGFkZElubmVyIChkb2MsIGRlY29yYXRpb25zLCBvZmZzZXQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgY2hpbGRyZW4sIGNoaWxkSW5kZXggPSAwO1xuICBkb2MuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGROb2RlLCBjaGlsZE9mZnNldCkge1xuICAgIHZhciBiYXNlT2Zmc2V0ID0gY2hpbGRPZmZzZXQgKyBvZmZzZXQsIGZvdW5kO1xuICAgIGlmICghKGZvdW5kID0gdGFrZVNwYW5zRm9yTm9kZShkZWNvcmF0aW9ucywgY2hpbGROb2RlLCBiYXNlT2Zmc2V0KSkpIHsgcmV0dXJuIH1cblxuICAgIGlmICghY2hpbGRyZW4pIHsgY2hpbGRyZW4gPSB0aGlzJDEuY2hpbGRyZW4uc2xpY2UoKTsgfVxuICAgIHdoaWxlIChjaGlsZEluZGV4IDwgY2hpbGRyZW4ubGVuZ3RoICYmIGNoaWxkcmVuW2NoaWxkSW5kZXhdIDwgY2hpbGRPZmZzZXQpIHsgY2hpbGRJbmRleCArPSAzOyB9XG4gICAgaWYgKGNoaWxkcmVuW2NoaWxkSW5kZXhdID09IGNoaWxkT2Zmc2V0KVxuICAgICAgeyBjaGlsZHJlbltjaGlsZEluZGV4ICsgMl0gPSBjaGlsZHJlbltjaGlsZEluZGV4ICsgMl0uYWRkSW5uZXIoY2hpbGROb2RlLCBmb3VuZCwgYmFzZU9mZnNldCArIDEpOyB9XG4gICAgZWxzZVxuICAgICAgeyBjaGlsZHJlbi5zcGxpY2UoY2hpbGRJbmRleCwgMCwgY2hpbGRPZmZzZXQsIGNoaWxkT2Zmc2V0ICsgY2hpbGROb2RlLm5vZGVTaXplLCBidWlsZFRyZWUoZm91bmQsIGNoaWxkTm9kZSwgYmFzZU9mZnNldCArIDEsIG5vU3BlYykpOyB9XG4gICAgY2hpbGRJbmRleCArPSAzO1xuICB9KTtcblxuICB2YXIgbG9jYWwgPSBtb3ZlU3BhbnMoY2hpbGRJbmRleCA/IHdpdGhvdXROdWxscyhkZWNvcmF0aW9ucykgOiBkZWNvcmF0aW9ucywgLW9mZnNldCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbG9jYWwubGVuZ3RoOyBpKyspIHsgaWYgKCFsb2NhbFtpXS50eXBlLnZhbGlkKGRvYywgbG9jYWxbaV0pKSB7IGxvY2FsLnNwbGljZShpLS0sIDEpOyB9IH1cblxuICByZXR1cm4gbmV3IERlY29yYXRpb25TZXQobG9jYWwubGVuZ3RoID8gdGhpcy5sb2NhbC5jb25jYXQobG9jYWwpLnNvcnQoYnlQb3MpIDogdGhpcy5sb2NhbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuIHx8IHRoaXMuY2hpbGRyZW4pXG59O1xuXG4vLyA6OiAoW0RlY29yYXRpb25dKSDihpIgRGVjb3JhdGlvblNldFxuLy8gQ3JlYXRlIGEgbmV3IHNldCB0aGF0IGNvbnRhaW5zIHRoZSBkZWNvcmF0aW9ucyBpbiB0aGlzIHNldCwgbWludXNcbi8vIHRoZSBvbmVzIGluIHRoZSBnaXZlbiBhcnJheS5cbkRlY29yYXRpb25TZXQucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSAoZGVjb3JhdGlvbnMpIHtcbiAgaWYgKGRlY29yYXRpb25zLmxlbmd0aCA9PSAwIHx8IHRoaXMgPT0gZW1wdHkpIHsgcmV0dXJuIHRoaXMgfVxuICByZXR1cm4gdGhpcy5yZW1vdmVJbm5lcihkZWNvcmF0aW9ucywgMClcbn07XG5cbkRlY29yYXRpb25TZXQucHJvdG90eXBlLnJlbW92ZUlubmVyID0gZnVuY3Rpb24gcmVtb3ZlSW5uZXIgKGRlY29yYXRpb25zLCBvZmZzZXQpIHtcbiAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbiwgbG9jYWwgPSB0aGlzLmxvY2FsO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgdmFyIGZvdW5kID0gKHZvaWQgMCksIGZyb20gPSBjaGlsZHJlbltpXSArIG9mZnNldCwgdG8gPSBjaGlsZHJlbltpICsgMV0gKyBvZmZzZXQ7XG4gICAgZm9yICh2YXIgaiA9IDAsIHNwYW4gPSAodm9pZCAwKTsgaiA8IGRlY29yYXRpb25zLmxlbmd0aDsgaisrKSB7IGlmIChzcGFuID0gZGVjb3JhdGlvbnNbal0pIHtcbiAgICAgIGlmIChzcGFuLmZyb20gPiBmcm9tICYmIHNwYW4udG8gPCB0bykge1xuICAgICAgICBkZWNvcmF0aW9uc1tqXSA9IG51bGxcbiAgICAgICAgOyhmb3VuZCB8fCAoZm91bmQgPSBbXSkpLnB1c2goc3Bhbik7XG4gICAgICB9XG4gICAgfSB9XG4gICAgaWYgKCFmb3VuZCkgeyBjb250aW51ZSB9XG4gICAgaWYgKGNoaWxkcmVuID09IHRoaXMuY2hpbGRyZW4pIHsgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLnNsaWNlKCk7IH1cbiAgICB2YXIgcmVtb3ZlZCA9IGNoaWxkcmVuW2kgKyAyXS5yZW1vdmVJbm5lcihmb3VuZCwgZnJvbSArIDEpO1xuICAgIGlmIChyZW1vdmVkICE9IGVtcHR5KSB7XG4gICAgICBjaGlsZHJlbltpICsgMl0gPSByZW1vdmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGlsZHJlbi5zcGxpY2UoaSwgMyk7XG4gICAgICBpIC09IDM7XG4gICAgfVxuICB9XG4gIGlmIChsb2NhbC5sZW5ndGgpIHsgZm9yICh2YXIgaSQxID0gMCwgc3BhbiQxID0gKHZvaWQgMCk7IGkkMSA8IGRlY29yYXRpb25zLmxlbmd0aDsgaSQxKyspIHsgaWYgKHNwYW4kMSA9IGRlY29yYXRpb25zW2kkMV0pIHtcbiAgICBmb3IgKHZhciBqJDEgPSAwOyBqJDEgPCBsb2NhbC5sZW5ndGg7IGokMSsrKSB7IGlmIChsb2NhbFtqJDFdLmVxKHNwYW4kMSwgb2Zmc2V0KSkge1xuICAgICAgaWYgKGxvY2FsID09IHRoaXMubG9jYWwpIHsgbG9jYWwgPSB0aGlzLmxvY2FsLnNsaWNlKCk7IH1cbiAgICAgIGxvY2FsLnNwbGljZShqJDEtLSwgMSk7XG4gICAgfSB9XG4gIH0gfSB9XG4gIGlmIChjaGlsZHJlbiA9PSB0aGlzLmNoaWxkcmVuICYmIGxvY2FsID09IHRoaXMubG9jYWwpIHsgcmV0dXJuIHRoaXMgfVxuICByZXR1cm4gbG9jYWwubGVuZ3RoIHx8IGNoaWxkcmVuLmxlbmd0aCA/IG5ldyBEZWNvcmF0aW9uU2V0KGxvY2FsLCBjaGlsZHJlbikgOiBlbXB0eVxufTtcblxuRGVjb3JhdGlvblNldC5wcm90b3R5cGUuZm9yQ2hpbGQgPSBmdW5jdGlvbiBmb3JDaGlsZCAob2Zmc2V0LCBub2RlKSB7XG4gIGlmICh0aGlzID09IGVtcHR5KSB7IHJldHVybiB0aGlzIH1cbiAgaWYgKG5vZGUuaXNMZWFmKSB7IHJldHVybiBEZWNvcmF0aW9uU2V0LmVtcHR5IH1cblxuICB2YXIgY2hpbGQsIGxvY2FsO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDMpIHsgaWYgKHRoaXMuY2hpbGRyZW5baV0gPj0gb2Zmc2V0KSB7XG4gICAgaWYgKHRoaXMuY2hpbGRyZW5baV0gPT0gb2Zmc2V0KSB7IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpICsgMl07IH1cbiAgICBicmVha1xuICB9IH1cbiAgdmFyIHN0YXJ0ID0gb2Zmc2V0ICsgMSwgZW5kID0gc3RhcnQgKyBub2RlLmNvbnRlbnQuc2l6ZTtcbiAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgdGhpcy5sb2NhbC5sZW5ndGg7IGkkMSsrKSB7XG4gICAgdmFyIGRlYyA9IHRoaXMubG9jYWxbaSQxXTtcbiAgICBpZiAoZGVjLmZyb20gPCBlbmQgJiYgZGVjLnRvID4gc3RhcnQgJiYgKGRlYy50eXBlIGluc3RhbmNlb2YgSW5saW5lVHlwZSkpIHtcbiAgICAgIHZhciBmcm9tID0gTWF0aC5tYXgoc3RhcnQsIGRlYy5mcm9tKSAtIHN0YXJ0LCB0byA9IE1hdGgubWluKGVuZCwgZGVjLnRvKSAtIHN0YXJ0O1xuICAgICAgaWYgKGZyb20gPCB0bykgeyAobG9jYWwgfHwgKGxvY2FsID0gW10pKS5wdXNoKGRlYy5jb3B5KGZyb20sIHRvKSk7IH1cbiAgICB9XG4gIH1cbiAgaWYgKGxvY2FsKSB7XG4gICAgdmFyIGxvY2FsU2V0ID0gbmV3IERlY29yYXRpb25TZXQobG9jYWwuc29ydChieVBvcykpO1xuICAgIHJldHVybiBjaGlsZCA/IG5ldyBEZWNvcmF0aW9uR3JvdXAoW2xvY2FsU2V0LCBjaGlsZF0pIDogbG9jYWxTZXRcbiAgfVxuICByZXR1cm4gY2hpbGQgfHwgZW1wdHlcbn07XG5cbkRlY29yYXRpb25TZXQucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gZXEgKG90aGVyKSB7XG4gIGlmICh0aGlzID09IG90aGVyKSB7IHJldHVybiB0cnVlIH1cbiAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBEZWNvcmF0aW9uU2V0KSB8fFxuICAgICAgdGhpcy5sb2NhbC5sZW5ndGggIT0gb3RoZXIubG9jYWwubGVuZ3RoIHx8XG4gICAgICB0aGlzLmNoaWxkcmVuLmxlbmd0aCAhPSBvdGhlci5jaGlsZHJlbi5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxvY2FsLmxlbmd0aDsgaSsrKVxuICAgIHsgaWYgKCF0aGlzLmxvY2FsW2ldLmVxKG90aGVyLmxvY2FsW2ldKSkgeyByZXR1cm4gZmFsc2UgfSB9XG4gIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpJDEgKz0gMylcbiAgICB7IGlmICh0aGlzLmNoaWxkcmVuW2kkMV0gIT0gb3RoZXIuY2hpbGRyZW5baSQxXSB8fFxuICAgICAgICB0aGlzLmNoaWxkcmVuW2kkMSArIDFdICE9IG90aGVyLmNoaWxkcmVuW2kkMSArIDFdIHx8XG4gICAgICAgICF0aGlzLmNoaWxkcmVuW2kkMSArIDJdLmVxKG90aGVyLmNoaWxkcmVuW2kkMSArIDJdKSkgeyByZXR1cm4gZmFsc2UgfSB9XG4gIHJldHVybiB0cnVlXG59O1xuXG5EZWNvcmF0aW9uU2V0LnByb3RvdHlwZS5sb2NhbHMgPSBmdW5jdGlvbiBsb2NhbHMgKG5vZGUpIHtcbiAgcmV0dXJuIHJlbW92ZU92ZXJsYXAodGhpcy5sb2NhbHNJbm5lcihub2RlKSlcbn07XG5cbkRlY29yYXRpb25TZXQucHJvdG90eXBlLmxvY2Fsc0lubmVyID0gZnVuY3Rpb24gbG9jYWxzSW5uZXIgKG5vZGUpIHtcbiAgaWYgKHRoaXMgPT0gZW1wdHkpIHsgcmV0dXJuIG5vbmUgfVxuICBpZiAobm9kZS5pbmxpbmVDb250ZW50IHx8ICF0aGlzLmxvY2FsLnNvbWUoSW5saW5lVHlwZS5pcykpIHsgcmV0dXJuIHRoaXMubG9jYWwgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sb2NhbC5sZW5ndGg7IGkrKykge1xuICAgIGlmICghKHRoaXMubG9jYWxbaV0udHlwZSBpbnN0YW5jZW9mIElubGluZVR5cGUpKVxuICAgICAgeyByZXN1bHQucHVzaCh0aGlzLmxvY2FsW2ldKTsgfVxuICB9XG4gIHJldHVybiByZXN1bHRcbn07XG5cbi8vIERlY29yYXRpb25Tb3VyY2U6OiBpbnRlcmZhY2Vcbi8vIEFuIG9iamVjdCB0aGF0IGNhbiBbcHJvdmlkZV0oI3ZpZXcuRWRpdG9yUHJvcHMuZGVjb3JhdGlvbnMpXG4vLyBkZWNvcmF0aW9ucy4gSW1wbGVtZW50ZWQgYnkgW2BEZWNvcmF0aW9uU2V0YF0oI3ZpZXcuRGVjb3JhdGlvblNldCksXG4vLyBhbmQgcGFzc2VkIHRvIFtub2RlIHZpZXdzXSgjdmlldy5FZGl0b3JQcm9wcy5ub2RlVmlld3MpLlxuLy9cbi8vICAgbWFwOjogKE1hcHBpbmcsIE5vZGUpIOKGkiBEZWNvcmF0aW9uU291cmNlXG4vLyAgIE1hcCB0aGUgc2V0IG9mIGRlY29yYXRpb25zIGluIHJlc3BvbnNlIHRvIGEgY2hhbmdlIGluIHRoZVxuLy8gICBkb2N1bWVudC5cblxudmFyIGVtcHR5ID0gbmV3IERlY29yYXRpb25TZXQoKTtcblxuLy8gOjogRGVjb3JhdGlvblNldFxuLy8gVGhlIGVtcHR5IHNldCBvZiBkZWNvcmF0aW9ucy5cbkRlY29yYXRpb25TZXQuZW1wdHkgPSBlbXB0eTtcblxuRGVjb3JhdGlvblNldC5yZW1vdmVPdmVybGFwID0gcmVtb3ZlT3ZlcmxhcDtcblxuLy8gOi0gQW4gYWJzdHJhY3Rpb24gdGhhdCBhbGxvd3MgdGhlIGNvZGUgZGVhbGluZyB3aXRoIGRlY29yYXRpb25zIHRvXG4vLyB0cmVhdCBtdWx0aXBsZSBEZWNvcmF0aW9uU2V0IG9iamVjdHMgYXMgaWYgaXQgd2VyZSBhIHNpbmdsZSBvYmplY3Rcbi8vIHdpdGggKGEgc3Vic2V0IG9mKSB0aGUgc2FtZSBpbnRlcmZhY2UuXG52YXIgRGVjb3JhdGlvbkdyb3VwID0gZnVuY3Rpb24gRGVjb3JhdGlvbkdyb3VwKG1lbWJlcnMpIHtcbiAgdGhpcy5tZW1iZXJzID0gbWVtYmVycztcbn07XG5cbkRlY29yYXRpb25Hcm91cC5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gbWFwIChtYXBwaW5nLCBkb2MpIHtcbiAgdmFyIG1hcHBlZERlY29zID0gdGhpcy5tZW1iZXJzLm1hcChcbiAgICBmdW5jdGlvbiAobWVtYmVyKSB7IHJldHVybiBtZW1iZXIubWFwKG1hcHBpbmcsIGRvYywgbm9TcGVjKTsgfVxuICApO1xuICByZXR1cm4gRGVjb3JhdGlvbkdyb3VwLmZyb20obWFwcGVkRGVjb3MpXG59O1xuXG5EZWNvcmF0aW9uR3JvdXAucHJvdG90eXBlLmZvckNoaWxkID0gZnVuY3Rpb24gZm9yQ2hpbGQgKG9mZnNldCwgY2hpbGQpIHtcbiAgaWYgKGNoaWxkLmlzTGVhZikgeyByZXR1cm4gRGVjb3JhdGlvblNldC5lbXB0eSB9XG4gIHZhciBmb3VuZCA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubWVtYmVycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciByZXN1bHQgPSB0aGlzLm1lbWJlcnNbaV0uZm9yQ2hpbGQob2Zmc2V0LCBjaGlsZCk7XG4gICAgaWYgKHJlc3VsdCA9PSBlbXB0eSkgeyBjb250aW51ZSB9XG4gICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIERlY29yYXRpb25Hcm91cCkgeyBmb3VuZCA9IGZvdW5kLmNvbmNhdChyZXN1bHQubWVtYmVycyk7IH1cbiAgICBlbHNlIHsgZm91bmQucHVzaChyZXN1bHQpOyB9XG4gIH1cbiAgcmV0dXJuIERlY29yYXRpb25Hcm91cC5mcm9tKGZvdW5kKVxufTtcblxuRGVjb3JhdGlvbkdyb3VwLnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIGVxIChvdGhlcikge1xuICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIERlY29yYXRpb25Hcm91cCkgfHxcbiAgICAgIG90aGVyLm1lbWJlcnMubGVuZ3RoICE9IHRoaXMubWVtYmVycy5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1lbWJlcnMubGVuZ3RoOyBpKyspXG4gICAgeyBpZiAoIXRoaXMubWVtYmVyc1tpXS5lcShvdGhlci5tZW1iZXJzW2ldKSkgeyByZXR1cm4gZmFsc2UgfSB9XG4gIHJldHVybiB0cnVlXG59O1xuXG5EZWNvcmF0aW9uR3JvdXAucHJvdG90eXBlLmxvY2FscyA9IGZ1bmN0aW9uIGxvY2FscyAobm9kZSkge1xuICB2YXIgcmVzdWx0LCBzb3J0ZWQgPSB0cnVlO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubWVtYmVycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBsb2NhbHMgPSB0aGlzLm1lbWJlcnNbaV0ubG9jYWxzSW5uZXIobm9kZSk7XG4gICAgaWYgKCFsb2NhbHMubGVuZ3RoKSB7IGNvbnRpbnVlIH1cbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgcmVzdWx0ID0gbG9jYWxzO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc29ydGVkKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgpO1xuICAgICAgICBzb3J0ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbG9jYWxzLmxlbmd0aDsgaisrKSB7IHJlc3VsdC5wdXNoKGxvY2Fsc1tqXSk7IH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdCA/IHJlbW92ZU92ZXJsYXAoc29ydGVkID8gcmVzdWx0IDogcmVzdWx0LnNvcnQoYnlQb3MpKSA6IG5vbmVcbn07XG5cbi8vIDogKFtEZWNvcmF0aW9uU2V0XSkg4oaSIHVuaW9uPERlY29yYXRpb25TZXQsIERlY29yYXRpb25Hcm91cD5cbi8vIENyZWF0ZSBhIGdyb3VwIGZvciB0aGUgZ2l2ZW4gYXJyYXkgb2YgZGVjb3JhdGlvbiBzZXRzLCBvciByZXR1cm5cbi8vIGEgc2luZ2xlIHNldCB3aGVuIHBvc3NpYmxlLlxuRGVjb3JhdGlvbkdyb3VwLmZyb20gPSBmdW5jdGlvbiBmcm9tIChtZW1iZXJzKSB7XG4gIHN3aXRjaCAobWVtYmVycy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6IHJldHVybiBlbXB0eVxuICAgIGNhc2UgMTogcmV0dXJuIG1lbWJlcnNbMF1cbiAgICBkZWZhdWx0OiByZXR1cm4gbmV3IERlY29yYXRpb25Hcm91cChtZW1iZXJzKVxuICB9XG59O1xuXG5mdW5jdGlvbiBtYXBDaGlsZHJlbihvbGRDaGlsZHJlbiwgbmV3TG9jYWwsIG1hcHBpbmcsIG5vZGUsIG9mZnNldCwgb2xkT2Zmc2V0LCBvcHRpb25zKSB7XG4gIHZhciBjaGlsZHJlbiA9IG9sZENoaWxkcmVuLnNsaWNlKCk7XG5cbiAgLy8gTWFyayB0aGUgY2hpbGRyZW4gdGhhdCBhcmUgZGlyZWN0bHkgdG91Y2hlZCBieSBjaGFuZ2VzLCBhbmRcbiAgLy8gbW92ZSB0aG9zZSB0aGF0IGFyZSBhZnRlciB0aGUgY2hhbmdlcy5cbiAgdmFyIHNoaWZ0ID0gZnVuY3Rpb24gKG9sZFN0YXJ0LCBvbGRFbmQsIG5ld1N0YXJ0LCBuZXdFbmQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICB2YXIgZW5kID0gY2hpbGRyZW5baSArIDFdLCBkU2l6ZSA9ICh2b2lkIDApO1xuICAgICAgaWYgKGVuZCA9PSAtMSB8fCBvbGRTdGFydCA+IGVuZCArIG9sZE9mZnNldCkgeyBjb250aW51ZSB9XG4gICAgICBpZiAob2xkRW5kID49IGNoaWxkcmVuW2ldICsgb2xkT2Zmc2V0KSB7XG4gICAgICAgIGNoaWxkcmVuW2kgKyAxXSA9IC0xO1xuICAgICAgfSBlbHNlIGlmIChuZXdTdGFydCA+PSBvZmZzZXQgJiYgKGRTaXplID0gKG5ld0VuZCAtIG5ld1N0YXJ0KSAtIChvbGRFbmQgLSBvbGRTdGFydCkpKSB7XG4gICAgICAgIGNoaWxkcmVuW2ldICs9IGRTaXplO1xuICAgICAgICBjaGlsZHJlbltpICsgMV0gKz0gZFNpemU7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcHBpbmcubWFwcy5sZW5ndGg7IGkrKykgeyBtYXBwaW5nLm1hcHNbaV0uZm9yRWFjaChzaGlmdCk7IH1cblxuICAvLyBGaW5kIHRoZSBjaGlsZCBub2RlcyB0aGF0IHN0aWxsIGNvcnJlc3BvbmQgdG8gYSBzaW5nbGUgbm9kZSxcbiAgLy8gcmVjdXJzaXZlbHkgY2FsbCBtYXBJbm5lciBvbiB0aGVtIGFuZCB1cGRhdGUgdGhlaXIgcG9zaXRpb25zLlxuICB2YXIgbXVzdFJlYnVpbGQgPSBmYWxzZTtcbiAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2hpbGRyZW4ubGVuZ3RoOyBpJDEgKz0gMykgeyBpZiAoY2hpbGRyZW5baSQxICsgMV0gPT0gLTEpIHsgLy8gVG91Y2hlZCBub2Rlc1xuICAgIHZhciBmcm9tID0gbWFwcGluZy5tYXAob2xkQ2hpbGRyZW5baSQxXSArIG9sZE9mZnNldCksIGZyb21Mb2NhbCA9IGZyb20gLSBvZmZzZXQ7XG4gICAgaWYgKGZyb21Mb2NhbCA8IDAgfHwgZnJvbUxvY2FsID49IG5vZGUuY29udGVudC5zaXplKSB7XG4gICAgICBtdXN0UmVidWlsZCA9IHRydWU7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICAvLyBNdXN0IHJlYWQgb2xkQ2hpbGRyZW4gYmVjYXVzZSBjaGlsZHJlbiB3YXMgdGFnZ2VkIHdpdGggLTFcbiAgICB2YXIgdG8gPSBtYXBwaW5nLm1hcChvbGRDaGlsZHJlbltpJDEgKyAxXSArIG9sZE9mZnNldCwgLTEpLCB0b0xvY2FsID0gdG8gLSBvZmZzZXQ7XG4gICAgdmFyIHJlZiA9IG5vZGUuY29udGVudC5maW5kSW5kZXgoZnJvbUxvY2FsKTtcbiAgICB2YXIgaW5kZXggPSByZWYuaW5kZXg7XG4gICAgdmFyIGNoaWxkT2Zmc2V0ID0gcmVmLm9mZnNldDtcbiAgICB2YXIgY2hpbGROb2RlID0gbm9kZS5tYXliZUNoaWxkKGluZGV4KTtcbiAgICBpZiAoY2hpbGROb2RlICYmIGNoaWxkT2Zmc2V0ID09IGZyb21Mb2NhbCAmJiBjaGlsZE9mZnNldCArIGNoaWxkTm9kZS5ub2RlU2l6ZSA9PSB0b0xvY2FsKSB7XG4gICAgICB2YXIgbWFwcGVkID0gY2hpbGRyZW5baSQxICsgMl0ubWFwSW5uZXIobWFwcGluZywgY2hpbGROb2RlLCBmcm9tICsgMSwgb2xkQ2hpbGRyZW5baSQxXSArIG9sZE9mZnNldCArIDEsIG9wdGlvbnMpO1xuICAgICAgaWYgKG1hcHBlZCAhPSBlbXB0eSkge1xuICAgICAgICBjaGlsZHJlbltpJDFdID0gZnJvbUxvY2FsO1xuICAgICAgICBjaGlsZHJlbltpJDEgKyAxXSA9IHRvTG9jYWw7XG4gICAgICAgIGNoaWxkcmVuW2kkMSArIDJdID0gbWFwcGVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hpbGRyZW5baSQxICsgMV0gPSAtMjtcbiAgICAgICAgbXVzdFJlYnVpbGQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtdXN0UmVidWlsZCA9IHRydWU7XG4gICAgfVxuICB9IH1cblxuICAvLyBSZW1haW5pbmcgY2hpbGRyZW4gbXVzdCBiZSBjb2xsZWN0ZWQgYW5kIHJlYnVpbHQgaW50byB0aGUgYXBwcm9wcmlhdGUgc3RydWN0dXJlXG4gIGlmIChtdXN0UmVidWlsZCkge1xuICAgIHZhciBkZWNvcmF0aW9ucyA9IG1hcEFuZEdhdGhlclJlbWFpbmluZ0RlY29yYXRpb25zKGNoaWxkcmVuLCBvbGRDaGlsZHJlbiwgbmV3TG9jYWwgfHwgW10sIG1hcHBpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0LCBvbGRPZmZzZXQsIG9wdGlvbnMpO1xuICAgIHZhciBidWlsdCA9IGJ1aWxkVHJlZShkZWNvcmF0aW9ucywgbm9kZSwgMCwgb3B0aW9ucyk7XG4gICAgbmV3TG9jYWwgPSBidWlsdC5sb2NhbDtcbiAgICBmb3IgKHZhciBpJDIgPSAwOyBpJDIgPCBjaGlsZHJlbi5sZW5ndGg7IGkkMiArPSAzKSB7IGlmIChjaGlsZHJlbltpJDIgKyAxXSA8IDApIHtcbiAgICAgIGNoaWxkcmVuLnNwbGljZShpJDIsIDMpO1xuICAgICAgaSQyIC09IDM7XG4gICAgfSB9XG4gICAgZm9yICh2YXIgaSQzID0gMCwgaiA9IDA7IGkkMyA8IGJ1aWx0LmNoaWxkcmVuLmxlbmd0aDsgaSQzICs9IDMpIHtcbiAgICAgIHZhciBmcm9tJDEgPSBidWlsdC5jaGlsZHJlbltpJDNdO1xuICAgICAgd2hpbGUgKGogPCBjaGlsZHJlbi5sZW5ndGggJiYgY2hpbGRyZW5bal0gPCBmcm9tJDEpIHsgaiArPSAzOyB9XG4gICAgICBjaGlsZHJlbi5zcGxpY2UoaiwgMCwgYnVpbHQuY2hpbGRyZW5baSQzXSwgYnVpbHQuY2hpbGRyZW5baSQzICsgMV0sIGJ1aWx0LmNoaWxkcmVuW2kkMyArIDJdKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IERlY29yYXRpb25TZXQobmV3TG9jYWwgJiYgbmV3TG9jYWwuc29ydChieVBvcyksIGNoaWxkcmVuKVxufVxuXG5mdW5jdGlvbiBtb3ZlU3BhbnMoc3BhbnMsIG9mZnNldCkge1xuICBpZiAoIW9mZnNldCB8fCAhc3BhbnMubGVuZ3RoKSB7IHJldHVybiBzcGFucyB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGFucy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzcGFuID0gc3BhbnNbaV07XG4gICAgcmVzdWx0LnB1c2gobmV3IERlY29yYXRpb24oc3Bhbi5mcm9tICsgb2Zmc2V0LCBzcGFuLnRvICsgb2Zmc2V0LCBzcGFuLnR5cGUpKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIG1hcEFuZEdhdGhlclJlbWFpbmluZ0RlY29yYXRpb25zKGNoaWxkcmVuLCBvbGRDaGlsZHJlbiwgZGVjb3JhdGlvbnMsIG1hcHBpbmcsIG9mZnNldCwgb2xkT2Zmc2V0LCBvcHRpb25zKSB7XG4gIC8vIEdhdGhlciBhbGwgZGVjb3JhdGlvbnMgZnJvbSB0aGUgcmVtYWluaW5nIG1hcmtlZCBjaGlsZHJlblxuICBmdW5jdGlvbiBnYXRoZXIoc2V0LCBvbGRPZmZzZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNldC5sb2NhbC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG1hcHBlZCA9IHNldC5sb2NhbFtpXS5tYXAobWFwcGluZywgb2Zmc2V0LCBvbGRPZmZzZXQpO1xuICAgICAgaWYgKG1hcHBlZCkgeyBkZWNvcmF0aW9ucy5wdXNoKG1hcHBlZCk7IH1cbiAgICAgIGVsc2UgaWYgKG9wdGlvbnMub25SZW1vdmUpIHsgb3B0aW9ucy5vblJlbW92ZShzZXQubG9jYWxbaV0uc3BlYyk7IH1cbiAgICB9XG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgc2V0LmNoaWxkcmVuLmxlbmd0aDsgaSQxICs9IDMpXG4gICAgICB7IGdhdGhlcihzZXQuY2hpbGRyZW5baSQxICsgMl0sIHNldC5jaGlsZHJlbltpJDFdICsgb2xkT2Zmc2V0ICsgMSk7IH1cbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSArPSAzKSB7IGlmIChjaGlsZHJlbltpICsgMV0gPT0gLTEpXG4gICAgeyBnYXRoZXIoY2hpbGRyZW5baSArIDJdLCBvbGRDaGlsZHJlbltpXSArIG9sZE9mZnNldCArIDEpOyB9IH1cblxuICByZXR1cm4gZGVjb3JhdGlvbnNcbn1cblxuZnVuY3Rpb24gdGFrZVNwYW5zRm9yTm9kZShzcGFucywgbm9kZSwgb2Zmc2V0KSB7XG4gIGlmIChub2RlLmlzTGVhZikgeyByZXR1cm4gbnVsbCB9XG4gIHZhciBlbmQgPSBvZmZzZXQgKyBub2RlLm5vZGVTaXplLCBmb3VuZCA9IG51bGw7XG4gIGZvciAodmFyIGkgPSAwLCBzcGFuID0gKHZvaWQgMCk7IGkgPCBzcGFucy5sZW5ndGg7IGkrKykge1xuICAgIGlmICgoc3BhbiA9IHNwYW5zW2ldKSAmJiBzcGFuLmZyb20gPiBvZmZzZXQgJiYgc3Bhbi50byA8IGVuZCkge1xuKGZvdW5kIHx8IChmb3VuZCA9IFtdKSkucHVzaChzcGFuKTtcbiAgICAgIHNwYW5zW2ldID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZvdW5kXG59XG5cbmZ1bmN0aW9uIHdpdGhvdXROdWxscyhhcnJheSkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspXG4gICAgeyBpZiAoYXJyYXlbaV0gIT0gbnVsbCkgeyByZXN1bHQucHVzaChhcnJheVtpXSk7IH0gfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8vIDogKFtEZWNvcmF0aW9uXSwgTm9kZSwgbnVtYmVyKSDihpIgRGVjb3JhdGlvblNldFxuLy8gQnVpbGQgdXAgYSB0cmVlIHRoYXQgY29ycmVzcG9uZHMgdG8gYSBzZXQgb2YgZGVjb3JhdGlvbnMuIGBvZmZzZXRgXG4vLyBpcyBhIGJhc2Ugb2Zmc2V0IHRoYXQgc2hvdWxkIGJlIHN1YnRyYWN0ZWQgZnJvbSB0aGUgYGZyb21gIGFuZCBgdG9gXG4vLyBwb3NpdGlvbnMgaW4gdGhlIHNwYW5zIChzbyB0aGF0IHdlIGRvbid0IGhhdmUgdG8gYWxsb2NhdGUgbmV3IHNwYW5zXG4vLyBmb3IgcmVjdXJzaXZlIGNhbGxzKS5cbmZ1bmN0aW9uIGJ1aWxkVHJlZShzcGFucywgbm9kZSwgb2Zmc2V0LCBvcHRpb25zKSB7XG4gIHZhciBjaGlsZHJlbiA9IFtdLCBoYXNOdWxscyA9IGZhbHNlO1xuICBub2RlLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkTm9kZSwgbG9jYWxTdGFydCkge1xuICAgIHZhciBmb3VuZCA9IHRha2VTcGFuc0Zvck5vZGUoc3BhbnMsIGNoaWxkTm9kZSwgbG9jYWxTdGFydCArIG9mZnNldCk7XG4gICAgaWYgKGZvdW5kKSB7XG4gICAgICBoYXNOdWxscyA9IHRydWU7XG4gICAgICB2YXIgc3VidHJlZSA9IGJ1aWxkVHJlZShmb3VuZCwgY2hpbGROb2RlLCBvZmZzZXQgKyBsb2NhbFN0YXJ0ICsgMSwgb3B0aW9ucyk7XG4gICAgICBpZiAoc3VidHJlZSAhPSBlbXB0eSlcbiAgICAgICAgeyBjaGlsZHJlbi5wdXNoKGxvY2FsU3RhcnQsIGxvY2FsU3RhcnQgKyBjaGlsZE5vZGUubm9kZVNpemUsIHN1YnRyZWUpOyB9XG4gICAgfVxuICB9KTtcbiAgdmFyIGxvY2FscyA9IG1vdmVTcGFucyhoYXNOdWxscyA/IHdpdGhvdXROdWxscyhzcGFucykgOiBzcGFucywgLW9mZnNldCkuc29ydChieVBvcyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbG9jYWxzLmxlbmd0aDsgaSsrKSB7IGlmICghbG9jYWxzW2ldLnR5cGUudmFsaWQobm9kZSwgbG9jYWxzW2ldKSkge1xuICAgIGlmIChvcHRpb25zLm9uUmVtb3ZlKSB7IG9wdGlvbnMub25SZW1vdmUobG9jYWxzW2ldLnNwZWMpOyB9XG4gICAgbG9jYWxzLnNwbGljZShpLS0sIDEpO1xuICB9IH1cbiAgcmV0dXJuIGxvY2Fscy5sZW5ndGggfHwgY2hpbGRyZW4ubGVuZ3RoID8gbmV3IERlY29yYXRpb25TZXQobG9jYWxzLCBjaGlsZHJlbikgOiBlbXB0eVxufVxuXG4vLyA6IChEZWNvcmF0aW9uLCBEZWNvcmF0aW9uKSDihpIgbnVtYmVyXG4vLyBVc2VkIHRvIHNvcnQgZGVjb3JhdGlvbnMgc28gdGhhdCBvbmVzIHdpdGggYSBsb3cgc3RhcnQgcG9zaXRpb25cbi8vIGNvbWUgZmlyc3QsIGFuZCB3aXRoaW4gYSBzZXQgd2l0aCB0aGUgc2FtZSBzdGFydCBwb3NpdGlvbiwgdGhvc2Vcbi8vIHdpdGggYW4gc21hbGxlciBlbmQgcG9zaXRpb24gY29tZSBmaXJzdC5cbmZ1bmN0aW9uIGJ5UG9zKGEsIGIpIHtcbiAgcmV0dXJuIGEuZnJvbSAtIGIuZnJvbSB8fCBhLnRvIC0gYi50b1xufVxuXG4vLyA6IChbRGVjb3JhdGlvbl0pIOKGkiBbRGVjb3JhdGlvbl1cbi8vIFNjYW4gYSBzb3J0ZWQgYXJyYXkgb2YgZGVjb3JhdGlvbnMgZm9yIHBhcnRpYWxseSBvdmVybGFwcGluZyBzcGFucyxcbi8vIGFuZCBzcGxpdCB0aG9zZSBzbyB0aGF0IG9ubHkgZnVsbHkgb3ZlcmxhcHBpbmcgc3BhbnMgYXJlIGxlZnQgKHRvXG4vLyBtYWtlIHN1YnNlcXVlbnQgcmVuZGVyaW5nIGVhc2llcikuIFdpbGwgcmV0dXJuIHRoZSBpbnB1dCBhcnJheSBpZlxuLy8gbm8gcGFydGlhbGx5IG92ZXJsYXBwaW5nIHNwYW5zIGFyZSBmb3VuZCAodGhlIGNvbW1vbiBjYXNlKS5cbmZ1bmN0aW9uIHJlbW92ZU92ZXJsYXAoc3BhbnMpIHtcbiAgdmFyIHdvcmtpbmcgPSBzcGFucztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB3b3JraW5nLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIHZhciBzcGFuID0gd29ya2luZ1tpXTtcbiAgICBpZiAoc3Bhbi5mcm9tICE9IHNwYW4udG8pIHsgZm9yICh2YXIgaiA9IGkgKyAxOyBqIDwgd29ya2luZy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIG5leHQgPSB3b3JraW5nW2pdO1xuICAgICAgaWYgKG5leHQuZnJvbSA9PSBzcGFuLmZyb20pIHtcbiAgICAgICAgaWYgKG5leHQudG8gIT0gc3Bhbi50bykge1xuICAgICAgICAgIGlmICh3b3JraW5nID09IHNwYW5zKSB7IHdvcmtpbmcgPSBzcGFucy5zbGljZSgpOyB9XG4gICAgICAgICAgLy8gRm9sbG93ZWQgYnkgYSBwYXJ0aWFsbHkgb3ZlcmxhcHBpbmcgbGFyZ2VyIHNwYW4uIFNwbGl0IHRoYXRcbiAgICAgICAgICAvLyBzcGFuLlxuICAgICAgICAgIHdvcmtpbmdbal0gPSBuZXh0LmNvcHkobmV4dC5mcm9tLCBzcGFuLnRvKTtcbiAgICAgICAgICBpbnNlcnRBaGVhZCh3b3JraW5nLCBqICsgMSwgbmV4dC5jb3B5KHNwYW4udG8sIG5leHQudG8pKTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG5leHQuZnJvbSA8IHNwYW4udG8pIHtcbiAgICAgICAgICBpZiAod29ya2luZyA9PSBzcGFucykgeyB3b3JraW5nID0gc3BhbnMuc2xpY2UoKTsgfVxuICAgICAgICAgIC8vIFRoZSBlbmQgb2YgdGhpcyBvbmUgb3ZlcmxhcHMgd2l0aCBhIHN1YnNlcXVlbnQgc3Bhbi4gU3BsaXRcbiAgICAgICAgICAvLyB0aGlzIG9uZS5cbiAgICAgICAgICB3b3JraW5nW2ldID0gc3Bhbi5jb3B5KHNwYW4uZnJvbSwgbmV4dC5mcm9tKTtcbiAgICAgICAgICBpbnNlcnRBaGVhZCh3b3JraW5nLCBqLCBzcGFuLmNvcHkobmV4dC5mcm9tLCBzcGFuLnRvKSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9IH1cbiAgfVxuICByZXR1cm4gd29ya2luZ1xufVxuXG5mdW5jdGlvbiBpbnNlcnRBaGVhZChhcnJheSwgaSwgZGVjbykge1xuICB3aGlsZSAoaSA8IGFycmF5Lmxlbmd0aCAmJiBieVBvcyhkZWNvLCBhcnJheVtpXSkgPiAwKSB7IGkrKzsgfVxuICBhcnJheS5zcGxpY2UoaSwgMCwgZGVjbyk7XG59XG5cbi8vIDogKEVkaXRvclZpZXcpIOKGkiB1bmlvbjxEZWNvcmF0aW9uU2V0LCBEZWNvcmF0aW9uR3JvdXA+XG4vLyBHZXQgdGhlIGRlY29yYXRpb25zIGFzc29jaWF0ZWQgd2l0aCB0aGUgY3VycmVudCBwcm9wcyBvZiBhIHZpZXcuXG5mdW5jdGlvbiB2aWV3RGVjb3JhdGlvbnModmlldykge1xuICB2YXIgZm91bmQgPSBbXTtcbiAgdmlldy5zb21lUHJvcChcImRlY29yYXRpb25zXCIsIGZ1bmN0aW9uIChmKSB7XG4gICAgdmFyIHJlc3VsdCA9IGYodmlldy5zdGF0ZSk7XG4gICAgaWYgKHJlc3VsdCAmJiByZXN1bHQgIT0gZW1wdHkpIHsgZm91bmQucHVzaChyZXN1bHQpOyB9XG4gIH0pO1xuICBpZiAodmlldy5jdXJzb3JXcmFwcGVyKVxuICAgIHsgZm91bmQucHVzaChEZWNvcmF0aW9uU2V0LmNyZWF0ZSh2aWV3LnN0YXRlLmRvYywgW3ZpZXcuY3Vyc29yV3JhcHBlci5kZWNvXSkpOyB9XG4gIHJldHVybiBEZWNvcmF0aW9uR3JvdXAuZnJvbShmb3VuZClcbn1cblxuLy8gOjotIEFuIGVkaXRvciB2aWV3IG1hbmFnZXMgdGhlIERPTSBzdHJ1Y3R1cmUgdGhhdCByZXByZXNlbnRzIGFuXG4vLyBlZGl0YWJsZSBkb2N1bWVudC4gSXRzIHN0YXRlIGFuZCBiZWhhdmlvciBhcmUgZGV0ZXJtaW5lZCBieSBpdHNcbi8vIFtwcm9wc10oI3ZpZXcuRGlyZWN0RWRpdG9yUHJvcHMpLlxudmFyIEVkaXRvclZpZXcgPSBmdW5jdGlvbiBFZGl0b3JWaWV3KHBsYWNlLCBwcm9wcykge1xuICB0aGlzLl9wcm9wcyA9IHByb3BzO1xuICAvLyA6OiBFZGl0b3JTdGF0ZVxuICAvLyBUaGUgdmlldydzIGN1cnJlbnQgW3N0YXRlXSgjc3RhdGUuRWRpdG9yU3RhdGUpLlxuICB0aGlzLnN0YXRlID0gcHJvcHMuc3RhdGU7XG5cbiAgdGhpcy5kaXJlY3RQbHVnaW5zID0gcHJvcHMucGx1Z2lucyB8fCBbXTtcbiAgdGhpcy5kaXJlY3RQbHVnaW5zLmZvckVhY2goY2hlY2tTdGF0ZUNvbXBvbmVudCk7XG5cbiAgdGhpcy5kaXNwYXRjaCA9IHRoaXMuZGlzcGF0Y2guYmluZCh0aGlzKTtcblxuICB0aGlzLl9yb290ID0gbnVsbDtcbiAgdGhpcy5mb2N1c2VkID0gZmFsc2U7XG4gIC8vIEtsdWRnZSB1c2VkIHRvIHdvcmsgYXJvdW5kIGEgQ2hyb21lIGJ1Z1xuICB0aGlzLnRyYWNrV3JpdGVzID0gbnVsbDtcblxuICAvLyA6OiBkb20uRWxlbWVudFxuICAvLyBBbiBlZGl0YWJsZSBET00gbm9kZSBjb250YWluaW5nIHRoZSBkb2N1bWVudC4gKFlvdSBwcm9iYWJseVxuICAvLyBzaG91bGQgbm90IGRpcmVjdGx5IGludGVyZmVyZSB3aXRoIGl0cyBjb250ZW50LilcbiAgdGhpcy5kb20gPSAocGxhY2UgJiYgcGxhY2UubW91bnQpIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIGlmIChwbGFjZSkge1xuICAgIGlmIChwbGFjZS5hcHBlbmRDaGlsZCkgeyBwbGFjZS5hcHBlbmRDaGlsZCh0aGlzLmRvbSk7IH1cbiAgICBlbHNlIGlmIChwbGFjZS5hcHBseSkgeyBwbGFjZSh0aGlzLmRvbSk7IH1cbiAgICBlbHNlIGlmIChwbGFjZS5tb3VudCkgeyB0aGlzLm1vdW50ZWQgPSB0cnVlOyB9XG4gIH1cblxuICAvLyA6OiBib29sXG4gIC8vIEluZGljYXRlcyB3aGV0aGVyIHRoZSBlZGl0b3IgaXMgY3VycmVudGx5IFtlZGl0YWJsZV0oI3ZpZXcuRWRpdG9yUHJvcHMuZWRpdGFibGUpLlxuICB0aGlzLmVkaXRhYmxlID0gZ2V0RWRpdGFibGUodGhpcyk7XG4gIHRoaXMubWFya0N1cnNvciA9IG51bGw7XG4gIHRoaXMuY3Vyc29yV3JhcHBlciA9IG51bGw7XG4gIHVwZGF0ZUN1cnNvcldyYXBwZXIodGhpcyk7XG4gIHRoaXMubm9kZVZpZXdzID0gYnVpbGROb2RlVmlld3ModGhpcyk7XG4gIHRoaXMuZG9jVmlldyA9IGRvY1ZpZXdEZXNjKHRoaXMuc3RhdGUuZG9jLCBjb21wdXRlRG9jRGVjbyh0aGlzKSwgdmlld0RlY29yYXRpb25zKHRoaXMpLCB0aGlzLmRvbSwgdGhpcyk7XG5cbiAgdGhpcy5sYXN0U2VsZWN0ZWRWaWV3RGVzYyA9IG51bGw7XG4gIC8vIDo6ID97c2xpY2U6IFNsaWNlLCBtb3ZlOiBib29sfVxuICAvLyBXaGVuIGVkaXRvciBjb250ZW50IGlzIGJlaW5nIGRyYWdnZWQsIHRoaXMgb2JqZWN0IGNvbnRhaW5zXG4gIC8vIGluZm9ybWF0aW9uIGFib3V0IHRoZSBkcmFnZ2VkIHNsaWNlIGFuZCB3aGV0aGVyIGl0IGlzIGJlaW5nXG4gIC8vIGNvcGllZCBvciBtb3ZlZC4gQXQgYW55IG90aGVyIHRpbWUsIGl0IGlzIG51bGwuXG4gIHRoaXMuZHJhZ2dpbmcgPSBudWxsO1xuXG4gIGluaXRJbnB1dCh0aGlzKTtcblxuICB0aGlzLnByZXZEaXJlY3RQbHVnaW5zID0gW107XG4gIHRoaXMucGx1Z2luVmlld3MgPSBbXTtcbiAgdGhpcy51cGRhdGVQbHVnaW5WaWV3cygpO1xufTtcblxudmFyIHByb3RvdHlwZUFjY2Vzc29ycyQyID0geyBwcm9wczogeyBjb25maWd1cmFibGU6IHRydWUgfSxyb290OiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbi8vIGNvbXBvc2luZzo6IGJvb2xlYW5cbi8vIEhvbGRzIGB0cnVlYCB3aGVuIGFcbi8vIFtjb21wb3NpdGlvbl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Nb3ppbGxhL0lNRV9oYW5kbGluZ19ndWlkZSlcbi8vIGlzIGFjdGl2ZS5cblxuLy8gOjogRGlyZWN0RWRpdG9yUHJvcHNcbi8vIFRoZSB2aWV3J3MgY3VycmVudCBbcHJvcHNdKCN2aWV3LkVkaXRvclByb3BzKS5cbnByb3RvdHlwZUFjY2Vzc29ycyQyLnByb3BzLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuX3Byb3BzLnN0YXRlICE9IHRoaXMuc3RhdGUpIHtcbiAgICB2YXIgcHJldiA9IHRoaXMuX3Byb3BzO1xuICAgIHRoaXMuX3Byb3BzID0ge307XG4gICAgZm9yICh2YXIgbmFtZSBpbiBwcmV2KSB7IHRoaXMuX3Byb3BzW25hbWVdID0gcHJldltuYW1lXTsgfVxuICAgIHRoaXMuX3Byb3BzLnN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgfVxuICByZXR1cm4gdGhpcy5fcHJvcHNcbn07XG5cbi8vIDo6IChEaXJlY3RFZGl0b3JQcm9wcylcbi8vIFVwZGF0ZSB0aGUgdmlldydzIHByb3BzLiBXaWxsIGltbWVkaWF0ZWx5IGNhdXNlIGFuIHVwZGF0ZSB0b1xuLy8gdGhlIERPTS5cbkVkaXRvclZpZXcucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAocHJvcHMpIHtcbiAgaWYgKHByb3BzLmhhbmRsZURPTUV2ZW50cyAhPSB0aGlzLl9wcm9wcy5oYW5kbGVET01FdmVudHMpIHsgZW5zdXJlTGlzdGVuZXJzKHRoaXMpOyB9XG4gIHRoaXMuX3Byb3BzID0gcHJvcHM7XG4gIGlmIChwcm9wcy5wbHVnaW5zKSB7XG4gICAgcHJvcHMucGx1Z2lucy5mb3JFYWNoKGNoZWNrU3RhdGVDb21wb25lbnQpO1xuICAgIHRoaXMuZGlyZWN0UGx1Z2lucyA9IHByb3BzLnBsdWdpbnM7XG4gIH1cbiAgdGhpcy51cGRhdGVTdGF0ZUlubmVyKHByb3BzLnN0YXRlLCB0cnVlKTtcbn07XG5cbi8vIDo6IChEaXJlY3RFZGl0b3JQcm9wcylcbi8vIFVwZGF0ZSB0aGUgdmlldyBieSB1cGRhdGluZyBleGlzdGluZyBwcm9wcyBvYmplY3Qgd2l0aCB0aGUgb2JqZWN0XG4vLyBnaXZlbiBhcyBhcmd1bWVudC4gRXF1aXZhbGVudCB0byBgdmlldy51cGRhdGUoT2JqZWN0LmFzc2lnbih7fSxcbi8vIHZpZXcucHJvcHMsIHByb3BzKSlgLlxuRWRpdG9yVmlldy5wcm90b3R5cGUuc2V0UHJvcHMgPSBmdW5jdGlvbiBzZXRQcm9wcyAocHJvcHMpIHtcbiAgdmFyIHVwZGF0ZWQgPSB7fTtcbiAgZm9yICh2YXIgbmFtZSBpbiB0aGlzLl9wcm9wcykgeyB1cGRhdGVkW25hbWVdID0gdGhpcy5fcHJvcHNbbmFtZV07IH1cbiAgdXBkYXRlZC5zdGF0ZSA9IHRoaXMuc3RhdGU7XG4gIGZvciAodmFyIG5hbWUkMSBpbiBwcm9wcykgeyB1cGRhdGVkW25hbWUkMV0gPSBwcm9wc1tuYW1lJDFdOyB9XG4gIHRoaXMudXBkYXRlKHVwZGF0ZWQpO1xufTtcblxuLy8gOjogKEVkaXRvclN0YXRlKVxuLy8gVXBkYXRlIHRoZSBlZGl0b3IncyBgc3RhdGVgIHByb3AsIHdpdGhvdXQgdG91Y2hpbmcgYW55IG9mIHRoZVxuLy8gb3RoZXIgcHJvcHMuXG5FZGl0b3JWaWV3LnByb3RvdHlwZS51cGRhdGVTdGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZVN0YXRlIChzdGF0ZSkge1xuICB0aGlzLnVwZGF0ZVN0YXRlSW5uZXIoc3RhdGUsIHRoaXMuc3RhdGUucGx1Z2lucyAhPSBzdGF0ZS5wbHVnaW5zKTtcbn07XG5cbkVkaXRvclZpZXcucHJvdG90eXBlLnVwZGF0ZVN0YXRlSW5uZXIgPSBmdW5jdGlvbiB1cGRhdGVTdGF0ZUlubmVyIChzdGF0ZSwgcmVjb25maWd1cmVkKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIHByZXYgPSB0aGlzLnN0YXRlLCByZWRyYXcgPSBmYWxzZSwgdXBkYXRlU2VsID0gZmFsc2U7XG4gIC8vIFdoZW4gc3RvcmVkIG1hcmtzIGFyZSBhZGRlZCwgc3RvcCBjb21wb3NpdGlvbiwgc28gdGhhdCB0aGV5IGNhblxuICAvLyBiZSBkaXNwbGF5ZWQuXG4gIGlmIChzdGF0ZS5zdG9yZWRNYXJrcyAmJiB0aGlzLmNvbXBvc2luZykge1xuICAgIGNsZWFyQ29tcG9zaXRpb24odGhpcyk7XG4gICAgdXBkYXRlU2VsID0gdHJ1ZTtcbiAgfVxuICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gIGlmIChyZWNvbmZpZ3VyZWQpIHtcbiAgICB2YXIgbm9kZVZpZXdzID0gYnVpbGROb2RlVmlld3ModGhpcyk7XG4gICAgaWYgKGNoYW5nZWROb2RlVmlld3Mobm9kZVZpZXdzLCB0aGlzLm5vZGVWaWV3cykpIHtcbiAgICAgIHRoaXMubm9kZVZpZXdzID0gbm9kZVZpZXdzO1xuICAgICAgcmVkcmF3ID0gdHJ1ZTtcbiAgICB9XG4gICAgZW5zdXJlTGlzdGVuZXJzKHRoaXMpO1xuICB9XG5cbiAgdGhpcy5lZGl0YWJsZSA9IGdldEVkaXRhYmxlKHRoaXMpO1xuICB1cGRhdGVDdXJzb3JXcmFwcGVyKHRoaXMpO1xuICB2YXIgaW5uZXJEZWNvID0gdmlld0RlY29yYXRpb25zKHRoaXMpLCBvdXRlckRlY28gPSBjb21wdXRlRG9jRGVjbyh0aGlzKTtcblxuICB2YXIgc2Nyb2xsID0gcmVjb25maWd1cmVkID8gXCJyZXNldFwiXG4gICAgICA6IHN0YXRlLnNjcm9sbFRvU2VsZWN0aW9uID4gcHJldi5zY3JvbGxUb1NlbGVjdGlvbiA/IFwidG8gc2VsZWN0aW9uXCIgOiBcInByZXNlcnZlXCI7XG4gIHZhciB1cGRhdGVEb2MgPSByZWRyYXcgfHwgIXRoaXMuZG9jVmlldy5tYXRjaGVzTm9kZShzdGF0ZS5kb2MsIG91dGVyRGVjbywgaW5uZXJEZWNvKTtcbiAgaWYgKHVwZGF0ZURvYyB8fCAhc3RhdGUuc2VsZWN0aW9uLmVxKHByZXYuc2VsZWN0aW9uKSkgeyB1cGRhdGVTZWwgPSB0cnVlOyB9XG4gIHZhciBvbGRTY3JvbGxQb3MgPSBzY3JvbGwgPT0gXCJwcmVzZXJ2ZVwiICYmIHVwZGF0ZVNlbCAmJiB0aGlzLmRvbS5zdHlsZS5vdmVyZmxvd0FuY2hvciA9PSBudWxsICYmIHN0b3JlU2Nyb2xsUG9zKHRoaXMpO1xuXG4gIGlmICh1cGRhdGVTZWwpIHtcbiAgICB0aGlzLmRvbU9ic2VydmVyLnN0b3AoKTtcbiAgICAvLyBXb3JrIGFyb3VuZCBhbiBpc3N1ZSBpbiBDaHJvbWUsIElFLCBhbmQgRWRnZSB3aGVyZSBjaGFuZ2luZ1xuICAgIC8vIHRoZSBET00gYXJvdW5kIGFuIGFjdGl2ZSBzZWxlY3Rpb24gcHV0cyBpdCBpbnRvIGEgYnJva2VuXG4gICAgLy8gc3RhdGUgd2hlcmUgdGhlIHRoaW5nIHRoZSB1c2VyIHNlZXMgZGlmZmVycyBmcm9tIHRoZVxuICAgIC8vIHNlbGVjdGlvbiByZXBvcnRlZCBieSB0aGUgU2VsZWN0aW9uIG9iamVjdCAoIzcxMCwgIzk3MyxcbiAgICAvLyAjMTAxMSwgIzEwMTMsICMxMDM1KS5cbiAgICB2YXIgZm9yY2VTZWxVcGRhdGUgPSB1cGRhdGVEb2MgJiYgKHJlc3VsdC5pZSB8fCByZXN1bHQuY2hyb21lKSAmJiAhdGhpcy5jb21wb3NpbmcgJiZcbiAgICAgICAgIXByZXYuc2VsZWN0aW9uLmVtcHR5ICYmICFzdGF0ZS5zZWxlY3Rpb24uZW1wdHkgJiYgc2VsZWN0aW9uQ29udGV4dENoYW5nZWQocHJldi5zZWxlY3Rpb24sIHN0YXRlLnNlbGVjdGlvbik7XG4gICAgaWYgKHVwZGF0ZURvYykge1xuICAgICAgLy8gSWYgdGhlIG5vZGUgdGhhdCB0aGUgc2VsZWN0aW9uIHBvaW50cyBpbnRvIGlzIHdyaXR0ZW4gdG8sXG4gICAgICAvLyBDaHJvbWUgc29tZXRpbWVzIHN0YXJ0cyBtaXNyZXBvcnRpbmcgdGhlIHNlbGVjdGlvbiwgc28gdGhpc1xuICAgICAgLy8gdHJhY2tzIHRoYXQgYW5kIGZvcmNlcyBhIHNlbGVjdGlvbiByZXNldCB3aGVuIG91ciB1cGRhdGVcbiAgICAgIC8vIGRpZCB3cml0ZSB0byB0aGUgbm9kZS5cbiAgICAgIHZhciBjaHJvbWVLbHVkZ2UgPSByZXN1bHQuY2hyb21lID8gKHRoaXMudHJhY2tXcml0ZXMgPSB0aGlzLnJvb3QuZ2V0U2VsZWN0aW9uKCkuZm9jdXNOb2RlKSA6IG51bGw7XG4gICAgICBpZiAocmVkcmF3IHx8ICF0aGlzLmRvY1ZpZXcudXBkYXRlKHN0YXRlLmRvYywgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHRoaXMpKSB7XG4gICAgICAgIHRoaXMuZG9jVmlldy51cGRhdGVPdXRlckRlY28oW10pO1xuICAgICAgICB0aGlzLmRvY1ZpZXcuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmRvY1ZpZXcgPSBkb2NWaWV3RGVzYyhzdGF0ZS5kb2MsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB0aGlzLmRvbSwgdGhpcyk7XG4gICAgICB9XG4gICAgICBpZiAoY2hyb21lS2x1ZGdlICYmICF0aGlzLnRyYWNrV3JpdGVzKSB7IGZvcmNlU2VsVXBkYXRlID0gdHJ1ZTsgfVxuICAgIH1cbiAgICAvLyBXb3JrIGFyb3VuZCBmb3IgYW4gaXNzdWUgd2hlcmUgYW4gdXBkYXRlIGFycml2aW5nIHJpZ2h0IGJldHdlZW5cbiAgICAvLyBhIERPTSBzZWxlY3Rpb24gY2hhbmdlIGFuZCB0aGUgXCJzZWxlY3Rpb25jaGFuZ2VcIiBldmVudCBmb3IgaXRcbiAgICAvLyBjYW4gY2F1c2UgYSBzcHVyaW91cyBET00gc2VsZWN0aW9uIHVwZGF0ZSwgZGlzcnVwdGluZyBtb3VzZVxuICAgIC8vIGRyYWcgc2VsZWN0aW9uLlxuICAgIGlmIChmb3JjZVNlbFVwZGF0ZSB8fFxuICAgICAgICAhKHRoaXMubW91c2VEb3duICYmIHRoaXMuZG9tT2JzZXJ2ZXIuY3VycmVudFNlbGVjdGlvbi5lcSh0aGlzLnJvb3QuZ2V0U2VsZWN0aW9uKCkpICYmIGFuY2hvckluUmlnaHRQbGFjZSh0aGlzKSkpIHtcbiAgICAgIHNlbGVjdGlvblRvRE9NKHRoaXMsIGZvcmNlU2VsVXBkYXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3luY05vZGVTZWxlY3Rpb24odGhpcywgc3RhdGUuc2VsZWN0aW9uKTtcbiAgICAgIHRoaXMuZG9tT2JzZXJ2ZXIuc2V0Q3VyU2VsZWN0aW9uKCk7XG4gICAgfVxuICAgIHRoaXMuZG9tT2JzZXJ2ZXIuc3RhcnQoKTtcbiAgfVxuXG4gIHRoaXMudXBkYXRlUGx1Z2luVmlld3MocHJldik7XG5cbiAgaWYgKHNjcm9sbCA9PSBcInJlc2V0XCIpIHtcbiAgICB0aGlzLmRvbS5zY3JvbGxUb3AgPSAwO1xuICB9IGVsc2UgaWYgKHNjcm9sbCA9PSBcInRvIHNlbGVjdGlvblwiKSB7XG4gICAgdmFyIHN0YXJ0RE9NID0gdGhpcy5yb290LmdldFNlbGVjdGlvbigpLmZvY3VzTm9kZTtcbiAgICBpZiAodGhpcy5zb21lUHJvcChcImhhbmRsZVNjcm9sbFRvU2VsZWN0aW9uXCIsIGZ1bmN0aW9uIChmKSB7IHJldHVybiBmKHRoaXMkMSk7IH0pKVxuICAgICAgOyAvLyBIYW5kbGVkXG4gICAgZWxzZSBpZiAoc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbilcbiAgICAgIHsgc2Nyb2xsUmVjdEludG9WaWV3KHRoaXMsIHRoaXMuZG9jVmlldy5kb21BZnRlclBvcyhzdGF0ZS5zZWxlY3Rpb24uZnJvbSkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHN0YXJ0RE9NKTsgfVxuICAgIGVsc2VcbiAgICAgIHsgc2Nyb2xsUmVjdEludG9WaWV3KHRoaXMsIHRoaXMuY29vcmRzQXRQb3Moc3RhdGUuc2VsZWN0aW9uLmhlYWQsIDEpLCBzdGFydERPTSk7IH1cbiAgfSBlbHNlIGlmIChvbGRTY3JvbGxQb3MpIHtcbiAgICByZXNldFNjcm9sbFBvcyhvbGRTY3JvbGxQb3MpO1xuICB9XG59O1xuXG5FZGl0b3JWaWV3LnByb3RvdHlwZS5kZXN0cm95UGx1Z2luVmlld3MgPSBmdW5jdGlvbiBkZXN0cm95UGx1Z2luVmlld3MgKCkge1xuICB2YXIgdmlldztcbiAgd2hpbGUgKHZpZXcgPSB0aGlzLnBsdWdpblZpZXdzLnBvcCgpKSB7IGlmICh2aWV3LmRlc3Ryb3kpIHsgdmlldy5kZXN0cm95KCk7IH0gfVxufTtcblxuRWRpdG9yVmlldy5wcm90b3R5cGUudXBkYXRlUGx1Z2luVmlld3MgPSBmdW5jdGlvbiB1cGRhdGVQbHVnaW5WaWV3cyAocHJldlN0YXRlKSB7XG4gIGlmICghcHJldlN0YXRlIHx8IHByZXZTdGF0ZS5wbHVnaW5zICE9IHRoaXMuc3RhdGUucGx1Z2lucyB8fCB0aGlzLmRpcmVjdFBsdWdpbnMgIT0gdGhpcy5wcmV2RGlyZWN0UGx1Z2lucykge1xuICAgIHRoaXMucHJldkRpcmVjdFBsdWdpbnMgPSB0aGlzLmRpcmVjdFBsdWdpbnM7XG4gICAgdGhpcy5kZXN0cm95UGx1Z2luVmlld3MoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGlyZWN0UGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHBsdWdpbiA9IHRoaXMuZGlyZWN0UGx1Z2luc1tpXTtcbiAgICAgIGlmIChwbHVnaW4uc3BlYy52aWV3KSB7IHRoaXMucGx1Z2luVmlld3MucHVzaChwbHVnaW4uc3BlYy52aWV3KHRoaXMpKTsgfVxuICAgIH1cbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCB0aGlzLnN0YXRlLnBsdWdpbnMubGVuZ3RoOyBpJDErKykge1xuICAgICAgdmFyIHBsdWdpbiQxID0gdGhpcy5zdGF0ZS5wbHVnaW5zW2kkMV07XG4gICAgICBpZiAocGx1Z2luJDEuc3BlYy52aWV3KSB7IHRoaXMucGx1Z2luVmlld3MucHVzaChwbHVnaW4kMS5zcGVjLnZpZXcodGhpcykpOyB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkkMiA9IDA7IGkkMiA8IHRoaXMucGx1Z2luVmlld3MubGVuZ3RoOyBpJDIrKykge1xuICAgICAgdmFyIHBsdWdpblZpZXcgPSB0aGlzLnBsdWdpblZpZXdzW2kkMl07XG4gICAgICBpZiAocGx1Z2luVmlldy51cGRhdGUpIHsgcGx1Z2luVmlldy51cGRhdGUodGhpcywgcHJldlN0YXRlKTsgfVxuICAgIH1cbiAgfVxufTtcblxuLy8gOjogKHN0cmluZywgPyhwcm9wOiAqKSDihpIgKikg4oaSICpcbi8vIEdvZXMgb3ZlciB0aGUgdmFsdWVzIG9mIGEgcHJvcCwgZmlyc3QgdGhvc2UgcHJvdmlkZWQgZGlyZWN0bHksXG4vLyB0aGVuIHRob3NlIGZyb20gcGx1Z2lucyBnaXZlbiB0byB0aGUgdmlldywgdGhlbiBmcm9tIHBsdWdpbnMgaW5cbi8vIHRoZSBzdGF0ZSAoaW4gb3JkZXIpLCBhbmQgY2FsbHMgYGZgIGV2ZXJ5IHRpbWUgYSBub24tdW5kZWZpbmVkXG4vLyB2YWx1ZSBpcyBmb3VuZC4gV2hlbiBgZmAgcmV0dXJucyBhIHRydXRoeSB2YWx1ZSwgdGhhdCBpc1xuLy8gaW1tZWRpYXRlbHkgcmV0dXJuZWQuIFdoZW4gYGZgIGlzbid0IHByb3ZpZGVkLCBpdCBpcyB0cmVhdGVkIGFzXG4vLyB0aGUgaWRlbnRpdHkgZnVuY3Rpb24gKHRoZSBwcm9wIHZhbHVlIGlzIHJldHVybmVkIGRpcmVjdGx5KS5cbkVkaXRvclZpZXcucHJvdG90eXBlLnNvbWVQcm9wID0gZnVuY3Rpb24gc29tZVByb3AgKHByb3BOYW1lLCBmKSB7XG4gIHZhciBwcm9wID0gdGhpcy5fcHJvcHMgJiYgdGhpcy5fcHJvcHNbcHJvcE5hbWVdLCB2YWx1ZTtcbiAgaWYgKHByb3AgIT0gbnVsbCAmJiAodmFsdWUgPSBmID8gZihwcm9wKSA6IHByb3ApKSB7IHJldHVybiB2YWx1ZSB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kaXJlY3RQbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByb3AkMSA9IHRoaXMuZGlyZWN0UGx1Z2luc1tpXS5wcm9wc1twcm9wTmFtZV07XG4gICAgaWYgKHByb3AkMSAhPSBudWxsICYmICh2YWx1ZSA9IGYgPyBmKHByb3AkMSkgOiBwcm9wJDEpKSB7IHJldHVybiB2YWx1ZSB9XG4gIH1cbiAgdmFyIHBsdWdpbnMgPSB0aGlzLnN0YXRlLnBsdWdpbnM7XG4gIGlmIChwbHVnaW5zKSB7IGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHBsdWdpbnMubGVuZ3RoOyBpJDErKykge1xuICAgIHZhciBwcm9wJDIgPSBwbHVnaW5zW2kkMV0ucHJvcHNbcHJvcE5hbWVdO1xuICAgIGlmIChwcm9wJDIgIT0gbnVsbCAmJiAodmFsdWUgPSBmID8gZihwcm9wJDIpIDogcHJvcCQyKSkgeyByZXR1cm4gdmFsdWUgfVxuICB9IH1cbn07XG5cbi8vIDo6ICgpIOKGkiBib29sXG4vLyBRdWVyeSB3aGV0aGVyIHRoZSB2aWV3IGhhcyBmb2N1cy5cbkVkaXRvclZpZXcucHJvdG90eXBlLmhhc0ZvY3VzID0gZnVuY3Rpb24gaGFzRm9jdXMgKCkge1xuICByZXR1cm4gdGhpcy5yb290LmFjdGl2ZUVsZW1lbnQgPT0gdGhpcy5kb21cbn07XG5cbi8vIDo6ICgpXG4vLyBGb2N1cyB0aGUgZWRpdG9yLlxuRWRpdG9yVmlldy5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbiBmb2N1cyAoKSB7XG4gIHRoaXMuZG9tT2JzZXJ2ZXIuc3RvcCgpO1xuICBpZiAodGhpcy5lZGl0YWJsZSkgeyBmb2N1c1ByZXZlbnRTY3JvbGwodGhpcy5kb20pOyB9XG4gIHNlbGVjdGlvblRvRE9NKHRoaXMpO1xuICB0aGlzLmRvbU9ic2VydmVyLnN0YXJ0KCk7XG59O1xuXG4vLyA6OiB1bmlvbjxkb20uRG9jdW1lbnQsIGRvbS5Eb2N1bWVudEZyYWdtZW50PlxuLy8gR2V0IHRoZSBkb2N1bWVudCByb290IGluIHdoaWNoIHRoZSBlZGl0b3IgZXhpc3RzLiBUaGlzIHdpbGxcbi8vIHVzdWFsbHkgYmUgdGhlIHRvcC1sZXZlbCBgZG9jdW1lbnRgLCBidXQgbWlnaHQgYmUgYSBbc2hhZG93XG4vLyBET01dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1dlYl9Db21wb25lbnRzL1NoYWRvd19ET00pXG4vLyByb290IGlmIHRoZSBlZGl0b3IgaXMgaW5zaWRlIG9uZS5cbnByb3RvdHlwZUFjY2Vzc29ycyQyLnJvb3QuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY2FjaGVkID0gdGhpcy5fcm9vdDtcbiAgaWYgKGNhY2hlZCA9PSBudWxsKSB7IGZvciAodmFyIHNlYXJjaCA9IHRoaXMuZG9tLnBhcmVudE5vZGU7IHNlYXJjaDsgc2VhcmNoID0gc2VhcmNoLnBhcmVudE5vZGUpIHtcbiAgICBpZiAoc2VhcmNoLm5vZGVUeXBlID09IDkgfHwgKHNlYXJjaC5ub2RlVHlwZSA9PSAxMSAmJiBzZWFyY2guaG9zdCkpIHtcbiAgICAgIGlmICghc2VhcmNoLmdldFNlbGVjdGlvbikgeyBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc2VhcmNoKS5nZXRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKTsgfTsgfVxuICAgICAgcmV0dXJuIHRoaXMuX3Jvb3QgPSBzZWFyY2hcbiAgICB9XG4gIH0gfVxuICByZXR1cm4gY2FjaGVkIHx8IGRvY3VtZW50XG59O1xuXG4vLyA6OiAoe2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9KSDihpIgP3twb3M6IG51bWJlciwgaW5zaWRlOiBudW1iZXJ9XG4vLyBHaXZlbiBhIHBhaXIgb2Ygdmlld3BvcnQgY29vcmRpbmF0ZXMsIHJldHVybiB0aGUgZG9jdW1lbnRcbi8vIHBvc2l0aW9uIHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlbS4gTWF5IHJldHVybiBudWxsIGlmIHRoZSBnaXZlblxuLy8gY29vcmRpbmF0ZXMgYXJlbid0IGluc2lkZSBvZiB0aGUgZWRpdG9yLiBXaGVuIGFuIG9iamVjdCBpc1xuLy8gcmV0dXJuZWQsIGl0cyBgcG9zYCBwcm9wZXJ0eSBpcyB0aGUgcG9zaXRpb24gbmVhcmVzdCB0byB0aGVcbi8vIGNvb3JkaW5hdGVzLCBhbmQgaXRzIGBpbnNpZGVgIHByb3BlcnR5IGhvbGRzIHRoZSBwb3NpdGlvbiBvZiB0aGVcbi8vIGlubmVyIG5vZGUgdGhhdCB0aGUgcG9zaXRpb24gZmFsbHMgaW5zaWRlIG9mLCBvciAtMSBpZiBpdCBpcyBhdFxuLy8gdGhlIHRvcCBsZXZlbCwgbm90IGluIGFueSBub2RlLlxuRWRpdG9yVmlldy5wcm90b3R5cGUucG9zQXRDb29yZHMgPSBmdW5jdGlvbiBwb3NBdENvb3JkcyQxIChjb29yZHMpIHtcbiAgcmV0dXJuIHBvc0F0Q29vcmRzKHRoaXMsIGNvb3Jkcylcbn07XG5cbi8vIDo6IChudW1iZXIsIG51bWJlcikg4oaSIHtsZWZ0OiBudW1iZXIsIHJpZ2h0OiBudW1iZXIsIHRvcDogbnVtYmVyLCBib3R0b206IG51bWJlcn1cbi8vIFJldHVybnMgdGhlIHZpZXdwb3J0IHJlY3RhbmdsZSBhdCBhIGdpdmVuIGRvY3VtZW50IHBvc2l0aW9uLlxuLy8gYGxlZnRgIGFuZCBgcmlnaHRgIHdpbGwgYmUgdGhlIHNhbWUgbnVtYmVyLCBhcyB0aGlzIHJldHVybnMgYVxuLy8gZmxhdCBjdXJzb3ItaXNoIHJlY3RhbmdsZS4gSWYgdGhlIHBvc2l0aW9uIGlzIGJldHdlZW4gdHdvIHRoaW5nc1xuLy8gdGhhdCBhcmVuJ3QgZGlyZWN0bHkgYWRqYWNlbnQsIGBzaWRlYCBkZXRlcm1pbmVzIHdoaWNoIGVsZW1lbnQgaXNcbi8vIHVzZWQuIFdoZW4gPCAwLCB0aGUgZWxlbWVudCBiZWZvcmUgdGhlIHBvc2l0aW9uIGlzIHVzZWQsXG4vLyBvdGhlcndpc2UgdGhlIGVsZW1lbnQgYWZ0ZXIuXG5FZGl0b3JWaWV3LnByb3RvdHlwZS5jb29yZHNBdFBvcyA9IGZ1bmN0aW9uIGNvb3Jkc0F0UG9zJDEgKHBvcywgc2lkZSkge1xuICAgIGlmICggc2lkZSA9PT0gdm9pZCAwICkgc2lkZSA9IDE7XG5cbiAgcmV0dXJuIGNvb3Jkc0F0UG9zKHRoaXMsIHBvcywgc2lkZSlcbn07XG5cbi8vIDo6IChudW1iZXIsIG51bWJlcikg4oaSIHtub2RlOiBkb20uTm9kZSwgb2Zmc2V0OiBudW1iZXJ9XG4vLyBGaW5kIHRoZSBET00gcG9zaXRpb24gdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgZ2l2ZW4gZG9jdW1lbnRcbi8vIHBvc2l0aW9uLiBXaGVuIGBzaWRlYCBpcyBuZWdhdGl2ZSwgZmluZCB0aGUgcG9zaXRpb24gYXMgY2xvc2UgYXNcbi8vIHBvc3NpYmxlIHRvIHRoZSBjb250ZW50IGJlZm9yZSB0aGUgcG9zaXRpb24uIFdoZW4gcG9zaXRpdmUsXG4vLyBwcmVmZXIgcG9zaXRpb25zIGNsb3NlIHRvIHRoZSBjb250ZW50IGFmdGVyIHRoZSBwb3NpdGlvbi4gV2hlblxuLy8gemVybywgcHJlZmVyIGFzIHNoYWxsb3cgYSBwb3NpdGlvbiBhcyBwb3NzaWJsZS5cbi8vXG4vLyBOb3RlIHRoYXQgeW91IHNob3VsZCAqKm5vdCoqIG11dGF0ZSB0aGUgZWRpdG9yJ3MgaW50ZXJuYWwgRE9NLFxuLy8gb25seSBpbnNwZWN0IGl0IChhbmQgZXZlbiB0aGF0IGlzIHVzdWFsbHkgbm90IG5lY2Vzc2FyeSkuXG5FZGl0b3JWaWV3LnByb3RvdHlwZS5kb21BdFBvcyA9IGZ1bmN0aW9uIGRvbUF0UG9zIChwb3MsIHNpZGUpIHtcbiAgICBpZiAoIHNpZGUgPT09IHZvaWQgMCApIHNpZGUgPSAwO1xuXG4gIHJldHVybiB0aGlzLmRvY1ZpZXcuZG9tRnJvbVBvcyhwb3MsIHNpZGUpXG59O1xuXG4vLyA6OiAobnVtYmVyKSDihpIgP2RvbS5Ob2RlXG4vLyBGaW5kIHRoZSBET00gbm9kZSB0aGF0IHJlcHJlc2VudHMgdGhlIGRvY3VtZW50IG5vZGUgYWZ0ZXIgdGhlXG4vLyBnaXZlbiBwb3NpdGlvbi4gTWF5IHJldHVybiBgbnVsbGAgd2hlbiB0aGUgcG9zaXRpb24gZG9lc24ndCBwb2ludFxuLy8gaW4gZnJvbnQgb2YgYSBub2RlIG9yIGlmIHRoZSBub2RlIGlzIGluc2lkZSBhbiBvcGFxdWUgbm9kZSB2aWV3LlxuLy9cbi8vIFRoaXMgaXMgaW50ZW5kZWQgdG8gYmUgYWJsZSB0byBjYWxsIHRoaW5ncyBsaWtlXG4vLyBgZ2V0Qm91bmRpbmdDbGllbnRSZWN0YCBvbiB0aGF0IERPTSBub2RlLiBEbyAqKm5vdCoqIG11dGF0ZSB0aGVcbi8vIGVkaXRvciBET00gZGlyZWN0bHksIG9yIGFkZCBzdHlsaW5nIHRoaXMgd2F5LCBzaW5jZSB0aGF0IHdpbGwgYmVcbi8vIGltbWVkaWF0ZWx5IG92ZXJyaWRlbiBieSB0aGUgZWRpdG9yIGFzIGl0IHJlZHJhd3MgdGhlIG5vZGUuXG5FZGl0b3JWaWV3LnByb3RvdHlwZS5ub2RlRE9NID0gZnVuY3Rpb24gbm9kZURPTSAocG9zKSB7XG4gIHZhciBkZXNjID0gdGhpcy5kb2NWaWV3LmRlc2NBdChwb3MpO1xuICByZXR1cm4gZGVzYyA/IGRlc2Mubm9kZURPTSA6IG51bGxcbn07XG5cbi8vIDo6IChkb20uTm9kZSwgbnVtYmVyLCA/bnVtYmVyKSDihpIgbnVtYmVyXG4vLyBGaW5kIHRoZSBkb2N1bWVudCBwb3NpdGlvbiB0aGF0IGNvcnJlc3BvbmRzIHRvIGEgZ2l2ZW4gRE9NXG4vLyBwb3NpdGlvbi4gKFdoZW5ldmVyIHBvc3NpYmxlLCBpdCBpcyBwcmVmZXJhYmxlIHRvIGluc3BlY3QgdGhlXG4vLyBkb2N1bWVudCBzdHJ1Y3R1cmUgZGlyZWN0bHksIHJhdGhlciB0aGFuIHBva2luZyBhcm91bmQgaW4gdGhlXG4vLyBET00sIGJ1dCBzb21ldGltZXPigJRmb3IgZXhhbXBsZSB3aGVuIGludGVycHJldGluZyBhbiBldmVudFxuLy8gdGFyZ2V04oCUeW91IGRvbid0IGhhdmUgYSBjaG9pY2UuKVxuLy9cbi8vIFRoZSBgYmlhc2AgcGFyYW1ldGVyIGNhbiBiZSB1c2VkIHRvIGluZmx1ZW5jZSB3aGljaCBzaWRlIG9mIGEgRE9NXG4vLyBub2RlIHRvIHVzZSB3aGVuIHRoZSBwb3NpdGlvbiBpcyBpbnNpZGUgYSBsZWFmIG5vZGUuXG5FZGl0b3JWaWV3LnByb3RvdHlwZS5wb3NBdERPTSA9IGZ1bmN0aW9uIHBvc0F0RE9NIChub2RlLCBvZmZzZXQsIGJpYXMpIHtcbiAgICBpZiAoIGJpYXMgPT09IHZvaWQgMCApIGJpYXMgPSAtMTtcblxuICB2YXIgcG9zID0gdGhpcy5kb2NWaWV3LnBvc0Zyb21ET00obm9kZSwgb2Zmc2V0LCBiaWFzKTtcbiAgaWYgKHBvcyA9PSBudWxsKSB7IHRocm93IG5ldyBSYW5nZUVycm9yKFwiRE9NIHBvc2l0aW9uIG5vdCBpbnNpZGUgdGhlIGVkaXRvclwiKSB9XG4gIHJldHVybiBwb3Ncbn07XG5cbi8vIDo6ICh1bmlvbjxcInVwXCIsIFwiZG93blwiLCBcImxlZnRcIiwgXCJyaWdodFwiLCBcImZvcndhcmRcIiwgXCJiYWNrd2FyZFwiPiwgP0VkaXRvclN0YXRlKSDihpIgYm9vbFxuLy8gRmluZCBvdXQgd2hldGhlciB0aGUgc2VsZWN0aW9uIGlzIGF0IHRoZSBlbmQgb2YgYSB0ZXh0YmxvY2sgd2hlblxuLy8gbW92aW5nIGluIGEgZ2l2ZW4gZGlyZWN0aW9uLiBXaGVuLCBmb3IgZXhhbXBsZSwgZ2l2ZW4gYFwibGVmdFwiYCxcbi8vIGl0IHdpbGwgcmV0dXJuIHRydWUgaWYgbW92aW5nIGxlZnQgZnJvbSB0aGUgY3VycmVudCBjdXJzb3Jcbi8vIHBvc2l0aW9uIHdvdWxkIGxlYXZlIHRoYXQgcG9zaXRpb24ncyBwYXJlbnQgdGV4dGJsb2NrLiBXaWxsIGFwcGx5XG4vLyB0byB0aGUgdmlldydzIGN1cnJlbnQgc3RhdGUgYnkgZGVmYXVsdCwgYnV0IGl0IGlzIHBvc3NpYmxlIHRvXG4vLyBwYXNzIGEgZGlmZmVyZW50IHN0YXRlLlxuRWRpdG9yVmlldy5wcm90b3R5cGUuZW5kT2ZUZXh0YmxvY2sgPSBmdW5jdGlvbiBlbmRPZlRleHRibG9jayQxIChkaXIsIHN0YXRlKSB7XG4gIHJldHVybiBlbmRPZlRleHRibG9jayh0aGlzLCBzdGF0ZSB8fCB0aGlzLnN0YXRlLCBkaXIpXG59O1xuXG4vLyA6OiAoKVxuLy8gUmVtb3ZlcyB0aGUgZWRpdG9yIGZyb20gdGhlIERPTSBhbmQgZGVzdHJveXMgYWxsIFtub2RlXG4vLyB2aWV3c10oI3ZpZXcuTm9kZVZpZXcpLlxuRWRpdG9yVmlldy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3kgKCkge1xuICBpZiAoIXRoaXMuZG9jVmlldykgeyByZXR1cm4gfVxuICBkZXN0cm95SW5wdXQodGhpcyk7XG4gIHRoaXMuZGVzdHJveVBsdWdpblZpZXdzKCk7XG4gIGlmICh0aGlzLm1vdW50ZWQpIHtcbiAgICB0aGlzLmRvY1ZpZXcudXBkYXRlKHRoaXMuc3RhdGUuZG9jLCBbXSwgdmlld0RlY29yYXRpb25zKHRoaXMpLCB0aGlzKTtcbiAgICB0aGlzLmRvbS50ZXh0Q29udGVudCA9IFwiXCI7XG4gIH0gZWxzZSBpZiAodGhpcy5kb20ucGFyZW50Tm9kZSkge1xuICAgIHRoaXMuZG9tLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5kb20pO1xuICB9XG4gIHRoaXMuZG9jVmlldy5kZXN0cm95KCk7XG4gIHRoaXMuZG9jVmlldyA9IG51bGw7XG59O1xuXG4vLyBVc2VkIGZvciB0ZXN0aW5nLlxuRWRpdG9yVmlldy5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQkMSAoZXZlbnQpIHtcbiAgcmV0dXJuIGRpc3BhdGNoRXZlbnQodGhpcywgZXZlbnQpXG59O1xuXG4vLyA6OiAoVHJhbnNhY3Rpb24pXG4vLyBEaXNwYXRjaCBhIHRyYW5zYWN0aW9uLiBXaWxsIGNhbGxcbi8vIFtgZGlzcGF0Y2hUcmFuc2FjdGlvbmBdKCN2aWV3LkRpcmVjdEVkaXRvclByb3BzLmRpc3BhdGNoVHJhbnNhY3Rpb24pXG4vLyB3aGVuIGdpdmVuLCBhbmQgb3RoZXJ3aXNlIGRlZmF1bHRzIHRvIGFwcGx5aW5nIHRoZSB0cmFuc2FjdGlvbiB0b1xuLy8gdGhlIGN1cnJlbnQgc3RhdGUgYW5kIGNhbGxpbmdcbi8vIFtgdXBkYXRlU3RhdGVgXSgjdmlldy5FZGl0b3JWaWV3LnVwZGF0ZVN0YXRlKSB3aXRoIHRoZSByZXN1bHQuXG4vLyBUaGlzIG1ldGhvZCBpcyBib3VuZCB0byB0aGUgdmlldyBpbnN0YW5jZSwgc28gdGhhdCBpdCBjYW4gYmVcbi8vIGVhc2lseSBwYXNzZWQgYXJvdW5kLlxuRWRpdG9yVmlldy5wcm90b3R5cGUuZGlzcGF0Y2ggPSBmdW5jdGlvbiBkaXNwYXRjaCAodHIpIHtcbiAgdmFyIGRpc3BhdGNoVHJhbnNhY3Rpb24gPSB0aGlzLl9wcm9wcy5kaXNwYXRjaFRyYW5zYWN0aW9uO1xuICBpZiAoZGlzcGF0Y2hUcmFuc2FjdGlvbikgeyBkaXNwYXRjaFRyYW5zYWN0aW9uLmNhbGwodGhpcywgdHIpOyB9XG4gIGVsc2UgeyB0aGlzLnVwZGF0ZVN0YXRlKHRoaXMuc3RhdGUuYXBwbHkodHIpKTsgfVxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIEVkaXRvclZpZXcucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMkMiApO1xuXG5mdW5jdGlvbiBjb21wdXRlRG9jRGVjbyh2aWV3KSB7XG4gIHZhciBhdHRycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGF0dHJzLmNsYXNzID0gXCJQcm9zZU1pcnJvclwiO1xuICBhdHRycy5jb250ZW50ZWRpdGFibGUgPSBTdHJpbmcodmlldy5lZGl0YWJsZSk7XG4gIGF0dHJzLnRyYW5zbGF0ZSA9IFwibm9cIjtcblxuICB2aWV3LnNvbWVQcm9wKFwiYXR0cmlidXRlc1wiLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09IFwiZnVuY3Rpb25cIikgeyB2YWx1ZSA9IHZhbHVlKHZpZXcuc3RhdGUpOyB9XG4gICAgaWYgKHZhbHVlKSB7IGZvciAodmFyIGF0dHIgaW4gdmFsdWUpIHtcbiAgICAgIGlmIChhdHRyID09IFwiY2xhc3NcIilcbiAgICAgICAgeyBhdHRycy5jbGFzcyArPSBcIiBcIiArIHZhbHVlW2F0dHJdOyB9XG4gICAgICBlbHNlIGlmICghYXR0cnNbYXR0cl0gJiYgYXR0ciAhPSBcImNvbnRlbnRlZGl0YWJsZVwiICYmIGF0dHIgIT0gXCJub2RlTmFtZVwiKVxuICAgICAgICB7IGF0dHJzW2F0dHJdID0gU3RyaW5nKHZhbHVlW2F0dHJdKTsgfVxuICAgIH0gfVxuICB9KTtcblxuICByZXR1cm4gW0RlY29yYXRpb24ubm9kZSgwLCB2aWV3LnN0YXRlLmRvYy5jb250ZW50LnNpemUsIGF0dHJzKV1cbn1cblxuZnVuY3Rpb24gdXBkYXRlQ3Vyc29yV3JhcHBlcih2aWV3KSB7XG4gIGlmICh2aWV3Lm1hcmtDdXJzb3IpIHtcbiAgICB2YXIgZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcbiAgICBkb20uY2xhc3NOYW1lID0gXCJQcm9zZU1pcnJvci1zZXBhcmF0b3JcIjtcbiAgICBkb20uc2V0QXR0cmlidXRlKFwibWFyay1wbGFjZWhvbGRlclwiLCBcInRydWVcIik7XG4gICAgdmlldy5jdXJzb3JXcmFwcGVyID0ge2RvbTogZG9tLCBkZWNvOiBEZWNvcmF0aW9uLndpZGdldCh2aWV3LnN0YXRlLnNlbGVjdGlvbi5oZWFkLCBkb20sIHtyYXc6IHRydWUsIG1hcmtzOiB2aWV3Lm1hcmtDdXJzb3J9KX07XG4gIH0gZWxzZSB7XG4gICAgdmlldy5jdXJzb3JXcmFwcGVyID0gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRFZGl0YWJsZSh2aWV3KSB7XG4gIHJldHVybiAhdmlldy5zb21lUHJvcChcImVkaXRhYmxlXCIsIGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmFsdWUodmlldy5zdGF0ZSkgPT09IGZhbHNlOyB9KVxufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25Db250ZXh0Q2hhbmdlZChzZWwxLCBzZWwyKSB7XG4gIHZhciBkZXB0aCA9IE1hdGgubWluKHNlbDEuJGFuY2hvci5zaGFyZWREZXB0aChzZWwxLmhlYWQpLCBzZWwyLiRhbmNob3Iuc2hhcmVkRGVwdGgoc2VsMi5oZWFkKSk7XG4gIHJldHVybiBzZWwxLiRhbmNob3Iuc3RhcnQoZGVwdGgpICE9IHNlbDIuJGFuY2hvci5zdGFydChkZXB0aClcbn1cblxuZnVuY3Rpb24gYnVpbGROb2RlVmlld3Modmlldykge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIHZpZXcuc29tZVByb3AoXCJub2RlVmlld3NcIiwgZnVuY3Rpb24gKG9iaikge1xuICAgIGZvciAodmFyIHByb3AgaW4gb2JqKSB7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwgcHJvcCkpXG4gICAgICB7IHJlc3VsdFtwcm9wXSA9IG9ialtwcm9wXTsgfSB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIGNoYW5nZWROb2RlVmlld3MoYSwgYikge1xuICB2YXIgbkEgPSAwLCBuQiA9IDA7XG4gIGZvciAodmFyIHByb3AgaW4gYSkge1xuICAgIGlmIChhW3Byb3BdICE9IGJbcHJvcF0pIHsgcmV0dXJuIHRydWUgfVxuICAgIG5BKys7XG4gIH1cbiAgZm9yICh2YXIgXyBpbiBiKSB7IG5CKys7IH1cbiAgcmV0dXJuIG5BICE9IG5CXG59XG5cbmZ1bmN0aW9uIGNoZWNrU3RhdGVDb21wb25lbnQocGx1Z2luKSB7XG4gIGlmIChwbHVnaW4uc3BlYy5zdGF0ZSB8fCBwbHVnaW4uc3BlYy5maWx0ZXJUcmFuc2FjdGlvbiB8fCBwbHVnaW4uc3BlYy5hcHBlbmRUcmFuc2FjdGlvbilcbiAgICB7IHRocm93IG5ldyBSYW5nZUVycm9yKFwiUGx1Z2lucyBwYXNzZWQgZGlyZWN0bHkgdG8gdGhlIHZpZXcgbXVzdCBub3QgaGF2ZSBhIHN0YXRlIGNvbXBvbmVudFwiKSB9XG59XG5cbi8vIEVkaXRvclByb3BzOjogaW50ZXJmYWNlXG4vL1xuLy8gUHJvcHMgYXJlIGNvbmZpZ3VyYXRpb24gdmFsdWVzIHRoYXQgY2FuIGJlIHBhc3NlZCB0byBhbiBlZGl0b3Igdmlld1xuLy8gb3IgaW5jbHVkZWQgaW4gYSBwbHVnaW4uIFRoaXMgaW50ZXJmYWNlIGxpc3RzIHRoZSBzdXBwb3J0ZWQgcHJvcHMuXG4vL1xuLy8gVGhlIHZhcmlvdXMgZXZlbnQtaGFuZGxpbmcgZnVuY3Rpb25zIG1heSBhbGwgcmV0dXJuIGB0cnVlYCB0b1xuLy8gaW5kaWNhdGUgdGhhdCB0aGV5IGhhbmRsZWQgdGhlIGdpdmVuIGV2ZW50LiBUaGUgdmlldyB3aWxsIHRoZW4gdGFrZVxuLy8gY2FyZSB0byBjYWxsIGBwcmV2ZW50RGVmYXVsdGAgb24gdGhlIGV2ZW50LCBleGNlcHQgd2l0aFxuLy8gYGhhbmRsZURPTUV2ZW50c2AsIHdoZXJlIHRoZSBoYW5kbGVyIGl0c2VsZiBpcyByZXNwb25zaWJsZSBmb3IgdGhhdC5cbi8vXG4vLyBIb3cgYSBwcm9wIGlzIHJlc29sdmVkIGRlcGVuZHMgb24gdGhlIHByb3AuIEhhbmRsZXIgZnVuY3Rpb25zIGFyZVxuLy8gY2FsbGVkIG9uZSBhdCBhIHRpbWUsIHN0YXJ0aW5nIHdpdGggdGhlIGJhc2UgcHJvcHMgYW5kIHRoZW5cbi8vIHNlYXJjaGluZyB0aHJvdWdoIHRoZSBwbHVnaW5zIChpbiBvcmRlciBvZiBhcHBlYXJhbmNlKSB1bnRpbCBvbmUgb2Zcbi8vIHRoZW0gcmV0dXJucyB0cnVlLiBGb3Igc29tZSBwcm9wcywgdGhlIGZpcnN0IHBsdWdpbiB0aGF0IHlpZWxkcyBhXG4vLyB2YWx1ZSBnZXRzIHByZWNlZGVuY2UuXG4vL1xuLy8gICBoYW5kbGVET01FdmVudHM6OiA/T2JqZWN0PCh2aWV3OiBFZGl0b3JWaWV3LCBldmVudDogZG9tLkV2ZW50KSDihpIgYm9vbD5cbi8vICAgQ2FuIGJlIGFuIG9iamVjdCBtYXBwaW5nIERPTSBldmVudCB0eXBlIG5hbWVzIHRvIGZ1bmN0aW9ucyB0aGF0XG4vLyAgIGhhbmRsZSB0aGVtLiBTdWNoIGZ1bmN0aW9ucyB3aWxsIGJlIGNhbGxlZCBiZWZvcmUgYW55IGhhbmRsaW5nXG4vLyAgIFByb3NlTWlycm9yIGRvZXMgb2YgZXZlbnRzIGZpcmVkIG9uIHRoZSBlZGl0YWJsZSBET00gZWxlbWVudC5cbi8vICAgQ29udHJhcnkgdG8gdGhlIG90aGVyIGV2ZW50IGhhbmRsaW5nIHByb3BzLCB3aGVuIHJldHVybmluZyB0cnVlXG4vLyAgIGZyb20gc3VjaCBhIGZ1bmN0aW9uLCB5b3UgYXJlIHJlc3BvbnNpYmxlIGZvciBjYWxsaW5nXG4vLyAgIGBwcmV2ZW50RGVmYXVsdGAgeW91cnNlbGYgKG9yIG5vdCwgaWYgeW91IHdhbnQgdG8gYWxsb3cgdGhlXG4vLyAgIGRlZmF1bHQgYmVoYXZpb3IpLlxuLy9cbi8vICAgaGFuZGxlS2V5RG93bjo6ID8odmlldzogRWRpdG9yVmlldywgZXZlbnQ6IGRvbS5LZXlib2FyZEV2ZW50KSDihpIgYm9vbFxuLy8gICBDYWxsZWQgd2hlbiB0aGUgZWRpdG9yIHJlY2VpdmVzIGEgYGtleWRvd25gIGV2ZW50LlxuLy9cbi8vICAgaGFuZGxlS2V5UHJlc3M6OiA/KHZpZXc6IEVkaXRvclZpZXcsIGV2ZW50OiBkb20uS2V5Ym9hcmRFdmVudCkg4oaSIGJvb2xcbi8vICAgSGFuZGxlciBmb3IgYGtleXByZXNzYCBldmVudHMuXG4vL1xuLy8gICBoYW5kbGVUZXh0SW5wdXQ6OiA/KHZpZXc6IEVkaXRvclZpZXcsIGZyb206IG51bWJlciwgdG86IG51bWJlciwgdGV4dDogc3RyaW5nKSDihpIgYm9vbFxuLy8gICBXaGVuZXZlciB0aGUgdXNlciBkaXJlY3RseSBpbnB1dCB0ZXh0LCB0aGlzIGhhbmRsZXIgaXMgY2FsbGVkXG4vLyAgIGJlZm9yZSB0aGUgaW5wdXQgaXMgYXBwbGllZC4gSWYgaXQgcmV0dXJucyBgdHJ1ZWAsIHRoZSBkZWZhdWx0XG4vLyAgIGJlaGF2aW9yIG9mIGFjdHVhbGx5IGluc2VydGluZyB0aGUgdGV4dCBpcyBzdXBwcmVzc2VkLlxuLy9cbi8vICAgaGFuZGxlQ2xpY2tPbjo6ID8odmlldzogRWRpdG9yVmlldywgcG9zOiBudW1iZXIsIG5vZGU6IE5vZGUsIG5vZGVQb3M6IG51bWJlciwgZXZlbnQ6IGRvbS5Nb3VzZUV2ZW50LCBkaXJlY3Q6IGJvb2wpIOKGkiBib29sXG4vLyAgIENhbGxlZCBmb3IgZWFjaCBub2RlIGFyb3VuZCBhIGNsaWNrLCBmcm9tIHRoZSBpbnNpZGUgb3V0LiBUaGVcbi8vICAgYGRpcmVjdGAgZmxhZyB3aWxsIGJlIHRydWUgZm9yIHRoZSBpbm5lciBub2RlLlxuLy9cbi8vICAgaGFuZGxlQ2xpY2s6OiA/KHZpZXc6IEVkaXRvclZpZXcsIHBvczogbnVtYmVyLCBldmVudDogZG9tLk1vdXNlRXZlbnQpIOKGkiBib29sXG4vLyAgIENhbGxlZCB3aGVuIHRoZSBlZGl0b3IgaXMgY2xpY2tlZCwgYWZ0ZXIgYGhhbmRsZUNsaWNrT25gIGhhbmRsZXJzXG4vLyAgIGhhdmUgYmVlbiBjYWxsZWQuXG4vL1xuLy8gICBoYW5kbGVEb3VibGVDbGlja09uOjogPyh2aWV3OiBFZGl0b3JWaWV3LCBwb3M6IG51bWJlciwgbm9kZTogTm9kZSwgbm9kZVBvczogbnVtYmVyLCBldmVudDogZG9tLk1vdXNlRXZlbnQsIGRpcmVjdDogYm9vbCkg4oaSIGJvb2xcbi8vICAgQ2FsbGVkIGZvciBlYWNoIG5vZGUgYXJvdW5kIGEgZG91YmxlIGNsaWNrLlxuLy9cbi8vICAgaGFuZGxlRG91YmxlQ2xpY2s6OiA/KHZpZXc6IEVkaXRvclZpZXcsIHBvczogbnVtYmVyLCBldmVudDogZG9tLk1vdXNlRXZlbnQpIOKGkiBib29sXG4vLyAgIENhbGxlZCB3aGVuIHRoZSBlZGl0b3IgaXMgZG91YmxlLWNsaWNrZWQsIGFmdGVyIGBoYW5kbGVEb3VibGVDbGlja09uYC5cbi8vXG4vLyAgIGhhbmRsZVRyaXBsZUNsaWNrT246OiA/KHZpZXc6IEVkaXRvclZpZXcsIHBvczogbnVtYmVyLCBub2RlOiBOb2RlLCBub2RlUG9zOiBudW1iZXIsIGV2ZW50OiBkb20uTW91c2VFdmVudCwgZGlyZWN0OiBib29sKSDihpIgYm9vbFxuLy8gICBDYWxsZWQgZm9yIGVhY2ggbm9kZSBhcm91bmQgYSB0cmlwbGUgY2xpY2suXG4vL1xuLy8gICBoYW5kbGVUcmlwbGVDbGljazo6ID8odmlldzogRWRpdG9yVmlldywgcG9zOiBudW1iZXIsIGV2ZW50OiBkb20uTW91c2VFdmVudCkg4oaSIGJvb2xcbi8vICAgQ2FsbGVkIHdoZW4gdGhlIGVkaXRvciBpcyB0cmlwbGUtY2xpY2tlZCwgYWZ0ZXIgYGhhbmRsZVRyaXBsZUNsaWNrT25gLlxuLy9cbi8vICAgaGFuZGxlUGFzdGU6OiA/KHZpZXc6IEVkaXRvclZpZXcsIGV2ZW50OiBkb20uQ2xpcGJvYXJkRXZlbnQsIHNsaWNlOiBTbGljZSkg4oaSIGJvb2xcbi8vICAgQ2FuIGJlIHVzZWQgdG8gb3ZlcnJpZGUgdGhlIGJlaGF2aW9yIG9mIHBhc3RpbmcuIGBzbGljZWAgaXMgdGhlXG4vLyAgIHBhc3RlZCBjb250ZW50IHBhcnNlZCBieSB0aGUgZWRpdG9yLCBidXQgeW91IGNhbiBkaXJlY3RseSBhY2Nlc3Ncbi8vICAgdGhlIGV2ZW50IHRvIGdldCBhdCB0aGUgcmF3IGNvbnRlbnQuXG4vL1xuLy8gICBoYW5kbGVEcm9wOjogPyh2aWV3OiBFZGl0b3JWaWV3LCBldmVudDogZG9tLkV2ZW50LCBzbGljZTogU2xpY2UsIG1vdmVkOiBib29sKSDihpIgYm9vbFxuLy8gICBDYWxsZWQgd2hlbiBzb21ldGhpbmcgaXMgZHJvcHBlZCBvbiB0aGUgZWRpdG9yLiBgbW92ZWRgIHdpbGwgYmVcbi8vICAgdHJ1ZSBpZiB0aGlzIGRyb3AgbW92ZXMgZnJvbSB0aGUgY3VycmVudCBzZWxlY3Rpb24gKHdoaWNoIHNob3VsZFxuLy8gICB0aHVzIGJlIGRlbGV0ZWQpLlxuLy9cbi8vICAgaGFuZGxlU2Nyb2xsVG9TZWxlY3Rpb246OiA/KHZpZXc6IEVkaXRvclZpZXcpIOKGkiBib29sXG4vLyAgIENhbGxlZCB3aGVuIHRoZSB2aWV3LCBhZnRlciB1cGRhdGluZyBpdHMgc3RhdGUsIHRyaWVzIHRvIHNjcm9sbFxuLy8gICB0aGUgc2VsZWN0aW9uIGludG8gdmlldy4gQSBoYW5kbGVyIGZ1bmN0aW9uIG1heSByZXR1cm4gZmFsc2UgdG9cbi8vICAgaW5kaWNhdGUgdGhhdCBpdCBkaWQgbm90IGhhbmRsZSB0aGUgc2Nyb2xsaW5nIGFuZCBmdXJ0aGVyXG4vLyAgIGhhbmRsZXJzIG9yIHRoZSBkZWZhdWx0IGJlaGF2aW9yIHNob3VsZCBiZSB0cmllZC5cbi8vXG4vLyAgIGNyZWF0ZVNlbGVjdGlvbkJldHdlZW46OiA/KHZpZXc6IEVkaXRvclZpZXcsIGFuY2hvcjogUmVzb2x2ZWRQb3MsIGhlYWQ6IFJlc29sdmVkUG9zKSDihpIgP1NlbGVjdGlvblxuLy8gICBDYW4gYmUgdXNlZCB0byBvdmVycmlkZSB0aGUgd2F5IGEgc2VsZWN0aW9uIGlzIGNyZWF0ZWQgd2hlblxuLy8gICByZWFkaW5nIGEgRE9NIHNlbGVjdGlvbiBiZXR3ZWVuIHRoZSBnaXZlbiBhbmNob3IgYW5kIGhlYWQuXG4vL1xuLy8gICBkb21QYXJzZXI6OiA/RE9NUGFyc2VyXG4vLyAgIFRoZSBbcGFyc2VyXSgjbW9kZWwuRE9NUGFyc2VyKSB0byB1c2Ugd2hlbiByZWFkaW5nIGVkaXRvciBjaGFuZ2VzXG4vLyAgIGZyb20gdGhlIERPTS4gRGVmYXVsdHMgdG8gY2FsbGluZ1xuLy8gICBbYERPTVBhcnNlci5mcm9tU2NoZW1hYF0oI21vZGVsLkRPTVBhcnNlcl5mcm9tU2NoZW1hKSBvbiB0aGVcbi8vICAgZWRpdG9yJ3Mgc2NoZW1hLlxuLy9cbi8vICAgdHJhbnNmb3JtUGFzdGVkSFRNTDo6ID8oaHRtbDogc3RyaW5nKSDihpIgc3RyaW5nXG4vLyAgIENhbiBiZSB1c2VkIHRvIHRyYW5zZm9ybSBwYXN0ZWQgSFRNTCB0ZXh0LCBfYmVmb3JlXyBpdCBpcyBwYXJzZWQsXG4vLyAgIGZvciBleGFtcGxlIHRvIGNsZWFuIGl0IHVwLlxuLy9cbi8vICAgY2xpcGJvYXJkUGFyc2VyOjogP0RPTVBhcnNlclxuLy8gICBUaGUgW3BhcnNlcl0oI21vZGVsLkRPTVBhcnNlcikgdG8gdXNlIHdoZW4gcmVhZGluZyBjb250ZW50IGZyb21cbi8vICAgdGhlIGNsaXBib2FyZC4gV2hlbiBub3QgZ2l2ZW4sIHRoZSB2YWx1ZSBvZiB0aGVcbi8vICAgW2Bkb21QYXJzZXJgXSgjdmlldy5FZGl0b3JQcm9wcy5kb21QYXJzZXIpIHByb3AgaXMgdXNlZC5cbi8vXG4vLyAgIHRyYW5zZm9ybVBhc3RlZFRleHQ6OiA/KHRleHQ6IHN0cmluZywgcGxhaW46IGJvb2wpIOKGkiBzdHJpbmdcbi8vICAgVHJhbnNmb3JtIHBhc3RlZCBwbGFpbiB0ZXh0LiBUaGUgYHBsYWluYCBmbGFnIHdpbGwgYmUgdHJ1ZSB3aGVuXG4vLyAgIHRoZSB0ZXh0IGlzIHBhc3RlZCBhcyBwbGFpbiB0ZXh0LlxuLy9cbi8vICAgY2xpcGJvYXJkVGV4dFBhcnNlcjo6ID8odGV4dDogc3RyaW5nLCAkY29udGV4dDogUmVzb2x2ZWRQb3MsIHBsYWluOiBib29sKSDihpIgU2xpY2Vcbi8vICAgQSBmdW5jdGlvbiB0byBwYXJzZSB0ZXh0IGZyb20gdGhlIGNsaXBib2FyZCBpbnRvIGEgZG9jdW1lbnRcbi8vICAgc2xpY2UuIENhbGxlZCBhZnRlclxuLy8gICBbYHRyYW5zZm9ybVBhc3RlZFRleHRgXSgjdmlldy5FZGl0b3JQcm9wcy50cmFuc2Zvcm1QYXN0ZWRUZXh0KS5cbi8vICAgVGhlIGRlZmF1bHQgYmVoYXZpb3IgaXMgdG8gc3BsaXQgdGhlIHRleHQgaW50byBsaW5lcywgd3JhcCB0aGVtXG4vLyAgIGluIGA8cD5gIHRhZ3MsIGFuZCBjYWxsXG4vLyAgIFtgY2xpcGJvYXJkUGFyc2VyYF0oI3ZpZXcuRWRpdG9yUHJvcHMuY2xpcGJvYXJkUGFyc2VyKSBvbiBpdC5cbi8vICAgVGhlIGBwbGFpbmAgZmxhZyB3aWxsIGJlIHRydWUgd2hlbiB0aGUgdGV4dCBpcyBwYXN0ZWQgYXMgcGxhaW4gdGV4dC5cbi8vXG4vLyAgIHRyYW5zZm9ybVBhc3RlZDo6ID8oU2xpY2UpIOKGkiBTbGljZVxuLy8gICBDYW4gYmUgdXNlZCB0byB0cmFuc2Zvcm0gcGFzdGVkIGNvbnRlbnQgYmVmb3JlIGl0IGlzIGFwcGxpZWQgdG9cbi8vICAgdGhlIGRvY3VtZW50LlxuLy9cbi8vICAgbm9kZVZpZXdzOjogP09iamVjdDwobm9kZTogTm9kZSwgdmlldzogRWRpdG9yVmlldywgZ2V0UG9zOiAoKSDihpIgbnVtYmVyLCBkZWNvcmF0aW9uczogW0RlY29yYXRpb25dLCBpbm5lckRlY29yYXRpb25zOiBEZWNvcmF0aW9uU291cmNlKSDihpIgTm9kZVZpZXc+XG4vLyAgIEFsbG93cyB5b3UgdG8gcGFzcyBjdXN0b20gcmVuZGVyaW5nIGFuZCBiZWhhdmlvciBsb2dpYyBmb3Igbm9kZXNcbi8vICAgYW5kIG1hcmtzLiBTaG91bGQgbWFwIG5vZGUgYW5kIG1hcmsgbmFtZXMgdG8gY29uc3RydWN0b3Jcbi8vICAgZnVuY3Rpb25zIHRoYXQgcHJvZHVjZSBhIFtgTm9kZVZpZXdgXSgjdmlldy5Ob2RlVmlldykgb2JqZWN0XG4vLyAgIGltcGxlbWVudGluZyB0aGUgbm9kZSdzIGRpc3BsYXkgYmVoYXZpb3IuIEZvciBub2RlcywgdGhlIHRoaXJkXG4vLyAgIGFyZ3VtZW50IGBnZXRQb3NgIGlzIGEgZnVuY3Rpb24gdGhhdCBjYW4gYmUgY2FsbGVkIHRvIGdldCB0aGVcbi8vICAgbm9kZSdzIGN1cnJlbnQgcG9zaXRpb24sIHdoaWNoIGNhbiBiZSB1c2VmdWwgd2hlbiBjcmVhdGluZ1xuLy8gICB0cmFuc2FjdGlvbnMgdG8gdXBkYXRlIGl0LiBGb3IgbWFya3MsIHRoZSB0aGlyZCBhcmd1bWVudCBpcyBhXG4vLyAgIGJvb2xlYW4gdGhhdCBpbmRpY2F0ZXMgd2hldGhlciB0aGUgbWFyaydzIGNvbnRlbnQgaXMgaW5saW5lLlxuLy9cbi8vICAgYGRlY29yYXRpb25zYCBpcyBhbiBhcnJheSBvZiBub2RlIG9yIGlubGluZSBkZWNvcmF0aW9ucyB0aGF0IGFyZVxuLy8gICBhY3RpdmUgYXJvdW5kIHRoZSBub2RlLiBUaGV5IGFyZSBhdXRvbWF0aWNhbGx5IGRyYXduIGluIHRoZVxuLy8gICBub3JtYWwgd2F5LCBhbmQgeW91IHdpbGwgdXN1YWxseSBqdXN0IHdhbnQgdG8gaWdub3JlIHRoaXMsIGJ1dFxuLy8gICB0aGV5IGNhbiBhbHNvIGJlIHVzZWQgYXMgYSB3YXkgdG8gcHJvdmlkZSBjb250ZXh0IGluZm9ybWF0aW9uIHRvXG4vLyAgIHRoZSBub2RlIHZpZXcgd2l0aG91dCBhZGRpbmcgaXQgdG8gdGhlIGRvY3VtZW50IGl0c2VsZi5cbi8vXG4vLyAgIGBpbm5lckRlY29yYXRpb25zYCBob2xkcyB0aGUgZGVjb3JhdGlvbnMgZm9yIHRoZSBub2RlJ3MgY29udGVudC5cbi8vICAgWW91IGNhbiBzYWZlbHkgaWdub3JlIHRoaXMgaWYgeW91ciB2aWV3IGhhcyBubyBjb250ZW50IG9yIGFcbi8vICAgYGNvbnRlbnRET01gIHByb3BlcnR5LCBzaW5jZSB0aGUgZWRpdG9yIHdpbGwgZHJhdyB0aGUgZGVjb3JhdGlvbnNcbi8vICAgb24gdGhlIGNvbnRlbnQuIEJ1dCBpZiB5b3UsIGZvciBleGFtcGxlLCB3YW50IHRvIGNyZWF0ZSBhIG5lc3RlZFxuLy8gICBlZGl0b3Igd2l0aCB0aGUgY29udGVudCwgaXQgbWF5IG1ha2Ugc2Vuc2UgdG8gcHJvdmlkZSBpdCB3aXRoIHRoZVxuLy8gICBpbm5lciBkZWNvcmF0aW9ucy5cbi8vXG4vLyAgIGNsaXBib2FyZFNlcmlhbGl6ZXI6OiA/RE9NU2VyaWFsaXplclxuLy8gICBUaGUgRE9NIHNlcmlhbGl6ZXIgdG8gdXNlIHdoZW4gcHV0dGluZyBjb250ZW50IG9udG8gdGhlXG4vLyAgIGNsaXBib2FyZC4gSWYgbm90IGdpdmVuLCB0aGUgcmVzdWx0IG9mXG4vLyAgIFtgRE9NU2VyaWFsaXplci5mcm9tU2NoZW1hYF0oI21vZGVsLkRPTVNlcmlhbGl6ZXJeZnJvbVNjaGVtYSlcbi8vICAgd2lsbCBiZSB1c2VkLlxuLy9cbi8vICAgY2xpcGJvYXJkVGV4dFNlcmlhbGl6ZXI6OiA/KFNsaWNlKSDihpIgc3RyaW5nXG4vLyAgIEEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB0byBnZXQgdGhlIHRleHQgZm9yIHRoZSBjdXJyZW50XG4vLyAgIHNlbGVjdGlvbiB3aGVuIGNvcHlpbmcgdGV4dCB0byB0aGUgY2xpcGJvYXJkLiBCeSBkZWZhdWx0LCB0aGVcbi8vICAgZWRpdG9yIHdpbGwgdXNlIFtgdGV4dEJldHdlZW5gXSgjbW9kZWwuTm9kZS50ZXh0QmV0d2Vlbikgb24gdGhlXG4vLyAgIHNlbGVjdGVkIHJhbmdlLlxuLy9cbi8vICAgZGVjb3JhdGlvbnM6OiA/KHN0YXRlOiBFZGl0b3JTdGF0ZSkg4oaSID9EZWNvcmF0aW9uU291cmNlXG4vLyAgIEEgc2V0IG9mIFtkb2N1bWVudCBkZWNvcmF0aW9uc10oI3ZpZXcuRGVjb3JhdGlvbikgdG8gc2hvdyBpbiB0aGVcbi8vICAgdmlldy5cbi8vXG4vLyAgIGVkaXRhYmxlOjogPyhzdGF0ZTogRWRpdG9yU3RhdGUpIOKGkiBib29sXG4vLyAgIFdoZW4gdGhpcyByZXR1cm5zIGZhbHNlLCB0aGUgY29udGVudCBvZiB0aGUgdmlldyBpcyBub3QgZGlyZWN0bHlcbi8vICAgZWRpdGFibGUuXG4vL1xuLy8gICBhdHRyaWJ1dGVzOjogP3VuaW9uPE9iamVjdDxzdHJpbmc+LCAoRWRpdG9yU3RhdGUpIOKGkiA/T2JqZWN0PHN0cmluZz4+XG4vLyAgIENvbnRyb2wgdGhlIERPTSBhdHRyaWJ1dGVzIG9mIHRoZSBlZGl0YWJsZSBlbGVtZW50LiBNYXkgYmUgZWl0aGVyXG4vLyAgIGFuIG9iamVjdCBvciBhIGZ1bmN0aW9uIGdvaW5nIGZyb20gYW4gZWRpdG9yIHN0YXRlIHRvIGFuIG9iamVjdC5cbi8vICAgQnkgZGVmYXVsdCwgdGhlIGVsZW1lbnQgd2lsbCBnZXQgYSBjbGFzcyBgXCJQcm9zZU1pcnJvclwiYCwgYW5kXG4vLyAgIHdpbGwgaGF2ZSBpdHMgYGNvbnRlbnRFZGl0YWJsZWAgYXR0cmlidXRlIGRldGVybWluZWQgYnkgdGhlXG4vLyAgIFtgZWRpdGFibGVgIHByb3BdKCN2aWV3LkVkaXRvclByb3BzLmVkaXRhYmxlKS4gQWRkaXRpb25hbCBjbGFzc2VzXG4vLyAgIHByb3ZpZGVkIGhlcmUgd2lsbCBiZSBhZGRlZCB0byB0aGUgY2xhc3MuIEZvciBvdGhlciBhdHRyaWJ1dGVzLFxuLy8gICB0aGUgdmFsdWUgcHJvdmlkZWQgZmlyc3QgKGFzIGluXG4vLyAgIFtgc29tZVByb3BgXSgjdmlldy5FZGl0b3JWaWV3LnNvbWVQcm9wKSkgd2lsbCBiZSB1c2VkLlxuLy9cbi8vICAgc2Nyb2xsVGhyZXNob2xkOjogP3VuaW9uPG51bWJlciwge3RvcDogbnVtYmVyLCByaWdodDogbnVtYmVyLCBib3R0b206IG51bWJlciwgbGVmdDogbnVtYmVyfT5cbi8vICAgRGV0ZXJtaW5lcyB0aGUgZGlzdGFuY2UgKGluIHBpeGVscykgYmV0d2VlbiB0aGUgY3Vyc29yIGFuZCB0aGVcbi8vICAgZW5kIG9mIHRoZSB2aXNpYmxlIHZpZXdwb3J0IGF0IHdoaWNoIHBvaW50LCB3aGVuIHNjcm9sbGluZyB0aGVcbi8vICAgY3Vyc29yIGludG8gdmlldywgc2Nyb2xsaW5nIHRha2VzIHBsYWNlLiBEZWZhdWx0cyB0byAwLlxuLy9cbi8vICAgc2Nyb2xsTWFyZ2luOjogP3VuaW9uPG51bWJlciwge3RvcDogbnVtYmVyLCByaWdodDogbnVtYmVyLCBib3R0b206IG51bWJlciwgbGVmdDogbnVtYmVyfT5cbi8vICAgRGV0ZXJtaW5lcyB0aGUgZXh0cmEgc3BhY2UgKGluIHBpeGVscykgdGhhdCBpcyBsZWZ0IGFib3ZlIG9yXG4vLyAgIGJlbG93IHRoZSBjdXJzb3Igd2hlbiBpdCBpcyBzY3JvbGxlZCBpbnRvIHZpZXcuIERlZmF1bHRzIHRvIDUuXG5cbi8vIERpcmVjdEVkaXRvclByb3BzOjogaW50ZXJmYWNlIGV4dGVuZHMgRWRpdG9yUHJvcHNcbi8vXG4vLyBUaGUgcHJvcHMgb2JqZWN0IGdpdmVuIGRpcmVjdGx5IHRvIHRoZSBlZGl0b3IgdmlldyBzdXBwb3J0cyB0d29cbi8vIGZpZWxkcyB0aGF0IGNhbid0IGJlIHVzZWQgaW4gcGx1Z2luczpcbi8vXG4vLyAgIHN0YXRlOjogRWRpdG9yU3RhdGVcbi8vICAgVGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGVkaXRvci5cbi8vXG4vLyAgIHBsdWdpbnM6OiBbUGx1Z2luXVxuLy8gICBBIHNldCBvZiBwbHVnaW5zIHRvIHVzZSBpbiB0aGUgdmlldywgYXBwbHlpbmcgdGhlaXIgW3BsdWdpblxuLy8gICB2aWV3XSgjc3RhdGUuUGx1Z2luU3BlYy52aWV3KSBhbmRcbi8vICAgW3Byb3BzXSgjc3RhdGUuUGx1Z2luU3BlYy5wcm9wcykuIFBhc3NpbmcgcGx1Z2lucyB3aXRoIGEgc3RhdGVcbi8vICAgY29tcG9uZW50IChhIFtzdGF0ZSBmaWVsZF0oI3N0YXRlLlBsdWdpblNwZWMuc3RhdGUpIGZpZWxkIG9yIGFcbi8vICAgW3RyYW5zYWN0aW9uKVsjc3RhdGUuUGx1Z2luU3BlYy5maWx0ZXJUcmFuc2FjdGlvbl0gZmlsdGVyIG9yXG4vLyAgIGFwcGVuZGVyKSB3aWxsIHJlc3VsdCBpbiBhbiBlcnJvciwgc2luY2Ugc3VjaCBwbHVnaW5zIG11c3QgYmVcbi8vICAgcHJlc2VudCBpbiB0aGUgc3RhdGUgdG8gd29yay5cbi8vXG4vLyAgIGRpc3BhdGNoVHJhbnNhY3Rpb246OiA/KHRyOiBUcmFuc2FjdGlvbilcbi8vICAgVGhlIGNhbGxiYWNrIG92ZXIgd2hpY2ggdG8gc2VuZCB0cmFuc2FjdGlvbnMgKHN0YXRlIHVwZGF0ZXMpXG4vLyAgIHByb2R1Y2VkIGJ5IHRoZSB2aWV3LiBJZiB5b3Ugc3BlY2lmeSB0aGlzLCB5b3UgcHJvYmFibHkgd2FudCB0b1xuLy8gICBtYWtlIHN1cmUgdGhpcyBlbmRzIHVwIGNhbGxpbmcgdGhlIHZpZXcnc1xuLy8gICBbYHVwZGF0ZVN0YXRlYF0oI3ZpZXcuRWRpdG9yVmlldy51cGRhdGVTdGF0ZSkgbWV0aG9kIHdpdGggYSBuZXdcbi8vICAgc3RhdGUgdGhhdCBoYXMgdGhlIHRyYW5zYWN0aW9uXG4vLyAgIFthcHBsaWVkXSgjc3RhdGUuRWRpdG9yU3RhdGUuYXBwbHkpLiBUaGUgY2FsbGJhY2sgd2lsbCBiZSBib3VuZCB0byBoYXZlXG4vLyAgIHRoZSB2aWV3IGluc3RhbmNlIGFzIGl0cyBgdGhpc2AgYmluZGluZy5cblxuZXhwb3J0IHsgRGVjb3JhdGlvbiwgRGVjb3JhdGlvblNldCwgRWRpdG9yVmlldywgZW5kQ29tcG9zaXRpb24gYXMgX19lbmRDb21wb3NpdGlvbiwgcGFyc2VGcm9tQ2xpcGJvYXJkIGFzIF9fcGFyc2VGcm9tQ2xpcGJvYXJkLCBzZXJpYWxpemVGb3JDbGlwYm9hcmQgYXMgX19zZXJpYWxpemVGb3JDbGlwYm9hcmQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzLmpzLm1hcFxuIiwidmFyIEdPT0RfTEVBRl9TSVpFID0gMjAwO1xuXG4vLyA6OiBjbGFzczxUPiBBIHJvcGUgc2VxdWVuY2UgaXMgYSBwZXJzaXN0ZW50IHNlcXVlbmNlIGRhdGEgc3RydWN0dXJlXG4vLyB0aGF0IHN1cHBvcnRzIGFwcGVuZGluZywgcHJlcGVuZGluZywgYW5kIHNsaWNpbmcgd2l0aG91dCBkb2luZyBhXG4vLyBmdWxsIGNvcHkuIEl0IGlzIHJlcHJlc2VudGVkIGFzIGEgbW9zdGx5LWJhbGFuY2VkIHRyZWUuXG52YXIgUm9wZVNlcXVlbmNlID0gZnVuY3Rpb24gUm9wZVNlcXVlbmNlICgpIHt9O1xuXG5Sb3BlU2VxdWVuY2UucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIGFwcGVuZCAob3RoZXIpIHtcbiAgaWYgKCFvdGhlci5sZW5ndGgpIHsgcmV0dXJuIHRoaXMgfVxuICBvdGhlciA9IFJvcGVTZXF1ZW5jZS5mcm9tKG90aGVyKTtcblxuICByZXR1cm4gKCF0aGlzLmxlbmd0aCAmJiBvdGhlcikgfHxcbiAgICAob3RoZXIubGVuZ3RoIDwgR09PRF9MRUFGX1NJWkUgJiYgdGhpcy5sZWFmQXBwZW5kKG90aGVyKSkgfHxcbiAgICAodGhpcy5sZW5ndGggPCBHT09EX0xFQUZfU0laRSAmJiBvdGhlci5sZWFmUHJlcGVuZCh0aGlzKSkgfHxcbiAgICB0aGlzLmFwcGVuZElubmVyKG90aGVyKVxufTtcblxuLy8gOjogKHVuaW9uPFtUXSwgUm9wZVNlcXVlbmNlPFQ+Pikg4oaSIFJvcGVTZXF1ZW5jZTxUPlxuLy8gUHJlcGVuZCBhbiBhcnJheSBvciBvdGhlciByb3BlIHRvIHRoaXMgb25lLCByZXR1cm5pbmcgYSBuZXcgcm9wZS5cblJvcGVTZXF1ZW5jZS5wcm90b3R5cGUucHJlcGVuZCA9IGZ1bmN0aW9uIHByZXBlbmQgKG90aGVyKSB7XG4gIGlmICghb3RoZXIubGVuZ3RoKSB7IHJldHVybiB0aGlzIH1cbiAgcmV0dXJuIFJvcGVTZXF1ZW5jZS5mcm9tKG90aGVyKS5hcHBlbmQodGhpcylcbn07XG5cblJvcGVTZXF1ZW5jZS5wcm90b3R5cGUuYXBwZW5kSW5uZXIgPSBmdW5jdGlvbiBhcHBlbmRJbm5lciAob3RoZXIpIHtcbiAgcmV0dXJuIG5ldyBBcHBlbmQodGhpcywgb3RoZXIpXG59O1xuXG4vLyA6OiAoP251bWJlciwgP251bWJlcikg4oaSIFJvcGVTZXF1ZW5jZTxUPlxuLy8gQ3JlYXRlIGEgcm9wZSByZXBlc2VudGluZyBhIHN1Yi1zZXF1ZW5jZSBvZiB0aGlzIHJvcGUuXG5Sb3BlU2VxdWVuY2UucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKGZyb20sIHRvKSB7XG4gICAgaWYgKCBmcm9tID09PSB2b2lkIDAgKSBmcm9tID0gMDtcbiAgICBpZiAoIHRvID09PSB2b2lkIDAgKSB0byA9IHRoaXMubGVuZ3RoO1xuXG4gIGlmIChmcm9tID49IHRvKSB7IHJldHVybiBSb3BlU2VxdWVuY2UuZW1wdHkgfVxuICByZXR1cm4gdGhpcy5zbGljZUlubmVyKE1hdGgubWF4KDAsIGZyb20pLCBNYXRoLm1pbih0aGlzLmxlbmd0aCwgdG8pKVxufTtcblxuLy8gOjogKG51bWJlcikg4oaSIFRcbi8vIFJldHJpZXZlIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBwb3NpdGlvbiBmcm9tIHRoaXMgcm9wZS5cblJvcGVTZXF1ZW5jZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChpKSB7XG4gIGlmIChpIDwgMCB8fCBpID49IHRoaXMubGVuZ3RoKSB7IHJldHVybiB1bmRlZmluZWQgfVxuICByZXR1cm4gdGhpcy5nZXRJbm5lcihpKVxufTtcblxuLy8gOjogKChlbGVtZW50OiBULCBpbmRleDogbnVtYmVyKSDihpIgP2Jvb2wsID9udW1iZXIsID9udW1iZXIpXG4vLyBDYWxsIHRoZSBnaXZlbiBmdW5jdGlvbiBmb3IgZWFjaCBlbGVtZW50IGJldHdlZW4gdGhlIGdpdmVuXG4vLyBpbmRpY2VzLiBUaGlzIHRlbmRzIHRvIGJlIG1vcmUgZWZmaWNpZW50IHRoYW4gbG9vcGluZyBvdmVyIHRoZVxuLy8gaW5kaWNlcyBhbmQgY2FsbGluZyBgZ2V0YCwgYmVjYXVzZSBpdCBkb2Vzbid0IGhhdmUgdG8gZGVzY2VuZCB0aGVcbi8vIHRyZWUgZm9yIGV2ZXJ5IGVsZW1lbnQuXG5Sb3BlU2VxdWVuY2UucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoIChmLCBmcm9tLCB0bykge1xuICAgIGlmICggZnJvbSA9PT0gdm9pZCAwICkgZnJvbSA9IDA7XG4gICAgaWYgKCB0byA9PT0gdm9pZCAwICkgdG8gPSB0aGlzLmxlbmd0aDtcblxuICBpZiAoZnJvbSA8PSB0bylcbiAgICB7IHRoaXMuZm9yRWFjaElubmVyKGYsIGZyb20sIHRvLCAwKTsgfVxuICBlbHNlXG4gICAgeyB0aGlzLmZvckVhY2hJbnZlcnRlZElubmVyKGYsIGZyb20sIHRvLCAwKTsgfVxufTtcblxuLy8gOjogKChlbGVtZW50OiBULCBpbmRleDogbnVtYmVyKSDihpIgVSwgP251bWJlciwgP251bWJlcikg4oaSIFtVXVxuLy8gTWFwIHRoZSBnaXZlbiBmdW5jdGlvbnMgb3ZlciB0aGUgZWxlbWVudHMgb2YgdGhlIHJvcGUsIHByb2R1Y2luZ1xuLy8gYSBmbGF0IGFycmF5LlxuUm9wZVNlcXVlbmNlLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiBtYXAgKGYsIGZyb20sIHRvKSB7XG4gICAgaWYgKCBmcm9tID09PSB2b2lkIDAgKSBmcm9tID0gMDtcbiAgICBpZiAoIHRvID09PSB2b2lkIDAgKSB0byA9IHRoaXMubGVuZ3RoO1xuXG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uIChlbHQsIGkpIHsgcmV0dXJuIHJlc3VsdC5wdXNoKGYoZWx0LCBpKSk7IH0sIGZyb20sIHRvKTtcbiAgcmV0dXJuIHJlc3VsdFxufTtcblxuLy8gOjogKD91bmlvbjxbVF0sIFJvcGVTZXF1ZW5jZTxUPj4pIOKGkiBSb3BlU2VxdWVuY2U8VD5cbi8vIENyZWF0ZSBhIHJvcGUgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiBhcnJheSwgb3IgcmV0dXJuIHRoZSByb3BlXG4vLyBpdHNlbGYgaWYgYSByb3BlIHdhcyBnaXZlbi5cblJvcGVTZXF1ZW5jZS5mcm9tID0gZnVuY3Rpb24gZnJvbSAodmFsdWVzKSB7XG4gIGlmICh2YWx1ZXMgaW5zdGFuY2VvZiBSb3BlU2VxdWVuY2UpIHsgcmV0dXJuIHZhbHVlcyB9XG4gIHJldHVybiB2YWx1ZXMgJiYgdmFsdWVzLmxlbmd0aCA/IG5ldyBMZWFmKHZhbHVlcykgOiBSb3BlU2VxdWVuY2UuZW1wdHlcbn07XG5cbnZhciBMZWFmID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoUm9wZVNlcXVlbmNlKSB7XG4gIGZ1bmN0aW9uIExlYWYodmFsdWVzKSB7XG4gICAgUm9wZVNlcXVlbmNlLmNhbGwodGhpcyk7XG4gICAgdGhpcy52YWx1ZXMgPSB2YWx1ZXM7XG4gIH1cblxuICBpZiAoIFJvcGVTZXF1ZW5jZSApIExlYWYuX19wcm90b19fID0gUm9wZVNlcXVlbmNlO1xuICBMZWFmLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFJvcGVTZXF1ZW5jZSAmJiBSb3BlU2VxdWVuY2UucHJvdG90eXBlICk7XG4gIExlYWYucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGVhZjtcblxuICB2YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBsZW5ndGg6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sZGVwdGg6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxuICBMZWFmLnByb3RvdHlwZS5mbGF0dGVuID0gZnVuY3Rpb24gZmxhdHRlbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVzXG4gIH07XG5cbiAgTGVhZi5wcm90b3R5cGUuc2xpY2VJbm5lciA9IGZ1bmN0aW9uIHNsaWNlSW5uZXIgKGZyb20sIHRvKSB7XG4gICAgaWYgKGZyb20gPT0gMCAmJiB0byA9PSB0aGlzLmxlbmd0aCkgeyByZXR1cm4gdGhpcyB9XG4gICAgcmV0dXJuIG5ldyBMZWFmKHRoaXMudmFsdWVzLnNsaWNlKGZyb20sIHRvKSlcbiAgfTtcblxuICBMZWFmLnByb3RvdHlwZS5nZXRJbm5lciA9IGZ1bmN0aW9uIGdldElubmVyIChpKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVzW2ldXG4gIH07XG5cbiAgTGVhZi5wcm90b3R5cGUuZm9yRWFjaElubmVyID0gZnVuY3Rpb24gZm9yRWFjaElubmVyIChmLCBmcm9tLCB0bywgc3RhcnQpIHtcbiAgICBmb3IgKHZhciBpID0gZnJvbTsgaSA8IHRvOyBpKyspXG4gICAgICB7IGlmIChmKHRoaXMudmFsdWVzW2ldLCBzdGFydCArIGkpID09PSBmYWxzZSkgeyByZXR1cm4gZmFsc2UgfSB9XG4gIH07XG5cbiAgTGVhZi5wcm90b3R5cGUuZm9yRWFjaEludmVydGVkSW5uZXIgPSBmdW5jdGlvbiBmb3JFYWNoSW52ZXJ0ZWRJbm5lciAoZiwgZnJvbSwgdG8sIHN0YXJ0KSB7XG4gICAgZm9yICh2YXIgaSA9IGZyb20gLSAxOyBpID49IHRvOyBpLS0pXG4gICAgICB7IGlmIChmKHRoaXMudmFsdWVzW2ldLCBzdGFydCArIGkpID09PSBmYWxzZSkgeyByZXR1cm4gZmFsc2UgfSB9XG4gIH07XG5cbiAgTGVhZi5wcm90b3R5cGUubGVhZkFwcGVuZCA9IGZ1bmN0aW9uIGxlYWZBcHBlbmQgKG90aGVyKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoICsgb3RoZXIubGVuZ3RoIDw9IEdPT0RfTEVBRl9TSVpFKVxuICAgICAgeyByZXR1cm4gbmV3IExlYWYodGhpcy52YWx1ZXMuY29uY2F0KG90aGVyLmZsYXR0ZW4oKSkpIH1cbiAgfTtcblxuICBMZWFmLnByb3RvdHlwZS5sZWFmUHJlcGVuZCA9IGZ1bmN0aW9uIGxlYWZQcmVwZW5kIChvdGhlcikge1xuICAgIGlmICh0aGlzLmxlbmd0aCArIG90aGVyLmxlbmd0aCA8PSBHT09EX0xFQUZfU0laRSlcbiAgICAgIHsgcmV0dXJuIG5ldyBMZWFmKG90aGVyLmZsYXR0ZW4oKS5jb25jYXQodGhpcy52YWx1ZXMpKSB9XG4gIH07XG5cbiAgcHJvdG90eXBlQWNjZXNzb3JzLmxlbmd0aC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnZhbHVlcy5sZW5ndGggfTtcblxuICBwcm90b3R5cGVBY2Nlc3NvcnMuZGVwdGguZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMCB9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBMZWFmLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzICk7XG5cbiAgcmV0dXJuIExlYWY7XG59KFJvcGVTZXF1ZW5jZSkpO1xuXG4vLyA6OiBSb3BlU2VxdWVuY2Vcbi8vIFRoZSBlbXB0eSByb3BlIHNlcXVlbmNlLlxuUm9wZVNlcXVlbmNlLmVtcHR5ID0gbmV3IExlYWYoW10pO1xuXG52YXIgQXBwZW5kID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoUm9wZVNlcXVlbmNlKSB7XG4gIGZ1bmN0aW9uIEFwcGVuZChsZWZ0LCByaWdodCkge1xuICAgIFJvcGVTZXF1ZW5jZS5jYWxsKHRoaXMpO1xuICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgIHRoaXMubGVuZ3RoID0gbGVmdC5sZW5ndGggKyByaWdodC5sZW5ndGg7XG4gICAgdGhpcy5kZXB0aCA9IE1hdGgubWF4KGxlZnQuZGVwdGgsIHJpZ2h0LmRlcHRoKSArIDE7XG4gIH1cblxuICBpZiAoIFJvcGVTZXF1ZW5jZSApIEFwcGVuZC5fX3Byb3RvX18gPSBSb3BlU2VxdWVuY2U7XG4gIEFwcGVuZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBSb3BlU2VxdWVuY2UgJiYgUm9wZVNlcXVlbmNlLnByb3RvdHlwZSApO1xuICBBcHBlbmQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQXBwZW5kO1xuXG4gIEFwcGVuZC5wcm90b3R5cGUuZmxhdHRlbiA9IGZ1bmN0aW9uIGZsYXR0ZW4gKCkge1xuICAgIHJldHVybiB0aGlzLmxlZnQuZmxhdHRlbigpLmNvbmNhdCh0aGlzLnJpZ2h0LmZsYXR0ZW4oKSlcbiAgfTtcblxuICBBcHBlbmQucHJvdG90eXBlLmdldElubmVyID0gZnVuY3Rpb24gZ2V0SW5uZXIgKGkpIHtcbiAgICByZXR1cm4gaSA8IHRoaXMubGVmdC5sZW5ndGggPyB0aGlzLmxlZnQuZ2V0KGkpIDogdGhpcy5yaWdodC5nZXQoaSAtIHRoaXMubGVmdC5sZW5ndGgpXG4gIH07XG5cbiAgQXBwZW5kLnByb3RvdHlwZS5mb3JFYWNoSW5uZXIgPSBmdW5jdGlvbiBmb3JFYWNoSW5uZXIgKGYsIGZyb20sIHRvLCBzdGFydCkge1xuICAgIHZhciBsZWZ0TGVuID0gdGhpcy5sZWZ0Lmxlbmd0aDtcbiAgICBpZiAoZnJvbSA8IGxlZnRMZW4gJiZcbiAgICAgICAgdGhpcy5sZWZ0LmZvckVhY2hJbm5lcihmLCBmcm9tLCBNYXRoLm1pbih0bywgbGVmdExlbiksIHN0YXJ0KSA9PT0gZmFsc2UpXG4gICAgICB7IHJldHVybiBmYWxzZSB9XG4gICAgaWYgKHRvID4gbGVmdExlbiAmJlxuICAgICAgICB0aGlzLnJpZ2h0LmZvckVhY2hJbm5lcihmLCBNYXRoLm1heChmcm9tIC0gbGVmdExlbiwgMCksIE1hdGgubWluKHRoaXMubGVuZ3RoLCB0bykgLSBsZWZ0TGVuLCBzdGFydCArIGxlZnRMZW4pID09PSBmYWxzZSlcbiAgICAgIHsgcmV0dXJuIGZhbHNlIH1cbiAgfTtcblxuICBBcHBlbmQucHJvdG90eXBlLmZvckVhY2hJbnZlcnRlZElubmVyID0gZnVuY3Rpb24gZm9yRWFjaEludmVydGVkSW5uZXIgKGYsIGZyb20sIHRvLCBzdGFydCkge1xuICAgIHZhciBsZWZ0TGVuID0gdGhpcy5sZWZ0Lmxlbmd0aDtcbiAgICBpZiAoZnJvbSA+IGxlZnRMZW4gJiZcbiAgICAgICAgdGhpcy5yaWdodC5mb3JFYWNoSW52ZXJ0ZWRJbm5lcihmLCBmcm9tIC0gbGVmdExlbiwgTWF0aC5tYXgodG8sIGxlZnRMZW4pIC0gbGVmdExlbiwgc3RhcnQgKyBsZWZ0TGVuKSA9PT0gZmFsc2UpXG4gICAgICB7IHJldHVybiBmYWxzZSB9XG4gICAgaWYgKHRvIDwgbGVmdExlbiAmJlxuICAgICAgICB0aGlzLmxlZnQuZm9yRWFjaEludmVydGVkSW5uZXIoZiwgTWF0aC5taW4oZnJvbSwgbGVmdExlbiksIHRvLCBzdGFydCkgPT09IGZhbHNlKVxuICAgICAgeyByZXR1cm4gZmFsc2UgfVxuICB9O1xuXG4gIEFwcGVuZC5wcm90b3R5cGUuc2xpY2VJbm5lciA9IGZ1bmN0aW9uIHNsaWNlSW5uZXIgKGZyb20sIHRvKSB7XG4gICAgaWYgKGZyb20gPT0gMCAmJiB0byA9PSB0aGlzLmxlbmd0aCkgeyByZXR1cm4gdGhpcyB9XG4gICAgdmFyIGxlZnRMZW4gPSB0aGlzLmxlZnQubGVuZ3RoO1xuICAgIGlmICh0byA8PSBsZWZ0TGVuKSB7IHJldHVybiB0aGlzLmxlZnQuc2xpY2UoZnJvbSwgdG8pIH1cbiAgICBpZiAoZnJvbSA+PSBsZWZ0TGVuKSB7IHJldHVybiB0aGlzLnJpZ2h0LnNsaWNlKGZyb20gLSBsZWZ0TGVuLCB0byAtIGxlZnRMZW4pIH1cbiAgICByZXR1cm4gdGhpcy5sZWZ0LnNsaWNlKGZyb20sIGxlZnRMZW4pLmFwcGVuZCh0aGlzLnJpZ2h0LnNsaWNlKDAsIHRvIC0gbGVmdExlbikpXG4gIH07XG5cbiAgQXBwZW5kLnByb3RvdHlwZS5sZWFmQXBwZW5kID0gZnVuY3Rpb24gbGVhZkFwcGVuZCAob3RoZXIpIHtcbiAgICB2YXIgaW5uZXIgPSB0aGlzLnJpZ2h0LmxlYWZBcHBlbmQob3RoZXIpO1xuICAgIGlmIChpbm5lcikgeyByZXR1cm4gbmV3IEFwcGVuZCh0aGlzLmxlZnQsIGlubmVyKSB9XG4gIH07XG5cbiAgQXBwZW5kLnByb3RvdHlwZS5sZWFmUHJlcGVuZCA9IGZ1bmN0aW9uIGxlYWZQcmVwZW5kIChvdGhlcikge1xuICAgIHZhciBpbm5lciA9IHRoaXMubGVmdC5sZWFmUHJlcGVuZChvdGhlcik7XG4gICAgaWYgKGlubmVyKSB7IHJldHVybiBuZXcgQXBwZW5kKGlubmVyLCB0aGlzLnJpZ2h0KSB9XG4gIH07XG5cbiAgQXBwZW5kLnByb3RvdHlwZS5hcHBlbmRJbm5lciA9IGZ1bmN0aW9uIGFwcGVuZElubmVyIChvdGhlcikge1xuICAgIGlmICh0aGlzLmxlZnQuZGVwdGggPj0gTWF0aC5tYXgodGhpcy5yaWdodC5kZXB0aCwgb3RoZXIuZGVwdGgpICsgMSlcbiAgICAgIHsgcmV0dXJuIG5ldyBBcHBlbmQodGhpcy5sZWZ0LCBuZXcgQXBwZW5kKHRoaXMucmlnaHQsIG90aGVyKSkgfVxuICAgIHJldHVybiBuZXcgQXBwZW5kKHRoaXMsIG90aGVyKVxuICB9O1xuXG4gIHJldHVybiBBcHBlbmQ7XG59KFJvcGVTZXF1ZW5jZSkpO1xuXG52YXIgcm9wZVNlcXVlbmNlID0gUm9wZVNlcXVlbmNlO1xuXG5leHBvcnQgZGVmYXVsdCByb3BlU2VxdWVuY2U7XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBpbXBvcnQvbm8tZXh0cmFuZW91cy1kZXBlbmRlbmNpZXMgKi9cbmltcG9ydCB7IEVkaXRvclN0YXRlIH0gZnJvbSAncHJvc2VtaXJyb3Itc3RhdGUnO1xuaW1wb3J0IHsgRWRpdG9yVmlldyB9IGZyb20gJ3Byb3NlbWlycm9yLXZpZXcnO1xuaW1wb3J0IHsgRE9NUGFyc2VyIH0gZnJvbSAncHJvc2VtaXJyb3ItbW9kZWwnO1xuaW1wb3J0IHsgc2NoZW1hIH0gZnJvbSAncHJvc2VtaXJyb3Itc2NoZW1hLWJhc2ljJztcbmltcG9ydCB7IGV4YW1wbGVTZXR1cCB9IGZyb20gJ3Byb3NlbWlycm9yLWV4YW1wbGUtc2V0dXAnO1xuaW1wb3J0IGF1dG9jb21wbGV0ZSwgeyBPcHRpb25zIH0gZnJvbSAnLi4vc3JjJztcbmltcG9ydCB7IHJlZHVjZXIgfSBmcm9tICcuL3JlZHVjZXInO1xuXG5jb25zdCBlZGl0b3IgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjZWRpdG9yJykgYXMgSFRNTERpdkVsZW1lbnQ7XG5jb25zdCBjb250ZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2NvbnRlbnQnKSBhcyBIVE1MRGl2RWxlbWVudDtcblxuY29uc3Qgb3B0aW9uczogT3B0aW9ucyA9IHtcbiAgcmVkdWNlcixcbiAgdHJpZ2dlcnM6IFtcbiAgICAvLyBGb3IgZGVtbyBwdXJwb3NlcywgbWFrZSB0aGUgYCNgIGFuZCBgQGAgZWFzaWVyIHRvIGNyZWF0ZVxuICAgIHsgbmFtZTogJ2hhc2h0YWcnLCB0cmlnZ2VyOiAvKCMpJC8gfSxcbiAgICB7IG5hbWU6ICdtZW50aW9uJywgdHJpZ2dlcjogLyhAKSQvIH0sXG4gICAgeyBuYW1lOiAnZW1vamknLCB0cmlnZ2VyOiAnOicgfSxcbiAgICB7IG5hbWU6ICdsaW5rJywgdHJpZ2dlcjogJ1tbJywgY2FuY2VsT25GaXJzdFNwYWNlOiBmYWxzZSB9LFxuICAgIHsgbmFtZTogJ2ppbmphJywgdHJpZ2dlcjogJ3t7JywgY2FuY2VsT25GaXJzdFNwYWNlOiBmYWxzZSB9LFxuICAgIHsgbmFtZTogJ2NvbW1hbmQnLCB0cmlnZ2VyOiAnLycsIGRlY29yYXRpb25BdHRyczogeyBjbGFzczogJ2NvbW1hbmQnIH0gfSxcbiAgICB7IG5hbWU6ICd2YXJpYWJsZScsIHRyaWdnZXI6IC8oKD86XlthLXpBLVowLTlfXSspXFxzPz0pJC8sIGNhbmNlbE9uRmlyc3RTcGFjZTogZmFsc2UgfSxcbiAgICB7IG5hbWU6ICdjb2RlJywgdHJpZ2dlcjogLygoPzpbYS16QS1aMC05X10rKVxcLikkLyB9LFxuICBdLFxufTtcblxuKHdpbmRvdyBhcyBhbnkpLnZpZXcgPSBuZXcgRWRpdG9yVmlldyhlZGl0b3IsIHtcbiAgc3RhdGU6IEVkaXRvclN0YXRlLmNyZWF0ZSh7XG4gICAgZG9jOiBET01QYXJzZXIuZnJvbVNjaGVtYShzY2hlbWEpLnBhcnNlKGNvbnRlbnQpLFxuICAgIHBsdWdpbnM6IFsuLi5hdXRvY29tcGxldGUob3B0aW9ucyksIC4uLmV4YW1wbGVTZXR1cCh7IHNjaGVtYSwgbWVudUJhcjogZmFsc2UgfSldLFxuICB9KSxcbn0pO1xuIiwiaW1wb3J0IHsgRWRpdG9yVmlldyB9IGZyb20gJ3Byb3NlbWlycm9yLXZpZXcnO1xuaW1wb3J0IHsgQWN0aW9uS2luZCwgQXV0b2NvbXBsZXRlQWN0aW9uLCBERUZBVUxUX0lELCBGcm9tVG8gfSBmcm9tICcuLi9zcmMnO1xuaW1wb3J0IHsgY2xvc2VBdXRvY29tcGxldGUgfSBmcm9tICcuLi9zcmMvYWN0aW9ucyc7XG5cbmNvbnN0IHN1Z2dlc3Rpb24gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjc3VnZ2VzdGlvbicpIGFzIEhUTUxEaXZFbGVtZW50O1xuY29uc3QgaW5mbyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNpbmZvJykgYXMgSFRNTERpdkVsZW1lbnQ7XG5cbmNvbnN0IHBpY2tlciA9IHtcbiAgdmlldzogbnVsbCBhcyBFZGl0b3JWaWV3IHwgbnVsbCxcbiAgb3BlbjogZmFsc2UsXG4gIGN1cnJlbnQ6IDAsXG4gIHJhbmdlOiBudWxsIGFzIEZyb21UbyB8IG51bGwsXG59O1xuXG5jb25zdCBOVU1fU1VHR0VTVElPTlMgPSBzdWdnZXN0aW9uLmNoaWxkcmVuLmxlbmd0aDtcblxuZnVuY3Rpb24gc2V0SW5mbyhhY3Rpb246IEF1dG9jb21wbGV0ZUFjdGlvbikge1xuICBpbmZvLmlubmVyVGV4dCA9IGBBY3Rpb246ICR7YWN0aW9uLmtpbmR9LCBSYW5nZTogJHthY3Rpb24ucmFuZ2UuZnJvbX0tJHthY3Rpb24ucmFuZ2UudG99LCBGaWx0ZXI6ICR7YWN0aW9uLmZpbHRlcn0sIFRyaWdnZXI6ICR7YWN0aW9uLnRyaWdnZXJ9LCBUeXBlOiAke2FjdGlvbi50eXBlPy5uYW1lfWA7XG59XG5cbmZ1bmN0aW9uIHBsYWNlU3VnZ2VzdGlvbigpIHtcbiAgc3VnZ2VzdGlvbi5zdHlsZS5kaXNwbGF5ID0gcGlja2VyLm9wZW4gPyAnYmxvY2snIDogJ25vbmUnO1xuICBjb25zdCByZWN0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoREVGQVVMVF9JRCk/LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBpZiAoIXJlY3QpIHJldHVybjtcbiAgc3VnZ2VzdGlvbi5zdHlsZS50b3AgPSBgJHtyZWN0LnRvcCArIHJlY3QuaGVpZ2h0fXB4YDtcbiAgc3VnZ2VzdGlvbi5zdHlsZS5sZWZ0ID0gYCR7cmVjdC5sZWZ0fXB4YDtcbiAgW10uZm9yRWFjaC5jYWxsKHN1Z2dlc3Rpb24uY2hpbGRyZW4sIChpdGVtOiBIVE1MRGl2RWxlbWVudCwgaSkgPT4ge1xuICAgIGl0ZW0uY2xhc3NMaXN0W2kgPT09IHBpY2tlci5jdXJyZW50ID8gJ2FkZCcgOiAncmVtb3ZlJ10oJ3NlbGVjdGVkJyk7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVkdWNlcihhY3Rpb246IEF1dG9jb21wbGV0ZUFjdGlvbik6IGJvb2xlYW4ge1xuICBwaWNrZXIudmlldyA9IGFjdGlvbi52aWV3O1xuICBzZXRJbmZvKGFjdGlvbik7XG4gIHN3aXRjaCAoYWN0aW9uLmtpbmQpIHtcbiAgICBjYXNlIEFjdGlvbktpbmQub3BlbjpcbiAgICAgIHBpY2tlci5jdXJyZW50ID0gMDtcbiAgICAgIHBpY2tlci5vcGVuID0gdHJ1ZTtcbiAgICAgIHBpY2tlci5yYW5nZSA9IGFjdGlvbi5yYW5nZTtcbiAgICAgIHBsYWNlU3VnZ2VzdGlvbigpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgY2FzZSBBY3Rpb25LaW5kLmNsb3NlOlxuICAgICAgcGlja2VyLm9wZW4gPSBmYWxzZTtcbiAgICAgIHBsYWNlU3VnZ2VzdGlvbigpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgY2FzZSBBY3Rpb25LaW5kLnVwOlxuICAgICAgcGlja2VyLmN1cnJlbnQgLT0gMTtcbiAgICAgIHBpY2tlci5jdXJyZW50ICs9IE5VTV9TVUdHRVNUSU9OUzsgLy8gbmVnYXRpdmUgbW9kdWx1cyBkb2Vzbid0IHdvcmtcbiAgICAgIHBpY2tlci5jdXJyZW50ICU9IE5VTV9TVUdHRVNUSU9OUztcbiAgICAgIHBsYWNlU3VnZ2VzdGlvbigpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgY2FzZSBBY3Rpb25LaW5kLmRvd246XG4gICAgICBwaWNrZXIuY3VycmVudCArPSAxO1xuICAgICAgcGlja2VyLmN1cnJlbnQgJT0gTlVNX1NVR0dFU1RJT05TO1xuICAgICAgcGxhY2VTdWdnZXN0aW9uKCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjYXNlIEFjdGlvbktpbmQuZW50ZXI6IHtcbiAgICAgIGNvbnN0IHRyID0gYWN0aW9uLnZpZXcuc3RhdGUudHJcbiAgICAgICAgLmRlbGV0ZVJhbmdlKGFjdGlvbi5yYW5nZS5mcm9tLCBhY3Rpb24ucmFuZ2UudG8pXG4gICAgICAgIC5pbnNlcnRUZXh0KGBZb3UgY2FuIGRlZmluZSB0aGlzICR7YWN0aW9uLnR5cGUgPyBgJHthY3Rpb24udHlwZT8ubmFtZX0gYCA6ICcnfWFjdGlvbiFgKTtcbiAgICAgIGFjdGlvbi52aWV3LmRpc3BhdGNoKHRyKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbltdLmZvckVhY2guY2FsbChzdWdnZXN0aW9uLmNoaWxkcmVuLCAoaXRlbTogSFRNTERpdkVsZW1lbnQsIGkpID0+IHtcbiAgaXRlbS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICBpZiAoIXBpY2tlci52aWV3KSByZXR1cm47XG4gICAgY2xvc2VBdXRvY29tcGxldGUocGlja2VyLnZpZXcpO1xuICAgIHBpY2tlci5vcGVuID0gZmFsc2U7XG4gICAgcGxhY2VTdWdnZXN0aW9uKCk7XG4gICAgaWYgKCFwaWNrZXIucmFuZ2UpIHJldHVybjtcbiAgICBjb25zdCB0ciA9IHBpY2tlci52aWV3LnN0YXRlLnRyXG4gICAgICAuZGVsZXRlUmFuZ2UocGlja2VyLnJhbmdlLmZyb20sIHBpY2tlci5yYW5nZS50bylcbiAgICAgIC5pbnNlcnRUZXh0KGBDbGlja2VkIG9uICR7aSArIDF9YCk7XG4gICAgcGlja2VyLnZpZXcuZGlzcGF0Y2godHIpO1xuICAgIHBpY2tlci52aWV3LmZvY3VzKCk7XG4gIH0pO1xufSk7XG4iLCJpbXBvcnQgeyBQbHVnaW4gfSBmcm9tICdwcm9zZW1pcnJvci1zdGF0ZSc7XG5pbXBvcnQgeyBFZGl0b3JWaWV3IH0gZnJvbSAncHJvc2VtaXJyb3Itdmlldyc7XG5pbXBvcnQgeyBBdXRvY29tcGxldGVUck1ldGEgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IHBsdWdpbktleSB9IGZyb20gJy4vdXRpbHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gb3BlbkF1dG9jb21wbGV0ZSh2aWV3OiBFZGl0b3JWaWV3LCB0cmlnZ2VyOiBzdHJpbmcsIGZpbHRlcj86IHN0cmluZykge1xuICAvLyBUT0RPOiBDYW4gYWN0aXZhdGUgYSB0eXBlP1xuICBjb25zdCBwbHVnaW4gPSBwbHVnaW5LZXkuZ2V0KHZpZXcuc3RhdGUpIGFzIFBsdWdpbjtcbiAgY29uc3QgbWV0YTogQXV0b2NvbXBsZXRlVHJNZXRhID0geyBhY3Rpb246ICdhZGQnLCB0cmlnZ2VyLCBmaWx0ZXIsIHR5cGU6IG51bGwgfTtcbiAgY29uc3QgdHIgPSB2aWV3LnN0YXRlLnRyXG4gICAgLmluc2VydFRleHQoYCR7dHJpZ2dlcn0ke2ZpbHRlciA/PyAnJ31gKVxuICAgIC5zY3JvbGxJbnRvVmlldygpXG4gICAgLnNldE1ldGEocGx1Z2luLCBtZXRhKTtcbiAgdmlldy5kaXNwYXRjaCh0cik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbG9zZUF1dG9jb21wbGV0ZSh2aWV3OiBFZGl0b3JWaWV3KSB7XG4gIGNvbnN0IHBsdWdpbiA9IHBsdWdpbktleS5nZXQodmlldy5zdGF0ZSkgYXMgUGx1Z2luO1xuICBjb25zdCBtZXRhOiBBdXRvY29tcGxldGVUck1ldGEgPSB7IGFjdGlvbjogJ3JlbW92ZScgfTtcbiAgY29uc3QgdHIgPSB2aWV3LnN0YXRlLnRyLnNldE1ldGEocGx1Z2luLCBtZXRhKTtcbiAgdmlldy5kaXNwYXRjaCh0cik7XG4gIHJldHVybiB0cnVlO1xufVxuIiwiaW1wb3J0IHsgdW5kb0lucHV0UnVsZSB9IGZyb20gJ3Byb3NlbWlycm9yLWlucHV0cnVsZXMnO1xuaW1wb3J0IHsgUGx1Z2luIH0gZnJvbSAncHJvc2VtaXJyb3Itc3RhdGUnO1xuaW1wb3J0IHsgRGVjb3JhdGlvbiwgRGVjb3JhdGlvblNldCwgRWRpdG9yVmlldyB9IGZyb20gJ3Byb3NlbWlycm9yLXZpZXcnO1xuaW1wb3J0IHsgY2xvc2VBdXRvY29tcGxldGUgfSBmcm9tICcuL2FjdGlvbnMnO1xuaW1wb3J0IHtcbiAgQWN0aXZlQXV0b2NvbXBsZXRlU3RhdGUsXG4gIEF1dG9jb21wbGV0ZVRyTWV0YSxcbiAgRnJvbVRvLFxuICBLRUVQX09QRU4sXG4gIE9wdGlvbnMsXG4gIEF1dG9jb21wbGV0ZUFjdGlvbixcbiAgQWN0aW9uS2luZCxcbiAgQXV0b2NvbXBsZXRlU3RhdGUsXG59IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgREVGQVVMVF9ERUNPX0FUVFJTLCBpblN1Z2dlc3Rpb24sIHBsdWdpbktleSB9IGZyb20gJy4vdXRpbHMnO1xuXG5jb25zdCBpbmFjdGl2ZVN1Z2dlc3Rpb25TdGF0ZTogQXV0b2NvbXBsZXRlU3RhdGUgPSB7XG4gIGFjdGl2ZTogZmFsc2UsXG4gIGRlY29yYXRpb25zOiBEZWNvcmF0aW9uU2V0LmVtcHR5LFxufTtcblxuZnVuY3Rpb24gYWN0aW9uRnJvbUV2ZW50KGV2ZW50OiBLZXlib2FyZEV2ZW50KTogQWN0aW9uS2luZCB8IG51bGwge1xuICBzd2l0Y2ggKGV2ZW50LmtleSkge1xuICAgIGNhc2UgJ0Fycm93VXAnOlxuICAgIGNhc2UgJ0Fycm93RG93bic6XG4gICAgY2FzZSAnQXJyb3dMZWZ0JzpcbiAgICBjYXNlICdBcnJvd1JpZ2h0JzpcbiAgICAgIHJldHVybiBldmVudC5rZXkgYXMgQWN0aW9uS2luZDtcbiAgICBjYXNlICdUYWInOlxuICAgIGNhc2UgJ0VudGVyJzpcbiAgICAgIHJldHVybiBBY3Rpb25LaW5kLmVudGVyO1xuICAgIGNhc2UgJ0VzY2FwZSc6XG4gICAgICByZXR1cm4gQWN0aW9uS2luZC5jbG9zZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FuY2VsSWZJbnNpZGVBbmRQYXNzKHZpZXc6IEVkaXRvclZpZXcpIHtcbiAgY29uc3QgcGx1Z2luID0gcGx1Z2luS2V5LmdldCh2aWV3LnN0YXRlKSBhcyBQbHVnaW47XG4gIGNvbnN0IHsgZGVjb3JhdGlvbnMgfSA9IHBsdWdpbi5nZXRTdGF0ZSh2aWV3LnN0YXRlKTtcbiAgaWYgKGluU3VnZ2VzdGlvbih2aWV3LnN0YXRlLnNlbGVjdGlvbiwgZGVjb3JhdGlvbnMpKSB7XG4gICAgY2xvc2VBdXRvY29tcGxldGUodmlldyk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVjb3JhdGlvblBsdWdpbihyZWR1Y2VyOiBSZXF1aXJlZDxPcHRpb25zPlsncmVkdWNlciddKSB7XG4gIGNvbnN0IHBsdWdpbjogUGx1Z2luPEF1dG9jb21wbGV0ZVN0YXRlPiA9IG5ldyBQbHVnaW4oe1xuICAgIGtleTogcGx1Z2luS2V5LFxuICAgIHZpZXcoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1cGRhdGU6ICh2aWV3LCBwcmV2U3RhdGUpID0+IHtcbiAgICAgICAgICBjb25zdCBwcmV2ID0gcGx1Z2luLmdldFN0YXRlKHByZXZTdGF0ZSkgYXMgQWN0aXZlQXV0b2NvbXBsZXRlU3RhdGU7XG4gICAgICAgICAgY29uc3QgbmV4dCA9IHBsdWdpbi5nZXRTdGF0ZSh2aWV3LnN0YXRlKSBhcyBBY3RpdmVBdXRvY29tcGxldGVTdGF0ZTtcblxuICAgICAgICAgIGNvbnN0IHN0YXJ0ZWQgPSAhcHJldi5hY3RpdmUgJiYgbmV4dC5hY3RpdmU7XG4gICAgICAgICAgY29uc3Qgc3RvcHBlZCA9IHByZXYuYWN0aXZlICYmICFuZXh0LmFjdGl2ZTtcbiAgICAgICAgICBjb25zdCBjaGFuZ2VkID0gbmV4dC5hY3RpdmUgJiYgIXN0YXJ0ZWQgJiYgIXN0b3BwZWQgJiYgcHJldi5maWx0ZXIgIT09IG5leHQuZmlsdGVyO1xuXG4gICAgICAgICAgY29uc3QgYWN0aW9uOiBPbWl0PEF1dG9jb21wbGV0ZUFjdGlvbiwgJ2tpbmQnPiA9IHtcbiAgICAgICAgICAgIHZpZXcsXG4gICAgICAgICAgICB0cmlnZ2VyOiBuZXh0LnRyaWdnZXIgPz8gKHByZXYudHJpZ2dlciBhcyBzdHJpbmcpLFxuICAgICAgICAgICAgZmlsdGVyOiBuZXh0LmZpbHRlciA/PyBwcmV2LmZpbHRlcixcbiAgICAgICAgICAgIHJhbmdlOiBuZXh0LnJhbmdlID8/IChwcmV2LnJhbmdlIGFzIEZyb21UbyksXG4gICAgICAgICAgICB0eXBlOiBuZXh0LnR5cGUgPz8gcHJldi50eXBlLFxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKHN0YXJ0ZWQpIHJlZHVjZXIoeyAuLi5hY3Rpb24sIGtpbmQ6IEFjdGlvbktpbmQub3BlbiB9KTtcbiAgICAgICAgICBpZiAoY2hhbmdlZCkgcmVkdWNlcih7IC4uLmFjdGlvbiwga2luZDogQWN0aW9uS2luZC5maWx0ZXIgfSk7XG4gICAgICAgICAgaWYgKHN0b3BwZWQpIHJlZHVjZXIoeyAuLi5hY3Rpb24sIGtpbmQ6IEFjdGlvbktpbmQuY2xvc2UgfSk7XG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH0sXG4gICAgc3RhdGU6IHtcbiAgICAgIGluaXQ6ICgpID0+ICh7IC4uLmluYWN0aXZlU3VnZ2VzdGlvblN0YXRlIH0gYXMgQXV0b2NvbXBsZXRlU3RhdGUpLFxuICAgICAgYXBwbHkodHIsIHN0YXRlKTogQXV0b2NvbXBsZXRlU3RhdGUge1xuICAgICAgICBjb25zdCBtZXRhID0gdHIuZ2V0TWV0YShwbHVnaW4pIGFzIEF1dG9jb21wbGV0ZVRyTWV0YTtcbiAgICAgICAgaWYgKG1ldGE/LmFjdGlvbiA9PT0gJ2FkZCcpIHtcbiAgICAgICAgICBjb25zdCB7IHRyaWdnZXIsIGZpbHRlciwgdHlwZSB9ID0gbWV0YTtcbiAgICAgICAgICBjb25zdCBmcm9tID0gdHIuc2VsZWN0aW9uLmZyb20gLSB0cmlnZ2VyLmxlbmd0aCAtIChmaWx0ZXI/Lmxlbmd0aCA/PyAwKTtcbiAgICAgICAgICBjb25zdCB0byA9IHRyLnNlbGVjdGlvbi5mcm9tO1xuICAgICAgICAgIGNvbnN0IGF0dHJzID0geyAuLi5ERUZBVUxUX0RFQ09fQVRUUlMsIC4uLnR5cGU/LmRlY29yYXRpb25BdHRycyB9O1xuICAgICAgICAgIGNvbnN0IGRlY28gPSBEZWNvcmF0aW9uLmlubGluZShmcm9tLCB0bywgYXR0cnMsIHtcbiAgICAgICAgICAgIGluY2x1c2l2ZVN0YXJ0OiBmYWxzZSxcbiAgICAgICAgICAgIGluY2x1c2l2ZUVuZDogdHJ1ZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWN0aXZlOiB0cnVlLFxuICAgICAgICAgICAgdHJpZ2dlcjogbWV0YS50cmlnZ2VyLFxuICAgICAgICAgICAgZGVjb3JhdGlvbnM6IERlY29yYXRpb25TZXQuY3JlYXRlKHRyLmRvYywgW2RlY29dKSxcbiAgICAgICAgICAgIGZpbHRlcjogZmlsdGVyID8/ICcnLFxuICAgICAgICAgICAgcmFuZ2U6IHsgZnJvbSwgdG8gfSxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGRlY29yYXRpb25zIH0gPSBzdGF0ZSBhcyBBdXRvY29tcGxldGVTdGF0ZTtcbiAgICAgICAgY29uc3QgbmV4dERlY29yYXRpb25zID0gZGVjb3JhdGlvbnMubWFwKHRyLm1hcHBpbmcsIHRyLmRvYyk7XG4gICAgICAgIGNvbnN0IGhhc0RlY29yYXRpb24gPSBuZXh0RGVjb3JhdGlvbnMuZmluZCgpLmxlbmd0aCA+IDA7XG4gICAgICAgIC8vIElmIG5vIGRlY29yYXRpb24sIGV4cGxpY2l0bHkgcmVtb3ZlLCBvciBjbGljayBzb21ld2hlcmUgZWxzZSBpbiB0aGUgZWRpdG9yXG4gICAgICAgIGlmIChcbiAgICAgICAgICBtZXRhPy5hY3Rpb24gPT09ICdyZW1vdmUnIHx8XG4gICAgICAgICAgIWluU3VnZ2VzdGlvbih0ci5zZWxlY3Rpb24sIG5leHREZWNvcmF0aW9ucykgfHxcbiAgICAgICAgICAhaGFzRGVjb3JhdGlvblxuICAgICAgICApXG4gICAgICAgICAgcmV0dXJuIGluYWN0aXZlU3VnZ2VzdGlvblN0YXRlO1xuXG4gICAgICAgIGNvbnN0IHsgYWN0aXZlLCB0cmlnZ2VyLCB0eXBlIH0gPSBzdGF0ZSBhcyBBY3RpdmVBdXRvY29tcGxldGVTdGF0ZTtcbiAgICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIHRyaWdnZXIgaXMgaW4gdGhlIGRlY29yYXRpb25cbiAgICAgICAgY29uc3QgeyBmcm9tLCB0byB9ID0gbmV4dERlY29yYXRpb25zLmZpbmQoKVswXTtcbiAgICAgICAgY29uc3QgdGV4dCA9IHRyLmRvYy50ZXh0QmV0d2Vlbihmcm9tLCB0byk7XG4gICAgICAgIGlmICghdGV4dC5zdGFydHNXaXRoKHRyaWdnZXIpKSByZXR1cm4gaW5hY3RpdmVTdWdnZXN0aW9uU3RhdGU7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBhY3RpdmUsXG4gICAgICAgICAgdHJpZ2dlcixcbiAgICAgICAgICBkZWNvcmF0aW9uczogbmV4dERlY29yYXRpb25zLFxuICAgICAgICAgIGZpbHRlcjogdGV4dC5zbGljZSh0cmlnZ2VyLmxlbmd0aCksXG4gICAgICAgICAgcmFuZ2U6IHsgZnJvbSwgdG8gfSxcbiAgICAgICAgICB0eXBlLFxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICB9LFxuICAgIHByb3BzOiB7XG4gICAgICBkZWNvcmF0aW9uczogKHN0YXRlKSA9PiBwbHVnaW4uZ2V0U3RhdGUoc3RhdGUpLmRlY29yYXRpb25zLFxuICAgICAgaGFuZGxlUGFzdGU6ICh2aWV3KSA9PiBjYW5jZWxJZkluc2lkZUFuZFBhc3ModmlldyksXG4gICAgICBoYW5kbGVEcm9wOiAodmlldykgPT4gY2FuY2VsSWZJbnNpZGVBbmRQYXNzKHZpZXcpLFxuICAgICAgaGFuZGxlS2V5RG93bih2aWV3LCBldmVudCkge1xuICAgICAgICBjb25zdCB7IHRyaWdnZXIsIGFjdGl2ZSwgZGVjb3JhdGlvbnMsIHR5cGUgfSA9IHBsdWdpbi5nZXRTdGF0ZShcbiAgICAgICAgICB2aWV3LnN0YXRlLFxuICAgICAgICApIGFzIEFjdGl2ZUF1dG9jb21wbGV0ZVN0YXRlO1xuXG4gICAgICAgIGlmICghYWN0aXZlIHx8ICFpblN1Z2dlc3Rpb24odmlldy5zdGF0ZS5zZWxlY3Rpb24sIGRlY29yYXRpb25zKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIGNvbnN0IHsgZnJvbSwgdG8gfSA9IGRlY29yYXRpb25zLmZpbmQoKVswXTtcbiAgICAgICAgY29uc3QgdGV4dCA9IHZpZXcuc3RhdGUuZG9jLnRleHRCZXR3ZWVuKGZyb20sIHRvKTtcblxuICAgICAgICAvLyBCZSBkZWZlbnNpdmUsIGp1c3QgaW4gY2FzZSB0aGUgdHJpZ2dlciBkb2Vzbid0IGV4aXN0XG4gICAgICAgIGNvbnN0IGZpbHRlciA9IHRleHQuc2xpY2UodHJpZ2dlcj8ubGVuZ3RoID8/IDEpO1xuXG4gICAgICAgIGNvbnN0IGNoZWNrQ2FuY2VsT25TcGFjZSA9IHR5cGU/LmNhbmNlbE9uRmlyc3RTcGFjZSA/PyB0cnVlO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgY2hlY2tDYW5jZWxPblNwYWNlICYmXG4gICAgICAgICAgZmlsdGVyLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgIChldmVudC5rZXkgPT09ICcgJyB8fCBldmVudC5rZXkgPT09ICdTcGFjZWJhcicpXG4gICAgICAgICkge1xuICAgICAgICAgIGNsb3NlQXV0b2NvbXBsZXRlKHZpZXcpO1xuICAgICAgICAgIC8vIFRha2Ugb3ZlciB0aGUgc3BhY2UgY3JlYXRpb24gc28gbm8gb3RoZXIgaW5wdXQgcnVsZXMgYXJlIGZpcmVkXG4gICAgICAgICAgdmlldy5kaXNwYXRjaCh2aWV3LnN0YXRlLnRyLmluc2VydFRleHQoJyAnKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlsdGVyLmxlbmd0aCA9PT0gMCAmJiBldmVudC5rZXkgPT09ICdCYWNrc3BhY2UnKSB7XG4gICAgICAgICAgdW5kb0lucHV0UnVsZSh2aWV3LnN0YXRlLCB2aWV3LmRpc3BhdGNoKTtcbiAgICAgICAgICBjbG9zZUF1dG9jb21wbGV0ZSh2aWV3KTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGtpbmQgPSBhY3Rpb25Gcm9tRXZlbnQoZXZlbnQpO1xuICAgICAgICBjb25zdCBhY3Rpb246IE9taXQ8QXV0b2NvbXBsZXRlQWN0aW9uLCAna2luZCc+ID0ge1xuICAgICAgICAgIHZpZXcsXG4gICAgICAgICAgdHJpZ2dlcixcbiAgICAgICAgICBmaWx0ZXIsXG4gICAgICAgICAgcmFuZ2U6IHsgZnJvbSwgdG8gfSxcbiAgICAgICAgICB0eXBlLFxuICAgICAgICB9O1xuICAgICAgICBzd2l0Y2ggKGtpbmQpIHtcbiAgICAgICAgICBjYXNlIEFjdGlvbktpbmQuY2xvc2U6XG4gICAgICAgICAgICAvLyBUaGUgdXNlciBhY3Rpb24gd2lsbCBiZSBoYW5kbGVkIGluIHRoZSB2aWV3IGNvZGUgYWJvdmVcbiAgICAgICAgICAgIC8vIEFsbG93cyBjbGlja2luZyBvZmYgdG8gYmUgaGFuZGxlZCBpbiB0aGUgc2FtZSB3YXlcbiAgICAgICAgICAgIHJldHVybiBjbG9zZUF1dG9jb21wbGV0ZSh2aWV3KTtcbiAgICAgICAgICBjYXNlIEFjdGlvbktpbmQuZW50ZXI6IHtcbiAgICAgICAgICAgIC8vIE9ubHkgdHJpZ2dlciB0aGUgY2FuY2VsIGlmIGl0IGlzIG5vdCBleHBsaXRpY2x5IGhhbmRsZWQgaW4gdGhlIHNlbGVjdFxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVkdWNlcih7IC4uLmFjdGlvbiwga2luZDogQWN0aW9uS2luZC5lbnRlciB9KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IEtFRVBfT1BFTikgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0IHx8IGNsb3NlQXV0b2NvbXBsZXRlKHZpZXcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIEFjdGlvbktpbmQudXA6XG4gICAgICAgICAgY2FzZSBBY3Rpb25LaW5kLmRvd246XG4gICAgICAgICAgICByZXR1cm4gQm9vbGVhbihyZWR1Y2VyKHsgLi4uYWN0aW9uLCBraW5kIH0pKTtcbiAgICAgICAgICBjYXNlIEFjdGlvbktpbmQubGVmdDpcbiAgICAgICAgICBjYXNlIEFjdGlvbktpbmQucmlnaHQ6XG4gICAgICAgICAgICBpZiAoIXR5cGU/LmFsbEFycm93S2V5cykgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4ocmVkdWNlcih7IC4uLmFjdGlvbiwga2luZCB9KSk7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0sXG4gICAgfSxcbiAgfSk7XG4gIHJldHVybiBwbHVnaW47XG59XG4iLCJpbXBvcnQgeyBhdXRvY29tcGxldGUgfSBmcm9tICcuL3BsdWdpbic7XG5cbmV4cG9ydCAqIGZyb20gJy4vdHlwZXMnO1xuZXhwb3J0ICogZnJvbSAnLi91dGlscyc7XG5leHBvcnQgKiBmcm9tICcuL3BsdWdpbic7XG5leHBvcnQgKiBmcm9tICcuL2FjdGlvbnMnO1xuXG5leHBvcnQgZGVmYXVsdCBhdXRvY29tcGxldGU7XG4iLCJpbXBvcnQgeyBJbnB1dFJ1bGUgfSBmcm9tICdwcm9zZW1pcnJvci1pbnB1dHJ1bGVzJztcbmltcG9ydCB7IFBsdWdpbiB9IGZyb20gJ3Byb3NlbWlycm9yLXN0YXRlJztcbmltcG9ydCB7IE9wZW5BdXRvY29tcGxldGUsIFRyaWdnZXIgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IGluU3VnZ2VzdGlvbiB9IGZyb20gJy4vdXRpbHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSW5wdXRSdWxlKHBsdWdpbjogUGx1Z2luLCB0eXBlOiBUcmlnZ2VyKSB7XG4gIGNvbnN0IHRyaWdnZXIgPVxuICAgIHR5cGVvZiB0eXBlLnRyaWdnZXIgPT09ICdzdHJpbmcnXG4gICAgICA/IFJlZ0V4cChgKD86XnxcXFxcc3xcXFxcbnxbXlxcXFxkXFxcXHddKSgke3R5cGUudHJpZ2dlci5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgJ1xcXFwkJicpfSkkYClcbiAgICAgIDogdHlwZS50cmlnZ2VyO1xuXG4gIHJldHVybiBuZXcgSW5wdXRSdWxlKHRyaWdnZXIsIChzdGF0ZSwgbWF0Y2gpID0+IHtcbiAgICBjb25zdCB7IGRlY29yYXRpb25zIH0gPSBwbHVnaW4uZ2V0U3RhdGUoc3RhdGUpO1xuICAgIC8vIElmIHdlIGFyZSBjdXJyZW50bHkgc3VnZ2VzdGluZywgZG9uJ3QgYWN0aXZhdGVcbiAgICBpZiAoaW5TdWdnZXN0aW9uKHN0YXRlLnNlbGVjdGlvbiwgZGVjb3JhdGlvbnMpKSByZXR1cm4gbnVsbDtcbiAgICAvLyBXZSBhcmUgdGFraW5nIG92ZXIgdGhlIHRleHQgaW5wdXQgaGVyZVxuICAgIGNvbnN0IHRyID0gc3RhdGUudHIuaW5zZXJ0VGV4dChtYXRjaFsxXVttYXRjaFsxXS5sZW5ndGggLSAxXSkuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICBjb25zdCBtZXRhOiBPcGVuQXV0b2NvbXBsZXRlID0geyBhY3Rpb246ICdhZGQnLCB0cmlnZ2VyOiBtYXRjaFsxXSwgdHlwZSB9O1xuICAgIHRyLnNldE1ldGEocGx1Z2luLCBtZXRhKTtcbiAgICByZXR1cm4gdHI7XG4gIH0pO1xufVxuIiwiaW1wb3J0IHsgUGx1Z2luIH0gZnJvbSAncHJvc2VtaXJyb3Itc3RhdGUnO1xuaW1wb3J0IHsgaW5wdXRSdWxlcyB9IGZyb20gJ3Byb3NlbWlycm9yLWlucHV0cnVsZXMnO1xuaW1wb3J0IHsgT3B0aW9ucywgQWN0aW9uS2luZCwgQXV0b2NvbXBsZXRlQWN0aW9uIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBnZXREZWNvcmF0aW9uUGx1Z2luIH0gZnJvbSAnLi9kZWNvcmF0aW9uJztcbmltcG9ydCB7IGNyZWF0ZUlucHV0UnVsZSB9IGZyb20gJy4vaW5wdXRSdWxlcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVkdWNlcihvcHRpb25zOiBQYXJ0aWFsPE9wdGlvbnM+KSB7XG4gIHJldHVybiAoYWN0aW9uOiBBdXRvY29tcGxldGVBY3Rpb24pOiBib29sZWFuID0+IHtcbiAgICBzd2l0Y2ggKGFjdGlvbi5raW5kKSB7XG4gICAgICBjYXNlIEFjdGlvbktpbmQub3BlbjpcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMub25PcGVuPy4oYWN0aW9uKSA/PyBmYWxzZTtcbiAgICAgIGNhc2UgQWN0aW9uS2luZC5jbG9zZTpcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMub25DbG9zZT8uKGFjdGlvbikgPz8gZmFsc2U7XG4gICAgICBjYXNlIEFjdGlvbktpbmQudXA6XG4gICAgICBjYXNlIEFjdGlvbktpbmQuZG93bjpcbiAgICAgIGNhc2UgQWN0aW9uS2luZC5sZWZ0OlxuICAgICAgY2FzZSBBY3Rpb25LaW5kLnJpZ2h0OlxuICAgICAgICByZXR1cm4gb3B0aW9ucy5vbkFycm93Py4oYWN0aW9uKSA/PyBmYWxzZTtcbiAgICAgIGNhc2UgQWN0aW9uS2luZC5maWx0ZXI6XG4gICAgICAgIHJldHVybiBvcHRpb25zLm9uRmlsdGVyPy4oYWN0aW9uKSA/PyBmYWxzZTtcbiAgICAgIGNhc2UgQWN0aW9uS2luZC5lbnRlcjpcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMub25FbnRlcj8uKGFjdGlvbikgPz8gZmFsc2U7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXV0b2NvbXBsZXRlKG9wdHM6IFBhcnRpYWw8T3B0aW9ucz4gPSB7fSkge1xuICBjb25zdCBvcHRpb25zOiBPcHRpb25zID0ge1xuICAgIHRyaWdnZXJzOiBbXSxcbiAgICByZWR1Y2VyOiBkZWZhdWx0UmVkdWNlcihvcHRzKSxcbiAgICAuLi5vcHRzLFxuICB9O1xuICBjb25zdCB7IHJlZHVjZXIsIHRyaWdnZXJzIH0gPSBvcHRpb25zO1xuXG4gIGNvbnN0IHBsdWdpbiA9IGdldERlY29yYXRpb25QbHVnaW4ocmVkdWNlcik7XG5cbiAgY29uc3QgcnVsZXM6IFBsdWdpbltdID0gW1xuICAgIHBsdWdpbixcbiAgICBpbnB1dFJ1bGVzKHtcbiAgICAgIC8vIENyZWF0ZSBhbiBpbnB1dCBydWxlIGZvciBlYWNoIHRyaWdnZXJcbiAgICAgIHJ1bGVzOiB0cmlnZ2Vycy5tYXAoKHR5cGUpID0+IGNyZWF0ZUlucHV0UnVsZShwbHVnaW4sIHR5cGUpKSxcbiAgICB9KSxcbiAgXTtcbiAgcmV0dXJuIHJ1bGVzO1xufVxuIiwiaW1wb3J0IHsgRGVjb3JhdGlvbkF0dHJzLCBEZWNvcmF0aW9uU2V0LCBFZGl0b3JWaWV3IH0gZnJvbSAncHJvc2VtaXJyb3Itdmlldyc7XG5cbmV4cG9ydCBjb25zdCBLRUVQX09QRU4gPSAnS0VFUF9PUEVOJztcblxuZXhwb3J0IGludGVyZmFjZSBGcm9tVG8ge1xuICBmcm9tOiBudW1iZXI7XG4gIHRvOiBudW1iZXI7XG59XG5cbmV4cG9ydCB0eXBlIEluYWN0aXZlQXV0b2NvbXBsZXRlU3RhdGUgPSB7XG4gIGFjdGl2ZTogZmFsc2U7XG4gIGRlY29yYXRpb25zOiBEZWNvcmF0aW9uU2V0O1xufTtcblxuZXhwb3J0IHR5cGUgQWN0aXZlQXV0b2NvbXBsZXRlU3RhdGUgPSB7XG4gIGFjdGl2ZTogdHJ1ZTtcbiAgZGVjb3JhdGlvbnM6IERlY29yYXRpb25TZXQ7XG4gIHRyaWdnZXI6IHN0cmluZztcbiAgZmlsdGVyOiBzdHJpbmc7XG4gIHJhbmdlOiBGcm9tVG87XG4gIHR5cGU6IFRyaWdnZXIgfCBudWxsO1xufTtcblxuZXhwb3J0IHR5cGUgQXV0b2NvbXBsZXRlU3RhdGUgPSBJbmFjdGl2ZUF1dG9jb21wbGV0ZVN0YXRlIHwgQWN0aXZlQXV0b2NvbXBsZXRlU3RhdGU7XG5cbmV4cG9ydCBlbnVtIEFjdGlvbktpbmQge1xuICAnb3BlbicgPSAnb3BlbicsXG4gICdjbG9zZScgPSAnY2xvc2UnLFxuICAnZmlsdGVyJyA9ICdmaWx0ZXInLFxuICAndXAnID0gJ0Fycm93VXAnLFxuICAnZG93bicgPSAnQXJyb3dEb3duJyxcbiAgJ2xlZnQnID0gJ0Fycm93TGVmdCcsXG4gICdyaWdodCcgPSAnQXJyb3dSaWdodCcsXG4gICdlbnRlcicgPSAnZW50ZXInLFxufVxuXG5leHBvcnQgdHlwZSBBdXRvY29tcGxldGVBY3Rpb24gPSB7XG4gIGtpbmQ6IEFjdGlvbktpbmQ7XG4gIHZpZXc6IEVkaXRvclZpZXc7XG4gIHRyaWdnZXI6IHN0cmluZztcbiAgZmlsdGVyPzogc3RyaW5nO1xuICByYW5nZTogRnJvbVRvO1xuICB0eXBlOiBUcmlnZ2VyIHwgbnVsbDtcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3BlbkF1dG9jb21wbGV0ZSB7XG4gIGFjdGlvbjogJ2FkZCc7XG4gIHRyaWdnZXI6IHN0cmluZztcbiAgZmlsdGVyPzogc3RyaW5nO1xuICB0eXBlOiBUcmlnZ2VyIHwgbnVsbDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDbG9zZUF1dG9jb21wbGV0ZSB7XG4gIGFjdGlvbjogJ3JlbW92ZSc7XG59XG5cbmV4cG9ydCB0eXBlIEF1dG9jb21wbGV0ZVRyTWV0YSA9IE9wZW5BdXRvY29tcGxldGUgfCBDbG9zZUF1dG9jb21wbGV0ZTtcblxuZXhwb3J0IHR5cGUgVHJpZ2dlciA9IHtcbiAgbmFtZTogc3RyaW5nO1xuICB0cmlnZ2VyOiBzdHJpbmcgfCBSZWdFeHA7XG4gIGNhbmNlbE9uRmlyc3RTcGFjZT86IGJvb2xlYW47IC8vIERlZmF1bHQgaXMgdHJ1ZVxuICBhbGxBcnJvd0tleXM/OiBib29sZWFuOyAvLyBEZWZhdWx0IGlzIGZhbHNlXG4gIGRlY29yYXRpb25BdHRycz86IERlY29yYXRpb25BdHRycztcbn07XG5cbmV4cG9ydCB0eXBlIE9wdGlvbnMgPSB7XG4gIG9uT3Blbj86IChhY3Rpb246IEF1dG9jb21wbGV0ZUFjdGlvbikgPT4gYm9vbGVhbjtcbiAgb25DbG9zZT86IChhY3Rpb246IEF1dG9jb21wbGV0ZUFjdGlvbikgPT4gYm9vbGVhbjtcbiAgb25GaWx0ZXI/OiAoYWN0aW9uOiBBdXRvY29tcGxldGVBY3Rpb24pID0+IGJvb2xlYW47XG4gIG9uQXJyb3c/OiAoYWN0aW9uOiBBdXRvY29tcGxldGVBY3Rpb24pID0+IGJvb2xlYW47XG4gIG9uRW50ZXI/OiAoYWN0aW9uOiBBdXRvY29tcGxldGVBY3Rpb24pID0+IGJvb2xlYW47XG4gIHJlZHVjZXI6IChhY3Rpb246IEF1dG9jb21wbGV0ZUFjdGlvbikgPT4gYm9vbGVhbiB8IHR5cGVvZiBLRUVQX09QRU47XG4gIHRyaWdnZXJzOiBUcmlnZ2VyW107XG59O1xuIiwiaW1wb3J0IHsgUGx1Z2luS2V5LCBTZWxlY3Rpb24gfSBmcm9tICdwcm9zZW1pcnJvci1zdGF0ZSc7XG5pbXBvcnQgeyBEZWNvcmF0aW9uU2V0IH0gZnJvbSAncHJvc2VtaXJyb3Itdmlldyc7XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX0lEID0gJ2F1dG9jb21wbGV0ZSc7XG5leHBvcnQgY29uc3QgREVGQVVMVF9ERUNPX0FUVFJTID0geyBpZDogREVGQVVMVF9JRCwgY2xhc3M6IERFRkFVTFRfSUQgfTtcblxuZXhwb3J0IGNvbnN0IHBsdWdpbktleSA9IG5ldyBQbHVnaW5LZXkoREVGQVVMVF9JRCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBpblN1Z2dlc3Rpb24oc2VsZWN0aW9uOiBTZWxlY3Rpb24sIGRlY29yYXRpb25zOiBEZWNvcmF0aW9uU2V0KSB7XG4gIHJldHVybiBkZWNvcmF0aW9ucy5maW5kKHNlbGVjdGlvbi5mcm9tLCBzZWxlY3Rpb24udG8pLmxlbmd0aCA+IDA7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVsdCgpIHtcbiAgdmFyIGVsdCA9IGFyZ3VtZW50c1swXVxuICBpZiAodHlwZW9mIGVsdCA9PSBcInN0cmluZ1wiKSBlbHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGVsdClcbiAgdmFyIGkgPSAxLCBuZXh0ID0gYXJndW1lbnRzWzFdXG4gIGlmIChuZXh0ICYmIHR5cGVvZiBuZXh0ID09IFwib2JqZWN0XCIgJiYgbmV4dC5ub2RlVHlwZSA9PSBudWxsICYmICFBcnJheS5pc0FycmF5KG5leHQpKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiBuZXh0KSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG5leHQsIG5hbWUpKSB7XG4gICAgICB2YXIgdmFsdWUgPSBuZXh0W25hbWVdXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIpIGVsdC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpXG4gICAgICBlbHNlIGlmICh2YWx1ZSAhPSBudWxsKSBlbHRbbmFtZV0gPSB2YWx1ZVxuICAgIH1cbiAgICBpKytcbiAgfVxuICBmb3IgKDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYWRkKGVsdCwgYXJndW1lbnRzW2ldKVxuICByZXR1cm4gZWx0XG59XG5cbmZ1bmN0aW9uIGFkZChlbHQsIGNoaWxkKSB7XG4gIGlmICh0eXBlb2YgY2hpbGQgPT0gXCJzdHJpbmdcIikge1xuICAgIGVsdC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjaGlsZCkpXG4gIH0gZWxzZSBpZiAoY2hpbGQgPT0gbnVsbCkge1xuICB9IGVsc2UgaWYgKGNoaWxkLm5vZGVUeXBlICE9IG51bGwpIHtcbiAgICBlbHQuYXBwZW5kQ2hpbGQoY2hpbGQpXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjaGlsZCkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkLmxlbmd0aDsgaSsrKSBhZGQoZWx0LCBjaGlsZFtpXSlcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlVuc3VwcG9ydGVkIGNoaWxkIG5vZGU6IFwiICsgY2hpbGQpXG4gIH1cbn1cbiIsImV4cG9ydCB2YXIgYmFzZSA9IHtcbiAgODogXCJCYWNrc3BhY2VcIixcbiAgOTogXCJUYWJcIixcbiAgMTA6IFwiRW50ZXJcIixcbiAgMTI6IFwiTnVtTG9ja1wiLFxuICAxMzogXCJFbnRlclwiLFxuICAxNjogXCJTaGlmdFwiLFxuICAxNzogXCJDb250cm9sXCIsXG4gIDE4OiBcIkFsdFwiLFxuICAyMDogXCJDYXBzTG9ja1wiLFxuICAyNzogXCJFc2NhcGVcIixcbiAgMzI6IFwiIFwiLFxuICAzMzogXCJQYWdlVXBcIixcbiAgMzQ6IFwiUGFnZURvd25cIixcbiAgMzU6IFwiRW5kXCIsXG4gIDM2OiBcIkhvbWVcIixcbiAgMzc6IFwiQXJyb3dMZWZ0XCIsXG4gIDM4OiBcIkFycm93VXBcIixcbiAgMzk6IFwiQXJyb3dSaWdodFwiLFxuICA0MDogXCJBcnJvd0Rvd25cIixcbiAgNDQ6IFwiUHJpbnRTY3JlZW5cIixcbiAgNDU6IFwiSW5zZXJ0XCIsXG4gIDQ2OiBcIkRlbGV0ZVwiLFxuICA1OTogXCI7XCIsXG4gIDYxOiBcIj1cIixcbiAgOTE6IFwiTWV0YVwiLFxuICA5MjogXCJNZXRhXCIsXG4gIDEwNjogXCIqXCIsXG4gIDEwNzogXCIrXCIsXG4gIDEwODogXCIsXCIsXG4gIDEwOTogXCItXCIsXG4gIDExMDogXCIuXCIsXG4gIDExMTogXCIvXCIsXG4gIDE0NDogXCJOdW1Mb2NrXCIsXG4gIDE0NTogXCJTY3JvbGxMb2NrXCIsXG4gIDE2MDogXCJTaGlmdFwiLFxuICAxNjE6IFwiU2hpZnRcIixcbiAgMTYyOiBcIkNvbnRyb2xcIixcbiAgMTYzOiBcIkNvbnRyb2xcIixcbiAgMTY0OiBcIkFsdFwiLFxuICAxNjU6IFwiQWx0XCIsXG4gIDE3MzogXCItXCIsXG4gIDE4NjogXCI7XCIsXG4gIDE4NzogXCI9XCIsXG4gIDE4ODogXCIsXCIsXG4gIDE4OTogXCItXCIsXG4gIDE5MDogXCIuXCIsXG4gIDE5MTogXCIvXCIsXG4gIDE5MjogXCJgXCIsXG4gIDIxOTogXCJbXCIsXG4gIDIyMDogXCJcXFxcXCIsXG4gIDIyMTogXCJdXCIsXG4gIDIyMjogXCInXCIsXG4gIDIyOTogXCJxXCJcbn1cblxuZXhwb3J0IHZhciBzaGlmdCA9IHtcbiAgNDg6IFwiKVwiLFxuICA0OTogXCIhXCIsXG4gIDUwOiBcIkBcIixcbiAgNTE6IFwiI1wiLFxuICA1MjogXCIkXCIsXG4gIDUzOiBcIiVcIixcbiAgNTQ6IFwiXlwiLFxuICA1NTogXCImXCIsXG4gIDU2OiBcIipcIixcbiAgNTc6IFwiKFwiLFxuICA1OTogXCI6XCIsXG4gIDYxOiBcIitcIixcbiAgMTczOiBcIl9cIixcbiAgMTg2OiBcIjpcIixcbiAgMTg3OiBcIitcIixcbiAgMTg4OiBcIjxcIixcbiAgMTg5OiBcIl9cIixcbiAgMTkwOiBcIj5cIixcbiAgMTkxOiBcIj9cIixcbiAgMTkyOiBcIn5cIixcbiAgMjE5OiBcIntcIixcbiAgMjIwOiBcInxcIixcbiAgMjIxOiBcIn1cIixcbiAgMjIyOiBcIlxcXCJcIixcbiAgMjI5OiBcIlFcIlxufVxuXG52YXIgY2hyb21lID0gdHlwZW9mIG5hdmlnYXRvciAhPSBcInVuZGVmaW5lZFwiICYmIC9DaHJvbWVcXC8oXFxkKykvLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudClcbnZhciBzYWZhcmkgPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgJiYgL0FwcGxlIENvbXB1dGVyLy50ZXN0KG5hdmlnYXRvci52ZW5kb3IpXG52YXIgZ2Vja28gPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgJiYgL0dlY2tvXFwvXFxkKy8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KVxudmFyIG1hYyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gXCJ1bmRlZmluZWRcIiAmJiAvTWFjLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSlcbnZhciBpZSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gXCJ1bmRlZmluZWRcIiAmJiAvTVNJRSBcXGR8VHJpZGVudFxcLyg/Ols3LTldfFxcZHsyLH0pXFwuLipydjooXFxkKykvLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudClcbnZhciBicm9rZW5Nb2RpZmllck5hbWVzID0gY2hyb21lICYmIChtYWMgfHwgK2Nocm9tZVsxXSA8IDU3KSB8fCBnZWNrbyAmJiBtYWNcblxuLy8gRmlsbCBpbiB0aGUgZGlnaXQga2V5c1xuZm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSBiYXNlWzQ4ICsgaV0gPSBiYXNlWzk2ICsgaV0gPSBTdHJpbmcoaSlcblxuLy8gVGhlIGZ1bmN0aW9uIGtleXNcbmZvciAodmFyIGkgPSAxOyBpIDw9IDI0OyBpKyspIGJhc2VbaSArIDExMV0gPSBcIkZcIiArIGlcblxuLy8gQW5kIHRoZSBhbHBoYWJldGljIGtleXNcbmZvciAodmFyIGkgPSA2NTsgaSA8PSA5MDsgaSsrKSB7XG4gIGJhc2VbaV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgKyAzMilcbiAgc2hpZnRbaV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXG59XG5cbi8vIEZvciBlYWNoIGNvZGUgdGhhdCBkb2Vzbid0IGhhdmUgYSBzaGlmdC1lcXVpdmFsZW50LCBjb3B5IHRoZSBiYXNlIG5hbWVcbmZvciAodmFyIGNvZGUgaW4gYmFzZSkgaWYgKCFzaGlmdC5oYXNPd25Qcm9wZXJ0eShjb2RlKSkgc2hpZnRbY29kZV0gPSBiYXNlW2NvZGVdXG5cbmV4cG9ydCBmdW5jdGlvbiBrZXlOYW1lKGV2ZW50KSB7XG4gIC8vIERvbid0IHRydXN0IGV2ZW50LmtleSBpbiBDaHJvbWUgd2hlbiB0aGVyZSBhcmUgbW9kaWZpZXJzIHVudGlsXG4gIC8vIHRoZXkgZml4IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTYzMzgzOFxuICB2YXIgaWdub3JlS2V5ID0gYnJva2VuTW9kaWZpZXJOYW1lcyAmJiAoZXZlbnQuY3RybEtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQubWV0YUtleSkgfHxcbiAgICAoc2FmYXJpIHx8IGllKSAmJiBldmVudC5zaGlmdEtleSAmJiBldmVudC5rZXkgJiYgZXZlbnQua2V5Lmxlbmd0aCA9PSAxXG4gIHZhciBuYW1lID0gKCFpZ25vcmVLZXkgJiYgZXZlbnQua2V5KSB8fFxuICAgIChldmVudC5zaGlmdEtleSA/IHNoaWZ0IDogYmFzZSlbZXZlbnQua2V5Q29kZV0gfHxcbiAgICBldmVudC5rZXkgfHwgXCJVbmlkZW50aWZpZWRcIlxuICAvLyBFZGdlIHNvbWV0aW1lcyBwcm9kdWNlcyB3cm9uZyBuYW1lcyAoSXNzdWUgIzMpXG4gIGlmIChuYW1lID09IFwiRXNjXCIpIG5hbWUgPSBcIkVzY2FwZVwiXG4gIGlmIChuYW1lID09IFwiRGVsXCIpIG5hbWUgPSBcIkRlbGV0ZVwiXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1pY3Jvc29mdC5jb20vZW4tdXMvbWljcm9zb2Z0LWVkZ2UvcGxhdGZvcm0vaXNzdWVzLzg4NjA1NzEvXG4gIGlmIChuYW1lID09IFwiTGVmdFwiKSBuYW1lID0gXCJBcnJvd0xlZnRcIlxuICBpZiAobmFtZSA9PSBcIlVwXCIpIG5hbWUgPSBcIkFycm93VXBcIlxuICBpZiAobmFtZSA9PSBcIlJpZ2h0XCIpIG5hbWUgPSBcIkFycm93UmlnaHRcIlxuICBpZiAobmFtZSA9PSBcIkRvd25cIikgbmFtZSA9IFwiQXJyb3dEb3duXCJcbiAgcmV0dXJuIG5hbWVcbn1cbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiIiwiLy8gc3RhcnR1cFxuLy8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vLyBUaGlzIGVudHJ5IG1vZHVsZSBpcyByZWZlcmVuY2VkIGJ5IG90aGVyIG1vZHVsZXMgc28gaXQgY2FuJ3QgYmUgaW5saW5lZFxudmFyIF9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9kZW1vL2luZGV4LnRzXCIpO1xuIiwiIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9